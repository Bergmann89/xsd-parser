//! This example showcases an advanced usage pattern of the XSD code generation
//! pipeline, where the components - `Parser`, `Interpreter`, `Optimizer`, and
//! `Generator` - are used individually rather than through the high-level `generate`
//! function.
//!
//! This modular approach allows for detailed control over each phase:
//! - **`Parser`** loads and resolves XSD schema files.
//! - **`Interpreter`** analyzes the parsed schema and extracts semantic type
//!   information.
//! - **`Optimizer`** transforms and simplifies the type data.
//! - **`Generator`** produces Rust code based on the refined type definitions.
//!
//! In contrast to the simpler `Config`-based interface, this setup provides full
//! flexibility for customization, experimentation, and debugging of each step.
//!
//! Additionally, this example defines and registers a custom renderer, which
//! overrides the default rendering logic used by the generator. This custom
//! renderer allows fine-tuned control over how specific typesâ€”such as enums,
//! unions, complex structs and references are converted into Rust code. It can
//! be used to inject specific attributes, formatting, or behaviors needed for
//! integration with your application.

#![allow(missing_docs)]

use std::path::PathBuf;
use std::{fmt::Display, fs::write};

use anyhow::Error;
use clap::Parser as ClapParser;
use proc_macro2::{Ident as Ident2, TokenStream};
use quote::{format_ident, quote, ToTokens};
use smallvec::{smallvec, SmallVec};
use tracing_subscriber::{fmt, EnvFilter};

use xsd_parser::{
    config::{GeneratorFlags, SerdeSupport, TypedefMode},
    generator::{
        renderer::Renderer, ComplexType, ComplexTypeAttribute, ComplexTypeContent,
        ComplexTypeElement, ComplexTypeEnum, ComplexTypeStruct, Context, CustomType, DynTypeTraits,
        DynamicType, EnumerationType, EnumerationTypeVariant, Occurs, ReferenceType, TypeData,
        UnionType, UnionTypeVariant,
    },
    parser::resolver::FileResolver,
    schema::{
        xs::{
            Annotation, AttributeGroupTypeContent, ComplexBaseTypeContent, ElementTypeContent,
            GroupTypeContent, SchemaContent, SimpleBaseTypeContent, Use,
        },
        Schemas,
    },
    types::{Ident, IdentType},
    Generator, Interpreter, Optimizer, Parser,
};

fn main() -> Result<(), Error> {
    // Initialize the logging framework. Log output can be controlled using the
    // `RUST_LOG` environment variable.
    fmt()
        .without_time()
        .with_file(true)
        .with_level(true)
        .with_line_number(true)
        .with_thread_ids(true)
        .with_thread_names(true)
        .pretty()
        .with_env_filter(EnvFilter::from_default_env())
        .init();

    // Parse the command line arguments
    let args = Args::parse();
    tracing::info!("Run with arguments: {args:#?}");

    // Canonicalize all input files, to ensure that the files exists and that
    // the path is valid. Store it in a vector for further processing.
    let inputs = args
        .inputs
        .into_iter()
        .map(|p| p.canonicalize())
        .collect::<Result<Vec<_>, _>>()?;

    // Setup the parser and load the different schemas from file
    let schemas = Parser::new()
        .with_resolver(FileResolver::new())
        .with_default_namespaces()
        .add_schema_from_files(inputs)?
        .finish();

    // Setup the interpreter to extract the type information from the schema
    let types = Interpreter::new(&schemas)
        .with_buildin_types()?
        .with_default_typedefs()?
        .with_xs_any_type()?
        .finish()?;

    // Apply additional optimizations to the type information
    let types = Optimizer::new(types)
        .remove_empty_enum_variants()
        .remove_empty_enums()
        .remove_duplicate_union_variants()
        .remove_empty_unions()
        .use_unrestricted_base_type()
        .convert_dynamic_to_choice()
        .flatten_complex_types()
        .flatten_unions()
        .merge_enum_unions()
        .resolve_typedefs()
        .remove_duplicates()
        .resolve_typedefs()
        .merge_choice_cardinalities()
        .finish();

    // Setup the generator and generate the code for named types only
    let module = Generator::new(&types)
        .flags(GeneratorFlags::all())
        .with_renderer(CustomRenderer::new(schemas))
        .into_fixed()
        .generate_named_types()?
        .into_module();

    // Convert the module generated by the generator into a string containing
    // the whole code.
    let code = module.to_token_stream().to_string();

    // Write the generated code to the output file
    write(&args.output, code)?;

    Ok(())
}

/// Simple command line tool to generate code out of any XML schema that is
/// passed as input argument.
#[derive(Debug, ClapParser)]
struct Args {
    /// Write additional debut output in the output directory.
    #[arg(short, long)]
    enable_debug_output: bool,

    /// Path to write the generated code to.
    #[arg()]
    output: PathBuf,

    /// Paths to read the schema files from.
    #[arg()]
    inputs: Vec<PathBuf>,
}

#[derive(Debug)]
pub struct CustomRenderer {
    schemas: Schemas,
}

impl Renderer for CustomRenderer {
    fn render_type(&mut self, ctx: &mut Context<'_, '_>, ty: &TypeData<'_>) {
        let ident = ctx.ident();
        let annotation = self.find_annotation(ident);

        dbg!(ident, annotation); // Do something with the annotation

        match ty {
            TypeData::BuildIn(_) => (),
            TypeData::Custom(ty) => self.render_custom(ty, ctx),
            TypeData::Union(ty) => self.render_union(ty, ctx),
            TypeData::Dynamic(ty) => self.render_dynamic(ty, ctx),
            TypeData::Reference(ty) => self.render_reference(ty, ctx),
            TypeData::Enumeration(ty) => self.render_enumeration(ty, ctx),
            TypeData::Complex(ty) => self.render_complex(ty, ctx),
        }
    }
}

impl CustomRenderer {
    fn new(schemas: Schemas) -> Self {
        Self { schemas }
    }

    fn find_annotation(&self, ident: &Ident) -> Option<&Annotation> {
        let ns = ident.ns.as_ref()?;
        let name = ident.name.as_named_str()?;
        let ns_info = self.schemas.get_namespace_info(ns)?;

        macro_rules! find_annotation {
            ($x:expr, $ty:ident::$var:ident) => {
                $x.content
                    .iter()
                    .find_map(|x| if let $ty::$var(x) = x { Some(x) } else { None })
            };
        }

        for id in &ns_info.schemas {
            let Some(schema) = self.schemas.get_schema(id) else {
                continue;
            };

            for c in &schema.content {
                match (ident.type_, c) {
                    (IdentType::Element, SchemaContent::Element(x)) if matches!(&x.name, Some(n) if n == name) =>
                    {
                        return find_annotation!(x, ElementTypeContent::Annotation);
                    }
                    (IdentType::Type, SchemaContent::SimpleType(x)) if matches!(&x.name, Some(n) if n == name) =>
                    {
                        return find_annotation!(x, SimpleBaseTypeContent::Annotation);
                    }
                    (IdentType::Type, SchemaContent::ComplexType(x)) if matches!(&x.name, Some(n) if n == name) =>
                    {
                        return find_annotation!(x, ComplexBaseTypeContent::Annotation);
                    }
                    (IdentType::Group, SchemaContent::Group(x)) if matches!(&x.name, Some(n) if n == name) =>
                    {
                        return find_annotation!(x, GroupTypeContent::Annotation);
                    }
                    (IdentType::AttributeGroup, SchemaContent::AttributeGroup(x)) if matches!(&x.name, Some(n) if n == name) =>
                    {
                        return find_annotation!(x, AttributeGroupTypeContent::Annotation);
                    }
                    (_, _) => (),
                }
            }
        }

        None
    }

    /* Custom */

    fn render_custom(&self, ty: &CustomType<'_>, ctx: &mut Context<'_, '_>) {
        let Some(include) = ty.info.include() else {
            return;
        };

        ctx.module().usings([include]);
    }

    /* Union */

    fn render_union(&self, ty: &UnionType<'_>, ctx: &mut Context<'_, '_>) {
        let UnionType {
            type_ident,
            trait_impls,
            variants,
            ..
        } = ty;

        let derive = get_derive(ctx, Option::<String>::None);
        let trait_impls = render_trait_impls(type_ident, trait_impls);
        let variants = variants
            .iter()
            .map(|var| self.render_union_variant(var, ctx));

        let code = quote! {
            #derive
            pub enum #type_ident {
                #( #variants )*
            }

            #( #trait_impls )*
        };

        ctx.module().append(code);
    }

    fn render_union_variant(
        &self,
        var: &UnionTypeVariant<'_>,
        ctx: &Context<'_, '_>,
    ) -> TokenStream {
        let UnionTypeVariant {
            variant_ident,
            target_type,
            ..
        } = var;

        let target_type = ctx.resolve_type_for_module(target_type);

        quote! {
            #variant_ident ( #target_type ),
        }
    }

    /* Dynamic */

    fn render_dynamic(&self, ty: &DynamicType<'_>, ctx: &mut Context<'_, '_>) {
        let DynamicType {
            type_ident,
            trait_ident,
            sub_traits,
            ..
        } = ty;

        let derive = get_derive(ctx, Option::<String>::None);
        let trait_impls = render_trait_impls(type_ident, &[]);
        let dyn_traits = sub_traits.as_ref().map_or_else(
            || get_dyn_type_traits(ctx),
            |traits| format_traits(traits.iter().map(|x| ctx.resolve_type_for_module(x))),
        );

        let code = quote! {
            #derive
            pub struct #type_ident(pub Box<dyn #trait_ident>);

            pub trait #trait_ident: #dyn_traits { }

            #( #trait_impls )*
        };

        ctx.module().append(code);
    }

    /* Reference */

    fn render_reference(&self, ty: &ReferenceType<'_>, ctx: &mut Context<'_, '_>) {
        let ReferenceType {
            mode,
            occurs,
            type_ident,
            target_type,
            trait_impls,
            ..
        } = ty;

        let target_type = ctx.resolve_type_for_module(target_type);

        let code = match mode {
            TypedefMode::Auto => unreachable!(),
            TypedefMode::Typedef => {
                let target_type = occurs.make_type(&target_type, false);

                quote! { pub type #type_ident = #target_type; }
            }
            TypedefMode::NewType => {
                let target_type = occurs.make_type(&target_type, false);
                let extra_derive =
                    matches!(occurs, Occurs::Optional | Occurs::DynamicList).then_some("Default");
                let derive = get_derive(ctx, extra_derive);
                let trait_impls = render_trait_impls(type_ident, trait_impls);

                quote! {
                    #derive
                    pub struct #type_ident(pub #target_type);

                    #( #trait_impls )*
                }
            }
        };

        ctx.module().append(code);
    }

    /* Enumeration */

    fn render_enumeration(&self, ty: &EnumerationType<'_>, ctx: &mut Context<'_, '_>) {
        let EnumerationType {
            type_ident,
            variants,
            trait_impls,
            ..
        } = ty;

        let derive = get_derive(ctx, Option::<String>::None);
        let trait_impls = render_trait_impls(type_ident, trait_impls);

        let variants = variants
            .iter()
            .map(|var| self.render_enum_variant(var, ctx))
            .collect::<Vec<_>>();

        let code = quote! {
            #derive
            pub enum #type_ident {
                #( #variants )*
            }

            #( #trait_impls )*
        };

        ctx.module().append(code);
    }

    fn render_enum_variant(
        &self,
        var: &EnumerationTypeVariant<'_>,
        ctx: &Context<'_, '_>,
    ) -> TokenStream {
        let EnumerationTypeVariant {
            info,
            variant_ident,
            target_type,
        } = var;

        let serde = if ctx.serde_support == SerdeSupport::None {
            None
        } else if info.type_.is_some() {
            Some(quote!(#[serde(other)]))
        } else {
            let name = format!("{}", info.ident.name);

            Some(quote!(#[serde(rename = #name)]))
        };

        let target_type = target_type.as_ref().map(|target_type| {
            let target_type = ctx.resolve_type_for_module(target_type);

            quote!((#target_type))
        });

        quote! {
            #serde
            #variant_ident #target_type,
        }
    }

    /* Complex */

    fn render_complex(&self, ty: &ComplexType<'_>, ctx: &mut Context<'_, '_>) {
        match ty {
            ComplexType::Enum {
                type_,
                content_type,
            } => {
                self.render_complex_enum(type_, ctx);

                if let Some(content_type) = content_type {
                    self.render_complex(&content_type, ctx);
                }
            }
            ComplexType::Struct {
                type_,
                content_type,
            } => {
                self.render_complex_struct(type_, ctx);

                if let Some(content_type) = content_type {
                    self.render_complex(&content_type, ctx);
                }
            }
        }
    }

    fn render_complex_enum(&self, ty: &ComplexTypeEnum<'_>, ctx: &mut Context<'_, '_>) {
        let derive = get_derive(ctx, Option::<String>::None);
        let type_ident = &ty.type_ident;
        let trait_impls = render_trait_impls(type_ident, &ty.trait_impls);

        let variants = ty
            .elements
            .iter()
            .map(|el| self.render_complex_enum_variant(el, ctx));

        let code = quote! {
            #derive
            pub enum #type_ident {
                #( #variants )*
            }

            #( #trait_impls )*
        };

        ctx.module().append(code);
    }

    fn render_complex_enum_variant(
        &self,
        el: &ComplexTypeElement<'_>,
        ctx: &Context<'_, '_>,
    ) -> TokenStream {
        let variant_ident = &el.variant_ident;
        let target_type = ctx.resolve_type_for_module(&el.target_type);
        let target_type = el.occurs.make_type(&target_type, el.need_indirection);

        let serde = match ctx.serde_support {
            SerdeSupport::None => None,
            SerdeSupport::QuickXml | SerdeSupport::SerdeXmlRs => {
                let name = el.info.ident.name.to_string();

                Some(quote!(#[serde(rename = #name)]))
            }
        };

        quote! {
            #serde
            #variant_ident(#target_type),
        }
    }

    fn render_complex_struct(&self, ty: &ComplexTypeStruct<'_>, ctx: &mut Context<'_, '_>) {
        let derive = get_derive(ctx, Option::<String>::None);
        let type_ident = &ty.type_ident;
        let trait_impls = render_trait_impls(type_ident, &ty.trait_impls);

        let attributes = ty
            .attributes
            .iter()
            .map(|attrib| self.render_complex_struct_attrib(attrib, type_ident, ctx));
        let fields = ty
            .elements()
            .iter()
            .map(|field| self.render_complex_struct_field(field, ctx));
        let content = ty
            .content()
            .as_ref()
            .and_then(|content| self.render_complex_struct_content(content, ctx));

        let struct_data = if ty.is_unit_struct() {
            quote!(;)
        } else {
            quote! {
                {
                    #( #attributes )*
                    #( #fields )*
                    #content
                }
            }
        };

        let code = quote! {
            #derive
            pub struct #type_ident
                #struct_data

            #( #trait_impls )*
        };

        ctx.module().append(code);
    }

    fn render_complex_struct_attrib(
        &self,
        attrib: &ComplexTypeAttribute<'_>,
        type_ident: &Ident2,
        ctx: &Context<'_, '_>,
    ) -> TokenStream {
        let field_ident = &attrib.ident;
        let target_type = ctx.resolve_type_for_module(&attrib.target_type);
        let default = if attrib.default_value.is_some() {
            let default_path = format!("{type_ident}::default_{field_ident}");

            quote!(default = #default_path,)
        } else if attrib.info.use_ == Use::Optional {
            quote!(default,)
        } else {
            quote!()
        };

        let serde = match ctx.serde_support {
            SerdeSupport::None => None,
            SerdeSupport::QuickXml => {
                let name = format!("@{}", attrib.info.ident.name);

                Some(quote!(#[serde(#default rename = #name)]))
            }
            SerdeSupport::SerdeXmlRs => {
                let name = format!("{}", attrib.info.ident.name);

                Some(quote!(#[serde(#default rename = #name)]))
            }
        };

        if attrib.is_option {
            quote! {
                #serde
                pub #field_ident: Option<#target_type>,
            }
        } else {
            quote! {
                #serde
                pub #field_ident: #target_type,
            }
        }
    }

    fn render_complex_struct_field(
        &self,
        field: &ComplexTypeElement<'_>,
        ctx: &Context<'_, '_>,
    ) -> TokenStream {
        let field_ident = &field.field_ident;
        let target_type = ctx.resolve_type_for_module(&field.target_type);
        let target_type = field
            .occurs
            .make_type(&target_type, field.need_indirection)
            .unwrap();

        let serde = match ctx.serde_support {
            SerdeSupport::None => None,
            SerdeSupport::QuickXml | SerdeSupport::SerdeXmlRs => {
                let name = field.info.ident.name.to_string();
                let default = match field.occurs {
                    Occurs::None | Occurs::Single | Occurs::StaticList(_) => quote!(),
                    Occurs::Optional | Occurs::DynamicList => quote!(default,),
                };

                Some(quote!(#[serde(#default rename = #name)]))
            }
        };

        quote! {
            #serde
            pub #field_ident: #target_type,
        }
    }

    fn render_complex_struct_content(
        &self,
        content: &ComplexTypeContent,
        ctx: &Context<'_, '_>,
    ) -> Option<TokenStream> {
        let target_type = ctx.resolve_type_for_module(&content.target_type);
        let target_type = content.occurs.make_type(&target_type, false)?;
        let serde_default = (content.min_occurs == 0).then(|| quote!(default,));
        let serde = match (ctx.serde_support, content.is_simple) {
            (SerdeSupport::None, _) => None,
            (SerdeSupport::QuickXml, true) => {
                Some(quote!(#[serde(#serde_default rename = "$text")]))
            }
            (_, _) => Some(quote!(#[serde(#serde_default rename = "$value")])),
        };

        Some(quote! {
            #serde
            pub content: #target_type,
        })
    }
}

/* Helper */

fn get_derive<I>(ctx: &Context<'_, '_>, extra: I) -> TokenStream
where
    I: IntoIterator,
    I::Item: Display,
{
    let serde: SmallVec<[Ident2; 2]> = if ctx.serde_support == SerdeSupport::None {
        smallvec![]
    } else {
        ctx.add_usings([quote!(serde::Serialize), quote!(serde::Deserialize)]);

        smallvec![format_ident!("Serialize"), format_ident!("Deserialize")]
    };

    let extra = extra.into_iter().map(|x| format_ident!("{x}"));
    let types = ctx
        .derive
        .iter()
        .cloned()
        .chain(serde)
        .chain(extra)
        .collect::<Vec<_>>();

    if types.is_empty() {
        quote! {}
    } else {
        quote! {
            #[derive( #( #types ),* )]
        }
    }
}

fn get_dyn_type_traits(ctx: &Context<'_, '_>) -> TokenStream {
    format_traits(match &ctx.dyn_type_traits {
        DynTypeTraits::Auto => vec![],
        DynTypeTraits::Custom(x) => x
            .iter()
            .map(|ident| {
                ctx.add_usings([quote!(#ident)]);

                let ident = ident.ident();

                quote!(#ident)
            })
            .collect::<Vec<_>>(),
    })
}

fn format_traits<I>(iter: I) -> TokenStream
where
    I: IntoIterator,
    I::Item: ToTokens,
{
    let parts = iter
        .into_iter()
        .enumerate()
        .map(|(i, x)| if i == 0 { quote!(#x) } else { quote!(+ #x) });

    quote! {
        #( #parts )*
    }
}

fn render_trait_impls<'a>(
    type_ident: &'a Ident2,
    trait_idents: &'a [TokenStream],
) -> impl Iterator<Item = TokenStream> + 'a {
    trait_idents.iter().map(move |trait_ident| {
        quote! {
            impl #trait_ident for #type_ident { }
        }
    })
}
