//! Contains the [`Config`] structures for the [`generate`](super::generate) method.

use std::path::PathBuf;

use bitflags::bitflags;
use url::Url;

pub use crate::generator::{BoxFlags, ContentMode, GenerateFlags, SerdeSupport, TypedefMode};
pub use crate::schema::{Namespace, NamespacePrefix};
pub use crate::types::{IdentType, Type};

/// Configuration structure for the [`generate`](super::generate) method.
#[must_use]
#[derive(Default, Debug, Clone)]
pub struct Config {
    /// Configuration for the schema parser.
    pub parser: ParserConfig,

    /// Configuration for the schema interpreter.
    pub interpreter: InterpreterConfig,

    /// Configuration for the type information optimizer.
    pub optimizer: OptimizerConfig,

    /// Configuration for the code generator.
    pub generator: GeneratorConfig,
}

/// Configuration for the schema parser.
#[derive(Debug, Clone)]
pub struct ParserConfig {
    /// List of resolvers to use for resolving referenced schemas.
    pub resolver: Vec<Resolver>,

    /// List of namespaces to add to the parser before the schemas are loaded.
    ///
    /// See [`with_namespace`](crate::Parser::with_namespace) for more details.
    pub namespaces: Vec<(NamespacePrefix, Namespace)>,

    /// List of schemas to load.
    pub schemas: Vec<Schema>,

    /// Additional flags to control the parser.
    pub flags: ParserFlags,

    /// Wether to enable the debug output and where to write it to.
    pub debug_output: Option<PathBuf>,
}

/// Configuration for the schema interpreter.
#[derive(Debug, Clone)]
pub struct InterpreterConfig {
    /// List of user defined types to add to the interpreter before the schemas
    /// are actually interpreted.
    ///
    /// See [`with_type`](crate::Interpreter::with_type) for more details.
    pub types: Vec<(IdentType, String, Type)>,

    /// Additional flags to control the interpreter.
    pub flags: InterpreterFlags,

    /// Wether to enable the debug output and where to write it to.
    pub debug_output: Option<PathBuf>,
}

/// Configuration for the type information optimizer.
#[derive(Debug, Clone)]
pub struct OptimizerConfig {
    /// Additional flags to control the optimizer.
    pub flags: OptimizerFlags,

    /// Wether to enable the debug output and where to write it to.
    pub debug_output: Option<PathBuf>,
}

/// Configuration for the code generator.
#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    /// Types to add to the generator before the actual code is generated.
    ///
    /// See [`with_type`](crate::Generator::with_type) for more details.
    pub types: Vec<(IdentType, String)>,

    /// Sets the traits the generated types should derive from.
    ///
    /// See [`derive`](crate::Generator::derive) for more details.
    pub derive: Option<Vec<String>>,

    /// Postfixes that should be applied to the name of the different generated
    /// types.
    ///
    /// See [`with_type_postfix`](crate::Generator::with_type_postfix) for more details.
    pub type_postfix: TypePostfix,

    /// Tell the generator how to deal with boxing.
    pub box_flags: BoxFlags,

    /// Tell the generator what type should be generated for the content of an XML element.
    pub content_mode: ContentMode,

    /// Tells the generator how to deal with type definitions.
    pub typedef_mode: TypedefMode,

    /// Tells the generator how to generate code for the [`serde`] crate.
    pub serde_support: SerdeSupport,

    /// Specify which types the generator should generate code for.
    pub generate: Generate,

    /// Additional flags to control the generator.
    pub flags: GenerateFlags,

    /// Name of the `xsd-parser` crate that is used for the generated code.
    pub xsd_parser: String,
}

/// Postfixed that will be added to the different types generated by the code generator.
#[derive(Debug, Clone)]
pub struct TypePostfix {
    /// Postfix added to normal types (like `xs:simpleType` or `xs:complexType`).
    pub type_: String,

    /// Postfixes added to elements (like `xs:element`).
    pub element: String,

    /// Postfixes added to inline types if elements (like `xs:element`).
    pub element_type: String,
}

/// Configuration for the resolver used in [`ParserConfig`].
#[derive(Debug, Clone)]
pub enum Resolver {
    /// Resolver that is used to resolve ewb resources (like `http://...` or `https://...`).
    #[cfg(feature = "web-resolver")]
    Web,

    /// Resolver that is used to resolve local resources from disk (like `./local-schema.xsd` or `file://...`).
    File {
        /// Use the directory the current schema is load from as search path for other schemas.
        use_current_path: bool,

        /// Add additional search paths that should be used to resolve other local stored schemas.
        search_paths: Vec<PathBuf>,
    },
}

/// Configuration for the schemas to load used in [`ParserConfig`].
#[derive(Debug, Clone)]
pub enum Schema {
    /// Load a schema from the provided URL.
    Url(Url),

    /// Load a schema from the provided file path.
    File(PathBuf),

    /// Load the schema from the provided string.
    Schema(String),
}

/// Configuration which types the [`Generator`](crate::Generator) should generate
/// code for used in [`GeneratorConfig`].
#[derive(Debug, Clone)]
pub enum Generate {
    /// The generator will generate code for all types of the schemas.
    All,

    /// List of identifiers the generator will generate code for.
    ///
    /// A type is a combination of a identifier type and a string like so:
    /// - `(IdentType::Type, "xs:int")`
    /// - `(IdentType::Element, "example:rootElement")`
    Types(Vec<(IdentType, String)>),
}

bitflags! {
    /// Flags to control the [`Parser`](crate::Parser).
    #[derive(Debug, Clone)]
    pub struct ParserFlags: u32 {
        /// Whether the parser should resolve `xs:include` and `xs:import` elements
        /// or not.
        ///
        /// See [`resolve_includes`](crate::Parser::resolve_includes) for details.
        const RESOLVE_INCLUDES = 1 << 0;

        /// Whether to add the default namespaces to the parser or not.
        ///
        /// See [`with_default_namespaces`](crate::Parser::with_default_namespaces) for details.
        const DEFAULT_NAMESPACES = 1 << 1;
    }
}

bitflags! {
    /// Flags to control the [`Interpreter`](crate::Interpreter).
    #[derive(Debug, Clone)]
    pub struct InterpreterFlags: u32 {
        /// Whether to add the build-in types to the interpreter or not.
        ///
        /// See [`with_buildin_types`](crate::Interpreter::with_buildin_types) for details.
        const BUILDIN_TYPES = 1 << 0;

        /// Whether to add the default types definitions to the interpreter or not.
        ///
        /// See [`with_default_typedefs`](crate::Interpreter::with_default_typedefs) for details.
        const DEFAULT_TYPEDEFS = 1 << 1;
    }
}

bitflags! {
    /// Flags to control the [`Optimizer`](crate::Optimizer).
    #[derive(Debug, Clone)]
    pub struct OptimizerFlags: u32 {
        /// Whether to remove empty enum variants or not.
        ///
        /// See [`remove_empty_enum_variants`](crate::Optimizer::remove_empty_enum_variants) for details.
        const REMOVE_EMPTY_ENUM_VARIANTS = 1 << 0;

        /// Whether to remove empty enums or not.
        ///
        /// See [`remove_empty_enums`](crate::Optimizer::remove_empty_enums) for details.
        const REMOVE_EMPTY_ENUMS = 1 << 1;

        /// Whether to remove duplicate union variants or not.
        ///
        /// See [`remove_duplicate_union_variants`](crate::Optimizer::remove_duplicate_union_variants) for details.
        const REMOVE_DUPLICATE_UNION_VARIANTS = 1 << 2;

        /// Whether to remove empty unions or not.
        ///
        /// See [`remove_empty_unions`](crate::Optimizer::remove_empty_unions) for details.
        const REMOVE_EMPTY_UNIONS = 1 << 3;

        /// Whether to use the unrestricted base type of a type or not.
        ///
        /// See [`use_unrestricted_base_type`](crate::Optimizer::use_unrestricted_base_type) for details.
        const USE_UNRESTRICTED_BASE_TYPE = 1 << 4;

        /// Whether to convert dynamic types to choices or not.
        ///
        /// See [`convert_dynamic_to_choice`](crate::Optimizer::convert_dynamic_to_choice) for details.
        const CONVERT_DYNAMIC_TO_CHOICE = 1 << 5;

        /// Whether to flatten the content of an element or not.
        ///
        /// See [`flatten_element_content`](crate::Optimizer::flatten_element_content) for details.
        const FLATTEN_ELEMENT_CONTENT = 1 << 6;

        /// Whether to flatten unions or not.
        ///
        /// See [`flatten_unions`](crate::Optimizer::flatten_unions) for details.
        const FLATTEN_UNIONS = 1 << 7;

        /// Whether to merge enumerations and unions or not.
        ///
        /// See [`merge_enum_unions`](crate::Optimizer::merge_enum_unions) for details.
        const MERGE_ENUM_UNIONS = 1 << 8;

        /// Whether to resolve type definitions or not.
        ///
        /// See [`resolve_typedefs`](crate::Optimizer::resolve_typedefs) for details.
        const RESOLVE_TYPEDEFS = 1 << 9;

        /// Whether to remove duplicate types or not.
        ///
        /// See [`remove_duplicates`](crate::Optimizer::remove_duplicates) for details.
        const REMOVE_DUPLICATES = 1 << 10;

        /// Group that contains all necessary optimization that should be applied
        /// if code with [`serde`] support should be rendered.
        const SERDE =  Self::FLATTEN_ELEMENT_CONTENT.bits()
            | Self::FLATTEN_UNIONS.bits()
            | Self::MERGE_ENUM_UNIONS.bits();
    }
}

impl Config {
    /// Add optimizer flags to the config.
    pub fn with_optimizer_flags(mut self, flags: OptimizerFlags) -> Self {
        self.optimizer.flags.insert(flags);

        self
    }

    /// Remove optimizer flags to the config.
    pub fn without_optimizer_flags(mut self, flags: OptimizerFlags) -> Self {
        self.optimizer.flags.remove(flags);

        self
    }

    /// Add code generator flags to the config.
    pub fn with_generate_flags(mut self, flags: GenerateFlags) -> Self {
        self.generator.flags.insert(flags);

        self
    }

    /// Remove code generator flags to the config.
    pub fn without_generate_flags(mut self, flags: GenerateFlags) -> Self {
        self.generator.flags.remove(flags);

        self
    }

    /// Add boxing flags to the code generator config.
    pub fn with_box_flags(mut self, flags: BoxFlags) -> Self {
        self.generator.box_flags.insert(flags);

        self
    }

    /// Remove boxing flags to the code generator config.
    pub fn without_box_flags(mut self, flags: BoxFlags) -> Self {
        self.generator.box_flags.remove(flags);

        self
    }

    /// Enable code generation for [`quick_xml`] serialization and deserialization.
    pub fn with_quick_xml(mut self) -> Self {
        self.generator.flags |= GenerateFlags::QUICK_XML | GenerateFlags::FLATTEN_CONTENT;

        self
    }

    /// Set the [`serde`] support.
    pub fn with_serde_support(mut self, serde_support: SerdeSupport) -> Self {
        self.generator.serde_support = serde_support;

        if self.generator.serde_support != SerdeSupport::None {
            self.optimizer.flags |= OptimizerFlags::SERDE;
        }

        self
    }

    /// Set the types the code should be generated for.
    pub fn with_generate<I, T>(mut self, types: I) -> Self
    where
        I: IntoIterator<Item = (IdentType, T)>,
        T: Into<String>,
    {
        self.generator.generate =
            Generate::Types(types.into_iter().map(|(a, b)| (a, b.into())).collect());

        self
    }

    /// Set the content mode for the generator.
    pub fn with_content_mode(mut self, mode: ContentMode) -> Self {
        self.generator.content_mode = mode;

        self
    }

    /// Set the typedef mode for the generator.
    pub fn with_typedef_mode(mut self, mode: TypedefMode) -> Self {
        self.generator.typedef_mode = mode;

        self
    }

    /// Set the traits the generated types should derive from.
    pub fn with_derive<I>(mut self, derive: I) -> Self
    where
        I: IntoIterator,
        I::Item: Into<String>,
    {
        self.generator.derive = Some(
            derive
                .into_iter()
                .map(Into::into)
                .filter(|s| !s.is_empty())
                .collect(),
        );

        self
    }
}

impl Default for ParserConfig {
    fn default() -> Self {
        Self {
            resolver: vec![Resolver::File {
                use_current_path: true,
                search_paths: vec![],
            }],
            schemas: vec![],
            namespaces: vec![],
            flags: ParserFlags::RESOLVE_INCLUDES | ParserFlags::DEFAULT_NAMESPACES,
            debug_output: None,
        }
    }
}

impl Default for InterpreterConfig {
    fn default() -> Self {
        Self {
            types: vec![],
            debug_output: None,
            flags: InterpreterFlags::BUILDIN_TYPES | InterpreterFlags::DEFAULT_TYPEDEFS,
        }
    }
}

impl Default for OptimizerConfig {
    fn default() -> Self {
        Self {
            debug_output: None,
            flags: OptimizerFlags::REMOVE_EMPTY_ENUM_VARIANTS
                | OptimizerFlags::REMOVE_EMPTY_ENUMS
                | OptimizerFlags::REMOVE_DUPLICATE_UNION_VARIANTS
                | OptimizerFlags::REMOVE_EMPTY_UNIONS,
        }
    }
}

impl Default for GeneratorConfig {
    fn default() -> Self {
        Self {
            types: vec![],
            derive: None,
            type_postfix: TypePostfix::default(),
            box_flags: BoxFlags::AUTO,
            content_mode: ContentMode::Auto,
            typedef_mode: TypedefMode::Auto,
            serde_support: SerdeSupport::None,
            generate: Generate::All,
            flags: GenerateFlags::empty(),
            xsd_parser: "xsd_parser".into(),
        }
    }
}

impl Default for TypePostfix {
    fn default() -> Self {
        Self {
            type_: String::from("Type"),
            element: String::new(),
            element_type: String::from("ElementType"),
        }
    }
}
