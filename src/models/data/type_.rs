use std::ops::Deref;

use crate::models::meta::MetaType;

use super::{
    BuildInData, ComplexData, CustomData, DynamicData, EnumerationData, ReferenceData, UnionData,
};

/// Represents the type data that is generated by the generator for a type that
/// needs to be rendered.
///
/// The generator adds additional useful data that is needed for the rendering
/// process to the actual [`MetaType`] that needs to be rendered. So instead of
/// passing the meta type directly to the renderer and re-calculate the data
/// inside every renderer, the type is once evaluated by the generator and then
/// any renderer can profit from the enriched data.
#[derive(Debug)]
pub struct DataType<'types> {
    /// Underlying meta type this data type contains additional information for
    pub meta: &'types MetaType,

    /// The variant of the data type.
    pub variant: DataTypeVariant<'types>,
}

/// Variant of a [`DataType`].
#[derive(Debug)]
pub enum DataTypeVariant<'types> {
    /// Corresponds to [`MetaTypeVariant::BuildIn`].
    BuildIn(BuildInData<'types>),

    /// Corresponds to [`MetaTypeVariant::Custom`].
    Custom(CustomData<'types>),

    /// Corresponds to [`MetaTypeVariant::Union`].
    Union(UnionData<'types>),

    /// Corresponds to [`MetaTypeVariant::Dynamic`].
    Dynamic(DynamicData<'types>),

    /// Corresponds to [`MetaTypeVariant::Reference`].
    Reference(ReferenceData<'types>),

    /// Corresponds to [`MetaTypeVariant::Enumeration`].
    Enumeration(EnumerationData<'types>),

    /// Corresponds to [`MetaTypeVariant::All`], [`MetaTypeVariant::Choice`],
    /// [`MetaTypeVariant::Sequence`] or [`MetaTypeVariant::ComplexType`].
    Complex(ComplexData<'types>),
}

impl Deref for DataType<'_> {
    type Target = MetaType;

    fn deref(&self) -> &Self::Target {
        self.meta
    }
}
