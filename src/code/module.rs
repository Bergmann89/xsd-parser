use std::collections::{BTreeMap, BTreeSet};
use std::mem::replace;
use std::str::FromStr;

use proc_macro2::{Ident as Ident2, TokenStream};
use quote::{format_ident, quote, ToTokens};

use super::IdentPath;

/// Manages the code that is generated for a specific module.
///
/// This type stores the generated code, the related using directives as well as
/// any sub-module for a specific module generated by the code generator.
#[derive(Default, Debug)]
pub struct Module {
    /// The actual code that is manages by this module.
    pub code: TokenStream,

    /// A set of using directives this module needs.
    pub usings: BTreeSet<String>,

    /// A map of sub-modules contained inside this module.
    pub modules: BTreeMap<String, Module>,
}

impl Module {
    /// Append the passed `code` to this module code.
    pub fn append(&mut self, code: TokenStream) -> &mut Self {
        self.code.extend(code);

        self
    }

    /// Prepend the passed `code` to this module code.
    pub fn prepend(&mut self, code: TokenStream) -> &mut Self {
        let code = replace(&mut self.code, code);

        self.append(code)
    }

    /// Add using directives to the set of this module.
    pub fn usings<I>(&mut self, usings: I) -> &mut Self
    where
        I: IntoIterator,
        I::Item: ToString,
    {
        for using in usings {
            self.usings.insert(using.to_string());
        }

        self
    }

    /// Get a reference to a sub-module identified by the passed `ident`.
    ///
    /// If the module does not exist `None` is returned.
    pub fn module<T>(&self, ident: T) -> Option<&Module>
    where
        T: AsRef<str>,
    {
        self.modules.get(ident.as_ref())
    }

    /// Get a mutable reference to a sub-module identified by the passed `ident`.
    ///
    /// If the module does not exist it will be created.
    pub fn module_mut<T>(&mut self, ident: T) -> &mut Module
    where
        T: Into<String>,
    {
        self.modules.entry(ident.into()).or_default()
    }
}

impl ToTokens for Module {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let Self {
            code,
            usings,
            modules,
        } = self;
        let usings = render_usings(usings.iter());

        tokens.extend(quote! {
            #usings
            #code
        });

        for (ident, module) in modules {
            let name = format_ident!("{ident}");

            tokens.extend(quote! {
                pub mod #name {
                    #module
                }
            });
        }
    }
}

fn render_usings<I>(usings: I) -> TokenStream
where
    I: IntoIterator,
    I::Item: AsRef<str>,
{
    #[derive(Default)]
    struct Module {
        usings: BTreeSet<Ident2>,
        sub_modules: BTreeMap<Ident2, Module>,
    }

    impl Module {
        fn render(&self) -> TokenStream {
            let count = self.usings.len() + self.sub_modules.len();

            let usings = self.usings.iter().map(|ident| quote!(#ident));
            let sub_modules = self.sub_modules.iter().map(|(ident, module)| {
                let using = module.render();

                quote!(#ident::#using)
            });

            let items = usings.chain(sub_modules);

            if count > 1 {
                quote!({ #( #items ),* })
            } else {
                quote!(#( #items )*)
            }
        }
    }

    let mut root = Module::default();

    for using in usings {
        let using = using.as_ref();
        let Ok(ident) = IdentPath::from_str(using) else {
            continue;
        };

        let (ident, path) = ident.into_parts();

        let mut module = &mut root;
        for part in path.into_iter().flat_map(|x| x.0) {
            module = module.sub_modules.entry(part).or_default();
        }

        module.usings.insert(ident);
    }

    let mut ret = TokenStream::new();
    for (ident, module) in &root.sub_modules {
        let using = module.render();
        ret.extend(quote!(use #ident::#using;));
    }

    ret
}
