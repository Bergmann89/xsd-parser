use std::mem::take;
use std::ops::Deref;

use proc_macro2::{Ident as Ident2, Literal, TokenStream};
use quote::{format_ident, quote};

use crate::{
    code::{format_field_ident, format_variant_ident, IdentPath, ModulePath},
    schema::{xs::Use, MaxOccurs, MinOccurs, NamespaceId},
    types::{
        AnyAttributeInfo, AnyInfo, AttributeInfo, BuildInInfo, ComplexInfo, ComplexTypeVariant, DynamicInfo, ElementInfo, EnumerationInfo, GroupInfo, Ident, ReferenceInfo, SimpleTypeVariant, Type, TypeDescriptor, Types, UnionInfo, UnionTypeInfo, VariantInfo
    },
};

use super::{
    misc::Occurs, BoxFlags, Config, Error, GeneratorFlags, State, TraitInfos, TypeRef, TypedefMode,
};

/// Represents the type data that is generated by teh generator for a type that
/// needs to be rendered.
///
/// The generator adds additional useful data that is needed for the rendering
/// process to the actual [`Type`] that needs to be rendered. So instead of
/// passing the type directly to the renderer and re-calculate the data inside
/// every renderer, the type is once evaluated by the generator and then any
/// renderer can profit from the enriched data.
#[derive(Debug)]
pub enum TypeData<'types> {
    /// Corresponds to [`TypeVariant::BuildIn`].
    BuildIn(BuildInType<'types>),

    /// Corresponds to [`TypeVariant::Union`].
    Union(UnionType<'types>),

    /// Corresponds to [`TypeVariant::Dynamic`].
    Dynamic(DynamicType<'types>),

    /// Corresponds to [`TypeVariant::Reference`].
    Reference(ReferenceType<'types>),

    /// Corresponds to [`TypeVariant::Enumeration`].
    Enumeration(EnumerationType<'types>),

    /// Corresponds to [`TypeVariant::All`], [`TypeVariant::Choice`],
    /// [`TypeVariant::Sequence`] or [`TypeVariant::ComplexType`].
    Complex(ComplexType<'types>),
}

impl<'types> TypeData<'types> {
    pub(super) fn new_simple(
        tyv: &'types SimpleTypeVariant,
        ident: &Ident,
        config: &Config<'types>,
        state: &mut State<'types>,
    ) -> Result<Self, Error> {
        let req = Request::new(ident, config, state);

        Ok(match &tyv {
            SimpleTypeVariant::Union(x) => Self::Union(UnionType::new(x, req)?),
            SimpleTypeVariant::BuildIn(x) => Self::BuildIn(BuildInType::new(x)),
            SimpleTypeVariant::Reference(x) => Self::Reference(ReferenceType::new(x, req)?),
            SimpleTypeVariant::Enumeration(x) => {
                Self::Enumeration(EnumerationType::new(x, req)?)
            }
        })
    }

    pub(super) fn new(
        ty: &'types Type,
        ident: &Ident,
        config: &Config<'types>,
        state: &mut State<'types>,
    ) -> Result<Self, Error> {

        Ok(match ty {
            Type::SimpleType(td) => Self::new_simple(td, ident, config, state)?,
            Type::ComplexType(td) => {
                if let ComplexTypeVariant::SimpleType(x) = &td.variant {
                    return Self::new_simple(x, ident, config, state);
                }

                let req = Request::new(ident, config, state);

                match &td.variant {
                ComplexTypeVariant::Reference(x) => Self::Reference(ReferenceType::new(x, req)?),
                ComplexTypeVariant::Dynamic(x) => Self::Dynamic(DynamicType::new(x, req)?),
                ComplexTypeVariant::All(x) => Self::Complex(ComplexType::new_all(x, req)?),
                ComplexTypeVariant::Choice(x) => Self::Complex(ComplexType::new_choice(x, req)?),
                ComplexTypeVariant::Sequence(x) => {
                    Self::Complex(ComplexType::new_sequence(x, req)?)
                }
                ComplexTypeVariant::ComplexType(x) => {
                    Self::Complex(ComplexType::new_complex(x, req)?)
                }
                ComplexTypeVariant::SimpleType(_) => unreachable!()
            }},
        })
    }
}

/// Contains additional information for the rendering process
/// of a [`TypeVariant::BuildIn`] type.
#[derive(Debug)]
pub struct BuildInType<'types> {
    /// Reference to the original type information.
    pub info: &'types BuildInInfo,
}

impl<'types> BuildInType<'types> {
    fn new(info: &'types BuildInInfo) -> Self {
        Self { info }
    }
}

/// Contains additional information for the rendering process
/// of a [`TypeVariant::Union`] type.
#[derive(Debug)]
pub struct UnionType<'types> {
    /// Reference to the original type information.
    pub info: &'types UnionInfo,

    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// List of variants contained in this union.
    pub variants: Vec<UnionTypeVariant<'types>>,

    /// List of traits that needs to be implemented by this type.
    pub trait_impls: Vec<IdentPath>,
}

/// Type variant used in [`UnionType`].
#[derive(Debug)]
pub struct UnionTypeVariant<'types> {
    /// Reference to the original type information.
    pub info: &'types UnionTypeInfo,

    /// The type that is stored by the this variant.
    pub target_type: IdentPath,

    /// Identifier of this variant.
    pub variant_ident: Ident2,
}

impl<'types> UnionType<'types> {
    fn new(info: &'types UnionInfo, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let type_ident = req.current_type_ref().type_ident.clone();
        let trait_impls = req.make_trait_impls()?;
        let variants = info
            .types
            .iter()
            .map(|info| info.make_variant(&mut req))
            .collect::<Result<_, _>>()?;

        Ok(Self {
            info,
            type_ident,
            variants,
            trait_impls,
        })
    }
}

impl UnionTypeInfo {
    fn make_variant<'types>(
        &'types self,
        req: &mut Request<'_, 'types>,
    ) -> Result<UnionTypeVariant<'types>, Error> {
        let type_ref = req.get_or_create_type_ref(self.type_.clone())?;
        let target_type = type_ref.to_ident_path();
        let variant_ident = format_variant_ident(&self.type_.name, self.display_name.as_deref());

        Ok(UnionTypeVariant {
            info: self,
            target_type,
            variant_ident,
        })
    }
}

/// Contains additional information for the rendering process
/// of a [`TypeVariant::Dynamic`] type.
#[derive(Debug)]
pub struct DynamicType<'types> {
    /// Reference to the original type information.
    pub info: &'types DynamicInfo,

    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// The identifier of the trait that needs to be implemented
    /// by the derived types.
    pub trait_ident: Ident2,

    /// Identifier of the deserializer for this type.
    pub deserializer_ident: Ident2,

    /// List of additional traits that need to be implemented by the derived
    /// types (if this type was inherited from another dynamic type).
    pub sub_traits: Option<Vec<IdentPath>>,

    /// List of derived types.
    pub derived_types: Vec<DerivedType>,
}

/// Represents a derived type used by [`DynamicType`].
#[derive(Debug)]
pub struct DerivedType {
    /// Identifier of the derived type.
    pub ident: Ident,

    /// Name of the derived type as byte string literal.
    pub b_name: Literal,

    /// The actual target type of this derived type information.
    pub target_type: IdentPath,

    /// Name of the variant used for this derived type information.
    pub variant_ident: Ident2,
}

impl<'types> DynamicType<'types> {
    fn new(info: &'types DynamicInfo, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let type_ident = req.current_type_ref().type_ident.clone();
        let trait_ident = format_ident!("{type_ident}Trait");
        let ident = req.ident.clone();
        let sub_traits = req
            .get_trait_infos()
            .get(&ident)
            .map(|info| info.traits_direct.clone())
            .map(|traits_direct| {
                traits_direct
                    .iter()
                    .map(|ident| {
                        req.get_or_create_type_ref(ident.clone()).map(|x| {
                            let ident = format_ident!("{}Trait", x.type_ident);

                            x.to_ident_path().with_ident(ident)
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()
            })
            .transpose()?;
        let derived_types = info
            .derived_types
            .iter()
            .map(|ident| make_derived_type_data(&mut req, ident))
            .collect::<Result<Vec<_>, _>>()?;

        let deserializer_ident = format_ident!("{type_ident}Deserializer");

        Ok(Self {
            info,
            type_ident,
            trait_ident,
            deserializer_ident,
            sub_traits,
            derived_types,
        })
    }
}

/// Contains additional information for the rendering process
/// of a [`TypeVariant::Reference`] type.
#[derive(Debug)]
pub struct ReferenceType<'types> {
    /// Reference to the original type information.
    pub info: &'types ReferenceInfo,

    /// Typedef mode that should be used to render this reference type.
    pub mode: TypedefMode,

    /// Occurrence of the referenced type within this type.
    pub occurs: Occurs,

    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// Actual target type of this referenced type.
    pub target_type: IdentPath,

    /// List of traits that needs to be implemented by this type.
    pub trait_impls: Vec<IdentPath>,
}

impl<'types> ReferenceType<'types> {
    fn new(info: &'types ReferenceInfo, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let occurs = Occurs::from_occurs(info.min_occurs, info.max_occurs);
        let type_ident = req.current_type_ref().type_ident.clone();
        let target_ref = req.get_or_create_type_ref(info.type_.clone())?;
        let target_type = target_ref.to_ident_path();
        let trait_impls = req.make_trait_impls()?;

        let mode = match (req.typedef_mode, occurs) {
            (TypedefMode::Auto, Occurs::None | Occurs::Single) => TypedefMode::Typedef,
            (TypedefMode::Auto, _) => TypedefMode::NewType,
            (mode, _) => mode,
        };

        Ok(Self {
            info,
            mode,
            occurs,
            type_ident,
            target_type,
            trait_impls,
        })
    }
}

/// Contains additional information for the rendering process
/// of a [`TypeVariant::Enumeration`] type.
#[derive(Debug)]
pub struct EnumerationType<'types> {
    /// Reference to the original type information.
    pub info: &'types EnumerationInfo,

    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// List of variants of this enumeration.
    pub variants: Vec<EnumerationTypeVariant<'types>>,

    /// List of traits that needs to be implemented by this type.
    pub trait_impls: Vec<IdentPath>,
}

/// Represents a enumeration variant used by [`EnumerationType`].
#[derive(Debug)]
pub struct EnumerationTypeVariant<'types> {
    /// Reference to the original type information.
    pub info: &'types VariantInfo,

    /// Name of this variant.
    pub variant_ident: Ident2,

    /// Target type of this variant.
    pub target_type: Option<IdentPath>,
}

impl<'types> EnumerationType<'types> {
    fn new(info: &'types EnumerationInfo, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let mut unknown = 0usize;
        let type_ident = req.current_type_ref().type_ident.clone();
        let trait_impls = req.make_trait_impls()?;

        let variants = info
            .variants
            .iter()
            .filter_map(|var| var.make_variant(&mut unknown, &mut req))
            .collect::<Result<Vec<_>, _>>()?;

        Ok(EnumerationType {
            info,
            type_ident,
            variants,
            trait_impls,
        })
    }
}

impl VariantInfo {
    fn make_variant<'types>(
        &'types self,
        unknown: &mut usize,
        req: &mut Request<'_, 'types>,
    ) -> Option<Result<EnumerationTypeVariant<'types>, Error>> {
        match self.use_ {
            Use::Prohibited => None,
            Use::Required | Use::Optional => {
                let type_ref = if let Some(t) = &self.type_ {
                    match req.get_or_create_type_ref(t.clone()) {
                        Ok(target_ref) => Some(target_ref),
                        Err(error) => return Some(Err(error)),
                    }
                } else {
                    None
                };

                let variant_ident = if let Some(display_name) = self.display_name.as_deref() {
                    format_ident!("{display_name}")
                } else if self.ident.name.as_str().is_empty() {
                    *unknown += 1;

                    format_ident!("Unknown{unknown}")
                } else {
                    format_variant_ident(&self.ident.name, self.display_name.as_deref())
                };

                let target_type = type_ref.map(TypeRef::to_ident_path);

                Some(Ok(EnumerationTypeVariant {
                    info: self,
                    variant_ident,
                    target_type,
                }))
            }
        }
    }
}

/// Contains additional information for the rendering process
/// of a [`TypeVariant::All`], [`TypeVariant::Choice`],
/// [`TypeVariant::Sequence`] or [`TypeVariant::ComplexType`] type.
///
/// To simplify the rendering process this recursive type was added to the
/// generator. It basically boils down to the following:
///
///   - A complex type with a `choice` will result in a struct with a enum
///     content type.
///   - A complex type with a `all` or `sequence` will result in a struct
///     with a struct content type.
///   - A simple `choice` will result in a single enum type.
///   - A simple `all` or `sequence` will result in a single sequence.
///
/// Additional improvements may be applied to the type, to reduce the complexity
/// of the generated type (for example flattening the content if possible).
#[derive(Debug)]
pub enum ComplexType<'types> {
    /// The type represents an enumeration.
    ///
    /// This is normally used for `choice` elements.
    Enum {
        /// The main type.
        type_: ComplexTypeEnum<'types>,

        /// The content of the main type (if needed).
        content_type: Option<Box<ComplexType<'types>>>,
    },

    /// The type represents a struct.
    ///
    /// This is normally used for `all`
    Struct {
        /// The main type.
        type_: ComplexTypeStruct<'types>,

        /// The content of the main type (if needed).
        content_type: Option<Box<ComplexType<'types>>>,
    },
}

/// Contains basic information for that is shared between [`ComplexTypeEnum`]
/// and [`ComplexTypeStruct`].
#[derive(Debug)]
pub struct ComplexTypeBase {
    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// List of traits that needs to be implemented by this type.
    pub trait_impls: Vec<IdentPath>,

    /// Name of the XML tag of the type (if the type represents an element in the XML).
    pub tag_name: Option<String>,

    /// `true` if the type is a complex type, `false` otherwise.
    pub is_complex: bool,

    /// `true` if the type is dynamic, `false` otherwise.
    pub is_dynamic: bool,

    /// Identifier of the serializer for this type.
    pub serializer_ident: Ident2,

    /// Identifier of the state of the serializer for this type.
    pub serializer_state_ident: Ident2,

    /// Identifier of the deserializer for this type.
    pub deserializer_ident: Ident2,

    /// Identifier of the state of the deserializer for this type.
    pub deserializer_state_ident: Ident2,
}

/// Represents a rust enum.
///
/// Is used as part of the [`ComplexType`].
#[derive(Debug)]
pub struct ComplexTypeEnum<'types> {
    /// Basic type information.
    pub base: ComplexTypeBase,

    /// List of `xs:element`s or variants contained in this enum
    pub elements: Vec<ComplexTypeElement<'types>>,

    /// Content of the `xs:any`.
    pub any_element: Option<&'types AnyInfo>,

    /// Content of the `xs:anyAttribute`.
    pub any_attribute: Option<&'types AnyAttributeInfo>,
}

/// Represents a rust struct.
///
/// Is used as part of the [`ComplexType`].
#[derive(Debug)]
pub struct ComplexTypeStruct<'types> {
    /// Basic type information.
    pub base: ComplexTypeBase,

    /// Additional information about the content of the struct.
    pub mode: StructMode<'types>,

    /// List of `xs:attribute`s contained in this struct.
    pub attributes: Vec<ComplexTypeAttribute<'types>>,

    /// Content of the `xs:anyAttribute`.
    pub any_attribute: Option<&'types AnyAttributeInfo>,
}

/// Content of a rust struct.
///
/// Used by [`ComplexTypeStruct`] to tell how the actual content of the struct
/// should be rendered.
#[derive(Debug)]
pub enum StructMode<'types> {
    /// The struct does not contain any `xs:element`s.
    Empty {
        /// Content of the `xs:any`.
        any_element: Option<&'types AnyInfo>,
    },

    /// The content of the struct is another generated type that contains
    /// the actual data.
    Content {
        /// Information about the content of the struct.
        content: ComplexTypeContent,
    },

    /// The content of the struct is a `xs:all` group.
    All {
        /// List of `xs:element`s inside the group.
        elements: Vec<ComplexTypeElement<'types>>,

        /// Content of the `xs:any`.
        any_element: Option<&'types AnyInfo>,
    },

    /// The content of the struct is a `xs:sequence` group.
    Sequence {
        /// List of `xs:element`s inside the group.
        elements: Vec<ComplexTypeElement<'types>>,

        /// Content of the `xs:any`.
        any_element: Option<&'types AnyInfo>,
    },
}

/// Contains details about the content of a struct.
///
/// Is used by [`StructMode`] to define the content of a struct.
#[derive(Debug)]
pub struct ComplexTypeContent {
    /// Occurrence of the content within this struct.
    pub occurs: Occurs,

    /// `true` if the content is a simple type (e.g. a enum, union, string,
    /// integer, ...), `false` otherwise.
    pub is_simple: bool,

    /// Minimum occurrence.
    pub min_occurs: MinOccurs,

    /// Maximum occurrence.
    pub max_occurs: MaxOccurs,

    /// Actual target type of the content.
    pub target_type: IdentPath,
}

/// Contains the details of an XML element.
///
/// Is used in [`ComplexTypeEnum`] or [`StructMode`].
#[derive(Debug)]
pub struct ComplexTypeElement<'types> {
    /// Reference to the original type information.
    pub info: &'types ElementInfo,

    /// Occurrence of the element within it's parent type.
    pub occurs: Occurs,

    /// Name of the element as string.
    pub s_name: String,

    /// Name of the element as byte string literal.
    pub b_name: Literal,

    /// Name of the XML tag of the element.
    pub tag_name: String,

    /// Field identifier of the element.
    pub field_ident: Ident2,

    /// Variant identifier of the element.
    pub variant_ident: Ident2,

    /// Actual target type of the element.
    pub target_type: IdentPath,

    /// `true` if this element needs some indirection
    /// (like a `Box` or a `Vec`), `false` otherwise.
    pub need_indirection: bool,

    /// `true` if the target type of this element is dynamic,
    /// `false` otherwise.
    pub target_is_dynamic: bool,
}

/// Contains the details of an XML attribute.
///
/// Is used in [`ComplexTypeStruct`].
#[derive(Debug)]
pub struct ComplexTypeAttribute<'types> {
    /// Reference to the original type information.
    pub info: &'types AttributeInfo,

    /// Identifier of the attribute.
    pub ident: Ident2,

    /// Name of the attribute as string.
    pub s_name: String,

    /// Name of the attribute as byte string literal.
    pub b_name: Literal,

    /// Name of the attribute inside the XML tag.
    pub tag_name: String,

    /// `true` if this attribute is optional, `false` otherwise.
    pub is_option: bool,

    /// The actual target type of the attribute.
    pub target_type: IdentPath,

    /// The default value of the attribute.
    pub default_value: Option<TokenStream>,
}

#[derive(Debug, Clone)]
enum TypeMode {
    All,
    Choice,
    Sequence,
    Simple { target_type: IdentPath },
}

impl<'types> ComplexType<'types> {
    fn new_all(info: &'types GroupInfo, req: Request<'_, 'types>) -> Result<Self, Error> {
        Self::new(
            req,
            TypeMode::All,
            1,
            MaxOccurs::Bounded(1),
            &[],
            None,
            &info.elements,
            info.any.as_ref(),
        )
    }

    fn new_choice(info: &'types GroupInfo, req: Request<'_, 'types>) -> Result<Self, Error> {
        Self::new(
            req,
            TypeMode::Choice,
            1,
            MaxOccurs::Bounded(1),
            &[],
            None,
            &info.elements,
            info.any.as_ref(),
        )
    }

    fn new_sequence(info: &'types GroupInfo, req: Request<'_, 'types>) -> Result<Self, Error> {
        Self::new(
            req,
            TypeMode::Sequence,
            1,
            MaxOccurs::Bounded(1),
            &[],
            None,
            &info.elements,
            info.any.as_ref(),
        )
    }

    fn new_complex(info: &'types ComplexInfo, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let (type_mode, elements, any_element) = info.content.as_ref().and_then(|ident| {
            req.types
                .get_resolved_type(ident)
                .map(|ty| (ty, ident))
        }).map(|a| match a { 
            (Type::ComplexType(TypeDescriptor { variant: ComplexTypeVariant::All(si), ..}), _) => Ok((TypeMode::All, &si.elements[..], si.any.as_ref())),
            (Type::ComplexType(TypeDescriptor { variant:ComplexTypeVariant::Choice(si), ..}), _) => {
                Ok((TypeMode::Choice, &si.elements[..], si.any.as_ref()))
            }
            (Type::ComplexType(TypeDescriptor { variant:ComplexTypeVariant::Sequence(si), ..}), _) => {
                Ok((TypeMode::Sequence, &si.elements[..], si.any.as_ref()))
            }
            (Type::SimpleType(TypeDescriptor { variant:
                SimpleTypeVariant::BuildIn(_)
                | SimpleTypeVariant::Union(_)
                | SimpleTypeVariant::Enumeration(_)
                | SimpleTypeVariant::Reference(_),
                 ..}),
                ident,
            ) => {
                let content_ref = req.get_or_create_type_ref(ident.clone())?;
                let target_type = content_ref.to_ident_path();

                Ok((TypeMode::Simple { target_type }, &[][..], None))
            }
            (x, _) => {
                let ident = &req.current_type_ref().type_ident;

                tracing::warn!("Complex type has unexpected content: ident={ident}, info={info:#?}, content={x:#?}!");

                Ok((TypeMode::Sequence, &[][..], None))
            }
        }).unwrap_or(Ok((TypeMode::Sequence, &[][..], None)))?;

        Self::new(
            req,
            type_mode,
            info.min_occurs,
            info.max_occurs,
            &info.attributes,
            info.any_attribute.as_ref(),
            elements,
            any_element,
        )
    }

    #[allow(clippy::too_many_arguments)]
    fn new(
        req: Request<'_, 'types>,
        type_mode: TypeMode,
        min_occurs: MinOccurs,
        max_occurs: MaxOccurs,
        attributes: &'types [AttributeInfo],
        any_attribute: Option<&'types AnyAttributeInfo>,
        elements: &'types [ElementInfo],
        any_element: Option<&'types AnyInfo>,
    ) -> Result<Self, Error> {
        match type_mode {
            TypeMode::Simple { target_type } => Self::new_simple(
                req,
                target_type,
                min_occurs,
                max_occurs,
                attributes,
                any_attribute,
            ),
            TypeMode::Choice => Self::new_enum(
                req,
                min_occurs,
                max_occurs,
                attributes,
                any_attribute,
                elements,
                any_element,
            ),
            TypeMode::All | TypeMode::Sequence => Self::new_struct(
                req,
                &type_mode,
                min_occurs,
                max_occurs,
                attributes,
                any_attribute,
                elements,
                any_element,
            ),
        }
    }

    fn new_simple(
        mut req: Request<'_, 'types>,
        target_type: IdentPath,
        min_occurs: MinOccurs,
        max_occurs: MaxOccurs,
        attributes: &'types [AttributeInfo],
        any_attribute: Option<&'types AnyAttributeInfo>,
    ) -> Result<Self, Error> {
        let base = ComplexTypeBase::new(&mut req)?;
        let occurs = Occurs::from_occurs(min_occurs, max_occurs);
        let attributes = attributes
            .iter()
            .filter_map(|info| ComplexTypeAttribute::new_field(info, &mut req).transpose())
            .collect::<Result<Vec<_>, _>>()?;

        let content = ComplexTypeContent {
            occurs,
            is_simple: true,
            min_occurs,
            max_occurs,
            target_type,
        };
        let type_ = ComplexTypeStruct {
            base,

            mode: StructMode::Content { content },

            attributes,
            any_attribute,
        };

        Ok(Self::Struct {
            type_,
            content_type: None,
        })
    }

    fn new_enum(
        mut req: Request<'_, 'types>,
        min_occurs: MinOccurs,
        max_occurs: MaxOccurs,
        attributes: &'types [AttributeInfo],
        any_attribute: Option<&'types AnyAttributeInfo>,
        elements: &'types [ElementInfo],
        any_element: Option<&'types AnyInfo>,
    ) -> Result<Self, Error> {
        let base = ComplexTypeBase::new(&mut req)?;
        let occurs = Occurs::from_occurs(min_occurs, max_occurs);
        let flatten = occurs == Occurs::Single
            && attributes.is_empty()
            && req.check_flags(GeneratorFlags::FLATTEN_ENUM_CONTENT);

        let attributes = attributes
            .iter()
            .filter_map(|info| ComplexTypeAttribute::new_field(info, &mut req).transpose())
            .collect::<Result<Vec<_>, _>>()?;

        let mut any_element = any_element;
        let mut elements = elements
            .iter()
            .filter_map(|info| {
                ComplexTypeElement::new_variant(info, &mut req, occurs.is_direct()).transpose()
            })
            .collect::<Result<Vec<_>, _>>()?;

        if flatten {
            let type_ = ComplexTypeEnum {
                base,
                elements,
                any_element,
                any_attribute,
            };

            return Ok(ComplexType::Enum {
                type_,
                content_type: None,
            });
        }

        let type_ident = &base.type_ident;
        let content_ident = format_ident!("{type_ident}Content");
        let has_content = occurs.is_some() && !elements.is_empty();

        let content_type = has_content.then(|| {
            let type_ = ComplexTypeEnum {
                base: ComplexTypeBase::new_empty(content_ident.clone()),
                elements: take(&mut elements),
                any_element: any_element.take(),
                any_attribute: None,
            };

            Box::new(ComplexType::Enum {
                type_,
                content_type: None,
            })
        });

        let mode = if has_content {
            let type_ref = req.current_type_ref();
            let target_type = type_ref.to_ident_path().with_ident(content_ident.clone());
            let content = ComplexTypeContent {
                occurs,
                is_simple: false,
                min_occurs,
                max_occurs,
                target_type,
            };

            StructMode::Content { content }
        } else {
            StructMode::Empty { any_element }
        };

        let type_ = ComplexTypeStruct {
            base,
            mode,

            attributes,
            any_attribute,
        };

        Ok(ComplexType::Struct {
            type_,
            content_type,
        })
    }

    #[allow(clippy::too_many_arguments)]
    fn new_struct(
        mut req: Request<'_, 'types>,
        type_mode: &TypeMode,
        min_occurs: MinOccurs,
        max_occurs: MaxOccurs,
        attributes: &'types [AttributeInfo],
        any_attribute: Option<&'types AnyAttributeInfo>,
        elements: &'types [ElementInfo],
        any_element: Option<&'types AnyInfo>,
    ) -> Result<Self, Error> {
        let base = ComplexTypeBase::new(&mut req)?;
        let occurs = Occurs::from_occurs(min_occurs, max_occurs);
        let flatten =
            occurs == Occurs::Single && req.check_flags(GeneratorFlags::FLATTEN_STRUCT_CONTENT);

        let attributes = attributes
            .iter()
            .filter_map(|info| ComplexTypeAttribute::new_field(info, &mut req).transpose())
            .collect::<Result<Vec<_>, _>>()?;

        let elements = elements
            .iter()
            .filter_map(|info| {
                ComplexTypeElement::new_field(info, &mut req, occurs.is_direct()).transpose()
            })
            .collect::<Result<Vec<_>, _>>()?;

        if flatten {
            let mode = match type_mode {
                _ if elements.is_empty() => StructMode::Empty { any_element },
                TypeMode::All => StructMode::All {
                    elements,
                    any_element,
                },
                TypeMode::Sequence => StructMode::Sequence {
                    elements,
                    any_element,
                },
                _ => crate::unreachable!(),
            };

            let type_ = ComplexTypeStruct {
                base,
                mode,

                attributes,
                any_attribute,
            };

            return Ok(ComplexType::Struct {
                type_,
                content_type: None,
            });
        }

        let type_ident = &base.type_ident;
        let content_ident = format_ident!("{type_ident}Content");
        let has_content = occurs.is_some() && !elements.is_empty();

        let content_type = has_content.then(|| {
            let mode = match type_mode {
                TypeMode::All => StructMode::All {
                    elements,
                    any_element,
                },
                TypeMode::Sequence => StructMode::Sequence {
                    elements,
                    any_element,
                },
                _ => crate::unreachable!(),
            };

            let type_ = ComplexTypeStruct {
                base: ComplexTypeBase::new_empty(content_ident.clone()),
                mode,

                attributes: Vec::new(),
                any_attribute: None,
            };

            Box::new(ComplexType::Struct {
                type_,
                content_type: None,
            })
        });

        let mode = if has_content {
            let type_ref = req.current_type_ref();
            let target_type = type_ref.to_ident_path().with_ident(content_ident.clone());
            let content = ComplexTypeContent {
                occurs,
                is_simple: false,
                min_occurs,
                max_occurs,
                target_type,
            };

            StructMode::Content { content }
        } else {
            StructMode::Empty { any_element }
        };

        let type_ = ComplexTypeStruct {
            base,
            mode,

            attributes,
            any_attribute,
        };

        Ok(ComplexType::Struct {
            type_,
            content_type,
        })
    }
}

impl ComplexTypeBase {
    pub(super) fn element_tag(&self) -> Option<&String> {
        self.is_complex.then_some(self.tag_name.as_ref()).flatten()
    }

    pub(crate) fn represents_element(&self) -> bool {
        self.is_complex && self.tag_name.is_some() && !self.is_dynamic
    }

    fn new(req: &mut Request<'_, '_>) -> Result<Self, Error> {
        let type_ref = req.current_type_ref();
        let type_ident = type_ref.type_ident.clone();

        let mut ret = Self::new_empty(type_ident);
        ret.tag_name = Some(make_tag_name(req.types, req.ident));
        ret.trait_impls = req.make_trait_impls()?;

        if let Some(ComplexTypeVariant::ComplexType(ci)) = req.types.get_complex_type(req.ident).map(|a| &a.variant) {
            ret.is_complex = true;
            ret.is_dynamic = ci.is_dynamic;
        }

        Ok(ret)
    }

    fn new_empty(type_ident: Ident2) -> Self {
        let serializer_ident = format_ident!("{type_ident}Serializer");
        let serializer_state_ident = format_ident!("{type_ident}SerializerState");

        let deserializer_ident = format_ident!("{type_ident}Deserializer");
        let deserializer_state_ident = format_ident!("{type_ident}DeserializerState");

        Self {
            type_ident,
            trait_impls: Vec::new(),

            tag_name: None,
            is_complex: false,
            is_dynamic: false,

            serializer_ident,
            serializer_state_ident,

            deserializer_ident,
            deserializer_state_ident,
        }
    }
}

impl Deref for ComplexTypeEnum<'_> {
    type Target = ComplexTypeBase;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl ComplexTypeStruct<'_> {
    pub(super) fn is_unit_struct(&self) -> bool {
        matches!(&self.mode, StructMode::Empty { .. }) && !self.has_attributes()
    }

    pub(super) fn has_attributes(&self) -> bool {
        !self.attributes.is_empty()
    }

    pub(super) fn has_content(&self) -> bool {
        match &self.mode {
            StructMode::All { elements, .. } | StructMode::Sequence { elements, .. } => {
                !elements.is_empty()
            }
            StructMode::Content { .. } => true,
            StructMode::Empty { .. } => false,
        }
    }

    pub(super) fn elements(&self) -> &[ComplexTypeElement<'_>] {
        if let StructMode::All { elements, .. } | StructMode::Sequence { elements, .. } = &self.mode
        {
            elements
        } else {
            &[]
        }
    }

    pub(super) fn any_element(&self) -> Option<&AnyInfo> {
        if let StructMode::All { any_element, .. } | StructMode::Sequence { any_element, .. } =
            &self.mode
        {
            *any_element
        } else {
            None
        }
    }

    pub(super) fn content(&self) -> Option<&ComplexTypeContent> {
        if let StructMode::Content { content, .. } = &self.mode {
            Some(content)
        } else {
            None
        }
    }
}

impl Deref for ComplexTypeStruct<'_> {
    type Target = ComplexTypeBase;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'types> ComplexTypeElement<'types> {
    fn new_variant(
        info: &'types ElementInfo,
        req: &mut Request<'_, 'types>,
        direct_usage: bool,
    ) -> Result<Option<Self>, Error> {
        let force_box = req.box_flags.intersects(BoxFlags::ENUM_ELEMENTS);

        Self::new(info, req, direct_usage, force_box)
    }

    fn new_field(
        info: &'types ElementInfo,
        req: &mut Request<'_, 'types>,
        direct_usage: bool,
    ) -> Result<Option<Self>, Error> {
        let force_box = req.box_flags.intersects(BoxFlags::STRUCT_ELEMENTS);

        Self::new(info, req, direct_usage, force_box)
    }

    fn new(
        info: &'types ElementInfo,
        req: &mut Request<'_, 'types>,
        direct_usage: bool,
        force_box: bool,
    ) -> Result<Option<Self>, Error> {
        let occurs = Occurs::from_occurs(info.min_occurs, info.max_occurs);
        if occurs == Occurs::None {
            return Ok(None);
        }

        let tag_name = make_tag_name(req.types, &info.ident);
        let s_name = info.ident.name.to_string();
        let b_name = Literal::byte_string(s_name.as_bytes());
        let field_ident = format_field_ident(&info.ident.name, info.display_name.as_deref());
        let variant_ident = format_variant_ident(&info.ident.name, info.display_name.as_deref());

        let target_ref = req.get_or_create_type_ref(info.type_.clone())?;
        let target_type = target_ref.to_ident_path();

        let need_box = req.current_type_ref().boxed_elements.contains(&info.ident);
        let need_indirection = (direct_usage && need_box) || force_box;
        let target_is_dynamic = is_dynamic(&info.type_, req.types);

        Ok(Some(Self {
            info,
            occurs,
            s_name,
            b_name,
            tag_name,
            field_ident,
            variant_ident,
            target_type,
            need_indirection,
            target_is_dynamic,
        }))
    }
}

impl<'types> ComplexTypeAttribute<'types> {
    fn new_field(
        info: &'types AttributeInfo,
        req: &mut Request<'_, 'types>,
    ) -> Result<Option<Self>, Error> {
        if info.use_ == Use::Prohibited {
            return Ok(None);
        }

        let current_module = req.current_module();
        let target_ref = req.get_or_create_type_ref(info.type_.clone())?;
        let ident = format_field_ident(&info.ident.name, info.display_name.as_deref());
        let target_type = target_ref.to_ident_path();
        let s_name = info.ident.name.to_string();
        let b_name = Literal::byte_string(s_name.as_bytes());
        let tag_name = make_tag_name(req.types, &info.ident);

        let default_value = info
            .default
            .as_ref()
            .map(|default| req.get_default(current_module, default, &info.type_))
            .transpose()?;
        let is_option = matches!((&info.use_, &default_value), (Use::Optional, None));

        Ok(Some(Self {
            info,
            ident,
            s_name,
            b_name,
            tag_name,
            is_option,
            target_type,
            default_value,
        }))
    }
}

/* Request */

/// Helper type that is used to request the code generation for a specific type.
struct Request<'a, 'types> {
    pub ident: &'a Ident,
    pub config: &'a Config<'types>,

    state: &'a mut State<'types>,
}

impl<'a, 'types> Request<'a, 'types> {
    fn new(ident: &'a Ident, config: &'a Config<'types>, state: &'a mut State<'types>) -> Self {
        Self {
            ident,
            config,
            state,
        }
    }

    fn current_module(&self) -> Option<NamespaceId> {
        self.check_flags(GeneratorFlags::USE_MODULES)
            .then_some(self.ident.ns)
            .flatten()
    }

    fn current_type_ref(&self) -> &TypeRef {
        self.state.cache.get(self.ident).unwrap()
    }

    fn get_trait_infos(&mut self) -> &TraitInfos {
        self.state
            .trait_infos
            .get_or_insert_with(|| TraitInfos::new(self.config.types))
    }

    fn get_or_create_type_ref(&mut self, ident: Ident) -> Result<&TypeRef, Error> {
        self.state.get_or_create_type_ref(self.config, ident)
    }

    fn make_trait_impls(&mut self) -> Result<Vec<IdentPath>, Error> {
        let ident = self.ident.clone();

        self.get_trait_infos()
            .get(&ident)
            .into_iter()
            .flat_map(|info| &info.traits_all)
            .cloned()
            .collect::<Vec<_>>()
            .into_iter()
            .map(|ident| {
                let type_ref = self.get_or_create_type_ref(ident.clone())?;
                let ident = format_ident!("{}Trait", type_ref.type_ident);
                let trait_type = type_ref.to_ident_path().with_ident(ident);

                Ok(trait_type)
            })
            .collect::<Result<Vec<_>, _>>()
    }

    fn get_default(
        &mut self,
        current_ns: Option<NamespaceId>,
        default: &str,
        ident: &Ident,
    ) -> Result<TokenStream, Error> {
        let types = self.types;
        let ty = types
            .get(ident)
            .ok_or_else(|| Error::UnknownType(ident.clone()))?;
        let type_ref = self.get_or_create_type_ref(ident.clone())?;

        macro_rules! build_in {
            ($ty:ty) => {
                if let Ok(val) = default.parse::<$ty>() {
                    return Ok(quote!(#val));
                }
            };
        }

        let ty = match ty {
            Type::SimpleType(type_descriptor) => type_descriptor,
            Type::ComplexType(_) => {
                return Err(Error::InvalidDefaultValue(
                    ident.clone(),
                    default.to_owned(),
                ))
            },
        };

        match &ty.variant {
            SimpleTypeVariant::BuildIn(BuildInInfo::U8) => build_in!(u8),
            SimpleTypeVariant::BuildIn(BuildInInfo::U16) => build_in!(u16),
            SimpleTypeVariant::BuildIn(BuildInInfo::U32) => build_in!(u32),
            SimpleTypeVariant::BuildIn(BuildInInfo::U64) => build_in!(u64),
            SimpleTypeVariant::BuildIn(BuildInInfo::U128) => build_in!(u128),
            SimpleTypeVariant::BuildIn(BuildInInfo::Usize) => build_in!(usize),

            SimpleTypeVariant::BuildIn(BuildInInfo::I8) => build_in!(i8),
            SimpleTypeVariant::BuildIn(BuildInInfo::I16) => build_in!(i16),
            SimpleTypeVariant::BuildIn(BuildInInfo::I32) => build_in!(i32),
            SimpleTypeVariant::BuildIn(BuildInInfo::I64) => build_in!(i64),
            SimpleTypeVariant::BuildIn(BuildInInfo::I128) => build_in!(i128),
            SimpleTypeVariant::BuildIn(BuildInInfo::Isize) => build_in!(isize),

            SimpleTypeVariant::BuildIn(BuildInInfo::F32) => build_in!(f32),
            SimpleTypeVariant::BuildIn(BuildInInfo::F64) => build_in!(f64),

            SimpleTypeVariant::BuildIn(BuildInInfo::Bool) => {
                match default.to_ascii_lowercase().as_str() {
                    "true" | "yes" | "1" => return Ok(quote!(true)),
                    "false" | "no" | "0" => return Ok(quote!(false)),
                    _ => (),
                }
            }
            SimpleTypeVariant::BuildIn(BuildInInfo::String) => {
                return Ok(quote!(String::from(#default)));
            }
            SimpleTypeVariant::BuildIn(BuildInInfo::Custom(x)) => {
                if let Some(x) = x.default(default) {
                    return Ok(x);
                }
            }

            SimpleTypeVariant::Enumeration(ei) => {
                let module_path = ModulePath::from_namespace(current_ns, types);
                let target_type = type_ref.to_ident_path().relative_to(&module_path);

                for var in &*ei.variants {
                    if var.type_.is_none() && var.ident.name.as_str() == default {
                        let variant_ident =
                            format_variant_ident(&var.ident.name, var.display_name.as_deref());

                        return Ok(quote!(#target_type :: #variant_ident));
                    }

                    if let Some(target_ident) = &var.type_ {
                        if let Ok(default) = self.get_default(current_ns, default, target_ident) {
                            let variant_ident =
                                format_variant_ident(&var.ident.name, var.display_name.as_deref());

                            return Ok(quote!(#target_type :: #variant_ident(#default)));
                        }
                    }
                }
            }

            SimpleTypeVariant::Union(ui) => {
                let module_path = ModulePath::from_namespace(current_ns, types);
                let target_type = type_ref.to_ident_path().relative_to(&module_path);

                for ty in &*ui.types {
                    if let Ok(code) = self.get_default(current_ns, default, &ty.type_) {
                        let variant_ident =
                            format_variant_ident(&ty.type_.name, ty.display_name.as_deref());

                        return Ok(quote! {
                            #target_type :: #variant_ident ( #code )
                        });
                    }
                }
            }

            SimpleTypeVariant::Reference(ti) => match Occurs::from_occurs(ti.min_occurs, ti.max_occurs) {
                Occurs::Single => return self.get_default(current_ns, default, &ti.type_),
                Occurs::DynamicList if default.is_empty() => {
                    let module_path = ModulePath::from_namespace(current_ns, types);
                    let target_type = type_ref.to_ident_path().relative_to(&module_path);

                    return Ok(quote! { #target_type(Vec::new()) });
                }
                _ => (),
            },
        }

        Err(Error::InvalidDefaultValue(
            ident.clone(),
            default.to_owned(),
        ))
    }
}

impl<'types> Deref for Request<'_, 'types> {
    type Target = Config<'types>;

    fn deref(&self) -> &Self::Target {
        self.config
    }
}

/* Helper */

fn is_dynamic(ident: &Ident, types: &Types) -> bool {
    let Some(ty) = types.get_complex_type(ident) else {
        return false;
    };

    match &ty.variant {
        ComplexTypeVariant::Dynamic(_) => true,
        ComplexTypeVariant::ComplexType(ci) => ci.is_dynamic,
        ComplexTypeVariant::Reference(x) if x.is_single() => is_dynamic(&x.type_, types),
        _ => false,
    }
}

fn make_tag_name(types: &Types, ident: &Ident) -> String {
    let name = ident.name.to_string();

    if let Some(module) = ident
        .ns
        .as_ref()
        .and_then(|ns| types.modules.get(ns))
        .and_then(|module| module.name.as_ref())
    {
        format!("{module}:{name}")
    } else {
        name
    }
}

fn make_derived_type_data<'types>(
    req: &mut Request<'_, 'types>,
    ident: &'types Ident,
) -> Result<DerivedType, Error> {
    let s_name = ident.name.to_string();
    let b_name = Literal::byte_string(s_name.as_bytes());

    let complex_ty = req
        .types
        .get_complex_type(ident)
        .ok_or_else(|| Error::UnknownType(ident.clone()))?;
    let base_ident = if let ComplexTypeVariant::Dynamic(di) = &complex_ty.variant {
        di.type_.clone()
    } else {
        None
    };
    let ident = base_ident.unwrap_or(ident.clone());

    let target_ref = req.get_or_create_type_ref(ident.clone())?;
    let target_type = target_ref.to_ident_path();
    let variant_ident = format_variant_ident(&ident.name, None);

    Ok(DerivedType {
        ident,
        b_name,
        target_type,
        variant_ident,
    })
}
