use std::mem::take;
use std::ops::Deref;

use proc_macro2::{Ident as Ident2, Literal, TokenStream};
use quote::{format_ident, quote};

use crate::models::{
    code::{format_field_ident, format_variant_ident, IdentPath, ModulePath},
    meta::{
        AttributeMeta, AttributeMetaVariant, BuildInMeta, ComplexMeta, CustomMeta, DynamicMeta,
        ElementMeta, ElementMetaVariant, EnumerationMeta, EnumerationMetaVariant, GroupMeta,
        MetaType, MetaTypeVariant, MetaTypes, ReferenceMeta, UnionMeta, UnionMetaType,
    },
    schema::{xs::Use, MaxOccurs, MinOccurs, NamespaceId},
    Ident,
};

use super::{
    misc::Occurs, BoxFlags, Config, Error, GeneratorFlags, State, TraitInfos, TypeRef, TypedefMode,
};

/// Represents the type data that is generated by teh generator for a type that
/// needs to be rendered.
///
/// The generator adds additional useful data that is needed for the rendering
/// process to the actual [`Type`] that needs to be rendered. So instead of
/// passing the type directly to the renderer and re-calculate the data inside
/// every renderer, the type is once evaluated by the generator and then any
/// renderer can profit from the enriched data.
#[derive(Debug)]
pub enum TypeData<'types> {
    /// Corresponds to [`MetaTypeVariant::BuildIn`].
    BuildIn(BuildInType<'types>),

    /// Corresponds to [`MetaTypeVariant::Custom`].
    Custom(CustomType<'types>),

    /// Corresponds to [`MetaTypeVariant::Union`].
    Union(UnionType<'types>),

    /// Corresponds to [`MetaTypeVariant::Dynamic`].
    Dynamic(DynamicType<'types>),

    /// Corresponds to [`MetaTypeVariant::Reference`].
    Reference(ReferenceType<'types>),

    /// Corresponds to [`MetaTypeVariant::Enumeration`].
    Enumeration(EnumerationType<'types>),

    /// Corresponds to [`MetaTypeVariant::All`], [`MetaTypeVariant::Choice`],
    /// [`MetaTypeVariant::Sequence`] or [`MetaTypeVariant::ComplexType`].
    Complex(ComplexType<'types>),
}

impl<'types> TypeData<'types> {
    pub(super) fn new(
        ty: &'types MetaType,
        ident: &Ident,
        config: &Config<'types>,
        state: &mut State<'types>,
    ) -> Result<Self, Error> {
        let req = Request::new(ident, config, state);

        Ok(match &ty.variant {
            MetaTypeVariant::BuildIn(x) => Self::BuildIn(BuildInType::new(x)),
            MetaTypeVariant::Custom(x) => Self::Custom(CustomType::new(x)),
            MetaTypeVariant::Union(x) => Self::Union(UnionType::new(x, req)?),
            MetaTypeVariant::Dynamic(x) => Self::Dynamic(DynamicType::new(x, req)?),
            MetaTypeVariant::Reference(x) => Self::Reference(ReferenceType::new(x, req)?),
            MetaTypeVariant::Enumeration(x) => Self::Enumeration(EnumerationType::new(x, req)?),
            MetaTypeVariant::All(x) => Self::Complex(ComplexType::new_all(x, req)?),
            MetaTypeVariant::Choice(x) => Self::Complex(ComplexType::new_choice(x, req)?),
            MetaTypeVariant::Sequence(x) => Self::Complex(ComplexType::new_sequence(x, req)?),
            MetaTypeVariant::ComplexType(x) => Self::Complex(ComplexType::new_complex(x, req)?),
        })
    }
}

/// Contains additional information for the rendering process
/// of a [`MetaTypeVariant::BuildIn`] type.
#[derive(Debug)]
pub struct BuildInType<'types> {
    /// Reference to the original type information.
    pub info: &'types BuildInMeta,
}

impl<'types> BuildInType<'types> {
    fn new(info: &'types BuildInMeta) -> Self {
        Self { info }
    }
}

/// Contains additional information for the rendering process
/// of a [`MetaTypeVariant::Custom`] type.
#[derive(Debug)]
pub struct CustomType<'types> {
    /// Reference to the original type information.
    pub info: &'types CustomMeta,
}

impl<'types> CustomType<'types> {
    fn new(info: &'types CustomMeta) -> Self {
        Self { info }
    }
}

/// Contains additional information for the rendering process
/// of a [`MetaTypeVariant::Union`] type.
#[derive(Debug)]
pub struct UnionType<'types> {
    /// Reference to the original type information.
    pub info: &'types UnionMeta,

    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// List of variants contained in this union.
    pub variants: Vec<UnionTypeVariant<'types>>,

    /// List of traits that needs to be implemented by this type.
    pub trait_impls: Vec<TokenStream>,
}

/// Type variant used in [`UnionType`].
#[derive(Debug)]
pub struct UnionTypeVariant<'types> {
    /// Reference to the original type information.
    pub info: &'types UnionMetaType,

    /// The type that is stored by the this variant.
    pub target_type: IdentPath,

    /// Identifier of this variant.
    pub variant_ident: Ident2,
}

impl<'types> UnionType<'types> {
    fn new(info: &'types UnionMeta, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let type_ident = req.current_type_ref().type_ident.clone();
        let trait_impls = req.make_trait_impls()?;
        let variants = info
            .types
            .iter()
            .map(|info| info.make_variant(&mut req))
            .collect::<Result<_, _>>()?;

        Ok(Self {
            info,
            type_ident,
            variants,
            trait_impls,
        })
    }
}

impl UnionMetaType {
    fn make_variant<'types>(
        &'types self,
        req: &mut Request<'_, 'types>,
    ) -> Result<UnionTypeVariant<'types>, Error> {
        let type_ref = req.get_or_create_type_ref(self.type_.clone())?;
        let target_type = type_ref.to_ident_path();
        let variant_ident = format_variant_ident(&self.type_.name, self.display_name.as_deref());

        Ok(UnionTypeVariant {
            info: self,
            target_type,
            variant_ident,
        })
    }
}

/// Contains additional information for the rendering process
/// of a [`MetaTypeVariant::Dynamic`] type.
#[derive(Debug)]
pub struct DynamicType<'types> {
    /// Reference to the original type information.
    pub info: &'types DynamicMeta,

    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// The identifier of the trait that needs to be implemented
    /// by the derived types.
    pub trait_ident: Ident2,

    /// Identifier of the deserializer for this type.
    pub deserializer_ident: Ident2,

    /// List of additional traits that need to be implemented by the derived
    /// types (if this type was inherited from another dynamic type).
    pub sub_traits: Option<Vec<IdentPath>>,

    /// List of derived types.
    pub derived_types: Vec<DerivedType>,
}

/// Represents a derived type used by [`DynamicType`].
#[derive(Debug)]
pub struct DerivedType {
    /// Identifier of the derived type.
    pub ident: Ident,

    /// Name of the derived type as byte string literal.
    pub b_name: Literal,

    /// The actual target type of this derived type information.
    pub target_type: IdentPath,

    /// Name of the variant used for this derived type information.
    pub variant_ident: Ident2,
}

impl<'types> DynamicType<'types> {
    fn new(info: &'types DynamicMeta, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let type_ident = req.current_type_ref().type_ident.clone();
        let trait_ident = format_ident!("{type_ident}Trait");
        let ident = req.ident.clone();
        let sub_traits = req
            .get_trait_infos()
            .get(&ident)
            .map(|info| info.traits_direct.clone())
            .map(|traits_direct| {
                traits_direct
                    .iter()
                    .map(|ident| {
                        req.get_or_create_type_ref(ident.clone()).map(|x| {
                            let ident = format_ident!("{}Trait", x.type_ident);

                            x.to_ident_path().with_ident(ident)
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()
            })
            .transpose()?;
        let derived_types = info
            .derived_types
            .iter()
            .map(|ident| make_derived_type_data(&mut req, ident))
            .collect::<Result<Vec<_>, _>>()?;

        let deserializer_ident = format_ident!("{type_ident}Deserializer");

        Ok(Self {
            info,
            type_ident,
            trait_ident,
            deserializer_ident,
            sub_traits,
            derived_types,
        })
    }
}

/// Contains additional information for the rendering process
/// of a [`MetaTypeVariant::Reference`] type.
#[derive(Debug)]
pub struct ReferenceType<'types> {
    /// Reference to the original type information.
    pub info: &'types ReferenceMeta,

    /// Typedef mode that should be used to render this reference type.
    pub mode: TypedefMode,

    /// Occurrence of the referenced type within this type.
    pub occurs: Occurs,

    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// Actual target type of this referenced type.
    pub target_type: IdentPath,

    /// List of traits that needs to be implemented by this type.
    pub trait_impls: Vec<TokenStream>,
}

impl<'types> ReferenceType<'types> {
    fn new(info: &'types ReferenceMeta, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let occurs = Occurs::from_occurs(info.min_occurs, info.max_occurs);
        let type_ident = req.current_type_ref().type_ident.clone();
        let target_ref = req.get_or_create_type_ref(info.type_.clone())?;
        let target_type = target_ref.to_ident_path();
        let trait_impls = req.make_trait_impls()?;

        let mode = match (req.typedef_mode, occurs) {
            (TypedefMode::Auto, Occurs::None | Occurs::Single) => TypedefMode::Typedef,
            (TypedefMode::Auto, _) => TypedefMode::NewType,
            (mode, _) => mode,
        };

        Ok(Self {
            info,
            mode,
            occurs,
            type_ident,
            target_type,
            trait_impls,
        })
    }
}

/// Contains additional information for the rendering process
/// of a [`MetaTypeVariant::Enumeration`] type.
#[derive(Debug)]
pub struct EnumerationType<'types> {
    /// Reference to the original type information.
    pub info: &'types EnumerationMeta,

    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// List of variants of this enumeration.
    pub variants: Vec<EnumerationTypeVariant<'types>>,

    /// List of traits that needs to be implemented by this type.
    pub trait_impls: Vec<TokenStream>,
}

/// Represents a enumeration variant used by [`EnumerationType`].
#[derive(Debug)]
pub struct EnumerationTypeVariant<'types> {
    /// Reference to the original type information.
    pub info: &'types EnumerationMetaVariant,

    /// Name of this variant.
    pub variant_ident: Ident2,

    /// Target type of this variant.
    pub target_type: Option<IdentPath>,
}

impl<'types> EnumerationType<'types> {
    fn new(info: &'types EnumerationMeta, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let mut unknown = 0usize;
        let type_ident = req.current_type_ref().type_ident.clone();
        let trait_impls = req.make_trait_impls()?;

        let variants = info
            .variants
            .iter()
            .filter_map(|var| var.make_variant(&mut unknown, &mut req))
            .collect::<Result<Vec<_>, _>>()?;

        Ok(EnumerationType {
            info,
            type_ident,
            variants,
            trait_impls,
        })
    }
}

impl EnumerationMetaVariant {
    fn make_variant<'types>(
        &'types self,
        unknown: &mut usize,
        req: &mut Request<'_, 'types>,
    ) -> Option<Result<EnumerationTypeVariant<'types>, Error>> {
        match self.use_ {
            Use::Prohibited => None,
            Use::Required | Use::Optional => {
                let type_ref = if let Some(t) = &self.type_ {
                    match req.get_or_create_type_ref(t.clone()) {
                        Ok(target_ref) => Some(target_ref),
                        Err(error) => return Some(Err(error)),
                    }
                } else {
                    None
                };

                let variant_ident = if let Some(display_name) = self.display_name.as_deref() {
                    format_ident!("{display_name}")
                } else if let (Some(type_ref), true) = (type_ref, self.ident.name.is_generated()) {
                    type_ref.type_ident.clone()
                } else if self.ident.name.as_str().is_empty() {
                    *unknown += 1;

                    format_ident!("Unknown{unknown}")
                } else {
                    format_variant_ident(&self.ident.name, self.display_name.as_deref())
                };

                let target_type = type_ref.map(TypeRef::to_ident_path);

                Some(Ok(EnumerationTypeVariant {
                    info: self,
                    variant_ident,
                    target_type,
                }))
            }
        }
    }
}

/// Contains additional information for the rendering process
/// of a [`MetaTypeVariant::All`], [`MetaTypeVariant::Choice`],
/// [`MetaTypeVariant::Sequence`] or [`MetaTypeVariant::ComplexType`] type.
///
/// To simplify the rendering process this recursive type was added to the
/// generator. It basically boils down to the following:
///
///   - A complex type with a `choice` will result in a struct with a enum
///     content type.
///   - A complex type with a `all` or `sequence` will result in a struct
///     with a struct content type.
///   - A simple `choice` will result in a single enum type.
///   - A simple `all` or `sequence` will result in a single sequence.
///
/// Additional improvements may be applied to the type, to reduce the complexity
/// of the generated type (for example flattening the content if possible).
#[derive(Debug)]
pub enum ComplexType<'types> {
    /// The type represents an enumeration.
    ///
    /// This is normally used for `choice` elements.
    Enum {
        /// The main type.
        type_: ComplexTypeEnum<'types>,

        /// The content of the main type (if needed).
        content_type: Option<Box<ComplexType<'types>>>,
    },

    /// The type represents a struct.
    ///
    /// This is normally used for `all`
    Struct {
        /// The main type.
        type_: ComplexTypeStruct<'types>,

        /// The content of the main type (if needed).
        content_type: Option<Box<ComplexType<'types>>>,
    },
}

/// Contains basic information for that is shared between [`ComplexTypeEnum`]
/// and [`ComplexTypeStruct`].
#[derive(Debug)]
pub struct ComplexTypeBase {
    /// The identifier of the rendered type.
    pub type_ident: Ident2,

    /// List of traits that needs to be implemented by this type.
    pub trait_impls: Vec<TokenStream>,

    /// Name of the XML tag of the type (if the type represents an element in the XML).
    pub tag_name: Option<String>,

    /// Whether the type has at least one `xs:any` element or not.
    pub has_any: bool,

    /// `true` if the type is a complex type, `false` otherwise.
    pub is_complex: bool,

    /// `true` if the type is dynamic, `false` otherwise.
    pub is_dynamic: bool,

    /// Identifier of the serializer for this type.
    pub serializer_ident: Ident2,

    /// Identifier of the state of the serializer for this type.
    pub serializer_state_ident: Ident2,

    /// Identifier of the deserializer for this type.
    pub deserializer_ident: Ident2,

    /// Identifier of the state of the deserializer for this type.
    pub deserializer_state_ident: Ident2,
}

/// Represents a rust enum.
///
/// Is used as part of the [`ComplexType`].
#[derive(Debug)]
pub struct ComplexTypeEnum<'types> {
    /// Basic type information.
    pub base: ComplexTypeBase,

    /// List of `xs:element`s or variants contained in this enum
    pub elements: Vec<ComplexTypeElement<'types>>,

    /// Whether any kind of element is allowed in the enum or not
    ///
    /// This is only true if no type for `xs:any` element is defined.
    pub allow_any: bool,

    /// Whether any kind of attribute is allowed in the enum or not
    ///
    /// This is only true if no type for `xs:anyAttribute` element is defined.
    pub allow_any_attribute: bool,
}

/// Represents a rust struct.
///
/// Is used as part of the [`ComplexType`].
#[derive(Debug)]
pub struct ComplexTypeStruct<'types> {
    /// Basic type information.
    pub base: ComplexTypeBase,

    /// Additional information about the content of the struct.
    pub mode: StructMode<'types>,

    /// List of `xs:attribute`s contained in this struct.
    pub attributes: Vec<ComplexTypeAttribute<'types>>,

    /// Whether any kind of attribute is allowed in the struct or not
    ///
    /// This is only true if no type for `xs:anyAttribute` element is defined.
    pub allow_any_attribute: bool,
}

/// Content of a rust struct.
///
/// Used by [`ComplexTypeStruct`] to tell how the actual content of the struct
/// should be rendered.
#[derive(Debug)]
pub enum StructMode<'types> {
    /// The struct does not contain any `xs:element`s.
    Empty {
        /// Whether any kind of element is allowed in the struct or not
        ///
        /// This is only true if no type for `xs:any` element is defined.
        allow_any: bool,
    },

    /// The content of the struct is another generated type that contains
    /// the actual data.
    Content {
        /// Information about the content of the struct.
        content: ComplexTypeContent,
    },

    /// The content of the struct is a `xs:all` group.
    All {
        /// List of `xs:element`s inside the group.
        elements: Vec<ComplexTypeElement<'types>>,

        /// Whether any kind of element is allowed in the struct or not
        ///
        /// This is only true if no type for `xs:any` element is defined.
        allow_any: bool,
    },

    /// The content of the struct is a `xs:sequence` group.
    Sequence {
        /// List of `xs:element`s inside the group.
        elements: Vec<ComplexTypeElement<'types>>,

        /// Whether any kind of element is allowed in the struct or not
        ///
        /// This is only true if no type for `xs:any` element is defined.
        allow_any: bool,
    },
}

/// Contains details about the content of a struct.
///
/// Is used by [`StructMode`] to define the content of a struct.
#[derive(Debug)]
pub struct ComplexTypeContent {
    /// Occurrence of the content within this struct.
    pub occurs: Occurs,

    /// `true` if the content is a simple type (e.g. a enum, union, string,
    /// integer, ...), `false` otherwise.
    pub is_simple: bool,

    /// Minimum occurrence.
    pub min_occurs: MinOccurs,

    /// Maximum occurrence.
    pub max_occurs: MaxOccurs,

    /// Actual target type of the content.
    pub target_type: IdentPath,
}

/// Contains the details of an XML element.
///
/// Is used in [`ComplexTypeEnum`] or [`StructMode`].
#[derive(Debug)]
pub struct ComplexTypeElement<'types> {
    /// Reference to the original type information.
    pub info: &'types ElementMeta,

    /// Occurrence of the element within it's parent type.
    pub occurs: Occurs,

    /// Name of the element as string.
    pub s_name: String,

    /// Name of the element as byte string literal.
    pub b_name: Literal,

    /// Name of the XML tag of the element.
    pub tag_name: String,

    /// Field identifier of the element.
    pub field_ident: Ident2,

    /// Variant identifier of the element.
    pub variant_ident: Ident2,

    /// Actual target type of the element.
    pub target_type: IdentPath,

    /// `true` if this element needs some indirection
    /// (like a `Box` or a `Vec`), `false` otherwise.
    pub need_indirection: bool,

    /// `true` if the target type of this element is dynamic,
    /// `false` otherwise.
    pub target_is_dynamic: bool,
}

/// Contains the details of an XML attribute.
///
/// Is used in [`ComplexTypeStruct`].
#[derive(Debug)]
pub struct ComplexTypeAttribute<'types> {
    /// Reference to the original type information.
    pub info: &'types AttributeMeta,

    /// Identifier of the attribute.
    pub ident: Ident2,

    /// Name of the attribute as string.
    pub s_name: String,

    /// Name of the attribute as byte string literal.
    pub b_name: Literal,

    /// Name of the attribute inside the XML tag.
    pub tag_name: String,

    /// `true` if this attribute is optional, `false` otherwise.
    pub is_option: bool,

    /// The actual target type of the attribute.
    pub target_type: IdentPath,

    /// The default value of the attribute.
    pub default_value: Option<TokenStream>,
}

#[derive(Debug, Clone)]
enum TypeMode {
    All,
    Choice,
    Sequence,
    Simple { target_type: IdentPath },
}

impl<'types> ComplexType<'types> {
    fn new_all(info: &'types GroupMeta, req: Request<'_, 'types>) -> Result<Self, Error> {
        Self::new(
            req,
            TypeMode::All,
            1,
            MaxOccurs::Bounded(1),
            &[],
            &info.elements,
        )
    }

    fn new_choice(info: &'types GroupMeta, req: Request<'_, 'types>) -> Result<Self, Error> {
        Self::new(
            req,
            TypeMode::Choice,
            1,
            MaxOccurs::Bounded(1),
            &[],
            &info.elements,
        )
    }

    fn new_sequence(info: &'types GroupMeta, req: Request<'_, 'types>) -> Result<Self, Error> {
        Self::new(
            req,
            TypeMode::Sequence,
            1,
            MaxOccurs::Bounded(1),
            &[],
            &info.elements,
        )
    }

    fn new_complex(info: &'types ComplexMeta, mut req: Request<'_, 'types>) -> Result<Self, Error> {
        let (type_mode, elements) = match info.content.as_ref().and_then(|ident| {
            req.types
                .get_resolved_type(ident)
                .map(|ty| (&ty.variant, ident))
        }) {
            None => (TypeMode::Sequence, &[][..]),
            Some((MetaTypeVariant::All(si), _)) => (TypeMode::All, &si.elements[..]),
            Some((MetaTypeVariant::Choice(si), _)) => (TypeMode::Choice, &si.elements[..]),
            Some((MetaTypeVariant::Sequence(si), _)) => (TypeMode::Sequence, &si.elements[..]),
            Some((
                MetaTypeVariant::BuildIn(_)
                | MetaTypeVariant::Union(_)
                | MetaTypeVariant::Enumeration(_)
                | MetaTypeVariant::Reference(_),
                ident,
            )) => {
                let content_ref = req.get_or_create_type_ref(ident.clone())?;
                let target_type = content_ref.to_ident_path();

                (TypeMode::Simple { target_type }, &[][..])
            }
            Some((x, _)) => {
                let ident = &req.current_type_ref().type_ident;

                tracing::warn!("Complex type has unexpected content: ident={ident}, info={info:#?}, content={x:#?}!");

                (TypeMode::Sequence, &[][..])
            }
        };

        Self::new(
            req,
            type_mode,
            info.min_occurs,
            info.max_occurs,
            &info.attributes,
            elements,
        )
    }

    #[allow(clippy::too_many_arguments)]
    fn new(
        req: Request<'_, 'types>,
        type_mode: TypeMode,
        min_occurs: MinOccurs,
        max_occurs: MaxOccurs,
        attributes: &'types [AttributeMeta],
        elements: &'types [ElementMeta],
    ) -> Result<Self, Error> {
        match type_mode {
            TypeMode::Simple { target_type } => {
                Self::new_simple(req, target_type, min_occurs, max_occurs, attributes)
            }
            TypeMode::Choice => Self::new_enum(req, min_occurs, max_occurs, attributes, elements),
            TypeMode::All | TypeMode::Sequence => Self::new_struct(
                req, &type_mode, min_occurs, max_occurs, attributes, elements,
            ),
        }
    }

    fn new_simple(
        mut req: Request<'_, 'types>,
        target_type: IdentPath,
        min_occurs: MinOccurs,
        max_occurs: MaxOccurs,
        attributes: &'types [AttributeMeta],
    ) -> Result<Self, Error> {
        let base = ComplexTypeBase::new(&mut req, false)?;
        let occurs = Occurs::from_occurs(min_occurs, max_occurs);

        let mut allow_any_attribute = false;
        let attributes = attributes
            .iter()
            .filter_map(|info| {
                ComplexTypeAttribute::new_field(info, &mut req, &mut allow_any_attribute)
                    .transpose()
            })
            .collect::<Result<Vec<_>, _>>()?;

        let content = ComplexTypeContent {
            occurs,
            is_simple: true,
            min_occurs,
            max_occurs,
            target_type,
        };

        let type_ = ComplexTypeStruct {
            base,
            mode: StructMode::Content { content },
            attributes,
            allow_any_attribute,
        };

        Ok(Self::Struct {
            type_,
            content_type: None,
        })
    }

    fn new_enum(
        mut req: Request<'_, 'types>,
        min_occurs: MinOccurs,
        max_occurs: MaxOccurs,
        attributes: &'types [AttributeMeta],
        elements: &'types [ElementMeta],
    ) -> Result<Self, Error> {
        let has_any = req.any_type.is_some() && elements.iter().any(ElementMeta::is_any);
        let mut base = ComplexTypeBase::new(&mut req, has_any)?;
        let occurs = Occurs::from_occurs(min_occurs, max_occurs);

        let mut allow_any_attribute = false;
        let attributes = attributes
            .iter()
            .filter_map(|info| {
                ComplexTypeAttribute::new_field(info, &mut req, &mut allow_any_attribute)
                    .transpose()
            })
            .collect::<Result<Vec<_>, _>>()?;

        let mut allow_any = false;
        let mut elements = elements
            .iter()
            .filter_map(|info| {
                ComplexTypeElement::new_variant(info, &mut req, &mut allow_any, occurs.is_direct())
                    .transpose()
            })
            .collect::<Result<Vec<_>, _>>()?;

        let flatten = occurs == Occurs::Single
            && attributes.is_empty()
            && req.check_flags(GeneratorFlags::FLATTEN_ENUM_CONTENT);

        if flatten {
            let type_ = ComplexTypeEnum {
                base,
                elements,
                allow_any,
                allow_any_attribute,
            };

            return Ok(ComplexType::Enum {
                type_,
                content_type: None,
            });
        }

        let type_ident = &base.type_ident;
        let content_ident = format_ident!("{type_ident}Content");
        let has_content = occurs.is_some() && !elements.is_empty();

        let content_type = has_content.then(|| {
            let type_ = ComplexTypeEnum {
                base: ComplexTypeBase::new_empty(content_ident.clone(), take(&mut base.has_any)),
                elements: take(&mut elements),
                allow_any,
                allow_any_attribute,
            };

            Box::new(ComplexType::Enum {
                type_,
                content_type: None,
            })
        });

        let mode = if has_content {
            let type_ref = req.current_type_ref();
            let target_type = type_ref.to_ident_path().with_ident(content_ident.clone());
            let content = ComplexTypeContent {
                occurs,
                is_simple: false,
                min_occurs,
                max_occurs,
                target_type,
            };

            StructMode::Content { content }
        } else {
            StructMode::Empty { allow_any }
        };

        let type_ = ComplexTypeStruct {
            base,
            mode,

            attributes,
            allow_any_attribute,
        };

        Ok(ComplexType::Struct {
            type_,
            content_type,
        })
    }

    #[allow(clippy::too_many_lines, clippy::too_many_arguments)]
    fn new_struct(
        mut req: Request<'_, 'types>,
        type_mode: &TypeMode,
        min_occurs: MinOccurs,
        max_occurs: MaxOccurs,
        attributes: &'types [AttributeMeta],
        elements: &'types [ElementMeta],
    ) -> Result<Self, Error> {
        let has_any = req.any_type.is_some() && elements.iter().any(ElementMeta::is_any);
        let mut base = ComplexTypeBase::new(&mut req, has_any)?;
        let occurs = Occurs::from_occurs(min_occurs, max_occurs);
        let flatten =
            occurs == Occurs::Single && req.check_flags(GeneratorFlags::FLATTEN_STRUCT_CONTENT);

        let mut allow_any_attribute = false;
        let attributes = attributes
            .iter()
            .filter_map(|info| {
                ComplexTypeAttribute::new_field(info, &mut req, &mut allow_any_attribute)
                    .transpose()
            })
            .collect::<Result<Vec<_>, _>>()?;

        let mut allow_any = false;
        let elements = elements
            .iter()
            .filter_map(|info| {
                ComplexTypeElement::new_field(info, &mut req, &mut allow_any, occurs.is_direct())
                    .transpose()
            })
            .collect::<Result<Vec<_>, _>>()?;

        if flatten {
            let mode = match type_mode {
                _ if elements.is_empty() => StructMode::Empty { allow_any },
                TypeMode::All => StructMode::All {
                    elements,
                    allow_any,
                },
                TypeMode::Sequence => StructMode::Sequence {
                    elements,
                    allow_any,
                },
                _ => crate::unreachable!(),
            };

            let type_ = ComplexTypeStruct {
                base,
                mode,

                attributes,
                allow_any_attribute,
            };

            return Ok(ComplexType::Struct {
                type_,
                content_type: None,
            });
        }

        let type_ident = &base.type_ident;
        let content_ident = format_ident!("{type_ident}Content");
        let has_content = occurs.is_some() && !elements.is_empty();

        let content_type = has_content.then(|| {
            let mode = match type_mode {
                TypeMode::All => StructMode::All {
                    elements,
                    allow_any,
                },
                TypeMode::Sequence => StructMode::Sequence {
                    elements,
                    allow_any,
                },
                _ => crate::unreachable!(),
            };

            let type_ = ComplexTypeStruct {
                base: ComplexTypeBase::new_empty(content_ident.clone(), take(&mut base.has_any)),
                mode,

                attributes: Vec::new(),
                allow_any_attribute: false,
            };

            Box::new(ComplexType::Struct {
                type_,
                content_type: None,
            })
        });

        let mode = if has_content {
            let type_ref = req.current_type_ref();
            let target_type = type_ref.to_ident_path().with_ident(content_ident.clone());
            let content = ComplexTypeContent {
                occurs,
                is_simple: false,
                min_occurs,
                max_occurs,
                target_type,
            };

            StructMode::Content { content }
        } else {
            StructMode::Empty { allow_any }
        };

        let type_ = ComplexTypeStruct {
            base,
            mode,

            attributes,
            allow_any_attribute,
        };

        Ok(ComplexType::Struct {
            type_,
            content_type,
        })
    }
}

impl ComplexTypeBase {
    /// Returns the name of the element tag, if type is represented by a XML element.
    #[must_use]
    pub fn element_tag(&self) -> Option<&String> {
        self.is_complex.then_some(self.tag_name.as_ref()).flatten()
    }

    /// Returns `true` if this type represents an element, `false` otherwise.
    #[must_use]
    pub fn represents_element(&self) -> bool {
        self.is_complex && self.tag_name.is_some() && !self.is_dynamic
    }

    fn new(req: &mut Request<'_, '_>, has_any: bool) -> Result<Self, Error> {
        let type_ref = req.current_type_ref();
        let type_ident = type_ref.type_ident.clone();

        let mut ret = Self::new_empty(type_ident, has_any);
        ret.tag_name = Some(make_tag_name(req.types, req.ident));
        ret.trait_impls = req.make_trait_impls()?;

        if let Some(MetaTypeVariant::ComplexType(ci)) = req.types.get_variant(req.ident) {
            ret.is_complex = true;
            ret.is_dynamic = ci.is_dynamic;
        }

        Ok(ret)
    }

    fn new_empty(type_ident: Ident2, has_any: bool) -> Self {
        let serializer_ident = format_ident!("{type_ident}Serializer");
        let serializer_state_ident = format_ident!("{type_ident}SerializerState");

        let deserializer_ident = format_ident!("{type_ident}Deserializer");
        let deserializer_state_ident = format_ident!("{type_ident}DeserializerState");

        Self {
            type_ident,
            trait_impls: Vec::new(),

            tag_name: None,
            has_any,
            is_complex: false,
            is_dynamic: false,

            serializer_ident,
            serializer_state_ident,

            deserializer_ident,
            deserializer_state_ident,
        }
    }
}

impl Deref for ComplexTypeEnum<'_> {
    type Target = ComplexTypeBase;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl ComplexTypeStruct<'_> {
    /// Returns `true` if this struct is a unit struct, `false` otherwise.
    #[must_use]
    pub fn is_unit_struct(&self) -> bool {
        matches!(&self.mode, StructMode::Empty { .. }) && !self.has_attributes()
    }

    /// Returns `true` if this struct has attributes, `false` otherwise.
    #[must_use]
    pub fn has_attributes(&self) -> bool {
        !self.attributes.is_empty()
    }

    /// Returns `true` if this struct has a content field, `false` otherwise.
    #[must_use]
    pub fn has_content(&self) -> bool {
        match &self.mode {
            StructMode::All { elements, .. } | StructMode::Sequence { elements, .. } => {
                !elements.is_empty()
            }
            StructMode::Content { .. } => true,
            StructMode::Empty { .. } => false,
        }
    }

    /// Returns the elements (fields) of this struct.
    #[must_use]
    pub fn elements(&self) -> &[ComplexTypeElement<'_>] {
        if let StructMode::All { elements, .. } | StructMode::Sequence { elements, .. } = &self.mode
        {
            elements
        } else {
            &[]
        }
    }

    /// Returns `true` if any kind of element is allowed in the struct, `false` otherwise.
    #[must_use]
    pub fn allow_any(&self) -> bool {
        if let StructMode::Empty { allow_any }
        | StructMode::All { allow_any, .. }
        | StructMode::Sequence { allow_any, .. } = &self.mode
        {
            *allow_any
        } else {
            false
        }
    }

    /// Returns the content type if this struct has one.
    #[must_use]
    pub fn content(&self) -> Option<&ComplexTypeContent> {
        if let StructMode::Content { content, .. } = &self.mode {
            Some(content)
        } else {
            None
        }
    }
}

impl Deref for ComplexTypeStruct<'_> {
    type Target = ComplexTypeBase;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'types> ComplexTypeElement<'types> {
    fn new_variant(
        info: &'types ElementMeta,
        req: &mut Request<'_, 'types>,
        allow_any: &mut bool,
        direct_usage: bool,
    ) -> Result<Option<Self>, Error> {
        let force_box = req.box_flags.intersects(BoxFlags::ENUM_ELEMENTS);

        Self::new(info, req, allow_any, direct_usage, force_box)
    }

    fn new_field(
        info: &'types ElementMeta,
        req: &mut Request<'_, 'types>,
        allow_any: &mut bool,
        direct_usage: bool,
    ) -> Result<Option<Self>, Error> {
        let force_box = req.box_flags.intersects(BoxFlags::STRUCT_ELEMENTS);

        Self::new(info, req, allow_any, direct_usage, force_box)
    }

    fn new(
        info: &'types ElementMeta,
        req: &mut Request<'_, 'types>,
        allow_any: &mut bool,
        direct_usage: bool,
        force_box: bool,
    ) -> Result<Option<Self>, Error> {
        let occurs = Occurs::from_occurs(info.min_occurs, info.max_occurs);
        if occurs == Occurs::None {
            return Ok(None);
        }

        let tag_name = make_tag_name(req.types, &info.ident);
        let s_name = info.ident.name.to_string();
        let b_name = Literal::byte_string(s_name.as_bytes());
        let field_ident = format_field_ident(&info.ident.name, info.display_name.as_deref());
        let variant_ident = format_variant_ident(&info.ident.name, info.display_name.as_deref());

        let (target_type, target_is_dynamic) = match &info.type_ {
            ElementMetaVariant::Any(_) => {
                let Some(type_) = req.any_type.as_ref() else {
                    *allow_any = true;

                    return Ok(None);
                };

                let target_type = IdentPath::from_ident(type_.ident().clone()).with_path([]);
                let target_is_dynamic = false;

                (target_type, target_is_dynamic)
            }
            ElementMetaVariant::Type(type_) => {
                let target_ref = req.get_or_create_type_ref(type_.clone())?;
                let target_type = target_ref.to_ident_path();
                let target_is_dynamic = is_dynamic(type_, req.types);

                (target_type, target_is_dynamic)
            }
        };

        let need_box = req.current_type_ref().boxed_elements.contains(&info.ident);
        let need_indirection = (direct_usage && need_box) || force_box;

        Ok(Some(Self {
            info,
            occurs,
            s_name,
            b_name,
            tag_name,
            field_ident,
            variant_ident,
            target_type,
            need_indirection,
            target_is_dynamic,
        }))
    }
}

impl<'types> ComplexTypeAttribute<'types> {
    fn new_field(
        info: &'types AttributeMeta,
        req: &mut Request<'_, 'types>,
        allow_any_attribute: &mut bool,
    ) -> Result<Option<Self>, Error> {
        if info.use_ == Use::Prohibited {
            return Ok(None);
        }

        let current_module = req.current_module();
        let ident = format_field_ident(&info.ident.name, info.display_name.as_deref());

        let (target_type, default_value) = match &info.variant {
            AttributeMetaVariant::Any(_) => {
                let Some(type_) = req.any_attribute_type.as_ref() else {
                    *allow_any_attribute = true;

                    return Ok(None);
                };

                let target_type = IdentPath::from_ident(type_.ident().clone()).with_path([]);

                (target_type, None)
            }
            AttributeMetaVariant::Type(type_) => {
                let target_ref = req.get_or_create_type_ref(type_.clone())?;
                let target_type = target_ref.to_ident_path();

                let default_value = info
                    .default
                    .as_ref()
                    .map(|default| req.get_default(current_module, default, type_))
                    .transpose()?;

                (target_type, default_value)
            }
        };

        let s_name = info.ident.name.to_string();
        let b_name = Literal::byte_string(s_name.as_bytes());
        let tag_name = make_tag_name(req.types, &info.ident);
        let is_option = matches!((&info.use_, &default_value), (Use::Optional, None));

        Ok(Some(Self {
            info,
            ident,
            s_name,
            b_name,
            tag_name,
            is_option,
            target_type,
            default_value,
        }))
    }
}

/* Request */

/// Helper type that is used to request the code generation for a specific type.
struct Request<'a, 'types> {
    pub ident: &'a Ident,
    pub config: &'a Config<'types>,

    state: &'a mut State<'types>,
}

impl<'a, 'types> Request<'a, 'types> {
    fn new(ident: &'a Ident, config: &'a Config<'types>, state: &'a mut State<'types>) -> Self {
        Self {
            ident,
            config,
            state,
        }
    }

    fn current_module(&self) -> Option<NamespaceId> {
        self.check_flags(GeneratorFlags::USE_MODULES)
            .then_some(self.ident.ns)
            .flatten()
    }

    fn current_type_ref(&self) -> &TypeRef {
        self.state.cache.get(self.ident).unwrap()
    }

    fn get_trait_infos(&mut self) -> &TraitInfos {
        self.state
            .trait_infos
            .get_or_insert_with(|| TraitInfos::new(self.config.types))
    }

    fn get_or_create_type_ref(&mut self, ident: Ident) -> Result<&TypeRef, Error> {
        self.state.get_or_create_type_ref(self.config, ident)
    }

    fn make_trait_impls(&mut self) -> Result<Vec<TokenStream>, Error> {
        let ident = self.ident.clone();
        let current_ns = self.current_module();
        let module_path = ModulePath::from_namespace(current_ns, self.types);

        self.get_trait_infos()
            .get(&ident)
            .into_iter()
            .flat_map(|info| &info.traits_all)
            .cloned()
            .collect::<Vec<_>>()
            .into_iter()
            .map(|ident| {
                let type_ref = self.get_or_create_type_ref(ident.clone())?;
                let ident = format_ident!("{}Trait", type_ref.type_ident);
                let trait_type = type_ref.to_ident_path().with_ident(ident);
                let trait_ident = trait_type.relative_to(&module_path);

                Ok(trait_ident)
            })
            .collect::<Result<Vec<_>, _>>()
    }

    #[allow(clippy::too_many_lines)]
    fn get_default(
        &mut self,
        current_ns: Option<NamespaceId>,
        default: &str,
        ident: &Ident,
    ) -> Result<TokenStream, Error> {
        let types = self.types;
        let ty = types
            .items
            .get(ident)
            .ok_or_else(|| Error::UnknownType(ident.clone()))?;
        let type_ref = self.get_or_create_type_ref(ident.clone())?;

        macro_rules! build_in {
            ($ty:ty) => {
                if let Ok(val) = default.parse::<$ty>() {
                    return Ok(quote!(#val));
                }
            };
        }

        match &ty.variant {
            MetaTypeVariant::BuildIn(BuildInMeta::U8) => build_in!(u8),
            MetaTypeVariant::BuildIn(BuildInMeta::U16) => build_in!(u16),
            MetaTypeVariant::BuildIn(BuildInMeta::U32) => build_in!(u32),
            MetaTypeVariant::BuildIn(BuildInMeta::U64) => build_in!(u64),
            MetaTypeVariant::BuildIn(BuildInMeta::U128) => build_in!(u128),
            MetaTypeVariant::BuildIn(BuildInMeta::Usize) => build_in!(usize),

            MetaTypeVariant::BuildIn(BuildInMeta::I8) => build_in!(i8),
            MetaTypeVariant::BuildIn(BuildInMeta::I16) => build_in!(i16),
            MetaTypeVariant::BuildIn(BuildInMeta::I32) => build_in!(i32),
            MetaTypeVariant::BuildIn(BuildInMeta::I64) => build_in!(i64),
            MetaTypeVariant::BuildIn(BuildInMeta::I128) => build_in!(i128),
            MetaTypeVariant::BuildIn(BuildInMeta::Isize) => build_in!(isize),

            MetaTypeVariant::BuildIn(BuildInMeta::F32) => build_in!(f32),
            MetaTypeVariant::BuildIn(BuildInMeta::F64) => build_in!(f64),

            MetaTypeVariant::BuildIn(BuildInMeta::Bool) => {
                match default.to_ascii_lowercase().as_str() {
                    "true" | "yes" | "1" => return Ok(quote!(true)),
                    "false" | "no" | "0" => return Ok(quote!(false)),
                    _ => (),
                }
            }
            MetaTypeVariant::BuildIn(BuildInMeta::String) => {
                return Ok(quote!(String::from(#default)));
            }

            MetaTypeVariant::Custom(x) => {
                if let Some(x) = x.default(default) {
                    return Ok(x);
                }
            }

            MetaTypeVariant::Enumeration(ei) => {
                let module_path = ModulePath::from_namespace(current_ns, types);
                let target_type = type_ref.to_ident_path().relative_to(&module_path);

                for var in &*ei.variants {
                    if var.type_.is_none() && var.ident.name.as_str() == default {
                        let variant_ident =
                            format_variant_ident(&var.ident.name, var.display_name.as_deref());

                        return Ok(quote!(#target_type :: #variant_ident));
                    }

                    if let Some(target_ident) = &var.type_ {
                        if let Ok(default) = self.get_default(current_ns, default, target_ident) {
                            let variant_ident = match self.state.cache.get(target_ident) {
                                Some(type_ref) if var.ident.name.is_generated() => {
                                    type_ref.type_ident.clone()
                                }
                                _ => format_variant_ident(
                                    &var.ident.name,
                                    var.display_name.as_deref(),
                                ),
                            };

                            return Ok(quote!(#target_type :: #variant_ident(#default)));
                        }
                    }
                }
            }

            MetaTypeVariant::Union(ui) => {
                let module_path = ModulePath::from_namespace(current_ns, types);
                let target_type = type_ref.to_ident_path().relative_to(&module_path);

                for ty in &*ui.types {
                    if let Ok(code) = self.get_default(current_ns, default, &ty.type_) {
                        let variant_ident = match self.state.cache.get(&ty.type_) {
                            Some(type_ref) if ty.type_.name.is_generated() => {
                                type_ref.type_ident.clone()
                            }
                            _ => format_variant_ident(&ty.type_.name, ty.display_name.as_deref()),
                        };

                        return Ok(quote! {
                            #target_type :: #variant_ident ( #code )
                        });
                    }
                }
            }

            MetaTypeVariant::Reference(ti) => {
                match Occurs::from_occurs(ti.min_occurs, ti.max_occurs) {
                    Occurs::Single => return self.get_default(current_ns, default, &ti.type_),
                    Occurs::DynamicList if default.is_empty() => {
                        let module_path = ModulePath::from_namespace(current_ns, types);
                        let target_type = type_ref.to_ident_path().relative_to(&module_path);

                        return Ok(quote! { #target_type(Vec::new()) });
                    }
                    _ => (),
                }
            }

            _ => (),
        }

        Err(Error::InvalidDefaultValue(
            ident.clone(),
            default.to_owned(),
        ))
    }
}

impl<'types> Deref for Request<'_, 'types> {
    type Target = Config<'types>;

    fn deref(&self) -> &Self::Target {
        self.config
    }
}

/* Helper */

fn is_dynamic(ident: &Ident, types: &MetaTypes) -> bool {
    let Some(ty) = types.items.get(ident) else {
        return false;
    };

    match &ty.variant {
        MetaTypeVariant::Dynamic(_) => true,
        MetaTypeVariant::ComplexType(ci) => ci.is_dynamic,
        MetaTypeVariant::Reference(x) if x.is_single() => is_dynamic(&x.type_, types),
        _ => false,
    }
}

fn make_tag_name(types: &MetaTypes, ident: &Ident) -> String {
    let name = ident.name.to_string();

    if let Some(module) = ident
        .ns
        .as_ref()
        .and_then(|ns| types.modules.get(ns))
        .and_then(|module| module.name.as_ref())
    {
        format!("{module}:{name}")
    } else {
        name
    }
}

fn make_derived_type_data<'types>(
    req: &mut Request<'_, 'types>,
    ident: &'types Ident,
) -> Result<DerivedType, Error> {
    let s_name = ident.name.to_string();
    let b_name = Literal::byte_string(s_name.as_bytes());

    let ty = req
        .types
        .items
        .get(ident)
        .ok_or_else(|| Error::UnknownType(ident.clone()))?;
    let base_ident = if let MetaTypeVariant::Dynamic(di) = &ty.variant {
        di.type_.clone()
    } else {
        None
    };
    let ident = base_ident.unwrap_or(ident.clone());

    let target_ref = req.get_or_create_type_ref(ident.clone())?;
    let target_type = target_ref.to_ident_path();
    let variant_ident = format_variant_ident(&ident.name, None);

    Ok(DerivedType {
        ident,
        b_name,
        target_type,
        variant_ident,
    })
}
