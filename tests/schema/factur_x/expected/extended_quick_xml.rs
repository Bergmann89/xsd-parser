use xsd_parser::{
    models::schema::Namespace,
    quick_xml::{Error, WithDeserializer, WithSerializer},
};
pub const NS_XS: Namespace = Namespace::new_const(b"http://www.w3.org/2001/XMLSchema");
pub const NS_XML: Namespace = Namespace::new_const(b"http://www.w3.org/XML/1998/namespace");
pub const NS_RSM: Namespace =
    Namespace::new_const(b"urn:un:unece:uncefact:data:standard:CrossIndustryInvoice:100");
pub const NS_QDT: Namespace =
    Namespace::new_const(b"urn:un:unece:uncefact:data:standard:QualifiedDataType:100");
pub const NS_RAM: Namespace = Namespace::new_const(
    b"urn:un:unece:uncefact:data:standard:ReusableAggregateBusinessInformationEntity:100",
);
pub const NS_UDT: Namespace =
    Namespace::new_const(b"urn:un:unece:uncefact:data:standard:UnqualifiedDataType:100");
pub type CrossIndustryInvoice = CrossIndustryInvoiceType;
#[derive(Debug)]
pub struct CrossIndustryInvoiceType {
    pub exchanged_document_context: ExchangedDocumentContextType,
    pub exchanged_document: ExchangedDocumentType,
    pub supply_chain_trade_transaction: SupplyChainTradeTransactionType,
}
impl WithSerializer for CrossIndustryInvoiceType {
    type Serializer<'x> = quick_xml_serialize::CrossIndustryInvoiceTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CrossIndustryInvoiceTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CrossIndustryInvoiceTypeSerializerState::Init__),
            name: name.unwrap_or("rsm:CrossIndustryInvoiceType"),
            is_root,
        })
    }
}
impl WithDeserializer for CrossIndustryInvoiceType {
    type Deserializer = quick_xml_deserialize::CrossIndustryInvoiceTypeDeserializer;
}
#[derive(Debug)]
pub struct ExchangedDocumentContextType {
    pub test_indicator: Option<IndicatorType>,
    pub business_process_specified_document_context_parameter: Option<DocumentContextParameterType>,
    pub guideline_specified_document_context_parameter: DocumentContextParameterType,
}
impl WithSerializer for ExchangedDocumentContextType {
    type Serializer<'x> = quick_xml_serialize::ExchangedDocumentContextTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::ExchangedDocumentContextTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ExchangedDocumentContextTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:ExchangedDocumentContextType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for ExchangedDocumentContextType {
    type Deserializer = quick_xml_deserialize::ExchangedDocumentContextTypeDeserializer;
}
#[derive(Debug)]
pub struct ExchangedDocumentType {
    pub id: IdType,
    pub name: Option<TextType>,
    pub type_code: DocumentCodeType,
    pub issue_date_time: DateTimeType,
    pub copy_indicator: Option<IndicatorType>,
    pub language_id: Option<IdType>,
    pub included_note: Vec<NoteType>,
    pub effective_specified_period: Option<SpecifiedPeriodType>,
}
impl WithSerializer for ExchangedDocumentType {
    type Serializer<'x> = quick_xml_serialize::ExchangedDocumentTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ExchangedDocumentTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ExchangedDocumentTypeSerializerState::Init__),
            name: name.unwrap_or("ram:ExchangedDocumentType"),
            is_root,
        })
    }
}
impl WithDeserializer for ExchangedDocumentType {
    type Deserializer = quick_xml_deserialize::ExchangedDocumentTypeDeserializer;
}
#[derive(Debug)]
pub struct SupplyChainTradeTransactionType {
    pub included_supply_chain_trade_line_item: Vec<SupplyChainTradeLineItemType>,
    pub applicable_header_trade_agreement: HeaderTradeAgreementType,
    pub applicable_header_trade_delivery: HeaderTradeDeliveryType,
    pub applicable_header_trade_settlement: HeaderTradeSettlementType,
}
impl WithSerializer for SupplyChainTradeTransactionType {
    type Serializer<'x> = quick_xml_serialize::SupplyChainTradeTransactionTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::SupplyChainTradeTransactionTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::SupplyChainTradeTransactionTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:SupplyChainTradeTransactionType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for SupplyChainTradeTransactionType {
    type Deserializer = quick_xml_deserialize::SupplyChainTradeTransactionTypeDeserializer;
}
#[derive(Debug)]
pub struct IndicatorType {
    pub content: IndicatorTypeContent,
}
#[derive(Debug)]
pub enum IndicatorTypeContent {
    Indicator(bool),
}
impl WithSerializer for IndicatorType {
    type Serializer<'x> = quick_xml_serialize::IndicatorTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::IndicatorTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::IndicatorTypeSerializerState::Init__),
            name: name.unwrap_or("udt:IndicatorType"),
            is_root,
        })
    }
}
impl WithSerializer for IndicatorTypeContent {
    type Serializer<'x> = quick_xml_serialize::IndicatorTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::IndicatorTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::IndicatorTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for IndicatorType {
    type Deserializer = quick_xml_deserialize::IndicatorTypeDeserializer;
}
impl WithDeserializer for IndicatorTypeContent {
    type Deserializer = quick_xml_deserialize::IndicatorTypeContentDeserializer;
}
#[derive(Debug)]
pub struct DocumentContextParameterType {
    pub id: IdType,
}
impl WithSerializer for DocumentContextParameterType {
    type Serializer<'x> = quick_xml_serialize::DocumentContextParameterTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::DocumentContextParameterTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DocumentContextParameterTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:DocumentContextParameterType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for DocumentContextParameterType {
    type Deserializer = quick_xml_deserialize::DocumentContextParameterTypeDeserializer;
}
#[derive(Debug)]
pub struct IdType {
    pub scheme_id: Option<String>,
    pub content: String,
}
impl WithSerializer for IdType {
    type Serializer<'x> = quick_xml_serialize::IdTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::IdTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::IdTypeSerializerState::Init__),
            name: name.unwrap_or("udt:IDType"),
            is_root,
        })
    }
}
impl WithDeserializer for IdType {
    type Deserializer = quick_xml_deserialize::IdTypeDeserializer;
}
#[derive(Debug)]
pub struct TextType {
    pub content: String,
}
impl WithSerializer for TextType {
    type Serializer<'x> = quick_xml_serialize::TextTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TextTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TextTypeSerializerState::Init__),
            name: name.unwrap_or("udt:TextType"),
            is_root,
        })
    }
}
impl WithDeserializer for TextType {
    type Deserializer = quick_xml_deserialize::TextTypeDeserializer;
}
#[derive(Debug)]
pub struct DocumentCodeType {
    pub content: String,
}
impl WithSerializer for DocumentCodeType {
    type Serializer<'x> = quick_xml_serialize::DocumentCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DocumentCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DocumentCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:DocumentCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for DocumentCodeType {
    type Deserializer = quick_xml_deserialize::DocumentCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct DateTimeType {
    pub content: DateTimeTypeContent,
}
#[derive(Debug)]
pub enum DateTimeTypeContent {
    DateTimeString(DateTimeTypeDateTimeStringType),
}
impl WithSerializer for DateTimeType {
    type Serializer<'x> = quick_xml_serialize::DateTimeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DateTimeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DateTimeTypeSerializerState::Init__),
            name: name.unwrap_or("udt:DateTimeType"),
            is_root,
        })
    }
}
impl WithSerializer for DateTimeTypeContent {
    type Serializer<'x> = quick_xml_serialize::DateTimeTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::DateTimeTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DateTimeTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for DateTimeType {
    type Deserializer = quick_xml_deserialize::DateTimeTypeDeserializer;
}
impl WithDeserializer for DateTimeTypeContent {
    type Deserializer = quick_xml_deserialize::DateTimeTypeContentDeserializer;
}
#[derive(Debug)]
pub struct NoteType {
    pub content_code: Option<CodeType>,
    pub content: Option<TextType>,
    pub subject_code: Option<CodeType>,
}
impl WithSerializer for NoteType {
    type Serializer<'x> = quick_xml_serialize::NoteTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::NoteTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::NoteTypeSerializerState::Init__),
            name: name.unwrap_or("ram:NoteType"),
            is_root,
        })
    }
}
impl WithDeserializer for NoteType {
    type Deserializer = quick_xml_deserialize::NoteTypeDeserializer;
}
#[derive(Debug)]
pub struct SpecifiedPeriodType {
    pub description: Option<TextType>,
    pub start_date_time: Option<DateTimeType>,
    pub end_date_time: Option<DateTimeType>,
    pub complete_date_time: Option<DateTimeType>,
}
impl WithSerializer for SpecifiedPeriodType {
    type Serializer<'x> = quick_xml_serialize::SpecifiedPeriodTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SpecifiedPeriodTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SpecifiedPeriodTypeSerializerState::Init__),
            name: name.unwrap_or("ram:SpecifiedPeriodType"),
            is_root,
        })
    }
}
impl WithDeserializer for SpecifiedPeriodType {
    type Deserializer = quick_xml_deserialize::SpecifiedPeriodTypeDeserializer;
}
#[derive(Debug)]
pub struct SupplyChainTradeLineItemType {
    pub associated_document_line_document: DocumentLineDocumentType,
    pub specified_trade_product: TradeProductType,
    pub specified_line_trade_agreement: LineTradeAgreementType,
    pub specified_line_trade_delivery: LineTradeDeliveryType,
    pub specified_line_trade_settlement: LineTradeSettlementType,
}
impl WithSerializer for SupplyChainTradeLineItemType {
    type Serializer<'x> = quick_xml_serialize::SupplyChainTradeLineItemTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::SupplyChainTradeLineItemTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::SupplyChainTradeLineItemTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:SupplyChainTradeLineItemType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for SupplyChainTradeLineItemType {
    type Deserializer = quick_xml_deserialize::SupplyChainTradeLineItemTypeDeserializer;
}
#[derive(Debug)]
pub struct HeaderTradeAgreementType {
    pub buyer_reference: Option<TextType>,
    pub seller_trade_party: TradePartyType,
    pub buyer_trade_party: TradePartyType,
    pub sales_agent_trade_party: Option<TradePartyType>,
    pub buyer_tax_representative_trade_party: Option<TradePartyType>,
    pub seller_tax_representative_trade_party: Option<TradePartyType>,
    pub product_end_user_trade_party: Option<TradePartyType>,
    pub applicable_trade_delivery_terms: Option<TradeDeliveryTermsType>,
    pub seller_order_referenced_document: Option<ReferencedDocumentType>,
    pub buyer_order_referenced_document: Option<ReferencedDocumentType>,
    pub quotation_referenced_document: Option<ReferencedDocumentType>,
    pub contract_referenced_document: Option<ReferencedDocumentType>,
    pub additional_referenced_document: Vec<ReferencedDocumentType>,
    pub buyer_agent_trade_party: Option<TradePartyType>,
    pub specified_procuring_project: Option<ProcuringProjectType>,
    pub ultimate_customer_order_referenced_document: Vec<ReferencedDocumentType>,
}
impl WithSerializer for HeaderTradeAgreementType {
    type Serializer<'x> = quick_xml_serialize::HeaderTradeAgreementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::HeaderTradeAgreementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::HeaderTradeAgreementTypeSerializerState::Init__),
            name: name.unwrap_or("ram:HeaderTradeAgreementType"),
            is_root,
        })
    }
}
impl WithDeserializer for HeaderTradeAgreementType {
    type Deserializer = quick_xml_deserialize::HeaderTradeAgreementTypeDeserializer;
}
#[derive(Debug)]
pub struct HeaderTradeDeliveryType {
    pub related_supply_chain_consignment: Option<SupplyChainConsignmentType>,
    pub ship_to_trade_party: Option<TradePartyType>,
    pub ultimate_ship_to_trade_party: Option<TradePartyType>,
    pub ship_from_trade_party: Option<TradePartyType>,
    pub actual_delivery_supply_chain_event: Option<SupplyChainEventType>,
    pub despatch_advice_referenced_document: Option<ReferencedDocumentType>,
    pub receiving_advice_referenced_document: Option<ReferencedDocumentType>,
    pub delivery_note_referenced_document: Option<ReferencedDocumentType>,
}
impl WithSerializer for HeaderTradeDeliveryType {
    type Serializer<'x> = quick_xml_serialize::HeaderTradeDeliveryTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::HeaderTradeDeliveryTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::HeaderTradeDeliveryTypeSerializerState::Init__),
            name: name.unwrap_or("ram:HeaderTradeDeliveryType"),
            is_root,
        })
    }
}
impl WithDeserializer for HeaderTradeDeliveryType {
    type Deserializer = quick_xml_deserialize::HeaderTradeDeliveryTypeDeserializer;
}
#[derive(Debug)]
pub struct HeaderTradeSettlementType {
    pub creditor_reference_id: Option<IdType>,
    pub payment_reference: Option<TextType>,
    pub tax_currency_code: Option<CurrencyCodeType>,
    pub invoice_currency_code: CurrencyCodeType,
    pub invoice_issuer_reference: Option<TextType>,
    pub invoicer_trade_party: Option<TradePartyType>,
    pub invoicee_trade_party: Option<TradePartyType>,
    pub payee_trade_party: Option<TradePartyType>,
    pub payer_trade_party: Option<TradePartyType>,
    pub tax_applicable_trade_currency_exchange: Option<TradeCurrencyExchangeType>,
    pub specified_trade_settlement_payment_means: Vec<TradeSettlementPaymentMeansType>,
    pub applicable_trade_tax: Vec<TradeTaxType>,
    pub billing_specified_period: Option<SpecifiedPeriodType>,
    pub specified_trade_allowance_charge: Vec<TradeAllowanceChargeType>,
    pub specified_logistics_service_charge: Vec<LogisticsServiceChargeType>,
    pub specified_trade_payment_terms: Vec<TradePaymentTermsType>,
    pub specified_trade_settlement_header_monetary_summation:
        TradeSettlementHeaderMonetarySummationType,
    pub invoice_referenced_document: Vec<ReferencedDocumentType>,
    pub receivable_specified_trade_accounting_account: Vec<TradeAccountingAccountType>,
    pub specified_advance_payment: Vec<AdvancePaymentType>,
}
impl WithSerializer for HeaderTradeSettlementType {
    type Serializer<'x> = quick_xml_serialize::HeaderTradeSettlementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::HeaderTradeSettlementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::HeaderTradeSettlementTypeSerializerState::Init__),
            name: name.unwrap_or("ram:HeaderTradeSettlementType"),
            is_root,
        })
    }
}
impl WithDeserializer for HeaderTradeSettlementType {
    type Deserializer = quick_xml_deserialize::HeaderTradeSettlementTypeDeserializer;
}
#[derive(Debug)]
pub struct DateTimeTypeDateTimeStringType {
    pub format: String,
    pub content: String,
}
impl WithSerializer for DateTimeTypeDateTimeStringType {
    type Serializer<'x> = quick_xml_serialize::DateTimeTypeDateTimeStringTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::DateTimeTypeDateTimeStringTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DateTimeTypeDateTimeStringTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("udt:DateTimeTypeDateTimeString"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for DateTimeTypeDateTimeStringType {
    type Deserializer = quick_xml_deserialize::DateTimeTypeDateTimeStringTypeDeserializer;
}
#[derive(Debug)]
pub struct CodeType {
    pub list_id: Option<String>,
    pub list_version_id: Option<String>,
    pub content: String,
}
impl WithSerializer for CodeType {
    type Serializer<'x> = quick_xml_serialize::CodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CodeTypeSerializerState::Init__),
            name: name.unwrap_or("udt:CodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for CodeType {
    type Deserializer = quick_xml_deserialize::CodeTypeDeserializer;
}
#[derive(Debug)]
pub struct DocumentLineDocumentType {
    pub line_id: IdType,
    pub parent_line_id: Option<IdType>,
    pub line_status_code: Option<LineStatusCodeType>,
    pub line_status_reason_code: Option<CodeType>,
    pub included_note: Vec<NoteType>,
}
impl WithSerializer for DocumentLineDocumentType {
    type Serializer<'x> = quick_xml_serialize::DocumentLineDocumentTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DocumentLineDocumentTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DocumentLineDocumentTypeSerializerState::Init__),
            name: name.unwrap_or("ram:DocumentLineDocumentType"),
            is_root,
        })
    }
}
impl WithDeserializer for DocumentLineDocumentType {
    type Deserializer = quick_xml_deserialize::DocumentLineDocumentTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeProductType {
    pub id: Option<IdType>,
    pub global_id: Option<IdType>,
    pub seller_assigned_id: Option<IdType>,
    pub buyer_assigned_id: Option<IdType>,
    pub industry_assigned_id: Option<IdType>,
    pub model_id: Option<IdType>,
    pub name: TextType,
    pub description: Option<TextType>,
    pub batch_id: Vec<IdType>,
    pub brand_name: Option<TextType>,
    pub model_name: Option<TextType>,
    pub applicable_product_characteristic: Vec<ProductCharacteristicType>,
    pub designated_product_classification: Vec<ProductClassificationType>,
    pub individual_trade_product_instance: Vec<TradeProductInstanceType>,
    pub origin_trade_country: Option<TradeCountryType>,
    pub included_referenced_product: Vec<ReferencedProductType>,
}
impl WithSerializer for TradeProductType {
    type Serializer<'x> = quick_xml_serialize::TradeProductTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeProductTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeProductTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeProductType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeProductType {
    type Deserializer = quick_xml_deserialize::TradeProductTypeDeserializer;
}
#[derive(Debug)]
pub struct LineTradeAgreementType {
    pub seller_order_referenced_document: Option<ReferencedDocumentType>,
    pub buyer_order_referenced_document: Option<ReferencedDocumentType>,
    pub quotation_referenced_document: Option<ReferencedDocumentType>,
    pub contract_referenced_document: Option<ReferencedDocumentType>,
    pub additional_referenced_document: Vec<ReferencedDocumentType>,
    pub gross_price_product_trade_price: Option<TradePriceType>,
    pub net_price_product_trade_price: TradePriceType,
    pub ultimate_customer_order_referenced_document: Vec<ReferencedDocumentType>,
}
impl WithSerializer for LineTradeAgreementType {
    type Serializer<'x> = quick_xml_serialize::LineTradeAgreementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::LineTradeAgreementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::LineTradeAgreementTypeSerializerState::Init__),
            name: name.unwrap_or("ram:LineTradeAgreementType"),
            is_root,
        })
    }
}
impl WithDeserializer for LineTradeAgreementType {
    type Deserializer = quick_xml_deserialize::LineTradeAgreementTypeDeserializer;
}
#[derive(Debug)]
pub struct LineTradeDeliveryType {
    pub billed_quantity: QuantityType,
    pub charge_free_quantity: Option<QuantityType>,
    pub package_quantity: Option<QuantityType>,
    pub ship_to_trade_party: Option<TradePartyType>,
    pub ultimate_ship_to_trade_party: Option<TradePartyType>,
    pub actual_delivery_supply_chain_event: Option<SupplyChainEventType>,
    pub despatch_advice_referenced_document: Option<ReferencedDocumentType>,
    pub receiving_advice_referenced_document: Option<ReferencedDocumentType>,
    pub delivery_note_referenced_document: Option<ReferencedDocumentType>,
}
impl WithSerializer for LineTradeDeliveryType {
    type Serializer<'x> = quick_xml_serialize::LineTradeDeliveryTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::LineTradeDeliveryTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::LineTradeDeliveryTypeSerializerState::Init__),
            name: name.unwrap_or("ram:LineTradeDeliveryType"),
            is_root,
        })
    }
}
impl WithDeserializer for LineTradeDeliveryType {
    type Deserializer = quick_xml_deserialize::LineTradeDeliveryTypeDeserializer;
}
#[derive(Debug)]
pub struct LineTradeSettlementType {
    pub applicable_trade_tax: Vec<TradeTaxType>,
    pub billing_specified_period: Option<SpecifiedPeriodType>,
    pub specified_trade_allowance_charge: Vec<TradeAllowanceChargeType>,
    pub specified_trade_settlement_line_monetary_summation:
        TradeSettlementLineMonetarySummationType,
    pub invoice_referenced_document: Option<ReferencedDocumentType>,
    pub additional_referenced_document: Vec<ReferencedDocumentType>,
    pub receivable_specified_trade_accounting_account: Option<TradeAccountingAccountType>,
}
impl WithSerializer for LineTradeSettlementType {
    type Serializer<'x> = quick_xml_serialize::LineTradeSettlementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::LineTradeSettlementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::LineTradeSettlementTypeSerializerState::Init__),
            name: name.unwrap_or("ram:LineTradeSettlementType"),
            is_root,
        })
    }
}
impl WithDeserializer for LineTradeSettlementType {
    type Deserializer = quick_xml_deserialize::LineTradeSettlementTypeDeserializer;
}
#[derive(Debug)]
pub struct TradePartyType {
    pub id: Vec<IdType>,
    pub global_id: Vec<IdType>,
    pub name: Option<TextType>,
    pub role_code: Option<PartyRoleCodeType>,
    pub description: Option<TextType>,
    pub specified_legal_organization: Option<LegalOrganizationType>,
    pub defined_trade_contact: Vec<TradeContactType>,
    pub postal_trade_address: Option<TradeAddressType>,
    pub uri_universal_communication: Option<UniversalCommunicationType>,
    pub specified_tax_registration: Vec<TaxRegistrationType>,
}
impl WithSerializer for TradePartyType {
    type Serializer<'x> = quick_xml_serialize::TradePartyTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradePartyTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradePartyTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradePartyType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradePartyType {
    type Deserializer = quick_xml_deserialize::TradePartyTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeDeliveryTermsType {
    pub delivery_type_code: DeliveryTermsCodeType,
}
impl WithSerializer for TradeDeliveryTermsType {
    type Serializer<'x> = quick_xml_serialize::TradeDeliveryTermsTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeDeliveryTermsTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeDeliveryTermsTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeDeliveryTermsType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeDeliveryTermsType {
    type Deserializer = quick_xml_deserialize::TradeDeliveryTermsTypeDeserializer;
}
#[derive(Debug)]
pub struct ReferencedDocumentType {
    pub issuer_assigned_id: Option<IdType>,
    pub uriid: Option<IdType>,
    pub line_id: Option<IdType>,
    pub type_code: Option<DocumentCodeType>,
    pub name: Option<TextType>,
    pub attachment_binary_object: Option<BinaryObjectType>,
    pub reference_type_code: Option<ReferenceCodeType>,
    pub formatted_issue_date_time: Option<FormattedDateTimeType>,
}
impl WithSerializer for ReferencedDocumentType {
    type Serializer<'x> = quick_xml_serialize::ReferencedDocumentTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ReferencedDocumentTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ReferencedDocumentTypeSerializerState::Init__),
            name: name.unwrap_or("ram:ReferencedDocumentType"),
            is_root,
        })
    }
}
impl WithDeserializer for ReferencedDocumentType {
    type Deserializer = quick_xml_deserialize::ReferencedDocumentTypeDeserializer;
}
#[derive(Debug)]
pub struct ProcuringProjectType {
    pub id: IdType,
    pub name: TextType,
}
impl WithSerializer for ProcuringProjectType {
    type Serializer<'x> = quick_xml_serialize::ProcuringProjectTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProcuringProjectTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProcuringProjectTypeSerializerState::Init__),
            name: name.unwrap_or("ram:ProcuringProjectType"),
            is_root,
        })
    }
}
impl WithDeserializer for ProcuringProjectType {
    type Deserializer = quick_xml_deserialize::ProcuringProjectTypeDeserializer;
}
#[derive(Debug)]
pub struct SupplyChainConsignmentType {
    pub specified_logistics_transport_movement: Vec<LogisticsTransportMovementType>,
}
impl WithSerializer for SupplyChainConsignmentType {
    type Serializer<'x> = quick_xml_serialize::SupplyChainConsignmentTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SupplyChainConsignmentTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SupplyChainConsignmentTypeSerializerState::Init__),
            name: name.unwrap_or("ram:SupplyChainConsignmentType"),
            is_root,
        })
    }
}
impl WithDeserializer for SupplyChainConsignmentType {
    type Deserializer = quick_xml_deserialize::SupplyChainConsignmentTypeDeserializer;
}
#[derive(Debug)]
pub struct SupplyChainEventType {
    pub occurrence_date_time: DateTimeType,
}
impl WithSerializer for SupplyChainEventType {
    type Serializer<'x> = quick_xml_serialize::SupplyChainEventTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SupplyChainEventTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SupplyChainEventTypeSerializerState::Init__),
            name: name.unwrap_or("ram:SupplyChainEventType"),
            is_root,
        })
    }
}
impl WithDeserializer for SupplyChainEventType {
    type Deserializer = quick_xml_deserialize::SupplyChainEventTypeDeserializer;
}
#[derive(Debug)]
pub struct CurrencyCodeType {
    pub content: String,
}
impl WithSerializer for CurrencyCodeType {
    type Serializer<'x> = quick_xml_serialize::CurrencyCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CurrencyCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CurrencyCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:CurrencyCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for CurrencyCodeType {
    type Deserializer = quick_xml_deserialize::CurrencyCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeCurrencyExchangeType {
    pub source_currency_code: CurrencyCodeType,
    pub target_currency_code: CurrencyCodeType,
    pub conversion_rate: RateType,
    pub conversion_rate_date_time: Option<DateTimeType>,
}
impl WithSerializer for TradeCurrencyExchangeType {
    type Serializer<'x> = quick_xml_serialize::TradeCurrencyExchangeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeCurrencyExchangeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeCurrencyExchangeTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeCurrencyExchangeType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeCurrencyExchangeType {
    type Deserializer = quick_xml_deserialize::TradeCurrencyExchangeTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeSettlementPaymentMeansType {
    pub type_code: PaymentMeansCodeType,
    pub information: Option<TextType>,
    pub applicable_trade_settlement_financial_card: Option<TradeSettlementFinancialCardType>,
    pub payer_party_debtor_financial_account: Option<DebtorFinancialAccountType>,
    pub payee_party_creditor_financial_account: Option<CreditorFinancialAccountType>,
    pub payee_specified_creditor_financial_institution: Option<CreditorFinancialInstitutionType>,
}
impl WithSerializer for TradeSettlementPaymentMeansType {
    type Serializer<'x> = quick_xml_serialize::TradeSettlementPaymentMeansTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TradeSettlementPaymentMeansTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TradeSettlementPaymentMeansTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:TradeSettlementPaymentMeansType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TradeSettlementPaymentMeansType {
    type Deserializer = quick_xml_deserialize::TradeSettlementPaymentMeansTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeTaxType {
    pub calculated_amount: Option<AmountType>,
    pub type_code: TaxTypeCodeType,
    pub exemption_reason: Option<TextType>,
    pub basis_amount: Option<AmountType>,
    pub line_total_basis_amount: Option<AmountType>,
    pub allowance_charge_basis_amount: Option<AmountType>,
    pub category_code: TaxCategoryCodeType,
    pub exemption_reason_code: Option<CodeType>,
    pub tax_point_date: Option<DateType>,
    pub due_date_type_code: Option<TimeReferenceCodeType>,
    pub rate_applicable_percent: Option<PercentType>,
}
impl WithSerializer for TradeTaxType {
    type Serializer<'x> = quick_xml_serialize::TradeTaxTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeTaxTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeTaxTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeTaxType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeTaxType {
    type Deserializer = quick_xml_deserialize::TradeTaxTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeAllowanceChargeType {
    pub charge_indicator: IndicatorType,
    pub sequence_numeric: Option<NumericType>,
    pub calculation_percent: Option<PercentType>,
    pub basis_amount: Option<AmountType>,
    pub basis_quantity: Option<QuantityType>,
    pub actual_amount: AmountType,
    pub reason_code: Option<AllowanceChargeReasonCodeType>,
    pub reason: Option<TextType>,
    pub category_trade_tax: Option<TradeTaxType>,
}
impl WithSerializer for TradeAllowanceChargeType {
    type Serializer<'x> = quick_xml_serialize::TradeAllowanceChargeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeAllowanceChargeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeAllowanceChargeTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeAllowanceChargeType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeAllowanceChargeType {
    type Deserializer = quick_xml_deserialize::TradeAllowanceChargeTypeDeserializer;
}
#[derive(Debug)]
pub struct LogisticsServiceChargeType {
    pub description: TextType,
    pub applied_amount: AmountType,
    pub applied_trade_tax: Vec<TradeTaxType>,
}
impl WithSerializer for LogisticsServiceChargeType {
    type Serializer<'x> = quick_xml_serialize::LogisticsServiceChargeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::LogisticsServiceChargeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::LogisticsServiceChargeTypeSerializerState::Init__),
            name: name.unwrap_or("ram:LogisticsServiceChargeType"),
            is_root,
        })
    }
}
impl WithDeserializer for LogisticsServiceChargeType {
    type Deserializer = quick_xml_deserialize::LogisticsServiceChargeTypeDeserializer;
}
#[derive(Debug)]
pub struct TradePaymentTermsType {
    pub description: Option<TextType>,
    pub due_date_date_time: Option<DateTimeType>,
    pub direct_debit_mandate_id: Option<IdType>,
    pub partial_payment_amount: Option<AmountType>,
    pub applicable_trade_payment_penalty_terms: Option<TradePaymentPenaltyTermsType>,
    pub applicable_trade_payment_discount_terms: Option<TradePaymentDiscountTermsType>,
    pub payee_trade_party: Option<TradePartyType>,
}
impl WithSerializer for TradePaymentTermsType {
    type Serializer<'x> = quick_xml_serialize::TradePaymentTermsTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradePaymentTermsTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradePaymentTermsTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradePaymentTermsType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradePaymentTermsType {
    type Deserializer = quick_xml_deserialize::TradePaymentTermsTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeSettlementHeaderMonetarySummationType {
    pub line_total_amount: AmountType,
    pub charge_total_amount: Option<AmountType>,
    pub allowance_total_amount: Option<AmountType>,
    pub tax_basis_total_amount: AmountType,
    pub tax_total_amount: Vec<AmountType>,
    pub rounding_amount: Option<AmountType>,
    pub grand_total_amount: AmountType,
    pub total_prepaid_amount: Option<AmountType>,
    pub due_payable_amount: AmountType,
}
impl WithSerializer for TradeSettlementHeaderMonetarySummationType {
    type Serializer<'x> =
        quick_xml_serialize::TradeSettlementHeaderMonetarySummationTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: TradeSettlementHeaderMonetarySummationTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: TradeSettlementHeaderMonetarySummationTypeSerializerState :: Init__) , name : name . unwrap_or ("ram:TradeSettlementHeaderMonetarySummationType") , is_root , })
    }
}
impl WithDeserializer for TradeSettlementHeaderMonetarySummationType {
    type Deserializer =
        quick_xml_deserialize::TradeSettlementHeaderMonetarySummationTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeAccountingAccountType {
    pub id: IdType,
    pub type_code: Option<AccountingAccountTypeCodeType>,
}
impl WithSerializer for TradeAccountingAccountType {
    type Serializer<'x> = quick_xml_serialize::TradeAccountingAccountTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeAccountingAccountTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeAccountingAccountTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeAccountingAccountType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeAccountingAccountType {
    type Deserializer = quick_xml_deserialize::TradeAccountingAccountTypeDeserializer;
}
#[derive(Debug)]
pub struct AdvancePaymentType {
    pub paid_amount: AmountType,
    pub formatted_received_date_time: Option<FormattedDateTimeType>,
    pub included_trade_tax: Vec<TradeTaxType>,
    pub invoice_specified_referenced_document: Option<ReferencedDocumentType>,
}
impl WithSerializer for AdvancePaymentType {
    type Serializer<'x> = quick_xml_serialize::AdvancePaymentTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::AdvancePaymentTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::AdvancePaymentTypeSerializerState::Init__),
            name: name.unwrap_or("ram:AdvancePaymentType"),
            is_root,
        })
    }
}
impl WithDeserializer for AdvancePaymentType {
    type Deserializer = quick_xml_deserialize::AdvancePaymentTypeDeserializer;
}
#[derive(Debug)]
pub struct LineStatusCodeType {
    pub content: String,
}
impl WithSerializer for LineStatusCodeType {
    type Serializer<'x> = quick_xml_serialize::LineStatusCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::LineStatusCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::LineStatusCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:LineStatusCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for LineStatusCodeType {
    type Deserializer = quick_xml_deserialize::LineStatusCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductCharacteristicType {
    pub type_code: Option<CodeType>,
    pub description: TextType,
    pub value_measure: Option<MeasureType>,
    pub value: TextType,
}
impl WithSerializer for ProductCharacteristicType {
    type Serializer<'x> = quick_xml_serialize::ProductCharacteristicTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductCharacteristicTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductCharacteristicTypeSerializerState::Init__),
            name: name.unwrap_or("ram:ProductCharacteristicType"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductCharacteristicType {
    type Deserializer = quick_xml_deserialize::ProductCharacteristicTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductClassificationType {
    pub class_code: Option<CodeType>,
    pub class_name: Option<TextType>,
}
impl WithSerializer for ProductClassificationType {
    type Serializer<'x> = quick_xml_serialize::ProductClassificationTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductClassificationTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductClassificationTypeSerializerState::Init__),
            name: name.unwrap_or("ram:ProductClassificationType"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductClassificationType {
    type Deserializer = quick_xml_deserialize::ProductClassificationTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeProductInstanceType {
    pub batch_id: Option<IdType>,
    pub supplier_assigned_serial_id: Option<IdType>,
}
impl WithSerializer for TradeProductInstanceType {
    type Serializer<'x> = quick_xml_serialize::TradeProductInstanceTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeProductInstanceTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeProductInstanceTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeProductInstanceType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeProductInstanceType {
    type Deserializer = quick_xml_deserialize::TradeProductInstanceTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeCountryType {
    pub id: CountryIdType,
}
impl WithSerializer for TradeCountryType {
    type Serializer<'x> = quick_xml_serialize::TradeCountryTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeCountryTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeCountryTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeCountryType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeCountryType {
    type Deserializer = quick_xml_deserialize::TradeCountryTypeDeserializer;
}
#[derive(Debug)]
pub struct ReferencedProductType {
    pub id: Option<IdType>,
    pub global_id: Vec<IdType>,
    pub seller_assigned_id: Option<IdType>,
    pub buyer_assigned_id: Option<IdType>,
    pub industry_assigned_id: Option<IdType>,
    pub name: TextType,
    pub description: Option<TextType>,
    pub unit_quantity: Option<QuantityType>,
}
impl WithSerializer for ReferencedProductType {
    type Serializer<'x> = quick_xml_serialize::ReferencedProductTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ReferencedProductTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ReferencedProductTypeSerializerState::Init__),
            name: name.unwrap_or("ram:ReferencedProductType"),
            is_root,
        })
    }
}
impl WithDeserializer for ReferencedProductType {
    type Deserializer = quick_xml_deserialize::ReferencedProductTypeDeserializer;
}
#[derive(Debug)]
pub struct TradePriceType {
    pub charge_amount: AmountType,
    pub basis_quantity: Option<QuantityType>,
    pub applied_trade_allowance_charge: Vec<TradeAllowanceChargeType>,
    pub included_trade_tax: Option<TradeTaxType>,
}
impl WithSerializer for TradePriceType {
    type Serializer<'x> = quick_xml_serialize::TradePriceTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradePriceTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradePriceTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradePriceType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradePriceType {
    type Deserializer = quick_xml_deserialize::TradePriceTypeDeserializer;
}
#[derive(Debug)]
pub struct QuantityType {
    pub unit_code: Option<String>,
    pub content: f64,
}
impl WithSerializer for QuantityType {
    type Serializer<'x> = quick_xml_serialize::QuantityTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::QuantityTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::QuantityTypeSerializerState::Init__),
            name: name.unwrap_or("udt:QuantityType"),
            is_root,
        })
    }
}
impl WithDeserializer for QuantityType {
    type Deserializer = quick_xml_deserialize::QuantityTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeSettlementLineMonetarySummationType {
    pub line_total_amount: AmountType,
    pub charge_total_amount: Option<AmountType>,
    pub allowance_total_amount: Option<AmountType>,
    pub tax_total_amount: Option<AmountType>,
    pub grand_total_amount: Option<AmountType>,
    pub total_allowance_charge_amount: Option<AmountType>,
}
impl WithSerializer for TradeSettlementLineMonetarySummationType {
    type Serializer<'x> =
        quick_xml_serialize::TradeSettlementLineMonetarySummationTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: TradeSettlementLineMonetarySummationTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: TradeSettlementLineMonetarySummationTypeSerializerState :: Init__) , name : name . unwrap_or ("ram:TradeSettlementLineMonetarySummationType") , is_root , })
    }
}
impl WithDeserializer for TradeSettlementLineMonetarySummationType {
    type Deserializer = quick_xml_deserialize::TradeSettlementLineMonetarySummationTypeDeserializer;
}
#[derive(Debug)]
pub struct PartyRoleCodeType {
    pub content: String,
}
impl WithSerializer for PartyRoleCodeType {
    type Serializer<'x> = quick_xml_serialize::PartyRoleCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PartyRoleCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PartyRoleCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:PartyRoleCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for PartyRoleCodeType {
    type Deserializer = quick_xml_deserialize::PartyRoleCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct LegalOrganizationType {
    pub id: Option<IdType>,
    pub trading_business_name: Option<TextType>,
    pub postal_trade_address: Option<TradeAddressType>,
}
impl WithSerializer for LegalOrganizationType {
    type Serializer<'x> = quick_xml_serialize::LegalOrganizationTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::LegalOrganizationTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::LegalOrganizationTypeSerializerState::Init__),
            name: name.unwrap_or("ram:LegalOrganizationType"),
            is_root,
        })
    }
}
impl WithDeserializer for LegalOrganizationType {
    type Deserializer = quick_xml_deserialize::LegalOrganizationTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeContactType {
    pub person_name: Option<TextType>,
    pub department_name: Option<TextType>,
    pub type_code: Option<ContactTypeCodeType>,
    pub telephone_universal_communication: Option<UniversalCommunicationType>,
    pub fax_universal_communication: Option<UniversalCommunicationType>,
    pub email_uri_universal_communication: Option<UniversalCommunicationType>,
}
impl WithSerializer for TradeContactType {
    type Serializer<'x> = quick_xml_serialize::TradeContactTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeContactTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeContactTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeContactType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeContactType {
    type Deserializer = quick_xml_deserialize::TradeContactTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeAddressType {
    pub postcode_code: Option<CodeType>,
    pub line_one: Option<TextType>,
    pub line_two: Option<TextType>,
    pub line_three: Option<TextType>,
    pub city_name: Option<TextType>,
    pub country_id: CountryIdType,
    pub country_sub_division_name: Option<TextType>,
}
impl WithSerializer for TradeAddressType {
    type Serializer<'x> = quick_xml_serialize::TradeAddressTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TradeAddressTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TradeAddressTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TradeAddressType"),
            is_root,
        })
    }
}
impl WithDeserializer for TradeAddressType {
    type Deserializer = quick_xml_deserialize::TradeAddressTypeDeserializer;
}
#[derive(Debug)]
pub struct UniversalCommunicationType {
    pub uriid: Option<IdType>,
    pub complete_number: Option<TextType>,
}
impl WithSerializer for UniversalCommunicationType {
    type Serializer<'x> = quick_xml_serialize::UniversalCommunicationTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UniversalCommunicationTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UniversalCommunicationTypeSerializerState::Init__),
            name: name.unwrap_or("ram:UniversalCommunicationType"),
            is_root,
        })
    }
}
impl WithDeserializer for UniversalCommunicationType {
    type Deserializer = quick_xml_deserialize::UniversalCommunicationTypeDeserializer;
}
#[derive(Debug)]
pub struct TaxRegistrationType {
    pub id: IdType,
}
impl WithSerializer for TaxRegistrationType {
    type Serializer<'x> = quick_xml_serialize::TaxRegistrationTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TaxRegistrationTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TaxRegistrationTypeSerializerState::Init__),
            name: name.unwrap_or("ram:TaxRegistrationType"),
            is_root,
        })
    }
}
impl WithDeserializer for TaxRegistrationType {
    type Deserializer = quick_xml_deserialize::TaxRegistrationTypeDeserializer;
}
#[derive(Debug)]
pub struct DeliveryTermsCodeType {
    pub content: String,
}
impl WithSerializer for DeliveryTermsCodeType {
    type Serializer<'x> = quick_xml_serialize::DeliveryTermsCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DeliveryTermsCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DeliveryTermsCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:DeliveryTermsCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for DeliveryTermsCodeType {
    type Deserializer = quick_xml_deserialize::DeliveryTermsCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct BinaryObjectType {
    pub mime_code: String,
    pub filename: String,
    pub content: String,
}
impl WithSerializer for BinaryObjectType {
    type Serializer<'x> = quick_xml_serialize::BinaryObjectTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::BinaryObjectTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BinaryObjectTypeSerializerState::Init__),
            name: name.unwrap_or("udt:BinaryObjectType"),
            is_root,
        })
    }
}
impl WithDeserializer for BinaryObjectType {
    type Deserializer = quick_xml_deserialize::BinaryObjectTypeDeserializer;
}
#[derive(Debug)]
pub struct ReferenceCodeType {
    pub content: String,
}
impl WithSerializer for ReferenceCodeType {
    type Serializer<'x> = quick_xml_serialize::ReferenceCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ReferenceCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ReferenceCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:ReferenceCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for ReferenceCodeType {
    type Deserializer = quick_xml_deserialize::ReferenceCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct FormattedDateTimeType {
    pub date_time_string: FormattedDateTimeTypeDateTimeStringType,
}
impl WithSerializer for FormattedDateTimeType {
    type Serializer<'x> = quick_xml_serialize::FormattedDateTimeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::FormattedDateTimeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::FormattedDateTimeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:FormattedDateTimeType"),
            is_root,
        })
    }
}
impl WithDeserializer for FormattedDateTimeType {
    type Deserializer = quick_xml_deserialize::FormattedDateTimeTypeDeserializer;
}
#[derive(Debug)]
pub struct LogisticsTransportMovementType {
    pub mode_code: TransportModeCodeType,
}
impl WithSerializer for LogisticsTransportMovementType {
    type Serializer<'x> = quick_xml_serialize::LogisticsTransportMovementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::LogisticsTransportMovementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::LogisticsTransportMovementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:LogisticsTransportMovementType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for LogisticsTransportMovementType {
    type Deserializer = quick_xml_deserialize::LogisticsTransportMovementTypeDeserializer;
}
#[derive(Debug)]
pub struct RateType {
    pub content: f64,
}
impl WithSerializer for RateType {
    type Serializer<'x> = quick_xml_serialize::RateTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::RateTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::RateTypeSerializerState::Init__),
            name: name.unwrap_or("udt:RateType"),
            is_root,
        })
    }
}
impl WithDeserializer for RateType {
    type Deserializer = quick_xml_deserialize::RateTypeDeserializer;
}
#[derive(Debug)]
pub struct PaymentMeansCodeType {
    pub content: String,
}
impl WithSerializer for PaymentMeansCodeType {
    type Serializer<'x> = quick_xml_serialize::PaymentMeansCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PaymentMeansCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PaymentMeansCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:PaymentMeansCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for PaymentMeansCodeType {
    type Deserializer = quick_xml_deserialize::PaymentMeansCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct TradeSettlementFinancialCardType {
    pub id: IdType,
    pub cardholder_name: Option<TextType>,
}
impl WithSerializer for TradeSettlementFinancialCardType {
    type Serializer<'x> = quick_xml_serialize::TradeSettlementFinancialCardTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TradeSettlementFinancialCardTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TradeSettlementFinancialCardTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:TradeSettlementFinancialCardType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TradeSettlementFinancialCardType {
    type Deserializer = quick_xml_deserialize::TradeSettlementFinancialCardTypeDeserializer;
}
#[derive(Debug)]
pub struct DebtorFinancialAccountType {
    pub ibanid: IdType,
}
impl WithSerializer for DebtorFinancialAccountType {
    type Serializer<'x> = quick_xml_serialize::DebtorFinancialAccountTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DebtorFinancialAccountTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DebtorFinancialAccountTypeSerializerState::Init__),
            name: name.unwrap_or("ram:DebtorFinancialAccountType"),
            is_root,
        })
    }
}
impl WithDeserializer for DebtorFinancialAccountType {
    type Deserializer = quick_xml_deserialize::DebtorFinancialAccountTypeDeserializer;
}
#[derive(Debug)]
pub struct CreditorFinancialAccountType {
    pub ibanid: Option<IdType>,
    pub account_name: Option<TextType>,
    pub proprietary_id: Option<IdType>,
}
impl WithSerializer for CreditorFinancialAccountType {
    type Serializer<'x> = quick_xml_serialize::CreditorFinancialAccountTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CreditorFinancialAccountTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CreditorFinancialAccountTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:CreditorFinancialAccountType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CreditorFinancialAccountType {
    type Deserializer = quick_xml_deserialize::CreditorFinancialAccountTypeDeserializer;
}
#[derive(Debug)]
pub struct CreditorFinancialInstitutionType {
    pub bicid: IdType,
}
impl WithSerializer for CreditorFinancialInstitutionType {
    type Serializer<'x> = quick_xml_serialize::CreditorFinancialInstitutionTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CreditorFinancialInstitutionTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CreditorFinancialInstitutionTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:CreditorFinancialInstitutionType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CreditorFinancialInstitutionType {
    type Deserializer = quick_xml_deserialize::CreditorFinancialInstitutionTypeDeserializer;
}
#[derive(Debug)]
pub struct AmountType {
    pub currency_id: Option<String>,
    pub content: f64,
}
impl WithSerializer for AmountType {
    type Serializer<'x> = quick_xml_serialize::AmountTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::AmountTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::AmountTypeSerializerState::Init__),
            name: name.unwrap_or("udt:AmountType"),
            is_root,
        })
    }
}
impl WithDeserializer for AmountType {
    type Deserializer = quick_xml_deserialize::AmountTypeDeserializer;
}
#[derive(Debug)]
pub struct TaxTypeCodeType {
    pub content: String,
}
impl WithSerializer for TaxTypeCodeType {
    type Serializer<'x> = quick_xml_serialize::TaxTypeCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TaxTypeCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TaxTypeCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:TaxTypeCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for TaxTypeCodeType {
    type Deserializer = quick_xml_deserialize::TaxTypeCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct TaxCategoryCodeType {
    pub content: String,
}
impl WithSerializer for TaxCategoryCodeType {
    type Serializer<'x> = quick_xml_serialize::TaxCategoryCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TaxCategoryCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TaxCategoryCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:TaxCategoryCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for TaxCategoryCodeType {
    type Deserializer = quick_xml_deserialize::TaxCategoryCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct DateType {
    pub content: DateTypeContent,
}
#[derive(Debug)]
pub enum DateTypeContent {
    DateString(DateTypeDateStringType),
}
impl WithSerializer for DateType {
    type Serializer<'x> = quick_xml_serialize::DateTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DateTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DateTypeSerializerState::Init__),
            name: name.unwrap_or("udt:DateType"),
            is_root,
        })
    }
}
impl WithSerializer for DateTypeContent {
    type Serializer<'x> = quick_xml_serialize::DateTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::DateTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DateTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for DateType {
    type Deserializer = quick_xml_deserialize::DateTypeDeserializer;
}
impl WithDeserializer for DateTypeContent {
    type Deserializer = quick_xml_deserialize::DateTypeContentDeserializer;
}
#[derive(Debug)]
pub struct TimeReferenceCodeType {
    pub content: String,
}
impl WithSerializer for TimeReferenceCodeType {
    type Serializer<'x> = quick_xml_serialize::TimeReferenceCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TimeReferenceCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TimeReferenceCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:TimeReferenceCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for TimeReferenceCodeType {
    type Deserializer = quick_xml_deserialize::TimeReferenceCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct PercentType {
    pub content: f64,
}
impl WithSerializer for PercentType {
    type Serializer<'x> = quick_xml_serialize::PercentTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PercentTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PercentTypeSerializerState::Init__),
            name: name.unwrap_or("udt:PercentType"),
            is_root,
        })
    }
}
impl WithDeserializer for PercentType {
    type Deserializer = quick_xml_deserialize::PercentTypeDeserializer;
}
#[derive(Debug)]
pub struct NumericType {
    pub content: f64,
}
impl WithSerializer for NumericType {
    type Serializer<'x> = quick_xml_serialize::NumericTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::NumericTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::NumericTypeSerializerState::Init__),
            name: name.unwrap_or("udt:NumericType"),
            is_root,
        })
    }
}
impl WithDeserializer for NumericType {
    type Deserializer = quick_xml_deserialize::NumericTypeDeserializer;
}
#[derive(Debug)]
pub struct AllowanceChargeReasonCodeType {
    pub content: String,
}
impl WithSerializer for AllowanceChargeReasonCodeType {
    type Serializer<'x> = quick_xml_serialize::AllowanceChargeReasonCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::AllowanceChargeReasonCodeTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::AllowanceChargeReasonCodeTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("qdt:AllowanceChargeReasonCodeType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for AllowanceChargeReasonCodeType {
    type Deserializer = quick_xml_deserialize::AllowanceChargeReasonCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct TradePaymentPenaltyTermsType {
    pub basis_date_time: Option<DateTimeType>,
    pub basis_period_measure: Option<MeasureType>,
    pub basis_amount: Option<AmountType>,
    pub calculation_percent: Option<PercentType>,
    pub actual_penalty_amount: Option<AmountType>,
}
impl WithSerializer for TradePaymentPenaltyTermsType {
    type Serializer<'x> = quick_xml_serialize::TradePaymentPenaltyTermsTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TradePaymentPenaltyTermsTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TradePaymentPenaltyTermsTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:TradePaymentPenaltyTermsType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TradePaymentPenaltyTermsType {
    type Deserializer = quick_xml_deserialize::TradePaymentPenaltyTermsTypeDeserializer;
}
#[derive(Debug)]
pub struct TradePaymentDiscountTermsType {
    pub basis_date_time: Option<DateTimeType>,
    pub basis_period_measure: Option<MeasureType>,
    pub basis_amount: Option<AmountType>,
    pub calculation_percent: Option<PercentType>,
    pub actual_discount_amount: Option<AmountType>,
}
impl WithSerializer for TradePaymentDiscountTermsType {
    type Serializer<'x> = quick_xml_serialize::TradePaymentDiscountTermsTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TradePaymentDiscountTermsTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TradePaymentDiscountTermsTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ram:TradePaymentDiscountTermsType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TradePaymentDiscountTermsType {
    type Deserializer = quick_xml_deserialize::TradePaymentDiscountTermsTypeDeserializer;
}
#[derive(Debug)]
pub struct AccountingAccountTypeCodeType {
    pub content: String,
}
impl WithSerializer for AccountingAccountTypeCodeType {
    type Serializer<'x> = quick_xml_serialize::AccountingAccountTypeCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::AccountingAccountTypeCodeTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::AccountingAccountTypeCodeTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("qdt:AccountingAccountTypeCodeType"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for AccountingAccountTypeCodeType {
    type Deserializer = quick_xml_deserialize::AccountingAccountTypeCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct MeasureType {
    pub unit_code: Option<String>,
    pub content: f64,
}
impl WithSerializer for MeasureType {
    type Serializer<'x> = quick_xml_serialize::MeasureTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::MeasureTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::MeasureTypeSerializerState::Init__),
            name: name.unwrap_or("udt:MeasureType"),
            is_root,
        })
    }
}
impl WithDeserializer for MeasureType {
    type Deserializer = quick_xml_deserialize::MeasureTypeDeserializer;
}
#[derive(Debug)]
pub struct CountryIdType {
    pub content: String,
}
impl WithSerializer for CountryIdType {
    type Serializer<'x> = quick_xml_serialize::CountryIdTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CountryIdTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CountryIdTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:CountryIDType"),
            is_root,
        })
    }
}
impl WithDeserializer for CountryIdType {
    type Deserializer = quick_xml_deserialize::CountryIdTypeDeserializer;
}
#[derive(Debug)]
pub struct ContactTypeCodeType {
    pub content: String,
}
impl WithSerializer for ContactTypeCodeType {
    type Serializer<'x> = quick_xml_serialize::ContactTypeCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ContactTypeCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ContactTypeCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:ContactTypeCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for ContactTypeCodeType {
    type Deserializer = quick_xml_deserialize::ContactTypeCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct FormattedDateTimeTypeDateTimeStringType {
    pub format: String,
    pub content: String,
}
impl WithSerializer for FormattedDateTimeTypeDateTimeStringType {
    type Serializer<'x> =
        quick_xml_serialize::FormattedDateTimeTypeDateTimeStringTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: FormattedDateTimeTypeDateTimeStringTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: FormattedDateTimeTypeDateTimeStringTypeSerializerState :: Init__) , name : name . unwrap_or ("qdt:FormattedDateTimeTypeDateTimeString") , is_root , })
    }
}
impl WithDeserializer for FormattedDateTimeTypeDateTimeStringType {
    type Deserializer = quick_xml_deserialize::FormattedDateTimeTypeDateTimeStringTypeDeserializer;
}
#[derive(Debug)]
pub struct TransportModeCodeType {
    pub content: String,
}
impl WithSerializer for TransportModeCodeType {
    type Serializer<'x> = quick_xml_serialize::TransportModeCodeTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TransportModeCodeTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TransportModeCodeTypeSerializerState::Init__),
            name: name.unwrap_or("qdt:TransportModeCodeType"),
            is_root,
        })
    }
}
impl WithDeserializer for TransportModeCodeType {
    type Deserializer = quick_xml_deserialize::TransportModeCodeTypeDeserializer;
}
#[derive(Debug)]
pub struct DateTypeDateStringType {
    pub format: String,
    pub content: String,
}
impl WithSerializer for DateTypeDateStringType {
    type Serializer<'x> = quick_xml_serialize::DateTypeDateStringTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DateTypeDateStringTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DateTypeDateStringTypeSerializerState::Init__),
            name: name.unwrap_or("udt:DateTypeDateString"),
            is_root,
        })
    }
}
impl WithDeserializer for DateTypeDateStringType {
    type Deserializer = quick_xml_deserialize::DateTypeDateStringTypeDeserializer;
}
pub mod quick_xml_deserialize {
    use core::mem::replace;
    use xsd_parser::quick_xml::{
        filter_xmlns_attributes, BytesStart, ContentDeserializer, DeserializeReader, Deserializer,
        DeserializerArtifact, DeserializerEvent, DeserializerOutput, DeserializerResult,
        ElementHandlerOutput, Error, ErrorKind, Event, RawByteStr, WithDeserializer,
    };
    #[derive(Debug)]
    pub struct CrossIndustryInvoiceTypeDeserializer {
        exchanged_document_context: Option<super::ExchangedDocumentContextType>,
        exchanged_document: Option<super::ExchangedDocumentType>,
        supply_chain_trade_transaction: Option<super::SupplyChainTradeTransactionType>,
        state: Box<CrossIndustryInvoiceTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CrossIndustryInvoiceTypeDeserializerState {
        Init__,
        ExchangedDocumentContext(
            Option<<super::ExchangedDocumentContextType as WithDeserializer>::Deserializer>,
        ),
        ExchangedDocument(Option<<super::ExchangedDocumentType as WithDeserializer>::Deserializer>),
        SupplyChainTradeTransaction(
            Option<<super::SupplyChainTradeTransactionType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl CrossIndustryInvoiceTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                exchanged_document_context: None,
                exchanged_document: None,
                supply_chain_trade_transaction: None,
                state: Box::new(CrossIndustryInvoiceTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CrossIndustryInvoiceTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CrossIndustryInvoiceTypeDeserializerState as S;
            match state {
                S::ExchangedDocumentContext(Some(deserializer)) => {
                    self.store_exchanged_document_context(deserializer.finish(reader)?)?
                }
                S::ExchangedDocument(Some(deserializer)) => {
                    self.store_exchanged_document(deserializer.finish(reader)?)?
                }
                S::SupplyChainTradeTransaction(Some(deserializer)) => {
                    self.store_supply_chain_trade_transaction(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_exchanged_document_context(
            &mut self,
            value: super::ExchangedDocumentContextType,
        ) -> Result<(), Error> {
            if self.exchanged_document_context.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ExchangedDocumentContext",
                )))?;
            }
            self.exchanged_document_context = Some(value);
            Ok(())
        }
        fn store_exchanged_document(
            &mut self,
            value: super::ExchangedDocumentType,
        ) -> Result<(), Error> {
            if self.exchanged_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ExchangedDocument",
                )))?;
            }
            self.exchanged_document = Some(value);
            Ok(())
        }
        fn store_supply_chain_trade_transaction(
            &mut self,
            value: super::SupplyChainTradeTransactionType,
        ) -> Result<(), Error> {
            if self.supply_chain_trade_transaction.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SupplyChainTradeTransaction",
                )))?;
            }
            self.supply_chain_trade_transaction = Some(value);
            Ok(())
        }
        fn handle_exchanged_document_context<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ExchangedDocumentContextType>,
            fallback: &mut Option<CrossIndustryInvoiceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.exchanged_document_context.is_some() {
                    fallback.get_or_insert(
                        CrossIndustryInvoiceTypeDeserializerState::ExchangedDocumentContext(None),
                    );
                    *self.state =
                        CrossIndustryInvoiceTypeDeserializerState::ExchangedDocument(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        CrossIndustryInvoiceTypeDeserializerState::ExchangedDocumentContext(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_exchanged_document_context(data)?;
                    *self.state =
                        CrossIndustryInvoiceTypeDeserializerState::ExchangedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CrossIndustryInvoiceTypeDeserializerState::ExchangedDocumentContext(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                CrossIndustryInvoiceTypeDeserializerState::ExchangedDocument(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CrossIndustryInvoiceTypeDeserializerState::ExchangedDocumentContext(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_exchanged_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ExchangedDocumentType>,
            fallback: &mut Option<CrossIndustryInvoiceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.exchanged_document.is_some() {
                    fallback.get_or_insert(
                        CrossIndustryInvoiceTypeDeserializerState::ExchangedDocument(None),
                    );
                    *self.state =
                        CrossIndustryInvoiceTypeDeserializerState::SupplyChainTradeTransaction(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        CrossIndustryInvoiceTypeDeserializerState::ExchangedDocument(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_exchanged_document(data)?;
                    *self.state =
                        CrossIndustryInvoiceTypeDeserializerState::SupplyChainTradeTransaction(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CrossIndustryInvoiceTypeDeserializerState::ExchangedDocument(Some(
                                    deserializer,
                                )),
                            );
                            * self . state = CrossIndustryInvoiceTypeDeserializerState :: SupplyChainTradeTransaction (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CrossIndustryInvoiceTypeDeserializerState::ExchangedDocument(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_supply_chain_trade_transaction<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplyChainTradeTransactionType>,
            fallback: &mut Option<CrossIndustryInvoiceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supply_chain_trade_transaction.is_some() {
                    fallback.get_or_insert(
                        CrossIndustryInvoiceTypeDeserializerState::SupplyChainTradeTransaction(
                            None,
                        ),
                    );
                    *self.state = CrossIndustryInvoiceTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        CrossIndustryInvoiceTypeDeserializerState::SupplyChainTradeTransaction(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supply_chain_trade_transaction(data)?;
                    *self.state = CrossIndustryInvoiceTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (CrossIndustryInvoiceTypeDeserializerState :: SupplyChainTradeTransaction (Some (deserializer))) ;
                            *self.state = CrossIndustryInvoiceTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = CrossIndustryInvoiceTypeDeserializerState :: SupplyChainTradeTransaction (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CrossIndustryInvoiceType>
        for CrossIndustryInvoiceTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CrossIndustryInvoiceType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CrossIndustryInvoiceType>
        where
            R: DeserializeReader,
        {
            use CrossIndustryInvoiceTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ExchangedDocumentContext(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_exchanged_document_context(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ExchangedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_exchanged_document(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SupplyChainTradeTransaction(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supply_chain_trade_transaction(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CrossIndustryInvoiceTypeDeserializerState::ExchangedDocumentContext(
                                None,
                            );
                        event
                    }
                    (
                        S::ExchangedDocumentContext(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RSM),
                            b"ExchangedDocumentContext",
                        ) {
                            let output = < super :: ExchangedDocumentContextType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_exchanged_document_context(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ExchangedDocument(None);
                            event
                        }
                    }
                    (S::ExchangedDocument(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RSM),
                            b"ExchangedDocument",
                        ) {
                            let output = < super :: ExchangedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_exchanged_document(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SupplyChainTradeTransaction(None);
                            event
                        }
                    }
                    (
                        S::SupplyChainTradeTransaction(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RSM),
                            b"SupplyChainTradeTransaction",
                        ) {
                            let output = < super :: SupplyChainTradeTransactionType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_supply_chain_trade_transaction(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CrossIndustryInvoiceType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CrossIndustryInvoiceTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CrossIndustryInvoiceType {
                exchanged_document_context: self
                    .exchanged_document_context
                    .ok_or_else(|| ErrorKind::MissingElement("ExchangedDocumentContext".into()))?,
                exchanged_document: self
                    .exchanged_document
                    .ok_or_else(|| ErrorKind::MissingElement("ExchangedDocument".into()))?,
                supply_chain_trade_transaction: self.supply_chain_trade_transaction.ok_or_else(
                    || ErrorKind::MissingElement("SupplyChainTradeTransaction".into()),
                )?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ExchangedDocumentContextTypeDeserializer {
        test_indicator: Option<super::IndicatorType>,
        business_process_specified_document_context_parameter:
            Option<super::DocumentContextParameterType>,
        guideline_specified_document_context_parameter: Option<super::DocumentContextParameterType>,
        state: Box<ExchangedDocumentContextTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ExchangedDocumentContextTypeDeserializerState {
        Init__,
        TestIndicator(Option<<super::IndicatorType as WithDeserializer>::Deserializer>),
        BusinessProcessSpecifiedDocumentContextParameter(
            Option<<super::DocumentContextParameterType as WithDeserializer>::Deserializer>,
        ),
        GuidelineSpecifiedDocumentContextParameter(
            Option<<super::DocumentContextParameterType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl ExchangedDocumentContextTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                test_indicator: None,
                business_process_specified_document_context_parameter: None,
                guideline_specified_document_context_parameter: None,
                state: Box::new(ExchangedDocumentContextTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ExchangedDocumentContextTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ExchangedDocumentContextTypeDeserializerState as S;
            match state {
                S::TestIndicator(Some(deserializer)) => {
                    self.store_test_indicator(deserializer.finish(reader)?)?
                }
                S::BusinessProcessSpecifiedDocumentContextParameter(Some(deserializer)) => self
                    .store_business_process_specified_document_context_parameter(
                        deserializer.finish(reader)?,
                    )?,
                S::GuidelineSpecifiedDocumentContextParameter(Some(deserializer)) => self
                    .store_guideline_specified_document_context_parameter(
                        deserializer.finish(reader)?,
                    )?,
                _ => (),
            }
            Ok(())
        }
        fn store_test_indicator(&mut self, value: super::IndicatorType) -> Result<(), Error> {
            if self.test_indicator.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TestIndicator",
                )))?;
            }
            self.test_indicator = Some(value);
            Ok(())
        }
        fn store_business_process_specified_document_context_parameter(
            &mut self,
            value: super::DocumentContextParameterType,
        ) -> Result<(), Error> {
            if self
                .business_process_specified_document_context_parameter
                .is_some()
            {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BusinessProcessSpecifiedDocumentContextParameter",
                )))?;
            }
            self.business_process_specified_document_context_parameter = Some(value);
            Ok(())
        }
        fn store_guideline_specified_document_context_parameter(
            &mut self,
            value: super::DocumentContextParameterType,
        ) -> Result<(), Error> {
            if self
                .guideline_specified_document_context_parameter
                .is_some()
            {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GuidelineSpecifiedDocumentContextParameter",
                )))?;
            }
            self.guideline_specified_document_context_parameter = Some(value);
            Ok(())
        }
        fn handle_test_indicator<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IndicatorType>,
            fallback: &mut Option<ExchangedDocumentContextTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ExchangedDocumentContextTypeDeserializerState::TestIndicator(None),
                );
                * self . state = ExchangedDocumentContextTypeDeserializerState :: BusinessProcessSpecifiedDocumentContextParameter (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_test_indicator(data)?;
                    * self . state = ExchangedDocumentContextTypeDeserializerState :: BusinessProcessSpecifiedDocumentContextParameter (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ExchangedDocumentContextTypeDeserializerState::TestIndicator(Some(
                                    deserializer,
                                )),
                            );
                            * self . state = ExchangedDocumentContextTypeDeserializerState :: BusinessProcessSpecifiedDocumentContextParameter (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ExchangedDocumentContextTypeDeserializerState::TestIndicator(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_business_process_specified_document_context_parameter<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentContextParameterType>,
            fallback: &mut Option<ExchangedDocumentContextTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (ExchangedDocumentContextTypeDeserializerState :: BusinessProcessSpecifiedDocumentContextParameter (None)) ;
                * self . state = ExchangedDocumentContextTypeDeserializerState :: GuidelineSpecifiedDocumentContextParameter (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_business_process_specified_document_context_parameter(data)?;
                    * self . state = ExchangedDocumentContextTypeDeserializerState :: GuidelineSpecifiedDocumentContextParameter (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ExchangedDocumentContextTypeDeserializerState :: BusinessProcessSpecifiedDocumentContextParameter (Some (deserializer))) ;
                            * self . state = ExchangedDocumentContextTypeDeserializerState :: GuidelineSpecifiedDocumentContextParameter (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ExchangedDocumentContextTypeDeserializerState :: BusinessProcessSpecifiedDocumentContextParameter (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_guideline_specified_document_context_parameter<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentContextParameterType>,
            fallback: &mut Option<ExchangedDocumentContextTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self
                    .guideline_specified_document_context_parameter
                    .is_some()
                {
                    fallback . get_or_insert (ExchangedDocumentContextTypeDeserializerState :: GuidelineSpecifiedDocumentContextParameter (None)) ;
                    *self.state = ExchangedDocumentContextTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = ExchangedDocumentContextTypeDeserializerState :: GuidelineSpecifiedDocumentContextParameter (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_guideline_specified_document_context_parameter(data)?;
                    *self.state = ExchangedDocumentContextTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ExchangedDocumentContextTypeDeserializerState :: GuidelineSpecifiedDocumentContextParameter (Some (deserializer))) ;
                            *self.state = ExchangedDocumentContextTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ExchangedDocumentContextTypeDeserializerState :: GuidelineSpecifiedDocumentContextParameter (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ExchangedDocumentContextType>
        for ExchangedDocumentContextTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ExchangedDocumentContextType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ExchangedDocumentContextType>
        where
            R: DeserializeReader,
        {
            use ExchangedDocumentContextTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TestIndicator(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_test_indicator(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (
                        S::BusinessProcessSpecifiedDocumentContextParameter(Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_business_process_specified_document_context_parameter(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::GuidelineSpecifiedDocumentContextParameter(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_guideline_specified_document_context_parameter(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ExchangedDocumentContextTypeDeserializerState::TestIndicator(None);
                        event
                    }
                    (S::TestIndicator(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TestIndicator",
                        ) {
                            let output =
                                <super::IndicatorType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_test_indicator(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BusinessProcessSpecifiedDocumentContextParameter(None);
                            event
                        }
                    }
                    (
                        S::BusinessProcessSpecifiedDocumentContextParameter(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BusinessProcessSpecifiedDocumentContextParameter",
                        ) {
                            let output = < super :: DocumentContextParameterType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self
                                .handle_business_process_specified_document_context_parameter(
                                    reader,
                                    output,
                                    &mut fallback,
                                )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::GuidelineSpecifiedDocumentContextParameter(None);
                            event
                        }
                    }
                    (
                        S::GuidelineSpecifiedDocumentContextParameter(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"GuidelineSpecifiedDocumentContextParameter",
                        ) {
                            let output = < super :: DocumentContextParameterType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_guideline_specified_document_context_parameter(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ExchangedDocumentContextType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ExchangedDocumentContextTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ExchangedDocumentContextType {
                test_indicator: self.test_indicator,
                business_process_specified_document_context_parameter: self
                    .business_process_specified_document_context_parameter,
                guideline_specified_document_context_parameter: self
                    .guideline_specified_document_context_parameter
                    .ok_or_else(|| {
                        ErrorKind::MissingElement(
                            "GuidelineSpecifiedDocumentContextParameter".into(),
                        )
                    })?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ExchangedDocumentTypeDeserializer {
        id: Option<super::IdType>,
        name: Option<super::TextType>,
        type_code: Option<super::DocumentCodeType>,
        issue_date_time: Option<super::DateTimeType>,
        copy_indicator: Option<super::IndicatorType>,
        language_id: Option<super::IdType>,
        included_note: Vec<super::NoteType>,
        effective_specified_period: Option<super::SpecifiedPeriodType>,
        state: Box<ExchangedDocumentTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ExchangedDocumentTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Name(Option<<super::TextType as WithDeserializer>::Deserializer>),
        TypeCode(Option<<super::DocumentCodeType as WithDeserializer>::Deserializer>),
        IssueDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        CopyIndicator(Option<<super::IndicatorType as WithDeserializer>::Deserializer>),
        LanguageId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        IncludedNote(Option<<super::NoteType as WithDeserializer>::Deserializer>),
        EffectiveSpecifiedPeriod(
            Option<<super::SpecifiedPeriodType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl ExchangedDocumentTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                name: None,
                type_code: None,
                issue_date_time: None,
                copy_indicator: None,
                language_id: None,
                included_note: Vec::new(),
                effective_specified_period: None,
                state: Box::new(ExchangedDocumentTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ExchangedDocumentTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ExchangedDocumentTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                S::Name(Some(deserializer)) => self.store_name(deserializer.finish(reader)?)?,
                S::TypeCode(Some(deserializer)) => {
                    self.store_type_code(deserializer.finish(reader)?)?
                }
                S::IssueDateTime(Some(deserializer)) => {
                    self.store_issue_date_time(deserializer.finish(reader)?)?
                }
                S::CopyIndicator(Some(deserializer)) => {
                    self.store_copy_indicator(deserializer.finish(reader)?)?
                }
                S::LanguageId(Some(deserializer)) => {
                    self.store_language_id(deserializer.finish(reader)?)?
                }
                S::IncludedNote(Some(deserializer)) => {
                    self.store_included_note(deserializer.finish(reader)?)?
                }
                S::EffectiveSpecifiedPeriod(Some(deserializer)) => {
                    self.store_effective_specified_period(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn store_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Name")))?;
            }
            self.name = Some(value);
            Ok(())
        }
        fn store_type_code(&mut self, value: super::DocumentCodeType) -> Result<(), Error> {
            if self.type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TypeCode",
                )))?;
            }
            self.type_code = Some(value);
            Ok(())
        }
        fn store_issue_date_time(&mut self, value: super::DateTimeType) -> Result<(), Error> {
            if self.issue_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"IssueDateTime",
                )))?;
            }
            self.issue_date_time = Some(value);
            Ok(())
        }
        fn store_copy_indicator(&mut self, value: super::IndicatorType) -> Result<(), Error> {
            if self.copy_indicator.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CopyIndicator",
                )))?;
            }
            self.copy_indicator = Some(value);
            Ok(())
        }
        fn store_language_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.language_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LanguageID",
                )))?;
            }
            self.language_id = Some(value);
            Ok(())
        }
        fn store_included_note(&mut self, value: super::NoteType) -> Result<(), Error> {
            self.included_note.push(value);
            Ok(())
        }
        fn store_effective_specified_period(
            &mut self,
            value: super::SpecifiedPeriodType,
        ) -> Result<(), Error> {
            if self.effective_specified_period.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"EffectiveSpecifiedPeriod",
                )))?;
            }
            self.effective_specified_period = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ExchangedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.id.is_some() {
                    fallback.get_or_insert(ExchangedDocumentTypeDeserializerState::Id(None));
                    *self.state = ExchangedDocumentTypeDeserializerState::Name(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ExchangedDocumentTypeDeserializerState::Id(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = ExchangedDocumentTypeDeserializerState::Name(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ExchangedDocumentTypeDeserializerState::Id(
                                Some(deserializer),
                            ));
                            *self.state = ExchangedDocumentTypeDeserializerState::Name(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ExchangedDocumentTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<ExchangedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ExchangedDocumentTypeDeserializerState::Name(None));
                *self.state = ExchangedDocumentTypeDeserializerState::TypeCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_name(data)?;
                    *self.state = ExchangedDocumentTypeDeserializerState::TypeCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ExchangedDocumentTypeDeserializerState::Name(
                                Some(deserializer),
                            ));
                            *self.state = ExchangedDocumentTypeDeserializerState::TypeCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ExchangedDocumentTypeDeserializerState::Name(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentCodeType>,
            fallback: &mut Option<ExchangedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.type_code.is_some() {
                    fallback.get_or_insert(ExchangedDocumentTypeDeserializerState::TypeCode(None));
                    *self.state = ExchangedDocumentTypeDeserializerState::IssueDateTime(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ExchangedDocumentTypeDeserializerState::TypeCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_type_code(data)?;
                    *self.state = ExchangedDocumentTypeDeserializerState::IssueDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ExchangedDocumentTypeDeserializerState::TypeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ExchangedDocumentTypeDeserializerState::IssueDateTime(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ExchangedDocumentTypeDeserializerState::TypeCode(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_issue_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<ExchangedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.issue_date_time.is_some() {
                    fallback
                        .get_or_insert(ExchangedDocumentTypeDeserializerState::IssueDateTime(None));
                    *self.state = ExchangedDocumentTypeDeserializerState::CopyIndicator(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ExchangedDocumentTypeDeserializerState::IssueDateTime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_issue_date_time(data)?;
                    *self.state = ExchangedDocumentTypeDeserializerState::CopyIndicator(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ExchangedDocumentTypeDeserializerState::IssueDateTime(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ExchangedDocumentTypeDeserializerState::CopyIndicator(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ExchangedDocumentTypeDeserializerState::IssueDateTime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_copy_indicator<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IndicatorType>,
            fallback: &mut Option<ExchangedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ExchangedDocumentTypeDeserializerState::CopyIndicator(None));
                *self.state = ExchangedDocumentTypeDeserializerState::LanguageId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_copy_indicator(data)?;
                    *self.state = ExchangedDocumentTypeDeserializerState::LanguageId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ExchangedDocumentTypeDeserializerState::CopyIndicator(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ExchangedDocumentTypeDeserializerState::LanguageId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ExchangedDocumentTypeDeserializerState::CopyIndicator(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_language_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ExchangedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ExchangedDocumentTypeDeserializerState::LanguageId(None));
                *self.state = ExchangedDocumentTypeDeserializerState::IncludedNote(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_language_id(data)?;
                    *self.state = ExchangedDocumentTypeDeserializerState::IncludedNote(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ExchangedDocumentTypeDeserializerState::LanguageId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ExchangedDocumentTypeDeserializerState::IncludedNote(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ExchangedDocumentTypeDeserializerState::LanguageId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_included_note<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::NoteType>,
            fallback: &mut Option<ExchangedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ExchangedDocumentTypeDeserializerState::IncludedNote(None));
                *self.state =
                    ExchangedDocumentTypeDeserializerState::EffectiveSpecifiedPeriod(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_included_note(data)?;
                    *self.state = ExchangedDocumentTypeDeserializerState::IncludedNote(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ExchangedDocumentTypeDeserializerState::IncludedNote(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ExchangedDocumentTypeDeserializerState::IncludedNote(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ExchangedDocumentTypeDeserializerState::IncludedNote(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_effective_specified_period<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SpecifiedPeriodType>,
            fallback: &mut Option<ExchangedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ExchangedDocumentTypeDeserializerState::EffectiveSpecifiedPeriod(None),
                );
                *self.state = ExchangedDocumentTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_effective_specified_period(data)?;
                    *self.state = ExchangedDocumentTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ExchangedDocumentTypeDeserializerState::EffectiveSpecifiedPeriod(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = ExchangedDocumentTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ExchangedDocumentTypeDeserializerState::EffectiveSpecifiedPeriod(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ExchangedDocumentType> for ExchangedDocumentTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ExchangedDocumentType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ExchangedDocumentType>
        where
            R: DeserializeReader,
        {
            use ExchangedDocumentTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Name(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IssueDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_issue_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CopyIndicator(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_copy_indicator(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LanguageId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_language_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IncludedNote(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_included_note(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::EffectiveSpecifiedPeriod(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_effective_specified_period(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ExchangedDocumentTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Name(None);
                            event
                        }
                    }
                    (S::Name(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Name") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TypeCode(None);
                            event
                        }
                    }
                    (S::TypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"TypeCode") {
                            let output =
                                <super::DocumentCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IssueDateTime(None);
                            event
                        }
                    }
                    (S::IssueDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IssueDateTime",
                        ) {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_issue_date_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CopyIndicator(None);
                            event
                        }
                    }
                    (S::CopyIndicator(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CopyIndicator",
                        ) {
                            let output =
                                <super::IndicatorType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_copy_indicator(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LanguageId(None);
                            event
                        }
                    }
                    (S::LanguageId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"LanguageID")
                        {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_language_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IncludedNote(None);
                            event
                        }
                    }
                    (S::IncludedNote(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IncludedNote",
                        ) {
                            let output = <super::NoteType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_included_note(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::EffectiveSpecifiedPeriod(None);
                            event
                        }
                    }
                    (
                        S::EffectiveSpecifiedPeriod(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"EffectiveSpecifiedPeriod",
                        ) {
                            let output = < super :: SpecifiedPeriodType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_effective_specified_period(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ExchangedDocumentType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ExchangedDocumentTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ExchangedDocumentType {
                id: self
                    .id
                    .ok_or_else(|| ErrorKind::MissingElement("ID".into()))?,
                name: self.name,
                type_code: self
                    .type_code
                    .ok_or_else(|| ErrorKind::MissingElement("TypeCode".into()))?,
                issue_date_time: self
                    .issue_date_time
                    .ok_or_else(|| ErrorKind::MissingElement("IssueDateTime".into()))?,
                copy_indicator: self.copy_indicator,
                language_id: self.language_id,
                included_note: self.included_note,
                effective_specified_period: self.effective_specified_period,
            })
        }
    }
    #[derive(Debug)]
    pub struct SupplyChainTradeTransactionTypeDeserializer {
        included_supply_chain_trade_line_item: Vec<super::SupplyChainTradeLineItemType>,
        applicable_header_trade_agreement: Option<super::HeaderTradeAgreementType>,
        applicable_header_trade_delivery: Option<super::HeaderTradeDeliveryType>,
        applicable_header_trade_settlement: Option<super::HeaderTradeSettlementType>,
        state: Box<SupplyChainTradeTransactionTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplyChainTradeTransactionTypeDeserializerState {
        Init__,
        IncludedSupplyChainTradeLineItem(
            Option<<super::SupplyChainTradeLineItemType as WithDeserializer>::Deserializer>,
        ),
        ApplicableHeaderTradeAgreement(
            Option<<super::HeaderTradeAgreementType as WithDeserializer>::Deserializer>,
        ),
        ApplicableHeaderTradeDelivery(
            Option<<super::HeaderTradeDeliveryType as WithDeserializer>::Deserializer>,
        ),
        ApplicableHeaderTradeSettlement(
            Option<<super::HeaderTradeSettlementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl SupplyChainTradeTransactionTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                included_supply_chain_trade_line_item: Vec::new(),
                applicable_header_trade_agreement: None,
                applicable_header_trade_delivery: None,
                applicable_header_trade_settlement: None,
                state: Box::new(SupplyChainTradeTransactionTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplyChainTradeTransactionTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SupplyChainTradeTransactionTypeDeserializerState as S;
            match state {
                S::IncludedSupplyChainTradeLineItem(Some(deserializer)) => {
                    self.store_included_supply_chain_trade_line_item(deserializer.finish(reader)?)?
                }
                S::ApplicableHeaderTradeAgreement(Some(deserializer)) => {
                    self.store_applicable_header_trade_agreement(deserializer.finish(reader)?)?
                }
                S::ApplicableHeaderTradeDelivery(Some(deserializer)) => {
                    self.store_applicable_header_trade_delivery(deserializer.finish(reader)?)?
                }
                S::ApplicableHeaderTradeSettlement(Some(deserializer)) => {
                    self.store_applicable_header_trade_settlement(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_included_supply_chain_trade_line_item(
            &mut self,
            value: super::SupplyChainTradeLineItemType,
        ) -> Result<(), Error> {
            self.included_supply_chain_trade_line_item.push(value);
            Ok(())
        }
        fn store_applicable_header_trade_agreement(
            &mut self,
            value: super::HeaderTradeAgreementType,
        ) -> Result<(), Error> {
            if self.applicable_header_trade_agreement.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ApplicableHeaderTradeAgreement",
                )))?;
            }
            self.applicable_header_trade_agreement = Some(value);
            Ok(())
        }
        fn store_applicable_header_trade_delivery(
            &mut self,
            value: super::HeaderTradeDeliveryType,
        ) -> Result<(), Error> {
            if self.applicable_header_trade_delivery.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ApplicableHeaderTradeDelivery",
                )))?;
            }
            self.applicable_header_trade_delivery = Some(value);
            Ok(())
        }
        fn store_applicable_header_trade_settlement(
            &mut self,
            value: super::HeaderTradeSettlementType,
        ) -> Result<(), Error> {
            if self.applicable_header_trade_settlement.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ApplicableHeaderTradeSettlement",
                )))?;
            }
            self.applicable_header_trade_settlement = Some(value);
            Ok(())
        }
        fn handle_included_supply_chain_trade_line_item<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplyChainTradeLineItemType>,
            fallback: &mut Option<SupplyChainTradeTransactionTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.included_supply_chain_trade_line_item.len() < 1usize {
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: IncludedSupplyChainTradeLineItem (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback . get_or_insert (SupplyChainTradeTransactionTypeDeserializerState :: IncludedSupplyChainTradeLineItem (None)) ;
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeAgreement (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_included_supply_chain_trade_line_item(data)?;
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: IncludedSupplyChainTradeLineItem (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeTransactionTypeDeserializerState :: IncludedSupplyChainTradeLineItem (Some (deserializer))) ;
                            if self
                                .included_supply_chain_trade_line_item
                                .len()
                                .saturating_add(1)
                                < 1usize
                            {
                                * self . state = SupplyChainTradeTransactionTypeDeserializerState :: IncludedSupplyChainTradeLineItem (None) ;
                            } else {
                                * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeAgreement (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeTransactionTypeDeserializerState :: IncludedSupplyChainTradeLineItem (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_header_trade_agreement<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::HeaderTradeAgreementType>,
            fallback: &mut Option<SupplyChainTradeTransactionTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.applicable_header_trade_agreement.is_some() {
                    fallback . get_or_insert (SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeAgreement (None)) ;
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeDelivery (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeAgreement (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_header_trade_agreement(data)?;
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeDelivery (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeAgreement (Some (deserializer))) ;
                            * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeDelivery (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeAgreement (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_header_trade_delivery<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::HeaderTradeDeliveryType>,
            fallback: &mut Option<SupplyChainTradeTransactionTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.applicable_header_trade_delivery.is_some() {
                    fallback . get_or_insert (SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeDelivery (None)) ;
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeSettlement (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeDelivery (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_header_trade_delivery(data)?;
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeSettlement (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeDelivery (Some (deserializer))) ;
                            * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeSettlement (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeDelivery (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_header_trade_settlement<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::HeaderTradeSettlementType>,
            fallback: &mut Option<SupplyChainTradeTransactionTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.applicable_header_trade_settlement.is_some() {
                    fallback . get_or_insert (SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeSettlement (None)) ;
                    *self.state = SupplyChainTradeTransactionTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeSettlement (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_header_trade_settlement(data)?;
                    *self.state = SupplyChainTradeTransactionTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeSettlement (Some (deserializer))) ;
                            *self.state = SupplyChainTradeTransactionTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeTransactionTypeDeserializerState :: ApplicableHeaderTradeSettlement (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SupplyChainTradeTransactionType>
        for SupplyChainTradeTransactionTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplyChainTradeTransactionType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplyChainTradeTransactionType>
        where
            R: DeserializeReader,
        {
            use SupplyChainTradeTransactionTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::IncludedSupplyChainTradeLineItem(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_included_supply_chain_trade_line_item(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableHeaderTradeAgreement(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_header_trade_agreement(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableHeaderTradeDelivery(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_header_trade_delivery(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableHeaderTradeSettlement(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_header_trade_settlement(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = SupplyChainTradeTransactionTypeDeserializerState :: IncludedSupplyChainTradeLineItem (None) ;
                        event
                    }
                    (
                        S::IncludedSupplyChainTradeLineItem(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IncludedSupplyChainTradeLineItem",
                        ) {
                            let output = < super :: SupplyChainTradeLineItemType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_included_supply_chain_trade_line_item(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableHeaderTradeAgreement(None);
                            event
                        }
                    }
                    (
                        S::ApplicableHeaderTradeAgreement(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableHeaderTradeAgreement",
                        ) {
                            let output = < super :: HeaderTradeAgreementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applicable_header_trade_agreement(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableHeaderTradeDelivery(None);
                            event
                        }
                    }
                    (
                        S::ApplicableHeaderTradeDelivery(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableHeaderTradeDelivery",
                        ) {
                            let output = < super :: HeaderTradeDeliveryType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applicable_header_trade_delivery(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableHeaderTradeSettlement(None);
                            event
                        }
                    }
                    (
                        S::ApplicableHeaderTradeSettlement(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableHeaderTradeSettlement",
                        ) {
                            let output = < super :: HeaderTradeSettlementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applicable_header_trade_settlement(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplyChainTradeTransactionType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplyChainTradeTransactionTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplyChainTradeTransactionType {
                included_supply_chain_trade_line_item: self.included_supply_chain_trade_line_item,
                applicable_header_trade_agreement: self
                    .applicable_header_trade_agreement
                    .ok_or_else(|| {
                        ErrorKind::MissingElement("ApplicableHeaderTradeAgreement".into())
                    })?,
                applicable_header_trade_delivery: self
                    .applicable_header_trade_delivery
                    .ok_or_else(|| {
                        ErrorKind::MissingElement("ApplicableHeaderTradeDelivery".into())
                    })?,
                applicable_header_trade_settlement: self
                    .applicable_header_trade_settlement
                    .ok_or_else(|| {
                        ErrorKind::MissingElement("ApplicableHeaderTradeSettlement".into())
                    })?,
            })
        }
    }
    #[derive(Debug)]
    pub struct IndicatorTypeDeserializer {
        content: Option<super::IndicatorTypeContent>,
        state: Box<IndicatorTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum IndicatorTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::IndicatorTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl IndicatorTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(IndicatorTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: IndicatorTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let IndicatorTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::IndicatorTypeContent) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IndicatorTypeContent>,
            fallback: &mut Option<IndicatorTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(IndicatorTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = IndicatorTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = IndicatorTypeDeserializerState::Content__(deserializer);
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::IndicatorType> for IndicatorTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::IndicatorType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::IndicatorType>
        where
            R: DeserializeReader,
        {
            use IndicatorTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output =
                            <super::IndicatorTypeContent as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::IndicatorType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, IndicatorTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::IndicatorType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct IndicatorTypeContentDeserializer {
        state: Box<IndicatorTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum IndicatorTypeContentDeserializerState {
        Init__,
        Indicator(
            Option<bool>,
            Option<<bool as WithDeserializer>::Deserializer>,
        ),
        Done__(super::IndicatorTypeContent),
        Unknown__,
    }
    impl IndicatorTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<IndicatorTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(IndicatorTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_UDT),
                Some(b"Indicator")
            ) {
                let output = <bool as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_indicator(reader, Default::default(), output, &mut *fallback);
            }
            *self.state = fallback
                .take()
                .unwrap_or(IndicatorTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: IndicatorTypeContentDeserializerState,
        ) -> Result<super::IndicatorTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use IndicatorTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Indicator(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_indicator(&mut values, value)?;
                    }
                    Ok(super::IndicatorTypeContent::Indicator(values.ok_or_else(
                        || ErrorKind::MissingElement("Indicator".into()),
                    )?))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_indicator(values: &mut Option<bool>, value: bool) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Indicator",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_indicator<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<bool>,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<IndicatorTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => IndicatorTypeContentDeserializerState::Indicator(values, None),
                    Some(IndicatorTypeContentDeserializerState::Indicator(
                        _,
                        Some(deserializer),
                    )) => {
                        IndicatorTypeContentDeserializerState::Indicator(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(IndicatorTypeContentDeserializerState::Indicator(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_indicator(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_indicator(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        IndicatorTypeContentDeserializerState::Indicator(values, None),
                    )?;
                    *self.state = IndicatorTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = IndicatorTypeContentDeserializerState::Indicator(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::IndicatorTypeContent> for IndicatorTypeContentDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::IndicatorTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(IndicatorTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, IndicatorTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::IndicatorTypeContent>
        where
            R: DeserializeReader,
        {
            use IndicatorTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Indicator(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_indicator(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Indicator(values, None), event) => {
                        let output = <bool as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_indicator(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::IndicatorTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct DocumentContextParameterTypeDeserializer {
        id: Option<super::IdType>,
        state: Box<DocumentContextParameterTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentContextParameterTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DocumentContextParameterTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                state: Box::new(DocumentContextParameterTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentContextParameterTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocumentContextParameterTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<DocumentContextParameterTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.id.is_some() {
                    fallback.get_or_insert(DocumentContextParameterTypeDeserializerState::Id(None));
                    *self.state = DocumentContextParameterTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DocumentContextParameterTypeDeserializerState::Id(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = DocumentContextParameterTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentContextParameterTypeDeserializerState::Id(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentContextParameterTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentContextParameterTypeDeserializerState::Id(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocumentContextParameterType>
        for DocumentContextParameterTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentContextParameterType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentContextParameterType>
        where
            R: DeserializeReader,
        {
            use DocumentContextParameterTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = DocumentContextParameterTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentContextParameterType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentContextParameterTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentContextParameterType {
                id: self
                    .id
                    .ok_or_else(|| ErrorKind::MissingElement("ID".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct IdTypeDeserializer {
        scheme_id: Option<String>,
        content: Option<String>,
        state: Box<IdTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum IdTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl IdTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut scheme_id: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"schemeID")
                ) {
                    reader.read_attrib(&mut scheme_id, b"schemeID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                scheme_id: scheme_id,
                content: None,
                state: Box::new(IdTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: IdTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let IdTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::IdType>
        where
            R: DeserializeReader,
        {
            use IdTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::IdType> for IdTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::IdType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::IdType>
        where
            R: DeserializeReader,
        {
            use IdTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::IdType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, IdTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::IdType {
                scheme_id: self.scheme_id,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TextTypeDeserializer {
        content: Option<String>,
        state: Box<TextTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TextTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl TextTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(TextTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TextTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let TextTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::TextType>
        where
            R: DeserializeReader,
        {
            use TextTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::TextType> for TextTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TextType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TextType>
        where
            R: DeserializeReader,
        {
            use TextTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TextType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, TextTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::TextType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocumentCodeTypeDeserializer {
        content: Option<String>,
        state: Box<DocumentCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DocumentCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(DocumentCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DocumentCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::DocumentCodeType>
        where
            R: DeserializeReader,
        {
            use DocumentCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::DocumentCodeType> for DocumentCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentCodeType>
        where
            R: DeserializeReader,
        {
            use DocumentCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DateTimeTypeDeserializer {
        content: Option<super::DateTimeTypeContent>,
        state: Box<DateTimeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DateTimeTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::DateTimeTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DateTimeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(DateTimeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DateTimeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DateTimeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::DateTimeTypeContent) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeTypeContent>,
            fallback: &mut Option<DateTimeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(DateTimeTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = DateTimeTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = DateTimeTypeDeserializerState::Content__(deserializer);
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DateTimeType> for DateTimeTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::DateTimeType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateTimeType>
        where
            R: DeserializeReader,
        {
            use DateTimeTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output =
                            <super::DateTimeTypeContent as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DateTimeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, DateTimeTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::DateTimeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DateTimeTypeContentDeserializer {
        state: Box<DateTimeTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum DateTimeTypeContentDeserializerState {
        Init__,
        DateTimeString(
            Option<super::DateTimeTypeDateTimeStringType>,
            Option<<super::DateTimeTypeDateTimeStringType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::DateTimeTypeContent),
        Unknown__,
    }
    impl DateTimeTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<DateTimeTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(DateTimeTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_UDT),
                Some(b"DateTimeString")
            ) {
                let output = < super :: DateTimeTypeDateTimeStringType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                return self.handle_date_time_string(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(DateTimeTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: DateTimeTypeContentDeserializerState,
        ) -> Result<super::DateTimeTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use DateTimeTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::DateTimeString(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_date_time_string(&mut values, value)?;
                    }
                    Ok(super::DateTimeTypeContent::DateTimeString(
                        values.ok_or_else(|| ErrorKind::MissingElement("DateTimeString".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_date_time_string(
            values: &mut Option<super::DateTimeTypeDateTimeStringType>,
            value: super::DateTimeTypeDateTimeStringType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DateTimeString",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_date_time_string<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::DateTimeTypeDateTimeStringType>,
            output: DeserializerOutput<'de, super::DateTimeTypeDateTimeStringType>,
            fallback: &mut Option<DateTimeTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => DateTimeTypeContentDeserializerState::DateTimeString(values, None),
                    Some(DateTimeTypeContentDeserializerState::DateTimeString(
                        _,
                        Some(deserializer),
                    )) => DateTimeTypeContentDeserializerState::DateTimeString(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(DateTimeTypeContentDeserializerState::DateTimeString(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_date_time_string(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_date_time_string(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        DateTimeTypeContentDeserializerState::DateTimeString(values, None),
                    )?;
                    *self.state = DateTimeTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = DateTimeTypeContentDeserializerState::DateTimeString(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DateTimeTypeContent> for DateTimeTypeContentDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateTimeTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(DateTimeTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, DateTimeTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateTimeTypeContent>
        where
            R: DeserializeReader,
        {
            use DateTimeTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DateTimeString(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_date_time_string(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::DateTimeString(values, None), event) => {
                        let output = < super :: DateTimeTypeDateTimeStringType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_date_time_string(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::DateTimeTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct NoteTypeDeserializer {
        content_code: Option<super::CodeType>,
        content: Option<super::TextType>,
        subject_code: Option<super::CodeType>,
        state: Box<NoteTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum NoteTypeDeserializerState {
        Init__,
        ContentCode(Option<<super::CodeType as WithDeserializer>::Deserializer>),
        Content(Option<<super::TextType as WithDeserializer>::Deserializer>),
        SubjectCode(Option<<super::CodeType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl NoteTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content_code: None,
                content: None,
                subject_code: None,
                state: Box::new(NoteTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: NoteTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use NoteTypeDeserializerState as S;
            match state {
                S::ContentCode(Some(deserializer)) => {
                    self.store_content_code(deserializer.finish(reader)?)?
                }
                S::Content(Some(deserializer)) => {
                    self.store_content(deserializer.finish(reader)?)?
                }
                S::SubjectCode(Some(deserializer)) => {
                    self.store_subject_code(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_content_code(&mut self, value: super::CodeType) -> Result<(), Error> {
            if self.content_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ContentCode",
                )))?;
            }
            self.content_code = Some(value);
            Ok(())
        }
        fn store_content(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Content",
                )))?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn store_subject_code(&mut self, value: super::CodeType) -> Result<(), Error> {
            if self.subject_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SubjectCode",
                )))?;
            }
            self.subject_code = Some(value);
            Ok(())
        }
        fn handle_content_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CodeType>,
            fallback: &mut Option<NoteTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(NoteTypeDeserializerState::ContentCode(None));
                *self.state = NoteTypeDeserializerState::Content(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content_code(data)?;
                    *self.state = NoteTypeDeserializerState::Content(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(NoteTypeDeserializerState::ContentCode(Some(
                                deserializer,
                            )));
                            *self.state = NoteTypeDeserializerState::Content(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                NoteTypeDeserializerState::ContentCode(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<NoteTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(NoteTypeDeserializerState::Content(None));
                *self.state = NoteTypeDeserializerState::SubjectCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = NoteTypeDeserializerState::SubjectCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(NoteTypeDeserializerState::Content(Some(
                                deserializer,
                            )));
                            *self.state = NoteTypeDeserializerState::SubjectCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = NoteTypeDeserializerState::Content(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_subject_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CodeType>,
            fallback: &mut Option<NoteTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(NoteTypeDeserializerState::SubjectCode(None));
                *self.state = NoteTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_subject_code(data)?;
                    *self.state = NoteTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(NoteTypeDeserializerState::SubjectCode(Some(
                                deserializer,
                            )));
                            *self.state = NoteTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                NoteTypeDeserializerState::SubjectCode(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::NoteType> for NoteTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::NoteType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::NoteType>
        where
            R: DeserializeReader,
        {
            use NoteTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ContentCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Content(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SubjectCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_subject_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = NoteTypeDeserializerState::ContentCode(None);
                        event
                    }
                    (S::ContentCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ContentCode")
                        {
                            let output = <super::CodeType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_content_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Content(None);
                            event
                        }
                    }
                    (S::Content(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Content") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SubjectCode(None);
                            event
                        }
                    }
                    (S::SubjectCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"SubjectCode")
                        {
                            let output = <super::CodeType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_subject_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::NoteType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, NoteTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::NoteType {
                content_code: self.content_code,
                content: self.content,
                subject_code: self.subject_code,
            })
        }
    }
    #[derive(Debug)]
    pub struct SpecifiedPeriodTypeDeserializer {
        description: Option<super::TextType>,
        start_date_time: Option<super::DateTimeType>,
        end_date_time: Option<super::DateTimeType>,
        complete_date_time: Option<super::DateTimeType>,
        state: Box<SpecifiedPeriodTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SpecifiedPeriodTypeDeserializerState {
        Init__,
        Description(Option<<super::TextType as WithDeserializer>::Deserializer>),
        StartDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        EndDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        CompleteDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SpecifiedPeriodTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                description: None,
                start_date_time: None,
                end_date_time: None,
                complete_date_time: None,
                state: Box::new(SpecifiedPeriodTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SpecifiedPeriodTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SpecifiedPeriodTypeDeserializerState as S;
            match state {
                S::Description(Some(deserializer)) => {
                    self.store_description(deserializer.finish(reader)?)?
                }
                S::StartDateTime(Some(deserializer)) => {
                    self.store_start_date_time(deserializer.finish(reader)?)?
                }
                S::EndDateTime(Some(deserializer)) => {
                    self.store_end_date_time(deserializer.finish(reader)?)?
                }
                S::CompleteDateTime(Some(deserializer)) => {
                    self.store_complete_date_time(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_description(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.description.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Description",
                )))?;
            }
            self.description = Some(value);
            Ok(())
        }
        fn store_start_date_time(&mut self, value: super::DateTimeType) -> Result<(), Error> {
            if self.start_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"StartDateTime",
                )))?;
            }
            self.start_date_time = Some(value);
            Ok(())
        }
        fn store_end_date_time(&mut self, value: super::DateTimeType) -> Result<(), Error> {
            if self.end_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"EndDateTime",
                )))?;
            }
            self.end_date_time = Some(value);
            Ok(())
        }
        fn store_complete_date_time(&mut self, value: super::DateTimeType) -> Result<(), Error> {
            if self.complete_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompleteDateTime",
                )))?;
            }
            self.complete_date_time = Some(value);
            Ok(())
        }
        fn handle_description<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<SpecifiedPeriodTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SpecifiedPeriodTypeDeserializerState::Description(None));
                *self.state = SpecifiedPeriodTypeDeserializerState::StartDateTime(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description(data)?;
                    *self.state = SpecifiedPeriodTypeDeserializerState::StartDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SpecifiedPeriodTypeDeserializerState::Description(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SpecifiedPeriodTypeDeserializerState::StartDateTime(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SpecifiedPeriodTypeDeserializerState::Description(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_start_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<SpecifiedPeriodTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SpecifiedPeriodTypeDeserializerState::StartDateTime(None));
                *self.state = SpecifiedPeriodTypeDeserializerState::EndDateTime(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_start_date_time(data)?;
                    *self.state = SpecifiedPeriodTypeDeserializerState::EndDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SpecifiedPeriodTypeDeserializerState::StartDateTime(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SpecifiedPeriodTypeDeserializerState::EndDateTime(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SpecifiedPeriodTypeDeserializerState::StartDateTime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_end_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<SpecifiedPeriodTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SpecifiedPeriodTypeDeserializerState::EndDateTime(None));
                *self.state = SpecifiedPeriodTypeDeserializerState::CompleteDateTime(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_end_date_time(data)?;
                    *self.state = SpecifiedPeriodTypeDeserializerState::CompleteDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SpecifiedPeriodTypeDeserializerState::EndDateTime(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                SpecifiedPeriodTypeDeserializerState::CompleteDateTime(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SpecifiedPeriodTypeDeserializerState::EndDateTime(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_complete_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<SpecifiedPeriodTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(SpecifiedPeriodTypeDeserializerState::CompleteDateTime(None));
                *self.state = SpecifiedPeriodTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_complete_date_time(data)?;
                    *self.state = SpecifiedPeriodTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SpecifiedPeriodTypeDeserializerState::CompleteDateTime(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SpecifiedPeriodTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SpecifiedPeriodTypeDeserializerState::CompleteDateTime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SpecifiedPeriodType> for SpecifiedPeriodTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SpecifiedPeriodType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SpecifiedPeriodType>
        where
            R: DeserializeReader,
        {
            use SpecifiedPeriodTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Description(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StartDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_start_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::EndDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_end_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CompleteDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_complete_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = SpecifiedPeriodTypeDeserializerState::Description(None);
                        event
                    }
                    (S::Description(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Description")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_description(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::StartDateTime(None);
                            event
                        }
                    }
                    (S::StartDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"StartDateTime",
                        ) {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_start_date_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::EndDateTime(None);
                            event
                        }
                    }
                    (S::EndDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"EndDateTime")
                        {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_end_date_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CompleteDateTime(None);
                            event
                        }
                    }
                    (S::CompleteDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CompleteDateTime",
                        ) {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_complete_date_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SpecifiedPeriodType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SpecifiedPeriodTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SpecifiedPeriodType {
                description: self.description,
                start_date_time: self.start_date_time,
                end_date_time: self.end_date_time,
                complete_date_time: self.complete_date_time,
            })
        }
    }
    #[derive(Debug)]
    pub struct SupplyChainTradeLineItemTypeDeserializer {
        associated_document_line_document: Option<super::DocumentLineDocumentType>,
        specified_trade_product: Option<super::TradeProductType>,
        specified_line_trade_agreement: Option<super::LineTradeAgreementType>,
        specified_line_trade_delivery: Option<super::LineTradeDeliveryType>,
        specified_line_trade_settlement: Option<super::LineTradeSettlementType>,
        state: Box<SupplyChainTradeLineItemTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplyChainTradeLineItemTypeDeserializerState {
        Init__,
        AssociatedDocumentLineDocument(
            Option<<super::DocumentLineDocumentType as WithDeserializer>::Deserializer>,
        ),
        SpecifiedTradeProduct(Option<<super::TradeProductType as WithDeserializer>::Deserializer>),
        SpecifiedLineTradeAgreement(
            Option<<super::LineTradeAgreementType as WithDeserializer>::Deserializer>,
        ),
        SpecifiedLineTradeDelivery(
            Option<<super::LineTradeDeliveryType as WithDeserializer>::Deserializer>,
        ),
        SpecifiedLineTradeSettlement(
            Option<<super::LineTradeSettlementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl SupplyChainTradeLineItemTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                associated_document_line_document: None,
                specified_trade_product: None,
                specified_line_trade_agreement: None,
                specified_line_trade_delivery: None,
                specified_line_trade_settlement: None,
                state: Box::new(SupplyChainTradeLineItemTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplyChainTradeLineItemTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SupplyChainTradeLineItemTypeDeserializerState as S;
            match state {
                S::AssociatedDocumentLineDocument(Some(deserializer)) => {
                    self.store_associated_document_line_document(deserializer.finish(reader)?)?
                }
                S::SpecifiedTradeProduct(Some(deserializer)) => {
                    self.store_specified_trade_product(deserializer.finish(reader)?)?
                }
                S::SpecifiedLineTradeAgreement(Some(deserializer)) => {
                    self.store_specified_line_trade_agreement(deserializer.finish(reader)?)?
                }
                S::SpecifiedLineTradeDelivery(Some(deserializer)) => {
                    self.store_specified_line_trade_delivery(deserializer.finish(reader)?)?
                }
                S::SpecifiedLineTradeSettlement(Some(deserializer)) => {
                    self.store_specified_line_trade_settlement(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_associated_document_line_document(
            &mut self,
            value: super::DocumentLineDocumentType,
        ) -> Result<(), Error> {
            if self.associated_document_line_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AssociatedDocumentLineDocument",
                )))?;
            }
            self.associated_document_line_document = Some(value);
            Ok(())
        }
        fn store_specified_trade_product(
            &mut self,
            value: super::TradeProductType,
        ) -> Result<(), Error> {
            if self.specified_trade_product.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SpecifiedTradeProduct",
                )))?;
            }
            self.specified_trade_product = Some(value);
            Ok(())
        }
        fn store_specified_line_trade_agreement(
            &mut self,
            value: super::LineTradeAgreementType,
        ) -> Result<(), Error> {
            if self.specified_line_trade_agreement.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SpecifiedLineTradeAgreement",
                )))?;
            }
            self.specified_line_trade_agreement = Some(value);
            Ok(())
        }
        fn store_specified_line_trade_delivery(
            &mut self,
            value: super::LineTradeDeliveryType,
        ) -> Result<(), Error> {
            if self.specified_line_trade_delivery.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SpecifiedLineTradeDelivery",
                )))?;
            }
            self.specified_line_trade_delivery = Some(value);
            Ok(())
        }
        fn store_specified_line_trade_settlement(
            &mut self,
            value: super::LineTradeSettlementType,
        ) -> Result<(), Error> {
            if self.specified_line_trade_settlement.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SpecifiedLineTradeSettlement",
                )))?;
            }
            self.specified_line_trade_settlement = Some(value);
            Ok(())
        }
        fn handle_associated_document_line_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentLineDocumentType>,
            fallback: &mut Option<SupplyChainTradeLineItemTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.associated_document_line_document.is_some() {
                    fallback . get_or_insert (SupplyChainTradeLineItemTypeDeserializerState :: AssociatedDocumentLineDocument (None)) ;
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedTradeProduct(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = SupplyChainTradeLineItemTypeDeserializerState :: AssociatedDocumentLineDocument (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_associated_document_line_document(data)?;
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedTradeProduct(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeLineItemTypeDeserializerState :: AssociatedDocumentLineDocument (Some (deserializer))) ;
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedTradeProduct (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: AssociatedDocumentLineDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_trade_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeProductType>,
            fallback: &mut Option<SupplyChainTradeLineItemTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.specified_trade_product.is_some() {
                    fallback.get_or_insert(
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedTradeProduct(None),
                    );
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeAgreement(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedTradeProduct(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_trade_product(data)?;
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeAgreement(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedTradeProduct (Some (deserializer))) ;
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeAgreement (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedTradeProduct (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_line_trade_agreement<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LineTradeAgreementType>,
            fallback: &mut Option<SupplyChainTradeLineItemTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.specified_line_trade_agreement.is_some() {
                    fallback.get_or_insert(
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeAgreement(
                            None,
                        ),
                    );
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeDelivery(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeAgreement(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_line_trade_agreement(data)?;
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeDelivery(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeAgreement (Some (deserializer))) ;
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeDelivery (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeAgreement (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_line_trade_delivery<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LineTradeDeliveryType>,
            fallback: &mut Option<SupplyChainTradeLineItemTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.specified_line_trade_delivery.is_some() {
                    fallback.get_or_insert(
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeDelivery(
                            None,
                        ),
                    );
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeSettlement(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeDelivery(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_line_trade_delivery(data)?;
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeSettlement(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeDelivery (Some (deserializer))) ;
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeSettlement (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeDelivery (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_line_trade_settlement<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LineTradeSettlementType>,
            fallback: &mut Option<SupplyChainTradeLineItemTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.specified_line_trade_settlement.is_some() {
                    fallback.get_or_insert(
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeSettlement(
                            None,
                        ),
                    );
                    *self.state = SupplyChainTradeLineItemTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        SupplyChainTradeLineItemTypeDeserializerState::SpecifiedLineTradeSettlement(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_line_trade_settlement(data)?;
                    *self.state = SupplyChainTradeLineItemTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeSettlement (Some (deserializer))) ;
                            *self.state = SupplyChainTradeLineItemTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainTradeLineItemTypeDeserializerState :: SpecifiedLineTradeSettlement (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SupplyChainTradeLineItemType>
        for SupplyChainTradeLineItemTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplyChainTradeLineItemType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplyChainTradeLineItemType>
        where
            R: DeserializeReader,
        {
            use SupplyChainTradeLineItemTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::AssociatedDocumentLineDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_associated_document_line_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedTradeProduct(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_trade_product(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedLineTradeAgreement(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_line_trade_agreement(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedLineTradeDelivery(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_line_trade_delivery(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedLineTradeSettlement(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_line_trade_settlement(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = SupplyChainTradeLineItemTypeDeserializerState :: AssociatedDocumentLineDocument (None) ;
                        event
                    }
                    (
                        S::AssociatedDocumentLineDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AssociatedDocumentLineDocument",
                        ) {
                            let output = < super :: DocumentLineDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_associated_document_line_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedTradeProduct(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedTradeProduct(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedTradeProduct",
                        ) {
                            let output =
                                <super::TradeProductType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_specified_trade_product(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedLineTradeAgreement(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedLineTradeAgreement(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedLineTradeAgreement",
                        ) {
                            let output = < super :: LineTradeAgreementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_line_trade_agreement(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedLineTradeDelivery(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedLineTradeDelivery(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedLineTradeDelivery",
                        ) {
                            let output = < super :: LineTradeDeliveryType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_line_trade_delivery(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedLineTradeSettlement(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedLineTradeSettlement(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedLineTradeSettlement",
                        ) {
                            let output = < super :: LineTradeSettlementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_line_trade_settlement(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplyChainTradeLineItemType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplyChainTradeLineItemTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplyChainTradeLineItemType {
                associated_document_line_document: self
                    .associated_document_line_document
                    .ok_or_else(|| {
                        ErrorKind::MissingElement("AssociatedDocumentLineDocument".into())
                    })?,
                specified_trade_product: self
                    .specified_trade_product
                    .ok_or_else(|| ErrorKind::MissingElement("SpecifiedTradeProduct".into()))?,
                specified_line_trade_agreement: self.specified_line_trade_agreement.ok_or_else(
                    || ErrorKind::MissingElement("SpecifiedLineTradeAgreement".into()),
                )?,
                specified_line_trade_delivery: self.specified_line_trade_delivery.ok_or_else(
                    || ErrorKind::MissingElement("SpecifiedLineTradeDelivery".into()),
                )?,
                specified_line_trade_settlement: self.specified_line_trade_settlement.ok_or_else(
                    || ErrorKind::MissingElement("SpecifiedLineTradeSettlement".into()),
                )?,
            })
        }
    }
    #[derive(Debug)]
    pub struct HeaderTradeAgreementTypeDeserializer {
        buyer_reference: Option<super::TextType>,
        seller_trade_party: Option<super::TradePartyType>,
        buyer_trade_party: Option<super::TradePartyType>,
        sales_agent_trade_party: Option<super::TradePartyType>,
        buyer_tax_representative_trade_party: Option<super::TradePartyType>,
        seller_tax_representative_trade_party: Option<super::TradePartyType>,
        product_end_user_trade_party: Option<super::TradePartyType>,
        applicable_trade_delivery_terms: Option<super::TradeDeliveryTermsType>,
        seller_order_referenced_document: Option<super::ReferencedDocumentType>,
        buyer_order_referenced_document: Option<super::ReferencedDocumentType>,
        quotation_referenced_document: Option<super::ReferencedDocumentType>,
        contract_referenced_document: Option<super::ReferencedDocumentType>,
        additional_referenced_document: Vec<super::ReferencedDocumentType>,
        buyer_agent_trade_party: Option<super::TradePartyType>,
        specified_procuring_project: Option<super::ProcuringProjectType>,
        ultimate_customer_order_referenced_document: Vec<super::ReferencedDocumentType>,
        state: Box<HeaderTradeAgreementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum HeaderTradeAgreementTypeDeserializerState {
        Init__,
        BuyerReference(Option<<super::TextType as WithDeserializer>::Deserializer>),
        SellerTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        BuyerTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        SalesAgentTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        BuyerTaxRepresentativeTradeParty(
            Option<<super::TradePartyType as WithDeserializer>::Deserializer>,
        ),
        SellerTaxRepresentativeTradeParty(
            Option<<super::TradePartyType as WithDeserializer>::Deserializer>,
        ),
        ProductEndUserTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        ApplicableTradeDeliveryTerms(
            Option<<super::TradeDeliveryTermsType as WithDeserializer>::Deserializer>,
        ),
        SellerOrderReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        BuyerOrderReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        QuotationReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        ContractReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        AdditionalReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        BuyerAgentTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        SpecifiedProcuringProject(
            Option<<super::ProcuringProjectType as WithDeserializer>::Deserializer>,
        ),
        UltimateCustomerOrderReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl HeaderTradeAgreementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                buyer_reference: None,
                seller_trade_party: None,
                buyer_trade_party: None,
                sales_agent_trade_party: None,
                buyer_tax_representative_trade_party: None,
                seller_tax_representative_trade_party: None,
                product_end_user_trade_party: None,
                applicable_trade_delivery_terms: None,
                seller_order_referenced_document: None,
                buyer_order_referenced_document: None,
                quotation_referenced_document: None,
                contract_referenced_document: None,
                additional_referenced_document: Vec::new(),
                buyer_agent_trade_party: None,
                specified_procuring_project: None,
                ultimate_customer_order_referenced_document: Vec::new(),
                state: Box::new(HeaderTradeAgreementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: HeaderTradeAgreementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use HeaderTradeAgreementTypeDeserializerState as S;
            match state {
                S::BuyerReference(Some(deserializer)) => {
                    self.store_buyer_reference(deserializer.finish(reader)?)?
                }
                S::SellerTradeParty(Some(deserializer)) => {
                    self.store_seller_trade_party(deserializer.finish(reader)?)?
                }
                S::BuyerTradeParty(Some(deserializer)) => {
                    self.store_buyer_trade_party(deserializer.finish(reader)?)?
                }
                S::SalesAgentTradeParty(Some(deserializer)) => {
                    self.store_sales_agent_trade_party(deserializer.finish(reader)?)?
                }
                S::BuyerTaxRepresentativeTradeParty(Some(deserializer)) => {
                    self.store_buyer_tax_representative_trade_party(deserializer.finish(reader)?)?
                }
                S::SellerTaxRepresentativeTradeParty(Some(deserializer)) => {
                    self.store_seller_tax_representative_trade_party(deserializer.finish(reader)?)?
                }
                S::ProductEndUserTradeParty(Some(deserializer)) => {
                    self.store_product_end_user_trade_party(deserializer.finish(reader)?)?
                }
                S::ApplicableTradeDeliveryTerms(Some(deserializer)) => {
                    self.store_applicable_trade_delivery_terms(deserializer.finish(reader)?)?
                }
                S::SellerOrderReferencedDocument(Some(deserializer)) => {
                    self.store_seller_order_referenced_document(deserializer.finish(reader)?)?
                }
                S::BuyerOrderReferencedDocument(Some(deserializer)) => {
                    self.store_buyer_order_referenced_document(deserializer.finish(reader)?)?
                }
                S::QuotationReferencedDocument(Some(deserializer)) => {
                    self.store_quotation_referenced_document(deserializer.finish(reader)?)?
                }
                S::ContractReferencedDocument(Some(deserializer)) => {
                    self.store_contract_referenced_document(deserializer.finish(reader)?)?
                }
                S::AdditionalReferencedDocument(Some(deserializer)) => {
                    self.store_additional_referenced_document(deserializer.finish(reader)?)?
                }
                S::BuyerAgentTradeParty(Some(deserializer)) => {
                    self.store_buyer_agent_trade_party(deserializer.finish(reader)?)?
                }
                S::SpecifiedProcuringProject(Some(deserializer)) => {
                    self.store_specified_procuring_project(deserializer.finish(reader)?)?
                }
                S::UltimateCustomerOrderReferencedDocument(Some(deserializer)) => self
                    .store_ultimate_customer_order_referenced_document(
                        deserializer.finish(reader)?,
                    )?,
                _ => (),
            }
            Ok(())
        }
        fn store_buyer_reference(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.buyer_reference.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BuyerReference",
                )))?;
            }
            self.buyer_reference = Some(value);
            Ok(())
        }
        fn store_seller_trade_party(&mut self, value: super::TradePartyType) -> Result<(), Error> {
            if self.seller_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SellerTradeParty",
                )))?;
            }
            self.seller_trade_party = Some(value);
            Ok(())
        }
        fn store_buyer_trade_party(&mut self, value: super::TradePartyType) -> Result<(), Error> {
            if self.buyer_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BuyerTradeParty",
                )))?;
            }
            self.buyer_trade_party = Some(value);
            Ok(())
        }
        fn store_sales_agent_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.sales_agent_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SalesAgentTradeParty",
                )))?;
            }
            self.sales_agent_trade_party = Some(value);
            Ok(())
        }
        fn store_buyer_tax_representative_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.buyer_tax_representative_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BuyerTaxRepresentativeTradeParty",
                )))?;
            }
            self.buyer_tax_representative_trade_party = Some(value);
            Ok(())
        }
        fn store_seller_tax_representative_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.seller_tax_representative_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SellerTaxRepresentativeTradeParty",
                )))?;
            }
            self.seller_tax_representative_trade_party = Some(value);
            Ok(())
        }
        fn store_product_end_user_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.product_end_user_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ProductEndUserTradeParty",
                )))?;
            }
            self.product_end_user_trade_party = Some(value);
            Ok(())
        }
        fn store_applicable_trade_delivery_terms(
            &mut self,
            value: super::TradeDeliveryTermsType,
        ) -> Result<(), Error> {
            if self.applicable_trade_delivery_terms.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ApplicableTradeDeliveryTerms",
                )))?;
            }
            self.applicable_trade_delivery_terms = Some(value);
            Ok(())
        }
        fn store_seller_order_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.seller_order_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SellerOrderReferencedDocument",
                )))?;
            }
            self.seller_order_referenced_document = Some(value);
            Ok(())
        }
        fn store_buyer_order_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.buyer_order_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BuyerOrderReferencedDocument",
                )))?;
            }
            self.buyer_order_referenced_document = Some(value);
            Ok(())
        }
        fn store_quotation_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.quotation_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"QuotationReferencedDocument",
                )))?;
            }
            self.quotation_referenced_document = Some(value);
            Ok(())
        }
        fn store_contract_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.contract_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ContractReferencedDocument",
                )))?;
            }
            self.contract_referenced_document = Some(value);
            Ok(())
        }
        fn store_additional_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            self.additional_referenced_document.push(value);
            Ok(())
        }
        fn store_buyer_agent_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.buyer_agent_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BuyerAgentTradeParty",
                )))?;
            }
            self.buyer_agent_trade_party = Some(value);
            Ok(())
        }
        fn store_specified_procuring_project(
            &mut self,
            value: super::ProcuringProjectType,
        ) -> Result<(), Error> {
            if self.specified_procuring_project.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SpecifiedProcuringProject",
                )))?;
            }
            self.specified_procuring_project = Some(value);
            Ok(())
        }
        fn store_ultimate_customer_order_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            self.ultimate_customer_order_referenced_document.push(value);
            Ok(())
        }
        fn handle_buyer_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(HeaderTradeAgreementTypeDeserializerState::BuyerReference(
                    None,
                ));
                *self.state = HeaderTradeAgreementTypeDeserializerState::SellerTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_reference(data)?;
                    *self.state = HeaderTradeAgreementTypeDeserializerState::SellerTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeAgreementTypeDeserializerState::BuyerReference(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::SellerTradeParty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = HeaderTradeAgreementTypeDeserializerState::BuyerReference(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_seller_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.seller_trade_party.is_some() {
                    fallback.get_or_insert(
                        HeaderTradeAgreementTypeDeserializerState::SellerTradeParty(None),
                    );
                    *self.state = HeaderTradeAgreementTypeDeserializerState::BuyerTradeParty(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderTradeAgreementTypeDeserializerState::SellerTradeParty(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_seller_trade_party(data)?;
                    *self.state = HeaderTradeAgreementTypeDeserializerState::BuyerTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeAgreementTypeDeserializerState::SellerTradeParty(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::BuyerTradeParty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::SellerTradeParty(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.buyer_trade_party.is_some() {
                    fallback.get_or_insert(
                        HeaderTradeAgreementTypeDeserializerState::BuyerTradeParty(None),
                    );
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::SalesAgentTradeParty(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderTradeAgreementTypeDeserializerState::BuyerTradeParty(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_trade_party(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::SalesAgentTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeAgreementTypeDeserializerState::BuyerTradeParty(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::SalesAgentTradeParty(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::BuyerTradeParty(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_sales_agent_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::SalesAgentTradeParty(None),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::BuyerTaxRepresentativeTradeParty(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_sales_agent_trade_party(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::BuyerTaxRepresentativeTradeParty(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeAgreementTypeDeserializerState::SalesAgentTradeParty(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: BuyerTaxRepresentativeTradeParty (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::SalesAgentTradeParty(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_tax_representative_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::BuyerTaxRepresentativeTradeParty(
                        None,
                    ),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::SellerTaxRepresentativeTradeParty(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_tax_representative_trade_party(data)?;
                    * self . state = HeaderTradeAgreementTypeDeserializerState :: SellerTaxRepresentativeTradeParty (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: BuyerTaxRepresentativeTradeParty (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: SellerTaxRepresentativeTradeParty (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: BuyerTaxRepresentativeTradeParty (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_seller_tax_representative_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::SellerTaxRepresentativeTradeParty(
                        None,
                    ),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::ProductEndUserTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_seller_tax_representative_trade_party(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::ProductEndUserTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: SellerTaxRepresentativeTradeParty (Some (deserializer))) ;
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::ProductEndUserTradeParty(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: SellerTaxRepresentativeTradeParty (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_end_user_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::ProductEndUserTradeParty(None),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::ApplicableTradeDeliveryTerms(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_end_user_trade_party(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::ApplicableTradeDeliveryTerms(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeAgreementTypeDeserializerState::ProductEndUserTradeParty(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: ApplicableTradeDeliveryTerms (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::ProductEndUserTradeParty(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_trade_delivery_terms<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeDeliveryTermsType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::ApplicableTradeDeliveryTerms(None),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::SellerOrderReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_trade_delivery_terms(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::SellerOrderReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: ApplicableTradeDeliveryTerms (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: SellerOrderReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: ApplicableTradeDeliveryTerms (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_seller_order_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::SellerOrderReferencedDocument(None),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::BuyerOrderReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_seller_order_referenced_document(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::BuyerOrderReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: SellerOrderReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: BuyerOrderReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: SellerOrderReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_order_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::BuyerOrderReferencedDocument(None),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::QuotationReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_order_referenced_document(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::QuotationReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: BuyerOrderReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: QuotationReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: BuyerOrderReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_quotation_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::QuotationReferencedDocument(None),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::ContractReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_quotation_referenced_document(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::ContractReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: QuotationReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: ContractReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: QuotationReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_contract_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::ContractReferencedDocument(None),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::AdditionalReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_contract_referenced_document(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::AdditionalReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: ContractReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: AdditionalReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: ContractReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_additional_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::AdditionalReferencedDocument(None),
                );
                *self.state = HeaderTradeAgreementTypeDeserializerState::BuyerAgentTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_additional_referenced_document(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::AdditionalReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: AdditionalReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: AdditionalReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: AdditionalReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_agent_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::BuyerAgentTradeParty(None),
                );
                *self.state =
                    HeaderTradeAgreementTypeDeserializerState::SpecifiedProcuringProject(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_agent_trade_party(data)?;
                    *self.state =
                        HeaderTradeAgreementTypeDeserializerState::SpecifiedProcuringProject(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeAgreementTypeDeserializerState::BuyerAgentTradeParty(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: SpecifiedProcuringProject (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeAgreementTypeDeserializerState::BuyerAgentTradeParty(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_procuring_project<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProcuringProjectType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeAgreementTypeDeserializerState::SpecifiedProcuringProject(None),
                );
                * self . state = HeaderTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_procuring_project(data)?;
                    * self . state = HeaderTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: SpecifiedProcuringProject (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: SpecifiedProcuringProject (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_ultimate_customer_order_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None)) ;
                *self.state = HeaderTradeAgreementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ultimate_customer_order_referenced_document(data)?;
                    * self . state = HeaderTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::HeaderTradeAgreementType>
        for HeaderTradeAgreementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderTradeAgreementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderTradeAgreementType>
        where
            R: DeserializeReader,
        {
            use HeaderTradeAgreementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BuyerReference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SellerTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_seller_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SalesAgentTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_sales_agent_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerTaxRepresentativeTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_tax_representative_trade_party(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SellerTaxRepresentativeTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_seller_tax_representative_trade_party(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductEndUserTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_end_user_trade_party(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableTradeDeliveryTerms(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_trade_delivery_terms(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SellerOrderReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_seller_order_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerOrderReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_order_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::QuotationReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_quotation_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ContractReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_contract_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AdditionalReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_additional_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerAgentTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_agent_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedProcuringProject(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_procuring_project(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UltimateCustomerOrderReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ultimate_customer_order_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            HeaderTradeAgreementTypeDeserializerState::BuyerReference(None);
                        event
                    }
                    (S::BuyerReference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BuyerReference",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_buyer_reference(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SellerTradeParty(None);
                            event
                        }
                    }
                    (S::SellerTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SellerTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_seller_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerTradeParty(None);
                            event
                        }
                    }
                    (S::BuyerTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BuyerTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_buyer_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SalesAgentTradeParty(None);
                            event
                        }
                    }
                    (
                        S::SalesAgentTradeParty(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SalesAgentTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_sales_agent_trade_party(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerTaxRepresentativeTradeParty(None);
                            event
                        }
                    }
                    (
                        S::BuyerTaxRepresentativeTradeParty(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BuyerTaxRepresentativeTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_buyer_tax_representative_trade_party(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SellerTaxRepresentativeTradeParty(None);
                            event
                        }
                    }
                    (
                        S::SellerTaxRepresentativeTradeParty(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SellerTaxRepresentativeTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_seller_tax_representative_trade_party(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductEndUserTradeParty(None);
                            event
                        }
                    }
                    (
                        S::ProductEndUserTradeParty(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ProductEndUserTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_product_end_user_trade_party(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableTradeDeliveryTerms(None);
                            event
                        }
                    }
                    (
                        S::ApplicableTradeDeliveryTerms(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableTradeDeliveryTerms",
                        ) {
                            let output = < super :: TradeDeliveryTermsType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applicable_trade_delivery_terms(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SellerOrderReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::SellerOrderReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SellerOrderReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_seller_order_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerOrderReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::BuyerOrderReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BuyerOrderReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_buyer_order_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::QuotationReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::QuotationReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"QuotationReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_quotation_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ContractReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::ContractReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ContractReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_contract_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AdditionalReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::AdditionalReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AdditionalReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_additional_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerAgentTradeParty(None);
                            event
                        }
                    }
                    (
                        S::BuyerAgentTradeParty(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BuyerAgentTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_buyer_agent_trade_party(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedProcuringProject(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedProcuringProject(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedProcuringProject",
                        ) {
                            let output = < super :: ProcuringProjectType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_procuring_project(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UltimateCustomerOrderReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::UltimateCustomerOrderReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"UltimateCustomerOrderReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_ultimate_customer_order_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::HeaderTradeAgreementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                HeaderTradeAgreementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::HeaderTradeAgreementType {
                buyer_reference: self.buyer_reference,
                seller_trade_party: self
                    .seller_trade_party
                    .ok_or_else(|| ErrorKind::MissingElement("SellerTradeParty".into()))?,
                buyer_trade_party: self
                    .buyer_trade_party
                    .ok_or_else(|| ErrorKind::MissingElement("BuyerTradeParty".into()))?,
                sales_agent_trade_party: self.sales_agent_trade_party,
                buyer_tax_representative_trade_party: self.buyer_tax_representative_trade_party,
                seller_tax_representative_trade_party: self.seller_tax_representative_trade_party,
                product_end_user_trade_party: self.product_end_user_trade_party,
                applicable_trade_delivery_terms: self.applicable_trade_delivery_terms,
                seller_order_referenced_document: self.seller_order_referenced_document,
                buyer_order_referenced_document: self.buyer_order_referenced_document,
                quotation_referenced_document: self.quotation_referenced_document,
                contract_referenced_document: self.contract_referenced_document,
                additional_referenced_document: self.additional_referenced_document,
                buyer_agent_trade_party: self.buyer_agent_trade_party,
                specified_procuring_project: self.specified_procuring_project,
                ultimate_customer_order_referenced_document: self
                    .ultimate_customer_order_referenced_document,
            })
        }
    }
    #[derive(Debug)]
    pub struct HeaderTradeDeliveryTypeDeserializer {
        related_supply_chain_consignment: Option<super::SupplyChainConsignmentType>,
        ship_to_trade_party: Option<super::TradePartyType>,
        ultimate_ship_to_trade_party: Option<super::TradePartyType>,
        ship_from_trade_party: Option<super::TradePartyType>,
        actual_delivery_supply_chain_event: Option<super::SupplyChainEventType>,
        despatch_advice_referenced_document: Option<super::ReferencedDocumentType>,
        receiving_advice_referenced_document: Option<super::ReferencedDocumentType>,
        delivery_note_referenced_document: Option<super::ReferencedDocumentType>,
        state: Box<HeaderTradeDeliveryTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum HeaderTradeDeliveryTypeDeserializerState {
        Init__,
        RelatedSupplyChainConsignment(
            Option<<super::SupplyChainConsignmentType as WithDeserializer>::Deserializer>,
        ),
        ShipToTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        UltimateShipToTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        ShipFromTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        ActualDeliverySupplyChainEvent(
            Option<<super::SupplyChainEventType as WithDeserializer>::Deserializer>,
        ),
        DespatchAdviceReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        ReceivingAdviceReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        DeliveryNoteReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl HeaderTradeDeliveryTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                related_supply_chain_consignment: None,
                ship_to_trade_party: None,
                ultimate_ship_to_trade_party: None,
                ship_from_trade_party: None,
                actual_delivery_supply_chain_event: None,
                despatch_advice_referenced_document: None,
                receiving_advice_referenced_document: None,
                delivery_note_referenced_document: None,
                state: Box::new(HeaderTradeDeliveryTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: HeaderTradeDeliveryTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use HeaderTradeDeliveryTypeDeserializerState as S;
            match state {
                S::RelatedSupplyChainConsignment(Some(deserializer)) => {
                    self.store_related_supply_chain_consignment(deserializer.finish(reader)?)?
                }
                S::ShipToTradeParty(Some(deserializer)) => {
                    self.store_ship_to_trade_party(deserializer.finish(reader)?)?
                }
                S::UltimateShipToTradeParty(Some(deserializer)) => {
                    self.store_ultimate_ship_to_trade_party(deserializer.finish(reader)?)?
                }
                S::ShipFromTradeParty(Some(deserializer)) => {
                    self.store_ship_from_trade_party(deserializer.finish(reader)?)?
                }
                S::ActualDeliverySupplyChainEvent(Some(deserializer)) => {
                    self.store_actual_delivery_supply_chain_event(deserializer.finish(reader)?)?
                }
                S::DespatchAdviceReferencedDocument(Some(deserializer)) => {
                    self.store_despatch_advice_referenced_document(deserializer.finish(reader)?)?
                }
                S::ReceivingAdviceReferencedDocument(Some(deserializer)) => {
                    self.store_receiving_advice_referenced_document(deserializer.finish(reader)?)?
                }
                S::DeliveryNoteReferencedDocument(Some(deserializer)) => {
                    self.store_delivery_note_referenced_document(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_related_supply_chain_consignment(
            &mut self,
            value: super::SupplyChainConsignmentType,
        ) -> Result<(), Error> {
            if self.related_supply_chain_consignment.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"RelatedSupplyChainConsignment",
                )))?;
            }
            self.related_supply_chain_consignment = Some(value);
            Ok(())
        }
        fn store_ship_to_trade_party(&mut self, value: super::TradePartyType) -> Result<(), Error> {
            if self.ship_to_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ShipToTradeParty",
                )))?;
            }
            self.ship_to_trade_party = Some(value);
            Ok(())
        }
        fn store_ultimate_ship_to_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.ultimate_ship_to_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UltimateShipToTradeParty",
                )))?;
            }
            self.ultimate_ship_to_trade_party = Some(value);
            Ok(())
        }
        fn store_ship_from_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.ship_from_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ShipFromTradeParty",
                )))?;
            }
            self.ship_from_trade_party = Some(value);
            Ok(())
        }
        fn store_actual_delivery_supply_chain_event(
            &mut self,
            value: super::SupplyChainEventType,
        ) -> Result<(), Error> {
            if self.actual_delivery_supply_chain_event.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ActualDeliverySupplyChainEvent",
                )))?;
            }
            self.actual_delivery_supply_chain_event = Some(value);
            Ok(())
        }
        fn store_despatch_advice_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.despatch_advice_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DespatchAdviceReferencedDocument",
                )))?;
            }
            self.despatch_advice_referenced_document = Some(value);
            Ok(())
        }
        fn store_receiving_advice_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.receiving_advice_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ReceivingAdviceReferencedDocument",
                )))?;
            }
            self.receiving_advice_referenced_document = Some(value);
            Ok(())
        }
        fn store_delivery_note_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.delivery_note_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DeliveryNoteReferencedDocument",
                )))?;
            }
            self.delivery_note_referenced_document = Some(value);
            Ok(())
        }
        fn handle_related_supply_chain_consignment<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplyChainConsignmentType>,
            fallback: &mut Option<HeaderTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeDeliveryTypeDeserializerState::RelatedSupplyChainConsignment(None),
                );
                *self.state = HeaderTradeDeliveryTypeDeserializerState::ShipToTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_related_supply_chain_consignment(data)?;
                    *self.state = HeaderTradeDeliveryTypeDeserializerState::ShipToTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeDeliveryTypeDeserializerState :: RelatedSupplyChainConsignment (Some (deserializer))) ;
                            *self.state =
                                HeaderTradeDeliveryTypeDeserializerState::ShipToTradeParty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: RelatedSupplyChainConsignment (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_ship_to_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(HeaderTradeDeliveryTypeDeserializerState::ShipToTradeParty(
                    None,
                ));
                *self.state =
                    HeaderTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ship_to_trade_party(data)?;
                    *self.state =
                        HeaderTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeDeliveryTypeDeserializerState::ShipToTradeParty(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                HeaderTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeDeliveryTypeDeserializerState::ShipToTradeParty(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_ultimate_ship_to_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(None),
                );
                *self.state = HeaderTradeDeliveryTypeDeserializerState::ShipFromTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ultimate_ship_to_trade_party(data)?;
                    *self.state =
                        HeaderTradeDeliveryTypeDeserializerState::ShipFromTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                HeaderTradeDeliveryTypeDeserializerState::ShipFromTradeParty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_ship_from_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeDeliveryTypeDeserializerState::ShipFromTradeParty(None),
                );
                *self.state =
                    HeaderTradeDeliveryTypeDeserializerState::ActualDeliverySupplyChainEvent(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ship_from_trade_party(data)?;
                    *self.state =
                        HeaderTradeDeliveryTypeDeserializerState::ActualDeliverySupplyChainEvent(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeDeliveryTypeDeserializerState::ShipFromTradeParty(Some(
                                    deserializer,
                                )),
                            );
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: ActualDeliverySupplyChainEvent (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeDeliveryTypeDeserializerState::ShipFromTradeParty(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_actual_delivery_supply_chain_event<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplyChainEventType>,
            fallback: &mut Option<HeaderTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeDeliveryTypeDeserializerState::ActualDeliverySupplyChainEvent(None),
                );
                *self.state =
                    HeaderTradeDeliveryTypeDeserializerState::DespatchAdviceReferencedDocument(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actual_delivery_supply_chain_event(data)?;
                    *self.state =
                        HeaderTradeDeliveryTypeDeserializerState::DespatchAdviceReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeDeliveryTypeDeserializerState :: ActualDeliverySupplyChainEvent (Some (deserializer))) ;
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: DespatchAdviceReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: ActualDeliverySupplyChainEvent (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_despatch_advice_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeDeliveryTypeDeserializerState::DespatchAdviceReferencedDocument(
                        None,
                    ),
                );
                *self.state =
                    HeaderTradeDeliveryTypeDeserializerState::ReceivingAdviceReferencedDocument(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_despatch_advice_referenced_document(data)?;
                    *self.state =
                        HeaderTradeDeliveryTypeDeserializerState::ReceivingAdviceReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeDeliveryTypeDeserializerState :: DespatchAdviceReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: ReceivingAdviceReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: DespatchAdviceReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_receiving_advice_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeDeliveryTypeDeserializerState::ReceivingAdviceReferencedDocument(
                        None,
                    ),
                );
                *self.state =
                    HeaderTradeDeliveryTypeDeserializerState::DeliveryNoteReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_receiving_advice_referenced_document(data)?;
                    *self.state =
                        HeaderTradeDeliveryTypeDeserializerState::DeliveryNoteReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeDeliveryTypeDeserializerState :: ReceivingAdviceReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: DeliveryNoteReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: ReceivingAdviceReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_delivery_note_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeDeliveryTypeDeserializerState::DeliveryNoteReferencedDocument(None),
                );
                *self.state = HeaderTradeDeliveryTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_delivery_note_referenced_document(data)?;
                    *self.state = HeaderTradeDeliveryTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeDeliveryTypeDeserializerState :: DeliveryNoteReferencedDocument (Some (deserializer))) ;
                            *self.state = HeaderTradeDeliveryTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeDeliveryTypeDeserializerState :: DeliveryNoteReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::HeaderTradeDeliveryType>
        for HeaderTradeDeliveryTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderTradeDeliveryType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderTradeDeliveryType>
        where
            R: DeserializeReader,
        {
            use HeaderTradeDeliveryTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::RelatedSupplyChainConsignment(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_related_supply_chain_consignment(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ShipToTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ship_to_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UltimateShipToTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ultimate_ship_to_trade_party(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ShipFromTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ship_from_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ActualDeliverySupplyChainEvent(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actual_delivery_supply_chain_event(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DespatchAdviceReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_despatch_advice_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReceivingAdviceReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_receiving_advice_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DeliveryNoteReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_delivery_note_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            HeaderTradeDeliveryTypeDeserializerState::RelatedSupplyChainConsignment(
                                None,
                            );
                        event
                    }
                    (
                        S::RelatedSupplyChainConsignment(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"RelatedSupplyChainConsignment",
                        ) {
                            let output = < super :: SupplyChainConsignmentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_related_supply_chain_consignment(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ShipToTradeParty(None);
                            event
                        }
                    }
                    (S::ShipToTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ShipToTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_ship_to_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UltimateShipToTradeParty(None);
                            event
                        }
                    }
                    (
                        S::UltimateShipToTradeParty(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"UltimateShipToTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_ultimate_ship_to_trade_party(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ShipFromTradeParty(None);
                            event
                        }
                    }
                    (S::ShipFromTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ShipFromTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_ship_from_trade_party(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ActualDeliverySupplyChainEvent(None);
                            event
                        }
                    }
                    (
                        S::ActualDeliverySupplyChainEvent(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ActualDeliverySupplyChainEvent",
                        ) {
                            let output = < super :: SupplyChainEventType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_actual_delivery_supply_chain_event(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DespatchAdviceReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::DespatchAdviceReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DespatchAdviceReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_despatch_advice_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReceivingAdviceReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::ReceivingAdviceReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ReceivingAdviceReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_receiving_advice_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DeliveryNoteReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::DeliveryNoteReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DeliveryNoteReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_delivery_note_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::HeaderTradeDeliveryType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                HeaderTradeDeliveryTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::HeaderTradeDeliveryType {
                related_supply_chain_consignment: self.related_supply_chain_consignment,
                ship_to_trade_party: self.ship_to_trade_party,
                ultimate_ship_to_trade_party: self.ultimate_ship_to_trade_party,
                ship_from_trade_party: self.ship_from_trade_party,
                actual_delivery_supply_chain_event: self.actual_delivery_supply_chain_event,
                despatch_advice_referenced_document: self.despatch_advice_referenced_document,
                receiving_advice_referenced_document: self.receiving_advice_referenced_document,
                delivery_note_referenced_document: self.delivery_note_referenced_document,
            })
        }
    }
    #[derive(Debug)]
    pub struct HeaderTradeSettlementTypeDeserializer {
        creditor_reference_id: Option<super::IdType>,
        payment_reference: Option<super::TextType>,
        tax_currency_code: Option<super::CurrencyCodeType>,
        invoice_currency_code: Option<super::CurrencyCodeType>,
        invoice_issuer_reference: Option<super::TextType>,
        invoicer_trade_party: Option<super::TradePartyType>,
        invoicee_trade_party: Option<super::TradePartyType>,
        payee_trade_party: Option<super::TradePartyType>,
        payer_trade_party: Option<super::TradePartyType>,
        tax_applicable_trade_currency_exchange: Option<super::TradeCurrencyExchangeType>,
        specified_trade_settlement_payment_means: Vec<super::TradeSettlementPaymentMeansType>,
        applicable_trade_tax: Vec<super::TradeTaxType>,
        billing_specified_period: Option<super::SpecifiedPeriodType>,
        specified_trade_allowance_charge: Vec<super::TradeAllowanceChargeType>,
        specified_logistics_service_charge: Vec<super::LogisticsServiceChargeType>,
        specified_trade_payment_terms: Vec<super::TradePaymentTermsType>,
        specified_trade_settlement_header_monetary_summation:
            Option<super::TradeSettlementHeaderMonetarySummationType>,
        invoice_referenced_document: Vec<super::ReferencedDocumentType>,
        receivable_specified_trade_accounting_account: Vec<super::TradeAccountingAccountType>,
        specified_advance_payment: Vec<super::AdvancePaymentType>,
        state: Box<HeaderTradeSettlementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum HeaderTradeSettlementTypeDeserializerState {
        Init__ , CreditorReferenceId (Option << super :: IdType as WithDeserializer > :: Deserializer >) , PaymentReference (Option << super :: TextType as WithDeserializer > :: Deserializer >) , TaxCurrencyCode (Option << super :: CurrencyCodeType as WithDeserializer > :: Deserializer >) , InvoiceCurrencyCode (Option << super :: CurrencyCodeType as WithDeserializer > :: Deserializer >) , InvoiceIssuerReference (Option << super :: TextType as WithDeserializer > :: Deserializer >) , InvoicerTradeParty (Option << super :: TradePartyType as WithDeserializer > :: Deserializer >) , InvoiceeTradeParty (Option << super :: TradePartyType as WithDeserializer > :: Deserializer >) , PayeeTradeParty (Option << super :: TradePartyType as WithDeserializer > :: Deserializer >) , PayerTradeParty (Option << super :: TradePartyType as WithDeserializer > :: Deserializer >) , TaxApplicableTradeCurrencyExchange (Option << super :: TradeCurrencyExchangeType as WithDeserializer > :: Deserializer >) , SpecifiedTradeSettlementPaymentMeans (Option << super :: TradeSettlementPaymentMeansType as WithDeserializer > :: Deserializer >) , ApplicableTradeTax (Option << super :: TradeTaxType as WithDeserializer > :: Deserializer >) , BillingSpecifiedPeriod (Option << super :: SpecifiedPeriodType as WithDeserializer > :: Deserializer >) , SpecifiedTradeAllowanceCharge (Option << super :: TradeAllowanceChargeType as WithDeserializer > :: Deserializer >) , SpecifiedLogisticsServiceCharge (Option << super :: LogisticsServiceChargeType as WithDeserializer > :: Deserializer >) , SpecifiedTradePaymentTerms (Option << super :: TradePaymentTermsType as WithDeserializer > :: Deserializer >) , SpecifiedTradeSettlementHeaderMonetarySummation (Option << super :: TradeSettlementHeaderMonetarySummationType as WithDeserializer > :: Deserializer >) , InvoiceReferencedDocument (Option << super :: ReferencedDocumentType as WithDeserializer > :: Deserializer >) , ReceivableSpecifiedTradeAccountingAccount (Option << super :: TradeAccountingAccountType as WithDeserializer > :: Deserializer >) , SpecifiedAdvancePayment (Option << super :: AdvancePaymentType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl HeaderTradeSettlementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                creditor_reference_id: None,
                payment_reference: None,
                tax_currency_code: None,
                invoice_currency_code: None,
                invoice_issuer_reference: None,
                invoicer_trade_party: None,
                invoicee_trade_party: None,
                payee_trade_party: None,
                payer_trade_party: None,
                tax_applicable_trade_currency_exchange: None,
                specified_trade_settlement_payment_means: Vec::new(),
                applicable_trade_tax: Vec::new(),
                billing_specified_period: None,
                specified_trade_allowance_charge: Vec::new(),
                specified_logistics_service_charge: Vec::new(),
                specified_trade_payment_terms: Vec::new(),
                specified_trade_settlement_header_monetary_summation: None,
                invoice_referenced_document: Vec::new(),
                receivable_specified_trade_accounting_account: Vec::new(),
                specified_advance_payment: Vec::new(),
                state: Box::new(HeaderTradeSettlementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: HeaderTradeSettlementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use HeaderTradeSettlementTypeDeserializerState as S;
            match state {
                S::CreditorReferenceId(Some(deserializer)) => {
                    self.store_creditor_reference_id(deserializer.finish(reader)?)?
                }
                S::PaymentReference(Some(deserializer)) => {
                    self.store_payment_reference(deserializer.finish(reader)?)?
                }
                S::TaxCurrencyCode(Some(deserializer)) => {
                    self.store_tax_currency_code(deserializer.finish(reader)?)?
                }
                S::InvoiceCurrencyCode(Some(deserializer)) => {
                    self.store_invoice_currency_code(deserializer.finish(reader)?)?
                }
                S::InvoiceIssuerReference(Some(deserializer)) => {
                    self.store_invoice_issuer_reference(deserializer.finish(reader)?)?
                }
                S::InvoicerTradeParty(Some(deserializer)) => {
                    self.store_invoicer_trade_party(deserializer.finish(reader)?)?
                }
                S::InvoiceeTradeParty(Some(deserializer)) => {
                    self.store_invoicee_trade_party(deserializer.finish(reader)?)?
                }
                S::PayeeTradeParty(Some(deserializer)) => {
                    self.store_payee_trade_party(deserializer.finish(reader)?)?
                }
                S::PayerTradeParty(Some(deserializer)) => {
                    self.store_payer_trade_party(deserializer.finish(reader)?)?
                }
                S::TaxApplicableTradeCurrencyExchange(Some(deserializer)) => {
                    self.store_tax_applicable_trade_currency_exchange(deserializer.finish(reader)?)?
                }
                S::SpecifiedTradeSettlementPaymentMeans(Some(deserializer)) => self
                    .store_specified_trade_settlement_payment_means(deserializer.finish(reader)?)?,
                S::ApplicableTradeTax(Some(deserializer)) => {
                    self.store_applicable_trade_tax(deserializer.finish(reader)?)?
                }
                S::BillingSpecifiedPeriod(Some(deserializer)) => {
                    self.store_billing_specified_period(deserializer.finish(reader)?)?
                }
                S::SpecifiedTradeAllowanceCharge(Some(deserializer)) => {
                    self.store_specified_trade_allowance_charge(deserializer.finish(reader)?)?
                }
                S::SpecifiedLogisticsServiceCharge(Some(deserializer)) => {
                    self.store_specified_logistics_service_charge(deserializer.finish(reader)?)?
                }
                S::SpecifiedTradePaymentTerms(Some(deserializer)) => {
                    self.store_specified_trade_payment_terms(deserializer.finish(reader)?)?
                }
                S::SpecifiedTradeSettlementHeaderMonetarySummation(Some(deserializer)) => self
                    .store_specified_trade_settlement_header_monetary_summation(
                        deserializer.finish(reader)?,
                    )?,
                S::InvoiceReferencedDocument(Some(deserializer)) => {
                    self.store_invoice_referenced_document(deserializer.finish(reader)?)?
                }
                S::ReceivableSpecifiedTradeAccountingAccount(Some(deserializer)) => self
                    .store_receivable_specified_trade_accounting_account(
                        deserializer.finish(reader)?,
                    )?,
                S::SpecifiedAdvancePayment(Some(deserializer)) => {
                    self.store_specified_advance_payment(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_creditor_reference_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.creditor_reference_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CreditorReferenceID",
                )))?;
            }
            self.creditor_reference_id = Some(value);
            Ok(())
        }
        fn store_payment_reference(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.payment_reference.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PaymentReference",
                )))?;
            }
            self.payment_reference = Some(value);
            Ok(())
        }
        fn store_tax_currency_code(&mut self, value: super::CurrencyCodeType) -> Result<(), Error> {
            if self.tax_currency_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TaxCurrencyCode",
                )))?;
            }
            self.tax_currency_code = Some(value);
            Ok(())
        }
        fn store_invoice_currency_code(
            &mut self,
            value: super::CurrencyCodeType,
        ) -> Result<(), Error> {
            if self.invoice_currency_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"InvoiceCurrencyCode",
                )))?;
            }
            self.invoice_currency_code = Some(value);
            Ok(())
        }
        fn store_invoice_issuer_reference(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.invoice_issuer_reference.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"InvoiceIssuerReference",
                )))?;
            }
            self.invoice_issuer_reference = Some(value);
            Ok(())
        }
        fn store_invoicer_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.invoicer_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"InvoicerTradeParty",
                )))?;
            }
            self.invoicer_trade_party = Some(value);
            Ok(())
        }
        fn store_invoicee_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.invoicee_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"InvoiceeTradeParty",
                )))?;
            }
            self.invoicee_trade_party = Some(value);
            Ok(())
        }
        fn store_payee_trade_party(&mut self, value: super::TradePartyType) -> Result<(), Error> {
            if self.payee_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PayeeTradeParty",
                )))?;
            }
            self.payee_trade_party = Some(value);
            Ok(())
        }
        fn store_payer_trade_party(&mut self, value: super::TradePartyType) -> Result<(), Error> {
            if self.payer_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PayerTradeParty",
                )))?;
            }
            self.payer_trade_party = Some(value);
            Ok(())
        }
        fn store_tax_applicable_trade_currency_exchange(
            &mut self,
            value: super::TradeCurrencyExchangeType,
        ) -> Result<(), Error> {
            if self.tax_applicable_trade_currency_exchange.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TaxApplicableTradeCurrencyExchange",
                )))?;
            }
            self.tax_applicable_trade_currency_exchange = Some(value);
            Ok(())
        }
        fn store_specified_trade_settlement_payment_means(
            &mut self,
            value: super::TradeSettlementPaymentMeansType,
        ) -> Result<(), Error> {
            self.specified_trade_settlement_payment_means.push(value);
            Ok(())
        }
        fn store_applicable_trade_tax(&mut self, value: super::TradeTaxType) -> Result<(), Error> {
            self.applicable_trade_tax.push(value);
            Ok(())
        }
        fn store_billing_specified_period(
            &mut self,
            value: super::SpecifiedPeriodType,
        ) -> Result<(), Error> {
            if self.billing_specified_period.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BillingSpecifiedPeriod",
                )))?;
            }
            self.billing_specified_period = Some(value);
            Ok(())
        }
        fn store_specified_trade_allowance_charge(
            &mut self,
            value: super::TradeAllowanceChargeType,
        ) -> Result<(), Error> {
            self.specified_trade_allowance_charge.push(value);
            Ok(())
        }
        fn store_specified_logistics_service_charge(
            &mut self,
            value: super::LogisticsServiceChargeType,
        ) -> Result<(), Error> {
            self.specified_logistics_service_charge.push(value);
            Ok(())
        }
        fn store_specified_trade_payment_terms(
            &mut self,
            value: super::TradePaymentTermsType,
        ) -> Result<(), Error> {
            self.specified_trade_payment_terms.push(value);
            Ok(())
        }
        fn store_specified_trade_settlement_header_monetary_summation(
            &mut self,
            value: super::TradeSettlementHeaderMonetarySummationType,
        ) -> Result<(), Error> {
            if self
                .specified_trade_settlement_header_monetary_summation
                .is_some()
            {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SpecifiedTradeSettlementHeaderMonetarySummation",
                )))?;
            }
            self.specified_trade_settlement_header_monetary_summation = Some(value);
            Ok(())
        }
        fn store_invoice_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            self.invoice_referenced_document.push(value);
            Ok(())
        }
        fn store_receivable_specified_trade_accounting_account(
            &mut self,
            value: super::TradeAccountingAccountType,
        ) -> Result<(), Error> {
            self.receivable_specified_trade_accounting_account
                .push(value);
            Ok(())
        }
        fn store_specified_advance_payment(
            &mut self,
            value: super::AdvancePaymentType,
        ) -> Result<(), Error> {
            self.specified_advance_payment.push(value);
            Ok(())
        }
        fn handle_creditor_reference_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::CreditorReferenceId(None),
                );
                *self.state = HeaderTradeSettlementTypeDeserializerState::PaymentReference(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_creditor_reference_id(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::PaymentReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::CreditorReferenceId(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::PaymentReference(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::CreditorReferenceId(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_payment_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::PaymentReference(None),
                );
                *self.state = HeaderTradeSettlementTypeDeserializerState::TaxCurrencyCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_payment_reference(data)?;
                    *self.state = HeaderTradeSettlementTypeDeserializerState::TaxCurrencyCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::PaymentReference(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::TaxCurrencyCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::PaymentReference(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_tax_currency_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CurrencyCodeType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::TaxCurrencyCode(None),
                );
                *self.state = HeaderTradeSettlementTypeDeserializerState::InvoiceCurrencyCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_tax_currency_code(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoiceCurrencyCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::TaxCurrencyCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::InvoiceCurrencyCode(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::TaxCurrencyCode(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_invoice_currency_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CurrencyCodeType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.invoice_currency_code.is_some() {
                    fallback.get_or_insert(
                        HeaderTradeSettlementTypeDeserializerState::InvoiceCurrencyCode(None),
                    );
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoiceIssuerReference(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoiceCurrencyCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_invoice_currency_code(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoiceIssuerReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::InvoiceCurrencyCode(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::InvoiceIssuerReference(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::InvoiceCurrencyCode(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_invoice_issuer_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::InvoiceIssuerReference(None),
                );
                *self.state = HeaderTradeSettlementTypeDeserializerState::InvoicerTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_invoice_issuer_reference(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoicerTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::InvoiceIssuerReference(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::InvoicerTradeParty(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::InvoiceIssuerReference(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_invoicer_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::InvoicerTradeParty(None),
                );
                *self.state = HeaderTradeSettlementTypeDeserializerState::InvoiceeTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_invoicer_trade_party(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoiceeTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::InvoicerTradeParty(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::InvoiceeTradeParty(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::InvoicerTradeParty(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_invoicee_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::InvoiceeTradeParty(None),
                );
                *self.state = HeaderTradeSettlementTypeDeserializerState::PayeeTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_invoicee_trade_party(data)?;
                    *self.state = HeaderTradeSettlementTypeDeserializerState::PayeeTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::InvoiceeTradeParty(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::PayeeTradeParty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::InvoiceeTradeParty(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_payee_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::PayeeTradeParty(None),
                );
                *self.state = HeaderTradeSettlementTypeDeserializerState::PayerTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_payee_trade_party(data)?;
                    *self.state = HeaderTradeSettlementTypeDeserializerState::PayerTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::PayeeTradeParty(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::PayerTradeParty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::PayeeTradeParty(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_payer_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::PayerTradeParty(None),
                );
                *self.state =
                    HeaderTradeSettlementTypeDeserializerState::TaxApplicableTradeCurrencyExchange(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_payer_trade_party(data)?;
                    * self . state = HeaderTradeSettlementTypeDeserializerState :: TaxApplicableTradeCurrencyExchange (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::PayerTradeParty(Some(
                                    deserializer,
                                )),
                            );
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: TaxApplicableTradeCurrencyExchange (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::PayerTradeParty(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_tax_applicable_trade_currency_exchange<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeCurrencyExchangeType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::TaxApplicableTradeCurrencyExchange(
                        None,
                    ),
                );
                * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementPaymentMeans (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_tax_applicable_trade_currency_exchange(data)?;
                    * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementPaymentMeans (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: TaxApplicableTradeCurrencyExchange (Some (deserializer))) ;
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementPaymentMeans (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: TaxApplicableTradeCurrencyExchange (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_trade_settlement_payment_means<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeSettlementPaymentMeansType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementPaymentMeans (None)) ;
                *self.state = HeaderTradeSettlementTypeDeserializerState::ApplicableTradeTax(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_trade_settlement_payment_means(data)?;
                    * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementPaymentMeans (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementPaymentMeans (Some (deserializer))) ;
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementPaymentMeans (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementPaymentMeans (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_trade_tax<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeTaxType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.applicable_trade_tax.len() < 1usize {
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::ApplicableTradeTax(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        HeaderTradeSettlementTypeDeserializerState::ApplicableTradeTax(None),
                    );
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::BillingSpecifiedPeriod(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_trade_tax(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::ApplicableTradeTax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::ApplicableTradeTax(
                                    Some(deserializer),
                                ),
                            );
                            if self.applicable_trade_tax.len().saturating_add(1) < 1usize {
                                *self.state =
                                    HeaderTradeSettlementTypeDeserializerState::ApplicableTradeTax(
                                        None,
                                    );
                            } else {
                                * self . state = HeaderTradeSettlementTypeDeserializerState :: BillingSpecifiedPeriod (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::ApplicableTradeTax(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_billing_specified_period<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SpecifiedPeriodType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::BillingSpecifiedPeriod(None),
                );
                *self.state =
                    HeaderTradeSettlementTypeDeserializerState::SpecifiedTradeAllowanceCharge(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_billing_specified_period(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::SpecifiedTradeAllowanceCharge(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::BillingSpecifiedPeriod(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeAllowanceCharge (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::BillingSpecifiedPeriod(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_trade_allowance_charge<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeAllowanceChargeType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::SpecifiedTradeAllowanceCharge(None),
                );
                *self.state =
                    HeaderTradeSettlementTypeDeserializerState::SpecifiedLogisticsServiceCharge(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_trade_allowance_charge(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::SpecifiedTradeAllowanceCharge(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeAllowanceCharge (Some (deserializer))) ;
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeAllowanceCharge (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeAllowanceCharge (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_logistics_service_charge<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LogisticsServiceChargeType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::SpecifiedLogisticsServiceCharge(
                        None,
                    ),
                );
                *self.state =
                    HeaderTradeSettlementTypeDeserializerState::SpecifiedTradePaymentTerms(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_logistics_service_charge(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::SpecifiedLogisticsServiceCharge(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: SpecifiedLogisticsServiceCharge (Some (deserializer))) ;
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedLogisticsServiceCharge (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedLogisticsServiceCharge (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_trade_payment_terms<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePaymentTermsType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::SpecifiedTradePaymentTerms(None),
                );
                * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementHeaderMonetarySummation (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_trade_payment_terms(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::SpecifiedTradePaymentTerms(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradePaymentTerms (Some (deserializer))) ;
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradePaymentTerms (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradePaymentTerms (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_trade_settlement_header_monetary_summation<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeSettlementHeaderMonetarySummationType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self
                    .specified_trade_settlement_header_monetary_summation
                    .is_some()
                {
                    fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementHeaderMonetarySummation (None)) ;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementHeaderMonetarySummation (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_trade_settlement_header_monetary_summation(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementHeaderMonetarySummation (Some (deserializer))) ;
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: InvoiceReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementHeaderMonetarySummation (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_invoice_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(None),
                );
                * self . state = HeaderTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_invoice_referenced_document(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: InvoiceReferencedDocument (Some (deserializer))) ;
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: InvoiceReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: InvoiceReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_receivable_specified_trade_accounting_account<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeAccountingAccountType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (None)) ;
                *self.state =
                    HeaderTradeSettlementTypeDeserializerState::SpecifiedAdvancePayment(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_receivable_specified_trade_accounting_account(data)?;
                    * self . state = HeaderTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (HeaderTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (Some (deserializer))) ;
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = HeaderTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_advance_payment<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AdvancePaymentType>,
            fallback: &mut Option<HeaderTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    HeaderTradeSettlementTypeDeserializerState::SpecifiedAdvancePayment(None),
                );
                *self.state = HeaderTradeSettlementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_advance_payment(data)?;
                    *self.state =
                        HeaderTradeSettlementTypeDeserializerState::SpecifiedAdvancePayment(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderTradeSettlementTypeDeserializerState::SpecifiedAdvancePayment(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::SpecifiedAdvancePayment(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderTradeSettlementTypeDeserializerState::SpecifiedAdvancePayment(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::HeaderTradeSettlementType>
        for HeaderTradeSettlementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderTradeSettlementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderTradeSettlementType>
        where
            R: DeserializeReader,
        {
            use HeaderTradeSettlementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CreditorReferenceId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_creditor_reference_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PaymentReference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_payment_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TaxCurrencyCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tax_currency_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InvoiceCurrencyCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_invoice_currency_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InvoiceIssuerReference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_invoice_issuer_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InvoicerTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_invoicer_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InvoiceeTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_invoicee_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PayeeTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_payee_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PayerTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_payer_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TaxApplicableTradeCurrencyExchange(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tax_applicable_trade_currency_exchange(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedTradeSettlementPaymentMeans(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_trade_settlement_payment_means(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableTradeTax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_trade_tax(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BillingSpecifiedPeriod(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_billing_specified_period(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedTradeAllowanceCharge(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_trade_allowance_charge(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedLogisticsServiceCharge(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_logistics_service_charge(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedTradePaymentTerms(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_trade_payment_terms(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (
                        S::SpecifiedTradeSettlementHeaderMonetarySummation(Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_trade_settlement_header_monetary_summation(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InvoiceReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_invoice_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReceivableSpecifiedTradeAccountingAccount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_receivable_specified_trade_accounting_account(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedAdvancePayment(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_advance_payment(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            HeaderTradeSettlementTypeDeserializerState::CreditorReferenceId(None);
                        event
                    }
                    (S::CreditorReferenceId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CreditorReferenceID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_creditor_reference_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PaymentReference(None);
                            event
                        }
                    }
                    (S::PaymentReference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PaymentReference",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_payment_reference(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TaxCurrencyCode(None);
                            event
                        }
                    }
                    (S::TaxCurrencyCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TaxCurrencyCode",
                        ) {
                            let output =
                                <super::CurrencyCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_tax_currency_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InvoiceCurrencyCode(None);
                            event
                        }
                    }
                    (S::InvoiceCurrencyCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"InvoiceCurrencyCode",
                        ) {
                            let output =
                                <super::CurrencyCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_invoice_currency_code(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InvoiceIssuerReference(None);
                            event
                        }
                    }
                    (
                        S::InvoiceIssuerReference(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"InvoiceIssuerReference",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_invoice_issuer_reference(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InvoicerTradeParty(None);
                            event
                        }
                    }
                    (S::InvoicerTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"InvoicerTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_invoicer_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InvoiceeTradeParty(None);
                            event
                        }
                    }
                    (S::InvoiceeTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"InvoiceeTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_invoicee_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PayeeTradeParty(None);
                            event
                        }
                    }
                    (S::PayeeTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PayeeTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_payee_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PayerTradeParty(None);
                            event
                        }
                    }
                    (S::PayerTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PayerTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_payer_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TaxApplicableTradeCurrencyExchange(None);
                            event
                        }
                    }
                    (
                        S::TaxApplicableTradeCurrencyExchange(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TaxApplicableTradeCurrencyExchange",
                        ) {
                            let output = < super :: TradeCurrencyExchangeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_tax_applicable_trade_currency_exchange(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedTradeSettlementPaymentMeans(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedTradeSettlementPaymentMeans(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedTradeSettlementPaymentMeans",
                        ) {
                            let output = < super :: TradeSettlementPaymentMeansType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_trade_settlement_payment_means(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableTradeTax(None);
                            event
                        }
                    }
                    (S::ApplicableTradeTax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableTradeTax",
                        ) {
                            let output =
                                <super::TradeTaxType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_applicable_trade_tax(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BillingSpecifiedPeriod(None);
                            event
                        }
                    }
                    (
                        S::BillingSpecifiedPeriod(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BillingSpecifiedPeriod",
                        ) {
                            let output = < super :: SpecifiedPeriodType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_billing_specified_period(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedTradeAllowanceCharge(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedTradeAllowanceCharge(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedTradeAllowanceCharge",
                        ) {
                            let output = < super :: TradeAllowanceChargeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_trade_allowance_charge(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedLogisticsServiceCharge(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedLogisticsServiceCharge(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedLogisticsServiceCharge",
                        ) {
                            let output = < super :: LogisticsServiceChargeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_logistics_service_charge(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedTradePaymentTerms(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedTradePaymentTerms(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedTradePaymentTerms",
                        ) {
                            let output = < super :: TradePaymentTermsType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_trade_payment_terms(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedTradeSettlementHeaderMonetarySummation(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedTradeSettlementHeaderMonetarySummation(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedTradeSettlementHeaderMonetarySummation",
                        ) {
                            let output = < super :: TradeSettlementHeaderMonetarySummationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_trade_settlement_header_monetary_summation(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InvoiceReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::InvoiceReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"InvoiceReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_invoice_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReceivableSpecifiedTradeAccountingAccount(None);
                            event
                        }
                    }
                    (
                        S::ReceivableSpecifiedTradeAccountingAccount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ReceivableSpecifiedTradeAccountingAccount",
                        ) {
                            let output = < super :: TradeAccountingAccountType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_receivable_specified_trade_accounting_account(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedAdvancePayment(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedAdvancePayment(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedAdvancePayment",
                        ) {
                            let output = < super :: AdvancePaymentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_advance_payment(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::HeaderTradeSettlementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                HeaderTradeSettlementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::HeaderTradeSettlementType {
                creditor_reference_id: self.creditor_reference_id,
                payment_reference: self.payment_reference,
                tax_currency_code: self.tax_currency_code,
                invoice_currency_code: self
                    .invoice_currency_code
                    .ok_or_else(|| ErrorKind::MissingElement("InvoiceCurrencyCode".into()))?,
                invoice_issuer_reference: self.invoice_issuer_reference,
                invoicer_trade_party: self.invoicer_trade_party,
                invoicee_trade_party: self.invoicee_trade_party,
                payee_trade_party: self.payee_trade_party,
                payer_trade_party: self.payer_trade_party,
                tax_applicable_trade_currency_exchange: self.tax_applicable_trade_currency_exchange,
                specified_trade_settlement_payment_means: self
                    .specified_trade_settlement_payment_means,
                applicable_trade_tax: self.applicable_trade_tax,
                billing_specified_period: self.billing_specified_period,
                specified_trade_allowance_charge: self.specified_trade_allowance_charge,
                specified_logistics_service_charge: self.specified_logistics_service_charge,
                specified_trade_payment_terms: self.specified_trade_payment_terms,
                specified_trade_settlement_header_monetary_summation: self
                    .specified_trade_settlement_header_monetary_summation
                    .ok_or_else(|| {
                        ErrorKind::MissingElement(
                            "SpecifiedTradeSettlementHeaderMonetarySummation".into(),
                        )
                    })?,
                invoice_referenced_document: self.invoice_referenced_document,
                receivable_specified_trade_accounting_account: self
                    .receivable_specified_trade_accounting_account,
                specified_advance_payment: self.specified_advance_payment,
            })
        }
    }
    #[derive(Debug)]
    pub struct DateTimeTypeDateTimeStringTypeDeserializer {
        format: String,
        content: Option<String>,
        state: Box<DateTimeTypeDateTimeStringTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DateTimeTypeDateTimeStringTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DateTimeTypeDateTimeStringTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut format: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"format")
                ) {
                    reader.read_attrib(&mut format, b"format", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                format: format.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("format".into()))
                })?,
                content: None,
                state: Box::new(DateTimeTypeDateTimeStringTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DateTimeTypeDateTimeStringTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DateTimeTypeDateTimeStringTypeDeserializerState::Content__(deserializer) = state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::DateTimeTypeDateTimeStringType>
        where
            R: DeserializeReader,
        {
            use DateTimeTypeDateTimeStringTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::DateTimeTypeDateTimeStringType>
        for DateTimeTypeDateTimeStringTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateTimeTypeDateTimeStringType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateTimeTypeDateTimeStringType>
        where
            R: DeserializeReader,
        {
            use DateTimeTypeDateTimeStringTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DateTimeTypeDateTimeStringType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DateTimeTypeDateTimeStringTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DateTimeTypeDateTimeStringType {
                format: self.format,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CodeTypeDeserializer {
        list_id: Option<String>,
        list_version_id: Option<String>,
        content: Option<String>,
        state: Box<CodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut list_id: Option<String> = None;
            let mut list_version_id: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"listID")
                ) {
                    reader.read_attrib(&mut list_id, b"listID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"listVersionID")
                ) {
                    reader.read_attrib(&mut list_version_id, b"listVersionID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                list_id: list_id,
                list_version_id: list_version_id,
                content: None,
                state: Box::new(CodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::CodeType>
        where
            R: DeserializeReader,
        {
            use CodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::CodeType> for CodeTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CodeType>
        where
            R: DeserializeReader,
        {
            use CodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CodeTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CodeType {
                list_id: self.list_id,
                list_version_id: self.list_version_id,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocumentLineDocumentTypeDeserializer {
        line_id: Option<super::IdType>,
        parent_line_id: Option<super::IdType>,
        line_status_code: Option<super::LineStatusCodeType>,
        line_status_reason_code: Option<super::CodeType>,
        included_note: Vec<super::NoteType>,
        state: Box<DocumentLineDocumentTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentLineDocumentTypeDeserializerState {
        Init__,
        LineId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        ParentLineId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        LineStatusCode(Option<<super::LineStatusCodeType as WithDeserializer>::Deserializer>),
        LineStatusReasonCode(Option<<super::CodeType as WithDeserializer>::Deserializer>),
        IncludedNote(Option<<super::NoteType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DocumentLineDocumentTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                line_id: None,
                parent_line_id: None,
                line_status_code: None,
                line_status_reason_code: None,
                included_note: Vec::new(),
                state: Box::new(DocumentLineDocumentTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentLineDocumentTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocumentLineDocumentTypeDeserializerState as S;
            match state {
                S::LineId(Some(deserializer)) => {
                    self.store_line_id(deserializer.finish(reader)?)?
                }
                S::ParentLineId(Some(deserializer)) => {
                    self.store_parent_line_id(deserializer.finish(reader)?)?
                }
                S::LineStatusCode(Some(deserializer)) => {
                    self.store_line_status_code(deserializer.finish(reader)?)?
                }
                S::LineStatusReasonCode(Some(deserializer)) => {
                    self.store_line_status_reason_code(deserializer.finish(reader)?)?
                }
                S::IncludedNote(Some(deserializer)) => {
                    self.store_included_note(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_line_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.line_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineID",
                )))?;
            }
            self.line_id = Some(value);
            Ok(())
        }
        fn store_parent_line_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.parent_line_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ParentLineID",
                )))?;
            }
            self.parent_line_id = Some(value);
            Ok(())
        }
        fn store_line_status_code(
            &mut self,
            value: super::LineStatusCodeType,
        ) -> Result<(), Error> {
            if self.line_status_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineStatusCode",
                )))?;
            }
            self.line_status_code = Some(value);
            Ok(())
        }
        fn store_line_status_reason_code(&mut self, value: super::CodeType) -> Result<(), Error> {
            if self.line_status_reason_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineStatusReasonCode",
                )))?;
            }
            self.line_status_reason_code = Some(value);
            Ok(())
        }
        fn store_included_note(&mut self, value: super::NoteType) -> Result<(), Error> {
            self.included_note.push(value);
            Ok(())
        }
        fn handle_line_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<DocumentLineDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.line_id.is_some() {
                    fallback.get_or_insert(DocumentLineDocumentTypeDeserializerState::LineId(None));
                    *self.state = DocumentLineDocumentTypeDeserializerState::ParentLineId(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DocumentLineDocumentTypeDeserializerState::LineId(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_id(data)?;
                    *self.state = DocumentLineDocumentTypeDeserializerState::ParentLineId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentLineDocumentTypeDeserializerState::LineId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                DocumentLineDocumentTypeDeserializerState::ParentLineId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentLineDocumentTypeDeserializerState::LineId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_parent_line_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<DocumentLineDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentLineDocumentTypeDeserializerState::ParentLineId(
                    None,
                ));
                *self.state = DocumentLineDocumentTypeDeserializerState::LineStatusCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_parent_line_id(data)?;
                    *self.state = DocumentLineDocumentTypeDeserializerState::LineStatusCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentLineDocumentTypeDeserializerState::ParentLineId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                DocumentLineDocumentTypeDeserializerState::LineStatusCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentLineDocumentTypeDeserializerState::ParentLineId(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_line_status_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LineStatusCodeType>,
            fallback: &mut Option<DocumentLineDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentLineDocumentTypeDeserializerState::LineStatusCode(
                    None,
                ));
                *self.state = DocumentLineDocumentTypeDeserializerState::LineStatusReasonCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_status_code(data)?;
                    *self.state =
                        DocumentLineDocumentTypeDeserializerState::LineStatusReasonCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentLineDocumentTypeDeserializerState::LineStatusCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                DocumentLineDocumentTypeDeserializerState::LineStatusReasonCode(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentLineDocumentTypeDeserializerState::LineStatusCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_line_status_reason_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CodeType>,
            fallback: &mut Option<DocumentLineDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    DocumentLineDocumentTypeDeserializerState::LineStatusReasonCode(None),
                );
                *self.state = DocumentLineDocumentTypeDeserializerState::IncludedNote(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_status_reason_code(data)?;
                    *self.state = DocumentLineDocumentTypeDeserializerState::IncludedNote(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentLineDocumentTypeDeserializerState::LineStatusReasonCode(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                DocumentLineDocumentTypeDeserializerState::IncludedNote(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentLineDocumentTypeDeserializerState::LineStatusReasonCode(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_included_note<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::NoteType>,
            fallback: &mut Option<DocumentLineDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentLineDocumentTypeDeserializerState::IncludedNote(
                    None,
                ));
                *self.state = DocumentLineDocumentTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_included_note(data)?;
                    *self.state = DocumentLineDocumentTypeDeserializerState::IncludedNote(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentLineDocumentTypeDeserializerState::IncludedNote(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                DocumentLineDocumentTypeDeserializerState::IncludedNote(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentLineDocumentTypeDeserializerState::IncludedNote(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocumentLineDocumentType>
        for DocumentLineDocumentTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentLineDocumentType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentLineDocumentType>
        where
            R: DeserializeReader,
        {
            use DocumentLineDocumentTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::LineId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ParentLineId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_parent_line_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LineStatusCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_status_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LineStatusReasonCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_status_reason_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IncludedNote(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_included_note(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = DocumentLineDocumentTypeDeserializerState::LineId(None);
                        event
                    }
                    (S::LineId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"LineID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_line_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ParentLineId(None);
                            event
                        }
                    }
                    (S::ParentLineId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ParentLineID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_parent_line_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LineStatusCode(None);
                            event
                        }
                    }
                    (S::LineStatusCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"LineStatusCode",
                        ) {
                            let output = < super :: LineStatusCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_line_status_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LineStatusReasonCode(None);
                            event
                        }
                    }
                    (
                        S::LineStatusReasonCode(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"LineStatusReasonCode",
                        ) {
                            let output = <super::CodeType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_line_status_reason_code(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IncludedNote(None);
                            event
                        }
                    }
                    (S::IncludedNote(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IncludedNote",
                        ) {
                            let output = <super::NoteType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_included_note(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentLineDocumentType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentLineDocumentTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentLineDocumentType {
                line_id: self
                    .line_id
                    .ok_or_else(|| ErrorKind::MissingElement("LineID".into()))?,
                parent_line_id: self.parent_line_id,
                line_status_code: self.line_status_code,
                line_status_reason_code: self.line_status_reason_code,
                included_note: self.included_note,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeProductTypeDeserializer {
        id: Option<super::IdType>,
        global_id: Option<super::IdType>,
        seller_assigned_id: Option<super::IdType>,
        buyer_assigned_id: Option<super::IdType>,
        industry_assigned_id: Option<super::IdType>,
        model_id: Option<super::IdType>,
        name: Option<super::TextType>,
        description: Option<super::TextType>,
        batch_id: Vec<super::IdType>,
        brand_name: Option<super::TextType>,
        model_name: Option<super::TextType>,
        applicable_product_characteristic: Vec<super::ProductCharacteristicType>,
        designated_product_classification: Vec<super::ProductClassificationType>,
        individual_trade_product_instance: Vec<super::TradeProductInstanceType>,
        origin_trade_country: Option<super::TradeCountryType>,
        included_referenced_product: Vec<super::ReferencedProductType>,
        state: Box<TradeProductTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeProductTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        GlobalId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        SellerAssignedId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        BuyerAssignedId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        IndustryAssignedId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        ModelId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Name(Option<<super::TextType as WithDeserializer>::Deserializer>),
        Description(Option<<super::TextType as WithDeserializer>::Deserializer>),
        BatchId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        BrandName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        ModelName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        ApplicableProductCharacteristic(
            Option<<super::ProductCharacteristicType as WithDeserializer>::Deserializer>,
        ),
        DesignatedProductClassification(
            Option<<super::ProductClassificationType as WithDeserializer>::Deserializer>,
        ),
        IndividualTradeProductInstance(
            Option<<super::TradeProductInstanceType as WithDeserializer>::Deserializer>,
        ),
        OriginTradeCountry(Option<<super::TradeCountryType as WithDeserializer>::Deserializer>),
        IncludedReferencedProduct(
            Option<<super::ReferencedProductType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TradeProductTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                global_id: None,
                seller_assigned_id: None,
                buyer_assigned_id: None,
                industry_assigned_id: None,
                model_id: None,
                name: None,
                description: None,
                batch_id: Vec::new(),
                brand_name: None,
                model_name: None,
                applicable_product_characteristic: Vec::new(),
                designated_product_classification: Vec::new(),
                individual_trade_product_instance: Vec::new(),
                origin_trade_country: None,
                included_referenced_product: Vec::new(),
                state: Box::new(TradeProductTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeProductTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeProductTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                S::GlobalId(Some(deserializer)) => {
                    self.store_global_id(deserializer.finish(reader)?)?
                }
                S::SellerAssignedId(Some(deserializer)) => {
                    self.store_seller_assigned_id(deserializer.finish(reader)?)?
                }
                S::BuyerAssignedId(Some(deserializer)) => {
                    self.store_buyer_assigned_id(deserializer.finish(reader)?)?
                }
                S::IndustryAssignedId(Some(deserializer)) => {
                    self.store_industry_assigned_id(deserializer.finish(reader)?)?
                }
                S::ModelId(Some(deserializer)) => {
                    self.store_model_id(deserializer.finish(reader)?)?
                }
                S::Name(Some(deserializer)) => self.store_name(deserializer.finish(reader)?)?,
                S::Description(Some(deserializer)) => {
                    self.store_description(deserializer.finish(reader)?)?
                }
                S::BatchId(Some(deserializer)) => {
                    self.store_batch_id(deserializer.finish(reader)?)?
                }
                S::BrandName(Some(deserializer)) => {
                    self.store_brand_name(deserializer.finish(reader)?)?
                }
                S::ModelName(Some(deserializer)) => {
                    self.store_model_name(deserializer.finish(reader)?)?
                }
                S::ApplicableProductCharacteristic(Some(deserializer)) => {
                    self.store_applicable_product_characteristic(deserializer.finish(reader)?)?
                }
                S::DesignatedProductClassification(Some(deserializer)) => {
                    self.store_designated_product_classification(deserializer.finish(reader)?)?
                }
                S::IndividualTradeProductInstance(Some(deserializer)) => {
                    self.store_individual_trade_product_instance(deserializer.finish(reader)?)?
                }
                S::OriginTradeCountry(Some(deserializer)) => {
                    self.store_origin_trade_country(deserializer.finish(reader)?)?
                }
                S::IncludedReferencedProduct(Some(deserializer)) => {
                    self.store_included_referenced_product(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn store_global_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.global_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GlobalID",
                )))?;
            }
            self.global_id = Some(value);
            Ok(())
        }
        fn store_seller_assigned_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.seller_assigned_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SellerAssignedID",
                )))?;
            }
            self.seller_assigned_id = Some(value);
            Ok(())
        }
        fn store_buyer_assigned_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.buyer_assigned_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BuyerAssignedID",
                )))?;
            }
            self.buyer_assigned_id = Some(value);
            Ok(())
        }
        fn store_industry_assigned_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.industry_assigned_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"IndustryAssignedID",
                )))?;
            }
            self.industry_assigned_id = Some(value);
            Ok(())
        }
        fn store_model_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.model_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ModelID",
                )))?;
            }
            self.model_id = Some(value);
            Ok(())
        }
        fn store_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Name")))?;
            }
            self.name = Some(value);
            Ok(())
        }
        fn store_description(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.description.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Description",
                )))?;
            }
            self.description = Some(value);
            Ok(())
        }
        fn store_batch_id(&mut self, value: super::IdType) -> Result<(), Error> {
            self.batch_id.push(value);
            Ok(())
        }
        fn store_brand_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.brand_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BrandName",
                )))?;
            }
            self.brand_name = Some(value);
            Ok(())
        }
        fn store_model_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.model_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ModelName",
                )))?;
            }
            self.model_name = Some(value);
            Ok(())
        }
        fn store_applicable_product_characteristic(
            &mut self,
            value: super::ProductCharacteristicType,
        ) -> Result<(), Error> {
            self.applicable_product_characteristic.push(value);
            Ok(())
        }
        fn store_designated_product_classification(
            &mut self,
            value: super::ProductClassificationType,
        ) -> Result<(), Error> {
            self.designated_product_classification.push(value);
            Ok(())
        }
        fn store_individual_trade_product_instance(
            &mut self,
            value: super::TradeProductInstanceType,
        ) -> Result<(), Error> {
            self.individual_trade_product_instance.push(value);
            Ok(())
        }
        fn store_origin_trade_country(
            &mut self,
            value: super::TradeCountryType,
        ) -> Result<(), Error> {
            if self.origin_trade_country.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"OriginTradeCountry",
                )))?;
            }
            self.origin_trade_country = Some(value);
            Ok(())
        }
        fn store_included_referenced_product(
            &mut self,
            value: super::ReferencedProductType,
        ) -> Result<(), Error> {
            self.included_referenced_product.push(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::Id(None));
                *self.state = TradeProductTypeDeserializerState::GlobalId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = TradeProductTypeDeserializerState::GlobalId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeProductTypeDeserializerState::Id(Some(
                                deserializer,
                            )));
                            *self.state = TradeProductTypeDeserializerState::GlobalId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeProductTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_global_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::GlobalId(None));
                *self.state = TradeProductTypeDeserializerState::SellerAssignedId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_global_id(data)?;
                    *self.state = TradeProductTypeDeserializerState::SellerAssignedId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeProductTypeDeserializerState::GlobalId(
                                Some(deserializer),
                            ));
                            *self.state = TradeProductTypeDeserializerState::SellerAssignedId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::GlobalId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_seller_assigned_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::SellerAssignedId(None));
                *self.state = TradeProductTypeDeserializerState::BuyerAssignedId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_seller_assigned_id(data)?;
                    *self.state = TradeProductTypeDeserializerState::BuyerAssignedId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductTypeDeserializerState::SellerAssignedId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeProductTypeDeserializerState::BuyerAssignedId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeProductTypeDeserializerState::SellerAssignedId(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_assigned_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::BuyerAssignedId(None));
                *self.state = TradeProductTypeDeserializerState::IndustryAssignedId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_assigned_id(data)?;
                    *self.state = TradeProductTypeDeserializerState::IndustryAssignedId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductTypeDeserializerState::BuyerAssignedId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeProductTypeDeserializerState::IndustryAssignedId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeProductTypeDeserializerState::BuyerAssignedId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_industry_assigned_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::IndustryAssignedId(None));
                *self.state = TradeProductTypeDeserializerState::ModelId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_industry_assigned_id(data)?;
                    *self.state = TradeProductTypeDeserializerState::ModelId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductTypeDeserializerState::IndustryAssignedId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeProductTypeDeserializerState::ModelId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeProductTypeDeserializerState::IndustryAssignedId(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_model_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::ModelId(None));
                *self.state = TradeProductTypeDeserializerState::Name(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_model_id(data)?;
                    *self.state = TradeProductTypeDeserializerState::Name(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeProductTypeDeserializerState::ModelId(
                                Some(deserializer),
                            ));
                            *self.state = TradeProductTypeDeserializerState::Name(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::ModelId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.name.is_some() {
                    fallback.get_or_insert(TradeProductTypeDeserializerState::Name(None));
                    *self.state = TradeProductTypeDeserializerState::Description(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeProductTypeDeserializerState::Name(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_name(data)?;
                    *self.state = TradeProductTypeDeserializerState::Description(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeProductTypeDeserializerState::Name(Some(
                                deserializer,
                            )));
                            *self.state = TradeProductTypeDeserializerState::Description(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::Name(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_description<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::Description(None));
                *self.state = TradeProductTypeDeserializerState::BatchId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description(data)?;
                    *self.state = TradeProductTypeDeserializerState::BatchId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeProductTypeDeserializerState::Description(
                                Some(deserializer),
                            ));
                            *self.state = TradeProductTypeDeserializerState::BatchId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::Description(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_batch_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::BatchId(None));
                *self.state = TradeProductTypeDeserializerState::BrandName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_batch_id(data)?;
                    *self.state = TradeProductTypeDeserializerState::BatchId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeProductTypeDeserializerState::BatchId(
                                Some(deserializer),
                            ));
                            *self.state = TradeProductTypeDeserializerState::BatchId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::BatchId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_brand_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::BrandName(None));
                *self.state = TradeProductTypeDeserializerState::ModelName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_brand_name(data)?;
                    *self.state = TradeProductTypeDeserializerState::ModelName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeProductTypeDeserializerState::BrandName(
                                Some(deserializer),
                            ));
                            *self.state = TradeProductTypeDeserializerState::ModelName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::BrandName(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_model_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::ModelName(None));
                *self.state =
                    TradeProductTypeDeserializerState::ApplicableProductCharacteristic(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_model_name(data)?;
                    *self.state =
                        TradeProductTypeDeserializerState::ApplicableProductCharacteristic(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeProductTypeDeserializerState::ModelName(
                                Some(deserializer),
                            ));
                            *self.state =
                                TradeProductTypeDeserializerState::ApplicableProductCharacteristic(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::ModelName(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_product_characteristic<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductCharacteristicType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeProductTypeDeserializerState::ApplicableProductCharacteristic(None),
                );
                *self.state =
                    TradeProductTypeDeserializerState::DesignatedProductClassification(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_product_characteristic(data)?;
                    *self.state =
                        TradeProductTypeDeserializerState::ApplicableProductCharacteristic(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductTypeDeserializerState::ApplicableProductCharacteristic(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradeProductTypeDeserializerState::ApplicableProductCharacteristic(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::ApplicableProductCharacteristic(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_designated_product_classification<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductClassificationType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeProductTypeDeserializerState::DesignatedProductClassification(None),
                );
                *self.state =
                    TradeProductTypeDeserializerState::IndividualTradeProductInstance(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_designated_product_classification(data)?;
                    *self.state =
                        TradeProductTypeDeserializerState::DesignatedProductClassification(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductTypeDeserializerState::DesignatedProductClassification(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradeProductTypeDeserializerState::DesignatedProductClassification(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::DesignatedProductClassification(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_individual_trade_product_instance<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeProductInstanceType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeProductTypeDeserializerState::IndividualTradeProductInstance(None),
                );
                *self.state = TradeProductTypeDeserializerState::OriginTradeCountry(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_individual_trade_product_instance(data)?;
                    *self.state =
                        TradeProductTypeDeserializerState::IndividualTradeProductInstance(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductTypeDeserializerState::IndividualTradeProductInstance(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradeProductTypeDeserializerState::IndividualTradeProductInstance(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::IndividualTradeProductInstance(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_origin_trade_country<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeCountryType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductTypeDeserializerState::OriginTradeCountry(None));
                *self.state = TradeProductTypeDeserializerState::IncludedReferencedProduct(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_origin_trade_country(data)?;
                    *self.state =
                        TradeProductTypeDeserializerState::IncludedReferencedProduct(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductTypeDeserializerState::OriginTradeCountry(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeProductTypeDeserializerState::IncludedReferencedProduct(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeProductTypeDeserializerState::OriginTradeCountry(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_included_referenced_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedProductType>,
            fallback: &mut Option<TradeProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeProductTypeDeserializerState::IncludedReferencedProduct(None),
                );
                *self.state = TradeProductTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_included_referenced_product(data)?;
                    *self.state =
                        TradeProductTypeDeserializerState::IncludedReferencedProduct(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductTypeDeserializerState::IncludedReferencedProduct(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeProductTypeDeserializerState::IncludedReferencedProduct(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductTypeDeserializerState::IncludedReferencedProduct(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeProductType> for TradeProductTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeProductType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeProductType>
        where
            R: DeserializeReader,
        {
            use TradeProductTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::GlobalId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_global_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SellerAssignedId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_seller_assigned_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerAssignedId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_assigned_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IndustryAssignedId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_industry_assigned_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ModelId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_model_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Name(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Description(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BatchId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_batch_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BrandName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_brand_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ModelName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_model_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableProductCharacteristic(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_product_characteristic(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DesignatedProductClassification(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_designated_product_classification(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IndividualTradeProductInstance(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_individual_trade_product_instance(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::OriginTradeCountry(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_origin_trade_country(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IncludedReferencedProduct(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_included_referenced_product(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradeProductTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::GlobalId(None);
                            event
                        }
                    }
                    (S::GlobalId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"GlobalID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_global_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SellerAssignedId(None);
                            event
                        }
                    }
                    (S::SellerAssignedId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SellerAssignedID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_seller_assigned_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerAssignedId(None);
                            event
                        }
                    }
                    (S::BuyerAssignedId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BuyerAssignedID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_buyer_assigned_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IndustryAssignedId(None);
                            event
                        }
                    }
                    (S::IndustryAssignedId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IndustryAssignedID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_industry_assigned_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ModelId(None);
                            event
                        }
                    }
                    (S::ModelId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ModelID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_model_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Name(None);
                            event
                        }
                    }
                    (S::Name(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Name") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Description(None);
                            event
                        }
                    }
                    (S::Description(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Description")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_description(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BatchId(None);
                            event
                        }
                    }
                    (S::BatchId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"BatchID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_batch_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BrandName(None);
                            event
                        }
                    }
                    (S::BrandName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"BrandName") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_brand_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ModelName(None);
                            event
                        }
                    }
                    (S::ModelName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ModelName") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_model_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableProductCharacteristic(None);
                            event
                        }
                    }
                    (
                        S::ApplicableProductCharacteristic(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableProductCharacteristic",
                        ) {
                            let output = < super :: ProductCharacteristicType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applicable_product_characteristic(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DesignatedProductClassification(None);
                            event
                        }
                    }
                    (
                        S::DesignatedProductClassification(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DesignatedProductClassification",
                        ) {
                            let output = < super :: ProductClassificationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_designated_product_classification(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IndividualTradeProductInstance(None);
                            event
                        }
                    }
                    (
                        S::IndividualTradeProductInstance(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IndividualTradeProductInstance",
                        ) {
                            let output = < super :: TradeProductInstanceType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_individual_trade_product_instance(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::OriginTradeCountry(None);
                            event
                        }
                    }
                    (S::OriginTradeCountry(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"OriginTradeCountry",
                        ) {
                            let output =
                                <super::TradeCountryType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_origin_trade_country(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IncludedReferencedProduct(None);
                            event
                        }
                    }
                    (
                        S::IncludedReferencedProduct(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IncludedReferencedProduct",
                        ) {
                            let output = < super :: ReferencedProductType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_included_referenced_product(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeProductType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeProductTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeProductType {
                id: self.id,
                global_id: self.global_id,
                seller_assigned_id: self.seller_assigned_id,
                buyer_assigned_id: self.buyer_assigned_id,
                industry_assigned_id: self.industry_assigned_id,
                model_id: self.model_id,
                name: self
                    .name
                    .ok_or_else(|| ErrorKind::MissingElement("Name".into()))?,
                description: self.description,
                batch_id: self.batch_id,
                brand_name: self.brand_name,
                model_name: self.model_name,
                applicable_product_characteristic: self.applicable_product_characteristic,
                designated_product_classification: self.designated_product_classification,
                individual_trade_product_instance: self.individual_trade_product_instance,
                origin_trade_country: self.origin_trade_country,
                included_referenced_product: self.included_referenced_product,
            })
        }
    }
    #[derive(Debug)]
    pub struct LineTradeAgreementTypeDeserializer {
        seller_order_referenced_document: Option<super::ReferencedDocumentType>,
        buyer_order_referenced_document: Option<super::ReferencedDocumentType>,
        quotation_referenced_document: Option<super::ReferencedDocumentType>,
        contract_referenced_document: Option<super::ReferencedDocumentType>,
        additional_referenced_document: Vec<super::ReferencedDocumentType>,
        gross_price_product_trade_price: Option<super::TradePriceType>,
        net_price_product_trade_price: Option<super::TradePriceType>,
        ultimate_customer_order_referenced_document: Vec<super::ReferencedDocumentType>,
        state: Box<LineTradeAgreementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LineTradeAgreementTypeDeserializerState {
        Init__,
        SellerOrderReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        BuyerOrderReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        QuotationReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        ContractReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        AdditionalReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        GrossPriceProductTradePrice(
            Option<<super::TradePriceType as WithDeserializer>::Deserializer>,
        ),
        NetPriceProductTradePrice(
            Option<<super::TradePriceType as WithDeserializer>::Deserializer>,
        ),
        UltimateCustomerOrderReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl LineTradeAgreementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                seller_order_referenced_document: None,
                buyer_order_referenced_document: None,
                quotation_referenced_document: None,
                contract_referenced_document: None,
                additional_referenced_document: Vec::new(),
                gross_price_product_trade_price: None,
                net_price_product_trade_price: None,
                ultimate_customer_order_referenced_document: Vec::new(),
                state: Box::new(LineTradeAgreementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LineTradeAgreementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use LineTradeAgreementTypeDeserializerState as S;
            match state {
                S::SellerOrderReferencedDocument(Some(deserializer)) => {
                    self.store_seller_order_referenced_document(deserializer.finish(reader)?)?
                }
                S::BuyerOrderReferencedDocument(Some(deserializer)) => {
                    self.store_buyer_order_referenced_document(deserializer.finish(reader)?)?
                }
                S::QuotationReferencedDocument(Some(deserializer)) => {
                    self.store_quotation_referenced_document(deserializer.finish(reader)?)?
                }
                S::ContractReferencedDocument(Some(deserializer)) => {
                    self.store_contract_referenced_document(deserializer.finish(reader)?)?
                }
                S::AdditionalReferencedDocument(Some(deserializer)) => {
                    self.store_additional_referenced_document(deserializer.finish(reader)?)?
                }
                S::GrossPriceProductTradePrice(Some(deserializer)) => {
                    self.store_gross_price_product_trade_price(deserializer.finish(reader)?)?
                }
                S::NetPriceProductTradePrice(Some(deserializer)) => {
                    self.store_net_price_product_trade_price(deserializer.finish(reader)?)?
                }
                S::UltimateCustomerOrderReferencedDocument(Some(deserializer)) => self
                    .store_ultimate_customer_order_referenced_document(
                        deserializer.finish(reader)?,
                    )?,
                _ => (),
            }
            Ok(())
        }
        fn store_seller_order_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.seller_order_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SellerOrderReferencedDocument",
                )))?;
            }
            self.seller_order_referenced_document = Some(value);
            Ok(())
        }
        fn store_buyer_order_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.buyer_order_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BuyerOrderReferencedDocument",
                )))?;
            }
            self.buyer_order_referenced_document = Some(value);
            Ok(())
        }
        fn store_quotation_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.quotation_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"QuotationReferencedDocument",
                )))?;
            }
            self.quotation_referenced_document = Some(value);
            Ok(())
        }
        fn store_contract_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.contract_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ContractReferencedDocument",
                )))?;
            }
            self.contract_referenced_document = Some(value);
            Ok(())
        }
        fn store_additional_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            self.additional_referenced_document.push(value);
            Ok(())
        }
        fn store_gross_price_product_trade_price(
            &mut self,
            value: super::TradePriceType,
        ) -> Result<(), Error> {
            if self.gross_price_product_trade_price.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GrossPriceProductTradePrice",
                )))?;
            }
            self.gross_price_product_trade_price = Some(value);
            Ok(())
        }
        fn store_net_price_product_trade_price(
            &mut self,
            value: super::TradePriceType,
        ) -> Result<(), Error> {
            if self.net_price_product_trade_price.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"NetPriceProductTradePrice",
                )))?;
            }
            self.net_price_product_trade_price = Some(value);
            Ok(())
        }
        fn store_ultimate_customer_order_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            self.ultimate_customer_order_referenced_document.push(value);
            Ok(())
        }
        fn handle_seller_order_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeAgreementTypeDeserializerState::SellerOrderReferencedDocument(None),
                );
                *self.state =
                    LineTradeAgreementTypeDeserializerState::BuyerOrderReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_seller_order_referenced_document(data)?;
                    *self.state =
                        LineTradeAgreementTypeDeserializerState::BuyerOrderReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeAgreementTypeDeserializerState :: SellerOrderReferencedDocument (Some (deserializer))) ;
                            * self . state = LineTradeAgreementTypeDeserializerState :: BuyerOrderReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeAgreementTypeDeserializerState :: SellerOrderReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_order_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeAgreementTypeDeserializerState::BuyerOrderReferencedDocument(None),
                );
                *self.state =
                    LineTradeAgreementTypeDeserializerState::QuotationReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_order_referenced_document(data)?;
                    *self.state =
                        LineTradeAgreementTypeDeserializerState::QuotationReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeAgreementTypeDeserializerState :: BuyerOrderReferencedDocument (Some (deserializer))) ;
                            * self . state = LineTradeAgreementTypeDeserializerState :: QuotationReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeAgreementTypeDeserializerState :: BuyerOrderReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_quotation_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeAgreementTypeDeserializerState::QuotationReferencedDocument(None),
                );
                *self.state =
                    LineTradeAgreementTypeDeserializerState::ContractReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_quotation_referenced_document(data)?;
                    *self.state =
                        LineTradeAgreementTypeDeserializerState::ContractReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeAgreementTypeDeserializerState :: QuotationReferencedDocument (Some (deserializer))) ;
                            *self.state =
                                LineTradeAgreementTypeDeserializerState::ContractReferencedDocument(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeAgreementTypeDeserializerState :: QuotationReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_contract_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeAgreementTypeDeserializerState::ContractReferencedDocument(None),
                );
                *self.state =
                    LineTradeAgreementTypeDeserializerState::AdditionalReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_contract_referenced_document(data)?;
                    *self.state =
                        LineTradeAgreementTypeDeserializerState::AdditionalReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeAgreementTypeDeserializerState::ContractReferencedDocument(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = LineTradeAgreementTypeDeserializerState :: AdditionalReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LineTradeAgreementTypeDeserializerState::ContractReferencedDocument(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_additional_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeAgreementTypeDeserializerState::AdditionalReferencedDocument(None),
                );
                *self.state =
                    LineTradeAgreementTypeDeserializerState::GrossPriceProductTradePrice(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_additional_referenced_document(data)?;
                    *self.state =
                        LineTradeAgreementTypeDeserializerState::AdditionalReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeAgreementTypeDeserializerState :: AdditionalReferencedDocument (Some (deserializer))) ;
                            * self . state = LineTradeAgreementTypeDeserializerState :: AdditionalReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeAgreementTypeDeserializerState :: AdditionalReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_gross_price_product_trade_price<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePriceType>,
            fallback: &mut Option<LineTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeAgreementTypeDeserializerState::GrossPriceProductTradePrice(None),
                );
                *self.state =
                    LineTradeAgreementTypeDeserializerState::NetPriceProductTradePrice(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_gross_price_product_trade_price(data)?;
                    *self.state =
                        LineTradeAgreementTypeDeserializerState::NetPriceProductTradePrice(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeAgreementTypeDeserializerState :: GrossPriceProductTradePrice (Some (deserializer))) ;
                            *self.state =
                                LineTradeAgreementTypeDeserializerState::NetPriceProductTradePrice(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeAgreementTypeDeserializerState :: GrossPriceProductTradePrice (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_net_price_product_trade_price<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePriceType>,
            fallback: &mut Option<LineTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.net_price_product_trade_price.is_some() {
                    fallback.get_or_insert(
                        LineTradeAgreementTypeDeserializerState::NetPriceProductTradePrice(None),
                    );
                    * self . state = LineTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        LineTradeAgreementTypeDeserializerState::NetPriceProductTradePrice(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_net_price_product_trade_price(data)?;
                    * self . state = LineTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeAgreementTypeDeserializerState::NetPriceProductTradePrice(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = LineTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LineTradeAgreementTypeDeserializerState::NetPriceProductTradePrice(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_ultimate_customer_order_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeAgreementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (LineTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None)) ;
                *self.state = LineTradeAgreementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ultimate_customer_order_referenced_document(data)?;
                    * self . state = LineTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (Some (deserializer))) ;
                            * self . state = LineTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeAgreementTypeDeserializerState :: UltimateCustomerOrderReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::LineTradeAgreementType> for LineTradeAgreementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LineTradeAgreementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LineTradeAgreementType>
        where
            R: DeserializeReader,
        {
            use LineTradeAgreementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SellerOrderReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_seller_order_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerOrderReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_order_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::QuotationReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_quotation_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ContractReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_contract_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AdditionalReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_additional_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::GrossPriceProductTradePrice(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_gross_price_product_trade_price(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::NetPriceProductTradePrice(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_net_price_product_trade_price(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UltimateCustomerOrderReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ultimate_customer_order_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            LineTradeAgreementTypeDeserializerState::SellerOrderReferencedDocument(
                                None,
                            );
                        event
                    }
                    (
                        S::SellerOrderReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SellerOrderReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_seller_order_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerOrderReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::BuyerOrderReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BuyerOrderReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_buyer_order_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::QuotationReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::QuotationReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"QuotationReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_quotation_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ContractReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::ContractReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ContractReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_contract_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AdditionalReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::AdditionalReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AdditionalReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_additional_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::GrossPriceProductTradePrice(None);
                            event
                        }
                    }
                    (
                        S::GrossPriceProductTradePrice(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"GrossPriceProductTradePrice",
                        ) {
                            let output =
                                <super::TradePriceType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_gross_price_product_trade_price(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::NetPriceProductTradePrice(None);
                            event
                        }
                    }
                    (
                        S::NetPriceProductTradePrice(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"NetPriceProductTradePrice",
                        ) {
                            let output =
                                <super::TradePriceType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_net_price_product_trade_price(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UltimateCustomerOrderReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::UltimateCustomerOrderReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"UltimateCustomerOrderReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_ultimate_customer_order_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LineTradeAgreementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LineTradeAgreementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LineTradeAgreementType {
                seller_order_referenced_document: self.seller_order_referenced_document,
                buyer_order_referenced_document: self.buyer_order_referenced_document,
                quotation_referenced_document: self.quotation_referenced_document,
                contract_referenced_document: self.contract_referenced_document,
                additional_referenced_document: self.additional_referenced_document,
                gross_price_product_trade_price: self.gross_price_product_trade_price,
                net_price_product_trade_price: self
                    .net_price_product_trade_price
                    .ok_or_else(|| ErrorKind::MissingElement("NetPriceProductTradePrice".into()))?,
                ultimate_customer_order_referenced_document: self
                    .ultimate_customer_order_referenced_document,
            })
        }
    }
    #[derive(Debug)]
    pub struct LineTradeDeliveryTypeDeserializer {
        billed_quantity: Option<super::QuantityType>,
        charge_free_quantity: Option<super::QuantityType>,
        package_quantity: Option<super::QuantityType>,
        ship_to_trade_party: Option<super::TradePartyType>,
        ultimate_ship_to_trade_party: Option<super::TradePartyType>,
        actual_delivery_supply_chain_event: Option<super::SupplyChainEventType>,
        despatch_advice_referenced_document: Option<super::ReferencedDocumentType>,
        receiving_advice_referenced_document: Option<super::ReferencedDocumentType>,
        delivery_note_referenced_document: Option<super::ReferencedDocumentType>,
        state: Box<LineTradeDeliveryTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LineTradeDeliveryTypeDeserializerState {
        Init__,
        BilledQuantity(Option<<super::QuantityType as WithDeserializer>::Deserializer>),
        ChargeFreeQuantity(Option<<super::QuantityType as WithDeserializer>::Deserializer>),
        PackageQuantity(Option<<super::QuantityType as WithDeserializer>::Deserializer>),
        ShipToTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        UltimateShipToTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        ActualDeliverySupplyChainEvent(
            Option<<super::SupplyChainEventType as WithDeserializer>::Deserializer>,
        ),
        DespatchAdviceReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        ReceivingAdviceReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        DeliveryNoteReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl LineTradeDeliveryTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                billed_quantity: None,
                charge_free_quantity: None,
                package_quantity: None,
                ship_to_trade_party: None,
                ultimate_ship_to_trade_party: None,
                actual_delivery_supply_chain_event: None,
                despatch_advice_referenced_document: None,
                receiving_advice_referenced_document: None,
                delivery_note_referenced_document: None,
                state: Box::new(LineTradeDeliveryTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LineTradeDeliveryTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use LineTradeDeliveryTypeDeserializerState as S;
            match state {
                S::BilledQuantity(Some(deserializer)) => {
                    self.store_billed_quantity(deserializer.finish(reader)?)?
                }
                S::ChargeFreeQuantity(Some(deserializer)) => {
                    self.store_charge_free_quantity(deserializer.finish(reader)?)?
                }
                S::PackageQuantity(Some(deserializer)) => {
                    self.store_package_quantity(deserializer.finish(reader)?)?
                }
                S::ShipToTradeParty(Some(deserializer)) => {
                    self.store_ship_to_trade_party(deserializer.finish(reader)?)?
                }
                S::UltimateShipToTradeParty(Some(deserializer)) => {
                    self.store_ultimate_ship_to_trade_party(deserializer.finish(reader)?)?
                }
                S::ActualDeliverySupplyChainEvent(Some(deserializer)) => {
                    self.store_actual_delivery_supply_chain_event(deserializer.finish(reader)?)?
                }
                S::DespatchAdviceReferencedDocument(Some(deserializer)) => {
                    self.store_despatch_advice_referenced_document(deserializer.finish(reader)?)?
                }
                S::ReceivingAdviceReferencedDocument(Some(deserializer)) => {
                    self.store_receiving_advice_referenced_document(deserializer.finish(reader)?)?
                }
                S::DeliveryNoteReferencedDocument(Some(deserializer)) => {
                    self.store_delivery_note_referenced_document(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_billed_quantity(&mut self, value: super::QuantityType) -> Result<(), Error> {
            if self.billed_quantity.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BilledQuantity",
                )))?;
            }
            self.billed_quantity = Some(value);
            Ok(())
        }
        fn store_charge_free_quantity(&mut self, value: super::QuantityType) -> Result<(), Error> {
            if self.charge_free_quantity.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ChargeFreeQuantity",
                )))?;
            }
            self.charge_free_quantity = Some(value);
            Ok(())
        }
        fn store_package_quantity(&mut self, value: super::QuantityType) -> Result<(), Error> {
            if self.package_quantity.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PackageQuantity",
                )))?;
            }
            self.package_quantity = Some(value);
            Ok(())
        }
        fn store_ship_to_trade_party(&mut self, value: super::TradePartyType) -> Result<(), Error> {
            if self.ship_to_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ShipToTradeParty",
                )))?;
            }
            self.ship_to_trade_party = Some(value);
            Ok(())
        }
        fn store_ultimate_ship_to_trade_party(
            &mut self,
            value: super::TradePartyType,
        ) -> Result<(), Error> {
            if self.ultimate_ship_to_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UltimateShipToTradeParty",
                )))?;
            }
            self.ultimate_ship_to_trade_party = Some(value);
            Ok(())
        }
        fn store_actual_delivery_supply_chain_event(
            &mut self,
            value: super::SupplyChainEventType,
        ) -> Result<(), Error> {
            if self.actual_delivery_supply_chain_event.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ActualDeliverySupplyChainEvent",
                )))?;
            }
            self.actual_delivery_supply_chain_event = Some(value);
            Ok(())
        }
        fn store_despatch_advice_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.despatch_advice_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DespatchAdviceReferencedDocument",
                )))?;
            }
            self.despatch_advice_referenced_document = Some(value);
            Ok(())
        }
        fn store_receiving_advice_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.receiving_advice_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ReceivingAdviceReferencedDocument",
                )))?;
            }
            self.receiving_advice_referenced_document = Some(value);
            Ok(())
        }
        fn store_delivery_note_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.delivery_note_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DeliveryNoteReferencedDocument",
                )))?;
            }
            self.delivery_note_referenced_document = Some(value);
            Ok(())
        }
        fn handle_billed_quantity<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::QuantityType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.billed_quantity.is_some() {
                    fallback.get_or_insert(LineTradeDeliveryTypeDeserializerState::BilledQuantity(
                        None,
                    ));
                    *self.state = LineTradeDeliveryTypeDeserializerState::ChargeFreeQuantity(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = LineTradeDeliveryTypeDeserializerState::BilledQuantity(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_billed_quantity(data)?;
                    *self.state = LineTradeDeliveryTypeDeserializerState::ChargeFreeQuantity(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeDeliveryTypeDeserializerState::BilledQuantity(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                LineTradeDeliveryTypeDeserializerState::ChargeFreeQuantity(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = LineTradeDeliveryTypeDeserializerState::BilledQuantity(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_charge_free_quantity<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::QuantityType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(LineTradeDeliveryTypeDeserializerState::ChargeFreeQuantity(
                    None,
                ));
                *self.state = LineTradeDeliveryTypeDeserializerState::PackageQuantity(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_charge_free_quantity(data)?;
                    *self.state = LineTradeDeliveryTypeDeserializerState::PackageQuantity(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeDeliveryTypeDeserializerState::ChargeFreeQuantity(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                LineTradeDeliveryTypeDeserializerState::PackageQuantity(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LineTradeDeliveryTypeDeserializerState::ChargeFreeQuantity(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_package_quantity<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::QuantityType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(LineTradeDeliveryTypeDeserializerState::PackageQuantity(
                    None,
                ));
                *self.state = LineTradeDeliveryTypeDeserializerState::ShipToTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_package_quantity(data)?;
                    *self.state = LineTradeDeliveryTypeDeserializerState::ShipToTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeDeliveryTypeDeserializerState::PackageQuantity(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                LineTradeDeliveryTypeDeserializerState::ShipToTradeParty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = LineTradeDeliveryTypeDeserializerState::PackageQuantity(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_ship_to_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(LineTradeDeliveryTypeDeserializerState::ShipToTradeParty(
                    None,
                ));
                *self.state =
                    LineTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ship_to_trade_party(data)?;
                    *self.state =
                        LineTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeDeliveryTypeDeserializerState::ShipToTradeParty(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                LineTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = LineTradeDeliveryTypeDeserializerState::ShipToTradeParty(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_ultimate_ship_to_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(None),
                );
                *self.state =
                    LineTradeDeliveryTypeDeserializerState::ActualDeliverySupplyChainEvent(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ultimate_ship_to_trade_party(data)?;
                    *self.state =
                        LineTradeDeliveryTypeDeserializerState::ActualDeliverySupplyChainEvent(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = LineTradeDeliveryTypeDeserializerState :: ActualDeliverySupplyChainEvent (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LineTradeDeliveryTypeDeserializerState::UltimateShipToTradeParty(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_actual_delivery_supply_chain_event<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplyChainEventType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeDeliveryTypeDeserializerState::ActualDeliverySupplyChainEvent(None),
                );
                *self.state =
                    LineTradeDeliveryTypeDeserializerState::DespatchAdviceReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actual_delivery_supply_chain_event(data)?;
                    *self.state =
                        LineTradeDeliveryTypeDeserializerState::DespatchAdviceReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeDeliveryTypeDeserializerState :: ActualDeliverySupplyChainEvent (Some (deserializer))) ;
                            * self . state = LineTradeDeliveryTypeDeserializerState :: DespatchAdviceReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeDeliveryTypeDeserializerState :: ActualDeliverySupplyChainEvent (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_despatch_advice_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeDeliveryTypeDeserializerState::DespatchAdviceReferencedDocument(None),
                );
                *self.state =
                    LineTradeDeliveryTypeDeserializerState::ReceivingAdviceReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_despatch_advice_referenced_document(data)?;
                    *self.state =
                        LineTradeDeliveryTypeDeserializerState::ReceivingAdviceReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeDeliveryTypeDeserializerState :: DespatchAdviceReferencedDocument (Some (deserializer))) ;
                            * self . state = LineTradeDeliveryTypeDeserializerState :: ReceivingAdviceReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeDeliveryTypeDeserializerState :: DespatchAdviceReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_receiving_advice_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeDeliveryTypeDeserializerState::ReceivingAdviceReferencedDocument(None),
                );
                *self.state =
                    LineTradeDeliveryTypeDeserializerState::DeliveryNoteReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_receiving_advice_referenced_document(data)?;
                    *self.state =
                        LineTradeDeliveryTypeDeserializerState::DeliveryNoteReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeDeliveryTypeDeserializerState :: ReceivingAdviceReferencedDocument (Some (deserializer))) ;
                            * self . state = LineTradeDeliveryTypeDeserializerState :: DeliveryNoteReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeDeliveryTypeDeserializerState :: ReceivingAdviceReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_delivery_note_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeDeliveryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeDeliveryTypeDeserializerState::DeliveryNoteReferencedDocument(None),
                );
                *self.state = LineTradeDeliveryTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_delivery_note_referenced_document(data)?;
                    *self.state = LineTradeDeliveryTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeDeliveryTypeDeserializerState :: DeliveryNoteReferencedDocument (Some (deserializer))) ;
                            *self.state = LineTradeDeliveryTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeDeliveryTypeDeserializerState :: DeliveryNoteReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::LineTradeDeliveryType> for LineTradeDeliveryTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LineTradeDeliveryType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LineTradeDeliveryType>
        where
            R: DeserializeReader,
        {
            use LineTradeDeliveryTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BilledQuantity(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_billed_quantity(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ChargeFreeQuantity(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_charge_free_quantity(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PackageQuantity(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_package_quantity(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ShipToTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ship_to_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UltimateShipToTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ultimate_ship_to_trade_party(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ActualDeliverySupplyChainEvent(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actual_delivery_supply_chain_event(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DespatchAdviceReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_despatch_advice_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReceivingAdviceReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_receiving_advice_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DeliveryNoteReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_delivery_note_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = LineTradeDeliveryTypeDeserializerState::BilledQuantity(None);
                        event
                    }
                    (S::BilledQuantity(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BilledQuantity",
                        ) {
                            let output =
                                <super::QuantityType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_billed_quantity(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ChargeFreeQuantity(None);
                            event
                        }
                    }
                    (S::ChargeFreeQuantity(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ChargeFreeQuantity",
                        ) {
                            let output =
                                <super::QuantityType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_charge_free_quantity(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PackageQuantity(None);
                            event
                        }
                    }
                    (S::PackageQuantity(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PackageQuantity",
                        ) {
                            let output =
                                <super::QuantityType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_package_quantity(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ShipToTradeParty(None);
                            event
                        }
                    }
                    (S::ShipToTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ShipToTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_ship_to_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UltimateShipToTradeParty(None);
                            event
                        }
                    }
                    (
                        S::UltimateShipToTradeParty(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"UltimateShipToTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_ultimate_ship_to_trade_party(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ActualDeliverySupplyChainEvent(None);
                            event
                        }
                    }
                    (
                        S::ActualDeliverySupplyChainEvent(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ActualDeliverySupplyChainEvent",
                        ) {
                            let output = < super :: SupplyChainEventType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_actual_delivery_supply_chain_event(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DespatchAdviceReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::DespatchAdviceReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DespatchAdviceReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_despatch_advice_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReceivingAdviceReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::ReceivingAdviceReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ReceivingAdviceReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_receiving_advice_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DeliveryNoteReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::DeliveryNoteReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DeliveryNoteReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_delivery_note_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LineTradeDeliveryType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LineTradeDeliveryTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LineTradeDeliveryType {
                billed_quantity: self
                    .billed_quantity
                    .ok_or_else(|| ErrorKind::MissingElement("BilledQuantity".into()))?,
                charge_free_quantity: self.charge_free_quantity,
                package_quantity: self.package_quantity,
                ship_to_trade_party: self.ship_to_trade_party,
                ultimate_ship_to_trade_party: self.ultimate_ship_to_trade_party,
                actual_delivery_supply_chain_event: self.actual_delivery_supply_chain_event,
                despatch_advice_referenced_document: self.despatch_advice_referenced_document,
                receiving_advice_referenced_document: self.receiving_advice_referenced_document,
                delivery_note_referenced_document: self.delivery_note_referenced_document,
            })
        }
    }
    #[derive(Debug)]
    pub struct LineTradeSettlementTypeDeserializer {
        applicable_trade_tax: Vec<super::TradeTaxType>,
        billing_specified_period: Option<super::SpecifiedPeriodType>,
        specified_trade_allowance_charge: Vec<super::TradeAllowanceChargeType>,
        specified_trade_settlement_line_monetary_summation:
            Option<super::TradeSettlementLineMonetarySummationType>,
        invoice_referenced_document: Option<super::ReferencedDocumentType>,
        additional_referenced_document: Vec<super::ReferencedDocumentType>,
        receivable_specified_trade_accounting_account: Option<super::TradeAccountingAccountType>,
        state: Box<LineTradeSettlementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LineTradeSettlementTypeDeserializerState {
        Init__,
        ApplicableTradeTax(Option<<super::TradeTaxType as WithDeserializer>::Deserializer>),
        BillingSpecifiedPeriod(
            Option<<super::SpecifiedPeriodType as WithDeserializer>::Deserializer>,
        ),
        SpecifiedTradeAllowanceCharge(
            Option<<super::TradeAllowanceChargeType as WithDeserializer>::Deserializer>,
        ),
        SpecifiedTradeSettlementLineMonetarySummation(
            Option<
                <super::TradeSettlementLineMonetarySummationType as WithDeserializer>::Deserializer,
            >,
        ),
        InvoiceReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        AdditionalReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        ReceivableSpecifiedTradeAccountingAccount(
            Option<<super::TradeAccountingAccountType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl LineTradeSettlementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                applicable_trade_tax: Vec::new(),
                billing_specified_period: None,
                specified_trade_allowance_charge: Vec::new(),
                specified_trade_settlement_line_monetary_summation: None,
                invoice_referenced_document: None,
                additional_referenced_document: Vec::new(),
                receivable_specified_trade_accounting_account: None,
                state: Box::new(LineTradeSettlementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LineTradeSettlementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use LineTradeSettlementTypeDeserializerState as S;
            match state {
                S::ApplicableTradeTax(Some(deserializer)) => {
                    self.store_applicable_trade_tax(deserializer.finish(reader)?)?
                }
                S::BillingSpecifiedPeriod(Some(deserializer)) => {
                    self.store_billing_specified_period(deserializer.finish(reader)?)?
                }
                S::SpecifiedTradeAllowanceCharge(Some(deserializer)) => {
                    self.store_specified_trade_allowance_charge(deserializer.finish(reader)?)?
                }
                S::SpecifiedTradeSettlementLineMonetarySummation(Some(deserializer)) => self
                    .store_specified_trade_settlement_line_monetary_summation(
                        deserializer.finish(reader)?,
                    )?,
                S::InvoiceReferencedDocument(Some(deserializer)) => {
                    self.store_invoice_referenced_document(deserializer.finish(reader)?)?
                }
                S::AdditionalReferencedDocument(Some(deserializer)) => {
                    self.store_additional_referenced_document(deserializer.finish(reader)?)?
                }
                S::ReceivableSpecifiedTradeAccountingAccount(Some(deserializer)) => self
                    .store_receivable_specified_trade_accounting_account(
                        deserializer.finish(reader)?,
                    )?,
                _ => (),
            }
            Ok(())
        }
        fn store_applicable_trade_tax(&mut self, value: super::TradeTaxType) -> Result<(), Error> {
            self.applicable_trade_tax.push(value);
            Ok(())
        }
        fn store_billing_specified_period(
            &mut self,
            value: super::SpecifiedPeriodType,
        ) -> Result<(), Error> {
            if self.billing_specified_period.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BillingSpecifiedPeriod",
                )))?;
            }
            self.billing_specified_period = Some(value);
            Ok(())
        }
        fn store_specified_trade_allowance_charge(
            &mut self,
            value: super::TradeAllowanceChargeType,
        ) -> Result<(), Error> {
            self.specified_trade_allowance_charge.push(value);
            Ok(())
        }
        fn store_specified_trade_settlement_line_monetary_summation(
            &mut self,
            value: super::TradeSettlementLineMonetarySummationType,
        ) -> Result<(), Error> {
            if self
                .specified_trade_settlement_line_monetary_summation
                .is_some()
            {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SpecifiedTradeSettlementLineMonetarySummation",
                )))?;
            }
            self.specified_trade_settlement_line_monetary_summation = Some(value);
            Ok(())
        }
        fn store_invoice_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.invoice_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"InvoiceReferencedDocument",
                )))?;
            }
            self.invoice_referenced_document = Some(value);
            Ok(())
        }
        fn store_additional_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            self.additional_referenced_document.push(value);
            Ok(())
        }
        fn store_receivable_specified_trade_accounting_account(
            &mut self,
            value: super::TradeAccountingAccountType,
        ) -> Result<(), Error> {
            if self.receivable_specified_trade_accounting_account.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ReceivableSpecifiedTradeAccountingAccount",
                )))?;
            }
            self.receivable_specified_trade_accounting_account = Some(value);
            Ok(())
        }
        fn handle_applicable_trade_tax<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeTaxType>,
            fallback: &mut Option<LineTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.applicable_trade_tax.len() < 1usize {
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::ApplicableTradeTax(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        LineTradeSettlementTypeDeserializerState::ApplicableTradeTax(None),
                    );
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::BillingSpecifiedPeriod(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_trade_tax(data)?;
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::ApplicableTradeTax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeSettlementTypeDeserializerState::ApplicableTradeTax(Some(
                                    deserializer,
                                )),
                            );
                            if self.applicable_trade_tax.len().saturating_add(1) < 1usize {
                                *self.state =
                                    LineTradeSettlementTypeDeserializerState::ApplicableTradeTax(
                                        None,
                                    );
                            } else {
                                * self . state = LineTradeSettlementTypeDeserializerState :: BillingSpecifiedPeriod (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LineTradeSettlementTypeDeserializerState::ApplicableTradeTax(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_billing_specified_period<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SpecifiedPeriodType>,
            fallback: &mut Option<LineTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeSettlementTypeDeserializerState::BillingSpecifiedPeriod(None),
                );
                *self.state =
                    LineTradeSettlementTypeDeserializerState::SpecifiedTradeAllowanceCharge(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_billing_specified_period(data)?;
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::SpecifiedTradeAllowanceCharge(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeSettlementTypeDeserializerState::BillingSpecifiedPeriod(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = LineTradeSettlementTypeDeserializerState :: SpecifiedTradeAllowanceCharge (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LineTradeSettlementTypeDeserializerState::BillingSpecifiedPeriod(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_trade_allowance_charge<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeAllowanceChargeType>,
            fallback: &mut Option<LineTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeSettlementTypeDeserializerState::SpecifiedTradeAllowanceCharge(None),
                );
                * self . state = LineTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementLineMonetarySummation (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_trade_allowance_charge(data)?;
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::SpecifiedTradeAllowanceCharge(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeSettlementTypeDeserializerState :: SpecifiedTradeAllowanceCharge (Some (deserializer))) ;
                            * self . state = LineTradeSettlementTypeDeserializerState :: SpecifiedTradeAllowanceCharge (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeSettlementTypeDeserializerState :: SpecifiedTradeAllowanceCharge (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_trade_settlement_line_monetary_summation<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeSettlementLineMonetarySummationType>,
            fallback: &mut Option<LineTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self
                    .specified_trade_settlement_line_monetary_summation
                    .is_some()
                {
                    fallback . get_or_insert (LineTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementLineMonetarySummation (None)) ;
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = LineTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementLineMonetarySummation (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_trade_settlement_line_monetary_summation(data)?;
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementLineMonetarySummation (Some (deserializer))) ;
                            *self.state =
                                LineTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeSettlementTypeDeserializerState :: SpecifiedTradeSettlementLineMonetarySummation (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_invoice_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(None),
                );
                *self.state =
                    LineTradeSettlementTypeDeserializerState::AdditionalReferencedDocument(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_invoice_referenced_document(data)?;
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::AdditionalReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LineTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = LineTradeSettlementTypeDeserializerState :: AdditionalReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LineTradeSettlementTypeDeserializerState::InvoiceReferencedDocument(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_additional_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<LineTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LineTradeSettlementTypeDeserializerState::AdditionalReferencedDocument(None),
                );
                * self . state = LineTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_additional_referenced_document(data)?;
                    *self.state =
                        LineTradeSettlementTypeDeserializerState::AdditionalReferencedDocument(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeSettlementTypeDeserializerState :: AdditionalReferencedDocument (Some (deserializer))) ;
                            * self . state = LineTradeSettlementTypeDeserializerState :: AdditionalReferencedDocument (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeSettlementTypeDeserializerState :: AdditionalReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_receivable_specified_trade_accounting_account<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeAccountingAccountType>,
            fallback: &mut Option<LineTradeSettlementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (LineTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (None)) ;
                *self.state = LineTradeSettlementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_receivable_specified_trade_accounting_account(data)?;
                    *self.state = LineTradeSettlementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (LineTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (Some (deserializer))) ;
                            *self.state = LineTradeSettlementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = LineTradeSettlementTypeDeserializerState :: ReceivableSpecifiedTradeAccountingAccount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::LineTradeSettlementType>
        for LineTradeSettlementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LineTradeSettlementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LineTradeSettlementType>
        where
            R: DeserializeReader,
        {
            use LineTradeSettlementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ApplicableTradeTax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_trade_tax(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BillingSpecifiedPeriod(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_billing_specified_period(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedTradeAllowanceCharge(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_trade_allowance_charge(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (
                        S::SpecifiedTradeSettlementLineMonetarySummation(Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_trade_settlement_line_monetary_summation(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InvoiceReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_invoice_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AdditionalReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_additional_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReceivableSpecifiedTradeAccountingAccount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_receivable_specified_trade_accounting_account(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            LineTradeSettlementTypeDeserializerState::ApplicableTradeTax(None);
                        event
                    }
                    (S::ApplicableTradeTax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableTradeTax",
                        ) {
                            let output =
                                <super::TradeTaxType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_applicable_trade_tax(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BillingSpecifiedPeriod(None);
                            event
                        }
                    }
                    (
                        S::BillingSpecifiedPeriod(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BillingSpecifiedPeriod",
                        ) {
                            let output = < super :: SpecifiedPeriodType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_billing_specified_period(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedTradeAllowanceCharge(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedTradeAllowanceCharge(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedTradeAllowanceCharge",
                        ) {
                            let output = < super :: TradeAllowanceChargeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_trade_allowance_charge(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedTradeSettlementLineMonetarySummation(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedTradeSettlementLineMonetarySummation(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedTradeSettlementLineMonetarySummation",
                        ) {
                            let output = < super :: TradeSettlementLineMonetarySummationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_trade_settlement_line_monetary_summation(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InvoiceReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::InvoiceReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"InvoiceReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_invoice_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AdditionalReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::AdditionalReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AdditionalReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_additional_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReceivableSpecifiedTradeAccountingAccount(None);
                            event
                        }
                    }
                    (
                        S::ReceivableSpecifiedTradeAccountingAccount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ReceivableSpecifiedTradeAccountingAccount",
                        ) {
                            let output = < super :: TradeAccountingAccountType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_receivable_specified_trade_accounting_account(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LineTradeSettlementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LineTradeSettlementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LineTradeSettlementType {
                applicable_trade_tax: self.applicable_trade_tax,
                billing_specified_period: self.billing_specified_period,
                specified_trade_allowance_charge: self.specified_trade_allowance_charge,
                specified_trade_settlement_line_monetary_summation: self
                    .specified_trade_settlement_line_monetary_summation
                    .ok_or_else(|| {
                        ErrorKind::MissingElement(
                            "SpecifiedTradeSettlementLineMonetarySummation".into(),
                        )
                    })?,
                invoice_referenced_document: self.invoice_referenced_document,
                additional_referenced_document: self.additional_referenced_document,
                receivable_specified_trade_accounting_account: self
                    .receivable_specified_trade_accounting_account,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradePartyTypeDeserializer {
        id: Vec<super::IdType>,
        global_id: Vec<super::IdType>,
        name: Option<super::TextType>,
        role_code: Option<super::PartyRoleCodeType>,
        description: Option<super::TextType>,
        specified_legal_organization: Option<super::LegalOrganizationType>,
        defined_trade_contact: Vec<super::TradeContactType>,
        postal_trade_address: Option<super::TradeAddressType>,
        uri_universal_communication: Option<super::UniversalCommunicationType>,
        specified_tax_registration: Vec<super::TaxRegistrationType>,
        state: Box<TradePartyTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradePartyTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        GlobalId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Name(Option<<super::TextType as WithDeserializer>::Deserializer>),
        RoleCode(Option<<super::PartyRoleCodeType as WithDeserializer>::Deserializer>),
        Description(Option<<super::TextType as WithDeserializer>::Deserializer>),
        SpecifiedLegalOrganization(
            Option<<super::LegalOrganizationType as WithDeserializer>::Deserializer>,
        ),
        DefinedTradeContact(Option<<super::TradeContactType as WithDeserializer>::Deserializer>),
        PostalTradeAddress(Option<<super::TradeAddressType as WithDeserializer>::Deserializer>),
        UriUniversalCommunication(
            Option<<super::UniversalCommunicationType as WithDeserializer>::Deserializer>,
        ),
        SpecifiedTaxRegistration(
            Option<<super::TaxRegistrationType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TradePartyTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: Vec::new(),
                global_id: Vec::new(),
                name: None,
                role_code: None,
                description: None,
                specified_legal_organization: None,
                defined_trade_contact: Vec::new(),
                postal_trade_address: None,
                uri_universal_communication: None,
                specified_tax_registration: Vec::new(),
                state: Box::new(TradePartyTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradePartyTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradePartyTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                S::GlobalId(Some(deserializer)) => {
                    self.store_global_id(deserializer.finish(reader)?)?
                }
                S::Name(Some(deserializer)) => self.store_name(deserializer.finish(reader)?)?,
                S::RoleCode(Some(deserializer)) => {
                    self.store_role_code(deserializer.finish(reader)?)?
                }
                S::Description(Some(deserializer)) => {
                    self.store_description(deserializer.finish(reader)?)?
                }
                S::SpecifiedLegalOrganization(Some(deserializer)) => {
                    self.store_specified_legal_organization(deserializer.finish(reader)?)?
                }
                S::DefinedTradeContact(Some(deserializer)) => {
                    self.store_defined_trade_contact(deserializer.finish(reader)?)?
                }
                S::PostalTradeAddress(Some(deserializer)) => {
                    self.store_postal_trade_address(deserializer.finish(reader)?)?
                }
                S::UriUniversalCommunication(Some(deserializer)) => {
                    self.store_uri_universal_communication(deserializer.finish(reader)?)?
                }
                S::SpecifiedTaxRegistration(Some(deserializer)) => {
                    self.store_specified_tax_registration(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            self.id.push(value);
            Ok(())
        }
        fn store_global_id(&mut self, value: super::IdType) -> Result<(), Error> {
            self.global_id.push(value);
            Ok(())
        }
        fn store_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Name")))?;
            }
            self.name = Some(value);
            Ok(())
        }
        fn store_role_code(&mut self, value: super::PartyRoleCodeType) -> Result<(), Error> {
            if self.role_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"RoleCode",
                )))?;
            }
            self.role_code = Some(value);
            Ok(())
        }
        fn store_description(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.description.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Description",
                )))?;
            }
            self.description = Some(value);
            Ok(())
        }
        fn store_specified_legal_organization(
            &mut self,
            value: super::LegalOrganizationType,
        ) -> Result<(), Error> {
            if self.specified_legal_organization.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SpecifiedLegalOrganization",
                )))?;
            }
            self.specified_legal_organization = Some(value);
            Ok(())
        }
        fn store_defined_trade_contact(
            &mut self,
            value: super::TradeContactType,
        ) -> Result<(), Error> {
            self.defined_trade_contact.push(value);
            Ok(())
        }
        fn store_postal_trade_address(
            &mut self,
            value: super::TradeAddressType,
        ) -> Result<(), Error> {
            if self.postal_trade_address.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PostalTradeAddress",
                )))?;
            }
            self.postal_trade_address = Some(value);
            Ok(())
        }
        fn store_uri_universal_communication(
            &mut self,
            value: super::UniversalCommunicationType,
        ) -> Result<(), Error> {
            if self.uri_universal_communication.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"URIUniversalCommunication",
                )))?;
            }
            self.uri_universal_communication = Some(value);
            Ok(())
        }
        fn store_specified_tax_registration(
            &mut self,
            value: super::TaxRegistrationType,
        ) -> Result<(), Error> {
            self.specified_tax_registration.push(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::Id(None));
                *self.state = TradePartyTypeDeserializerState::GlobalId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = TradePartyTypeDeserializerState::Id(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradePartyTypeDeserializerState::Id(Some(
                                deserializer,
                            )));
                            *self.state = TradePartyTypeDeserializerState::Id(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePartyTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_global_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::GlobalId(None));
                *self.state = TradePartyTypeDeserializerState::Name(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_global_id(data)?;
                    *self.state = TradePartyTypeDeserializerState::GlobalId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradePartyTypeDeserializerState::GlobalId(
                                Some(deserializer),
                            ));
                            *self.state = TradePartyTypeDeserializerState::GlobalId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePartyTypeDeserializerState::GlobalId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::Name(None));
                *self.state = TradePartyTypeDeserializerState::RoleCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_name(data)?;
                    *self.state = TradePartyTypeDeserializerState::RoleCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradePartyTypeDeserializerState::Name(Some(
                                deserializer,
                            )));
                            *self.state = TradePartyTypeDeserializerState::RoleCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePartyTypeDeserializerState::Name(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_role_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PartyRoleCodeType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::RoleCode(None));
                *self.state = TradePartyTypeDeserializerState::Description(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_role_code(data)?;
                    *self.state = TradePartyTypeDeserializerState::Description(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradePartyTypeDeserializerState::RoleCode(
                                Some(deserializer),
                            ));
                            *self.state = TradePartyTypeDeserializerState::Description(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePartyTypeDeserializerState::RoleCode(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_description<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::Description(None));
                *self.state = TradePartyTypeDeserializerState::SpecifiedLegalOrganization(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description(data)?;
                    *self.state = TradePartyTypeDeserializerState::SpecifiedLegalOrganization(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradePartyTypeDeserializerState::Description(
                                Some(deserializer),
                            ));
                            *self.state =
                                TradePartyTypeDeserializerState::SpecifiedLegalOrganization(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePartyTypeDeserializerState::Description(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_legal_organization<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LegalOrganizationType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePartyTypeDeserializerState::SpecifiedLegalOrganization(None),
                );
                *self.state = TradePartyTypeDeserializerState::DefinedTradeContact(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_legal_organization(data)?;
                    *self.state = TradePartyTypeDeserializerState::DefinedTradeContact(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePartyTypeDeserializerState::SpecifiedLegalOrganization(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePartyTypeDeserializerState::DefinedTradeContact(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePartyTypeDeserializerState::SpecifiedLegalOrganization(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_defined_trade_contact<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeContactType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::DefinedTradeContact(None));
                *self.state = TradePartyTypeDeserializerState::PostalTradeAddress(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_defined_trade_contact(data)?;
                    *self.state = TradePartyTypeDeserializerState::DefinedTradeContact(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePartyTypeDeserializerState::DefinedTradeContact(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePartyTypeDeserializerState::DefinedTradeContact(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePartyTypeDeserializerState::DefinedTradeContact(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_postal_trade_address<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeAddressType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::PostalTradeAddress(None));
                *self.state = TradePartyTypeDeserializerState::UriUniversalCommunication(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_postal_trade_address(data)?;
                    *self.state = TradePartyTypeDeserializerState::UriUniversalCommunication(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePartyTypeDeserializerState::PostalTradeAddress(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePartyTypeDeserializerState::UriUniversalCommunication(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePartyTypeDeserializerState::PostalTradeAddress(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_uri_universal_communication<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UniversalCommunicationType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::UriUniversalCommunication(
                    None,
                ));
                *self.state = TradePartyTypeDeserializerState::SpecifiedTaxRegistration(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_uri_universal_communication(data)?;
                    *self.state = TradePartyTypeDeserializerState::SpecifiedTaxRegistration(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePartyTypeDeserializerState::UriUniversalCommunication(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePartyTypeDeserializerState::SpecifiedTaxRegistration(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePartyTypeDeserializerState::UriUniversalCommunication(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_specified_tax_registration<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TaxRegistrationType>,
            fallback: &mut Option<TradePartyTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePartyTypeDeserializerState::SpecifiedTaxRegistration(
                    None,
                ));
                *self.state = TradePartyTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_tax_registration(data)?;
                    if self.specified_tax_registration.len() < 2usize {
                        *self.state =
                            TradePartyTypeDeserializerState::SpecifiedTaxRegistration(None);
                    } else {
                        *self.state = TradePartyTypeDeserializerState::Done__;
                    }
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePartyTypeDeserializerState::SpecifiedTaxRegistration(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePartyTypeDeserializerState::SpecifiedTaxRegistration(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePartyTypeDeserializerState::SpecifiedTaxRegistration(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradePartyType> for TradePartyTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TradePartyType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradePartyType>
        where
            R: DeserializeReader,
        {
            use TradePartyTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::GlobalId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_global_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Name(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::RoleCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_role_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Description(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedLegalOrganization(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_legal_organization(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DefinedTradeContact(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_defined_trade_contact(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PostalTradeAddress(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_postal_trade_address(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UriUniversalCommunication(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_uri_universal_communication(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecifiedTaxRegistration(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_tax_registration(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradePartyTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::GlobalId(None);
                            event
                        }
                    }
                    (S::GlobalId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"GlobalID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_global_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Name(None);
                            event
                        }
                    }
                    (S::Name(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Name") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::RoleCode(None);
                            event
                        }
                    }
                    (S::RoleCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"RoleCode") {
                            let output =
                                <super::PartyRoleCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_role_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Description(None);
                            event
                        }
                    }
                    (S::Description(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Description")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_description(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedLegalOrganization(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedLegalOrganization(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedLegalOrganization",
                        ) {
                            let output = < super :: LegalOrganizationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_legal_organization(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DefinedTradeContact(None);
                            event
                        }
                    }
                    (S::DefinedTradeContact(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DefinedTradeContact",
                        ) {
                            let output =
                                <super::TradeContactType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_defined_trade_contact(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PostalTradeAddress(None);
                            event
                        }
                    }
                    (S::PostalTradeAddress(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PostalTradeAddress",
                        ) {
                            let output =
                                <super::TradeAddressType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_postal_trade_address(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UriUniversalCommunication(None);
                            event
                        }
                    }
                    (
                        S::UriUniversalCommunication(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"URIUniversalCommunication",
                        ) {
                            let output = < super :: UniversalCommunicationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_uri_universal_communication(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecifiedTaxRegistration(None);
                            event
                        }
                    }
                    (
                        S::SpecifiedTaxRegistration(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedTaxRegistration",
                        ) {
                            let output = < super :: TaxRegistrationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_tax_registration(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradePartyType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, TradePartyTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::TradePartyType {
                id: self.id,
                global_id: self.global_id,
                name: self.name,
                role_code: self.role_code,
                description: self.description,
                specified_legal_organization: self.specified_legal_organization,
                defined_trade_contact: self.defined_trade_contact,
                postal_trade_address: self.postal_trade_address,
                uri_universal_communication: self.uri_universal_communication,
                specified_tax_registration: self.specified_tax_registration,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeDeliveryTermsTypeDeserializer {
        delivery_type_code: Option<super::DeliveryTermsCodeType>,
        state: Box<TradeDeliveryTermsTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeDeliveryTermsTypeDeserializerState {
        Init__,
        DeliveryTypeCode(Option<<super::DeliveryTermsCodeType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeDeliveryTermsTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                delivery_type_code: None,
                state: Box::new(TradeDeliveryTermsTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeDeliveryTermsTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeDeliveryTermsTypeDeserializerState as S;
            match state {
                S::DeliveryTypeCode(Some(deserializer)) => {
                    self.store_delivery_type_code(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_delivery_type_code(
            &mut self,
            value: super::DeliveryTermsCodeType,
        ) -> Result<(), Error> {
            if self.delivery_type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DeliveryTypeCode",
                )))?;
            }
            self.delivery_type_code = Some(value);
            Ok(())
        }
        fn handle_delivery_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DeliveryTermsCodeType>,
            fallback: &mut Option<TradeDeliveryTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.delivery_type_code.is_some() {
                    fallback.get_or_insert(
                        TradeDeliveryTermsTypeDeserializerState::DeliveryTypeCode(None),
                    );
                    *self.state = TradeDeliveryTermsTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeDeliveryTermsTypeDeserializerState::DeliveryTypeCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_delivery_type_code(data)?;
                    *self.state = TradeDeliveryTermsTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeDeliveryTermsTypeDeserializerState::DeliveryTypeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeDeliveryTermsTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeDeliveryTermsTypeDeserializerState::DeliveryTypeCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeDeliveryTermsType> for TradeDeliveryTermsTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeDeliveryTermsType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeDeliveryTermsType>
        where
            R: DeserializeReader,
        {
            use TradeDeliveryTermsTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DeliveryTypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_delivery_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TradeDeliveryTermsTypeDeserializerState::DeliveryTypeCode(None);
                        event
                    }
                    (S::DeliveryTypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DeliveryTypeCode",
                        ) {
                            let output = < super :: DeliveryTermsCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_delivery_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeDeliveryTermsType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeDeliveryTermsTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeDeliveryTermsType {
                delivery_type_code: self
                    .delivery_type_code
                    .ok_or_else(|| ErrorKind::MissingElement("DeliveryTypeCode".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ReferencedDocumentTypeDeserializer {
        issuer_assigned_id: Option<super::IdType>,
        uriid: Option<super::IdType>,
        line_id: Option<super::IdType>,
        type_code: Option<super::DocumentCodeType>,
        name: Option<super::TextType>,
        attachment_binary_object: Option<super::BinaryObjectType>,
        reference_type_code: Option<super::ReferenceCodeType>,
        formatted_issue_date_time: Option<super::FormattedDateTimeType>,
        state: Box<ReferencedDocumentTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ReferencedDocumentTypeDeserializerState {
        Init__,
        IssuerAssignedId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Uriid(Option<<super::IdType as WithDeserializer>::Deserializer>),
        LineId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        TypeCode(Option<<super::DocumentCodeType as WithDeserializer>::Deserializer>),
        Name(Option<<super::TextType as WithDeserializer>::Deserializer>),
        AttachmentBinaryObject(Option<<super::BinaryObjectType as WithDeserializer>::Deserializer>),
        ReferenceTypeCode(Option<<super::ReferenceCodeType as WithDeserializer>::Deserializer>),
        FormattedIssueDateTime(
            Option<<super::FormattedDateTimeType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl ReferencedDocumentTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                issuer_assigned_id: None,
                uriid: None,
                line_id: None,
                type_code: None,
                name: None,
                attachment_binary_object: None,
                reference_type_code: None,
                formatted_issue_date_time: None,
                state: Box::new(ReferencedDocumentTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ReferencedDocumentTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ReferencedDocumentTypeDeserializerState as S;
            match state {
                S::IssuerAssignedId(Some(deserializer)) => {
                    self.store_issuer_assigned_id(deserializer.finish(reader)?)?
                }
                S::Uriid(Some(deserializer)) => self.store_uriid(deserializer.finish(reader)?)?,
                S::LineId(Some(deserializer)) => {
                    self.store_line_id(deserializer.finish(reader)?)?
                }
                S::TypeCode(Some(deserializer)) => {
                    self.store_type_code(deserializer.finish(reader)?)?
                }
                S::Name(Some(deserializer)) => self.store_name(deserializer.finish(reader)?)?,
                S::AttachmentBinaryObject(Some(deserializer)) => {
                    self.store_attachment_binary_object(deserializer.finish(reader)?)?
                }
                S::ReferenceTypeCode(Some(deserializer)) => {
                    self.store_reference_type_code(deserializer.finish(reader)?)?
                }
                S::FormattedIssueDateTime(Some(deserializer)) => {
                    self.store_formatted_issue_date_time(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_issuer_assigned_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.issuer_assigned_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"IssuerAssignedID",
                )))?;
            }
            self.issuer_assigned_id = Some(value);
            Ok(())
        }
        fn store_uriid(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.uriid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"URIID",
                )))?;
            }
            self.uriid = Some(value);
            Ok(())
        }
        fn store_line_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.line_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineID",
                )))?;
            }
            self.line_id = Some(value);
            Ok(())
        }
        fn store_type_code(&mut self, value: super::DocumentCodeType) -> Result<(), Error> {
            if self.type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TypeCode",
                )))?;
            }
            self.type_code = Some(value);
            Ok(())
        }
        fn store_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Name")))?;
            }
            self.name = Some(value);
            Ok(())
        }
        fn store_attachment_binary_object(
            &mut self,
            value: super::BinaryObjectType,
        ) -> Result<(), Error> {
            if self.attachment_binary_object.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AttachmentBinaryObject",
                )))?;
            }
            self.attachment_binary_object = Some(value);
            Ok(())
        }
        fn store_reference_type_code(
            &mut self,
            value: super::ReferenceCodeType,
        ) -> Result<(), Error> {
            if self.reference_type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ReferenceTypeCode",
                )))?;
            }
            self.reference_type_code = Some(value);
            Ok(())
        }
        fn store_formatted_issue_date_time(
            &mut self,
            value: super::FormattedDateTimeType,
        ) -> Result<(), Error> {
            if self.formatted_issue_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FormattedIssueDateTime",
                )))?;
            }
            self.formatted_issue_date_time = Some(value);
            Ok(())
        }
        fn handle_issuer_assigned_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ReferencedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedDocumentTypeDeserializerState::IssuerAssignedId(
                    None,
                ));
                *self.state = ReferencedDocumentTypeDeserializerState::Uriid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_issuer_assigned_id(data)?;
                    *self.state = ReferencedDocumentTypeDeserializerState::Uriid(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedDocumentTypeDeserializerState::IssuerAssignedId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ReferencedDocumentTypeDeserializerState::Uriid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ReferencedDocumentTypeDeserializerState::IssuerAssignedId(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_uriid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ReferencedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedDocumentTypeDeserializerState::Uriid(None));
                *self.state = ReferencedDocumentTypeDeserializerState::LineId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_uriid(data)?;
                    *self.state = ReferencedDocumentTypeDeserializerState::LineId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ReferencedDocumentTypeDeserializerState::Uriid(
                                Some(deserializer),
                            ));
                            *self.state = ReferencedDocumentTypeDeserializerState::LineId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::Uriid(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_line_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ReferencedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedDocumentTypeDeserializerState::LineId(None));
                *self.state = ReferencedDocumentTypeDeserializerState::TypeCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_id(data)?;
                    *self.state = ReferencedDocumentTypeDeserializerState::TypeCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedDocumentTypeDeserializerState::LineId(Some(deserializer)),
                            );
                            *self.state = ReferencedDocumentTypeDeserializerState::TypeCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::LineId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentCodeType>,
            fallback: &mut Option<ReferencedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedDocumentTypeDeserializerState::TypeCode(None));
                *self.state = ReferencedDocumentTypeDeserializerState::Name(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_type_code(data)?;
                    *self.state = ReferencedDocumentTypeDeserializerState::Name(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedDocumentTypeDeserializerState::TypeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ReferencedDocumentTypeDeserializerState::Name(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ReferencedDocumentTypeDeserializerState::TypeCode(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<ReferencedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedDocumentTypeDeserializerState::Name(None));
                *self.state = ReferencedDocumentTypeDeserializerState::AttachmentBinaryObject(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_name(data)?;
                    *self.state =
                        ReferencedDocumentTypeDeserializerState::AttachmentBinaryObject(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ReferencedDocumentTypeDeserializerState::Name(
                                Some(deserializer),
                            ));
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::AttachmentBinaryObject(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::Name(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_attachment_binary_object<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::BinaryObjectType>,
            fallback: &mut Option<ReferencedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ReferencedDocumentTypeDeserializerState::AttachmentBinaryObject(None),
                );
                *self.state = ReferencedDocumentTypeDeserializerState::ReferenceTypeCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_attachment_binary_object(data)?;
                    *self.state = ReferencedDocumentTypeDeserializerState::ReferenceTypeCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedDocumentTypeDeserializerState::AttachmentBinaryObject(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::ReferenceTypeCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::AttachmentBinaryObject(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_reference_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferenceCodeType>,
            fallback: &mut Option<ReferencedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedDocumentTypeDeserializerState::ReferenceTypeCode(
                    None,
                ));
                *self.state = ReferencedDocumentTypeDeserializerState::FormattedIssueDateTime(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reference_type_code(data)?;
                    *self.state =
                        ReferencedDocumentTypeDeserializerState::FormattedIssueDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedDocumentTypeDeserializerState::ReferenceTypeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::FormattedIssueDateTime(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::ReferenceTypeCode(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_formatted_issue_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::FormattedDateTimeType>,
            fallback: &mut Option<ReferencedDocumentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ReferencedDocumentTypeDeserializerState::FormattedIssueDateTime(None),
                );
                *self.state = ReferencedDocumentTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_formatted_issue_date_time(data)?;
                    *self.state = ReferencedDocumentTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedDocumentTypeDeserializerState::FormattedIssueDateTime(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = ReferencedDocumentTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedDocumentTypeDeserializerState::FormattedIssueDateTime(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ReferencedDocumentType> for ReferencedDocumentTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ReferencedDocumentType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ReferencedDocumentType>
        where
            R: DeserializeReader,
        {
            use ReferencedDocumentTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::IssuerAssignedId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_issuer_assigned_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Uriid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_uriid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LineId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Name(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AttachmentBinaryObject(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_attachment_binary_object(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReferenceTypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reference_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FormattedIssueDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_formatted_issue_date_time(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ReferencedDocumentTypeDeserializerState::IssuerAssignedId(None);
                        event
                    }
                    (S::IssuerAssignedId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IssuerAssignedID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_issuer_assigned_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Uriid(None);
                            event
                        }
                    }
                    (S::Uriid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"URIID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_uriid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LineId(None);
                            event
                        }
                    }
                    (S::LineId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"LineID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_line_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TypeCode(None);
                            event
                        }
                    }
                    (S::TypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"TypeCode") {
                            let output =
                                <super::DocumentCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Name(None);
                            event
                        }
                    }
                    (S::Name(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Name") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AttachmentBinaryObject(None);
                            event
                        }
                    }
                    (
                        S::AttachmentBinaryObject(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AttachmentBinaryObject",
                        ) {
                            let output =
                                <super::BinaryObjectType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_attachment_binary_object(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReferenceTypeCode(None);
                            event
                        }
                    }
                    (S::ReferenceTypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ReferenceTypeCode",
                        ) {
                            let output =
                                <super::ReferenceCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_reference_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::FormattedIssueDateTime(None);
                            event
                        }
                    }
                    (
                        S::FormattedIssueDateTime(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"FormattedIssueDateTime",
                        ) {
                            let output = < super :: FormattedDateTimeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_formatted_issue_date_time(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ReferencedDocumentType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ReferencedDocumentTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ReferencedDocumentType {
                issuer_assigned_id: self.issuer_assigned_id,
                uriid: self.uriid,
                line_id: self.line_id,
                type_code: self.type_code,
                name: self.name,
                attachment_binary_object: self.attachment_binary_object,
                reference_type_code: self.reference_type_code,
                formatted_issue_date_time: self.formatted_issue_date_time,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProcuringProjectTypeDeserializer {
        id: Option<super::IdType>,
        name: Option<super::TextType>,
        state: Box<ProcuringProjectTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProcuringProjectTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Name(Option<<super::TextType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProcuringProjectTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                name: None,
                state: Box::new(ProcuringProjectTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProcuringProjectTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProcuringProjectTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                S::Name(Some(deserializer)) => self.store_name(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn store_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Name")))?;
            }
            self.name = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ProcuringProjectTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.id.is_some() {
                    fallback.get_or_insert(ProcuringProjectTypeDeserializerState::Id(None));
                    *self.state = ProcuringProjectTypeDeserializerState::Name(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProcuringProjectTypeDeserializerState::Id(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = ProcuringProjectTypeDeserializerState::Name(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ProcuringProjectTypeDeserializerState::Id(
                                Some(deserializer),
                            ));
                            *self.state = ProcuringProjectTypeDeserializerState::Name(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProcuringProjectTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<ProcuringProjectTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.name.is_some() {
                    fallback.get_or_insert(ProcuringProjectTypeDeserializerState::Name(None));
                    *self.state = ProcuringProjectTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProcuringProjectTypeDeserializerState::Name(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_name(data)?;
                    *self.state = ProcuringProjectTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ProcuringProjectTypeDeserializerState::Name(
                                Some(deserializer),
                            ));
                            *self.state = ProcuringProjectTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProcuringProjectTypeDeserializerState::Name(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProcuringProjectType> for ProcuringProjectTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProcuringProjectType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProcuringProjectType>
        where
            R: DeserializeReader,
        {
            use ProcuringProjectTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Name(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ProcuringProjectTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Name(None);
                            event
                        }
                    }
                    (S::Name(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Name") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProcuringProjectType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProcuringProjectTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProcuringProjectType {
                id: self
                    .id
                    .ok_or_else(|| ErrorKind::MissingElement("ID".into()))?,
                name: self
                    .name
                    .ok_or_else(|| ErrorKind::MissingElement("Name".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct SupplyChainConsignmentTypeDeserializer {
        specified_logistics_transport_movement: Vec<super::LogisticsTransportMovementType>,
        state: Box<SupplyChainConsignmentTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplyChainConsignmentTypeDeserializerState {
        Init__,
        SpecifiedLogisticsTransportMovement(
            Option<<super::LogisticsTransportMovementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl SupplyChainConsignmentTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                specified_logistics_transport_movement: Vec::new(),
                state: Box::new(SupplyChainConsignmentTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplyChainConsignmentTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SupplyChainConsignmentTypeDeserializerState as S;
            match state {
                S::SpecifiedLogisticsTransportMovement(Some(deserializer)) => {
                    self.store_specified_logistics_transport_movement(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_specified_logistics_transport_movement(
            &mut self,
            value: super::LogisticsTransportMovementType,
        ) -> Result<(), Error> {
            self.specified_logistics_transport_movement.push(value);
            Ok(())
        }
        fn handle_specified_logistics_transport_movement<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LogisticsTransportMovementType>,
            fallback: &mut Option<SupplyChainConsignmentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (SupplyChainConsignmentTypeDeserializerState :: SpecifiedLogisticsTransportMovement (None)) ;
                *self.state = SupplyChainConsignmentTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_specified_logistics_transport_movement(data)?;
                    * self . state = SupplyChainConsignmentTypeDeserializerState :: SpecifiedLogisticsTransportMovement (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SupplyChainConsignmentTypeDeserializerState :: SpecifiedLogisticsTransportMovement (Some (deserializer))) ;
                            * self . state = SupplyChainConsignmentTypeDeserializerState :: SpecifiedLogisticsTransportMovement (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SupplyChainConsignmentTypeDeserializerState :: SpecifiedLogisticsTransportMovement (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SupplyChainConsignmentType>
        for SupplyChainConsignmentTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplyChainConsignmentType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplyChainConsignmentType>
        where
            R: DeserializeReader,
        {
            use SupplyChainConsignmentTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SpecifiedLogisticsTransportMovement(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_specified_logistics_transport_movement(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = SupplyChainConsignmentTypeDeserializerState :: SpecifiedLogisticsTransportMovement (None) ;
                        event
                    }
                    (
                        S::SpecifiedLogisticsTransportMovement(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SpecifiedLogisticsTransportMovement",
                        ) {
                            let output = < super :: LogisticsTransportMovementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_specified_logistics_transport_movement(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplyChainConsignmentType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplyChainConsignmentTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplyChainConsignmentType {
                specified_logistics_transport_movement: self.specified_logistics_transport_movement,
            })
        }
    }
    #[derive(Debug)]
    pub struct SupplyChainEventTypeDeserializer {
        occurrence_date_time: Option<super::DateTimeType>,
        state: Box<SupplyChainEventTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplyChainEventTypeDeserializerState {
        Init__,
        OccurrenceDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SupplyChainEventTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                occurrence_date_time: None,
                state: Box::new(SupplyChainEventTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplyChainEventTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SupplyChainEventTypeDeserializerState as S;
            match state {
                S::OccurrenceDateTime(Some(deserializer)) => {
                    self.store_occurrence_date_time(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_occurrence_date_time(&mut self, value: super::DateTimeType) -> Result<(), Error> {
            if self.occurrence_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"OccurrenceDateTime",
                )))?;
            }
            self.occurrence_date_time = Some(value);
            Ok(())
        }
        fn handle_occurrence_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<SupplyChainEventTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.occurrence_date_time.is_some() {
                    fallback.get_or_insert(
                        SupplyChainEventTypeDeserializerState::OccurrenceDateTime(None),
                    );
                    *self.state = SupplyChainEventTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = SupplyChainEventTypeDeserializerState::OccurrenceDateTime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_occurrence_date_time(data)?;
                    *self.state = SupplyChainEventTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplyChainEventTypeDeserializerState::OccurrenceDateTime(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplyChainEventTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplyChainEventTypeDeserializerState::OccurrenceDateTime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SupplyChainEventType> for SupplyChainEventTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplyChainEventType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplyChainEventType>
        where
            R: DeserializeReader,
        {
            use SupplyChainEventTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::OccurrenceDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_occurrence_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            SupplyChainEventTypeDeserializerState::OccurrenceDateTime(None);
                        event
                    }
                    (S::OccurrenceDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"OccurrenceDateTime",
                        ) {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_occurrence_date_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplyChainEventType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplyChainEventTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplyChainEventType {
                occurrence_date_time: self
                    .occurrence_date_time
                    .ok_or_else(|| ErrorKind::MissingElement("OccurrenceDateTime".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CurrencyCodeTypeDeserializer {
        content: Option<String>,
        state: Box<CurrencyCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CurrencyCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CurrencyCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(CurrencyCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CurrencyCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CurrencyCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::CurrencyCodeType>
        where
            R: DeserializeReader,
        {
            use CurrencyCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::CurrencyCodeType> for CurrencyCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CurrencyCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CurrencyCodeType>
        where
            R: DeserializeReader,
        {
            use CurrencyCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CurrencyCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CurrencyCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CurrencyCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeCurrencyExchangeTypeDeserializer {
        source_currency_code: Option<super::CurrencyCodeType>,
        target_currency_code: Option<super::CurrencyCodeType>,
        conversion_rate: Option<super::RateType>,
        conversion_rate_date_time: Option<super::DateTimeType>,
        state: Box<TradeCurrencyExchangeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeCurrencyExchangeTypeDeserializerState {
        Init__,
        SourceCurrencyCode(Option<<super::CurrencyCodeType as WithDeserializer>::Deserializer>),
        TargetCurrencyCode(Option<<super::CurrencyCodeType as WithDeserializer>::Deserializer>),
        ConversionRate(Option<<super::RateType as WithDeserializer>::Deserializer>),
        ConversionRateDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeCurrencyExchangeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                source_currency_code: None,
                target_currency_code: None,
                conversion_rate: None,
                conversion_rate_date_time: None,
                state: Box::new(TradeCurrencyExchangeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeCurrencyExchangeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeCurrencyExchangeTypeDeserializerState as S;
            match state {
                S::SourceCurrencyCode(Some(deserializer)) => {
                    self.store_source_currency_code(deserializer.finish(reader)?)?
                }
                S::TargetCurrencyCode(Some(deserializer)) => {
                    self.store_target_currency_code(deserializer.finish(reader)?)?
                }
                S::ConversionRate(Some(deserializer)) => {
                    self.store_conversion_rate(deserializer.finish(reader)?)?
                }
                S::ConversionRateDateTime(Some(deserializer)) => {
                    self.store_conversion_rate_date_time(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_source_currency_code(
            &mut self,
            value: super::CurrencyCodeType,
        ) -> Result<(), Error> {
            if self.source_currency_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SourceCurrencyCode",
                )))?;
            }
            self.source_currency_code = Some(value);
            Ok(())
        }
        fn store_target_currency_code(
            &mut self,
            value: super::CurrencyCodeType,
        ) -> Result<(), Error> {
            if self.target_currency_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TargetCurrencyCode",
                )))?;
            }
            self.target_currency_code = Some(value);
            Ok(())
        }
        fn store_conversion_rate(&mut self, value: super::RateType) -> Result<(), Error> {
            if self.conversion_rate.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ConversionRate",
                )))?;
            }
            self.conversion_rate = Some(value);
            Ok(())
        }
        fn store_conversion_rate_date_time(
            &mut self,
            value: super::DateTimeType,
        ) -> Result<(), Error> {
            if self.conversion_rate_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ConversionRateDateTime",
                )))?;
            }
            self.conversion_rate_date_time = Some(value);
            Ok(())
        }
        fn handle_source_currency_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CurrencyCodeType>,
            fallback: &mut Option<TradeCurrencyExchangeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.source_currency_code.is_some() {
                    fallback.get_or_insert(
                        TradeCurrencyExchangeTypeDeserializerState::SourceCurrencyCode(None),
                    );
                    *self.state =
                        TradeCurrencyExchangeTypeDeserializerState::TargetCurrencyCode(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TradeCurrencyExchangeTypeDeserializerState::SourceCurrencyCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_source_currency_code(data)?;
                    *self.state =
                        TradeCurrencyExchangeTypeDeserializerState::TargetCurrencyCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeCurrencyExchangeTypeDeserializerState::SourceCurrencyCode(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradeCurrencyExchangeTypeDeserializerState::TargetCurrencyCode(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeCurrencyExchangeTypeDeserializerState::SourceCurrencyCode(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_target_currency_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CurrencyCodeType>,
            fallback: &mut Option<TradeCurrencyExchangeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.target_currency_code.is_some() {
                    fallback.get_or_insert(
                        TradeCurrencyExchangeTypeDeserializerState::TargetCurrencyCode(None),
                    );
                    *self.state = TradeCurrencyExchangeTypeDeserializerState::ConversionRate(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TradeCurrencyExchangeTypeDeserializerState::TargetCurrencyCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_target_currency_code(data)?;
                    *self.state = TradeCurrencyExchangeTypeDeserializerState::ConversionRate(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeCurrencyExchangeTypeDeserializerState::TargetCurrencyCode(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradeCurrencyExchangeTypeDeserializerState::ConversionRate(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeCurrencyExchangeTypeDeserializerState::TargetCurrencyCode(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_conversion_rate<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::RateType>,
            fallback: &mut Option<TradeCurrencyExchangeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.conversion_rate.is_some() {
                    fallback.get_or_insert(
                        TradeCurrencyExchangeTypeDeserializerState::ConversionRate(None),
                    );
                    *self.state =
                        TradeCurrencyExchangeTypeDeserializerState::ConversionRateDateTime(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeCurrencyExchangeTypeDeserializerState::ConversionRate(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_conversion_rate(data)?;
                    *self.state =
                        TradeCurrencyExchangeTypeDeserializerState::ConversionRateDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeCurrencyExchangeTypeDeserializerState::ConversionRate(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeCurrencyExchangeTypeDeserializerState::ConversionRateDateTime(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeCurrencyExchangeTypeDeserializerState::ConversionRate(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_conversion_rate_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<TradeCurrencyExchangeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeCurrencyExchangeTypeDeserializerState::ConversionRateDateTime(None),
                );
                *self.state = TradeCurrencyExchangeTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_conversion_rate_date_time(data)?;
                    *self.state = TradeCurrencyExchangeTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeCurrencyExchangeTypeDeserializerState::ConversionRateDateTime(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = TradeCurrencyExchangeTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeCurrencyExchangeTypeDeserializerState::ConversionRateDateTime(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeCurrencyExchangeType>
        for TradeCurrencyExchangeTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeCurrencyExchangeType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeCurrencyExchangeType>
        where
            R: DeserializeReader,
        {
            use TradeCurrencyExchangeTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SourceCurrencyCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_source_currency_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TargetCurrencyCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_target_currency_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ConversionRate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_conversion_rate(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ConversionRateDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_conversion_rate_date_time(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TradeCurrencyExchangeTypeDeserializerState::SourceCurrencyCode(None);
                        event
                    }
                    (S::SourceCurrencyCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SourceCurrencyCode",
                        ) {
                            let output =
                                <super::CurrencyCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_source_currency_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TargetCurrencyCode(None);
                            event
                        }
                    }
                    (S::TargetCurrencyCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TargetCurrencyCode",
                        ) {
                            let output =
                                <super::CurrencyCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_target_currency_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ConversionRate(None);
                            event
                        }
                    }
                    (S::ConversionRate(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ConversionRate",
                        ) {
                            let output = <super::RateType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_conversion_rate(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ConversionRateDateTime(None);
                            event
                        }
                    }
                    (
                        S::ConversionRateDateTime(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ConversionRateDateTime",
                        ) {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_conversion_rate_date_time(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeCurrencyExchangeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeCurrencyExchangeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeCurrencyExchangeType {
                source_currency_code: self
                    .source_currency_code
                    .ok_or_else(|| ErrorKind::MissingElement("SourceCurrencyCode".into()))?,
                target_currency_code: self
                    .target_currency_code
                    .ok_or_else(|| ErrorKind::MissingElement("TargetCurrencyCode".into()))?,
                conversion_rate: self
                    .conversion_rate
                    .ok_or_else(|| ErrorKind::MissingElement("ConversionRate".into()))?,
                conversion_rate_date_time: self.conversion_rate_date_time,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeSettlementPaymentMeansTypeDeserializer {
        type_code: Option<super::PaymentMeansCodeType>,
        information: Option<super::TextType>,
        applicable_trade_settlement_financial_card: Option<super::TradeSettlementFinancialCardType>,
        payer_party_debtor_financial_account: Option<super::DebtorFinancialAccountType>,
        payee_party_creditor_financial_account: Option<super::CreditorFinancialAccountType>,
        payee_specified_creditor_financial_institution:
            Option<super::CreditorFinancialInstitutionType>,
        state: Box<TradeSettlementPaymentMeansTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeSettlementPaymentMeansTypeDeserializerState {
        Init__,
        TypeCode(Option<<super::PaymentMeansCodeType as WithDeserializer>::Deserializer>),
        Information(Option<<super::TextType as WithDeserializer>::Deserializer>),
        ApplicableTradeSettlementFinancialCard(
            Option<<super::TradeSettlementFinancialCardType as WithDeserializer>::Deserializer>,
        ),
        PayerPartyDebtorFinancialAccount(
            Option<<super::DebtorFinancialAccountType as WithDeserializer>::Deserializer>,
        ),
        PayeePartyCreditorFinancialAccount(
            Option<<super::CreditorFinancialAccountType as WithDeserializer>::Deserializer>,
        ),
        PayeeSpecifiedCreditorFinancialInstitution(
            Option<<super::CreditorFinancialInstitutionType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TradeSettlementPaymentMeansTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                type_code: None,
                information: None,
                applicable_trade_settlement_financial_card: None,
                payer_party_debtor_financial_account: None,
                payee_party_creditor_financial_account: None,
                payee_specified_creditor_financial_institution: None,
                state: Box::new(TradeSettlementPaymentMeansTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeSettlementPaymentMeansTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeSettlementPaymentMeansTypeDeserializerState as S;
            match state {
                S::TypeCode(Some(deserializer)) => {
                    self.store_type_code(deserializer.finish(reader)?)?
                }
                S::Information(Some(deserializer)) => {
                    self.store_information(deserializer.finish(reader)?)?
                }
                S::ApplicableTradeSettlementFinancialCard(Some(deserializer)) => self
                    .store_applicable_trade_settlement_financial_card(
                        deserializer.finish(reader)?,
                    )?,
                S::PayerPartyDebtorFinancialAccount(Some(deserializer)) => {
                    self.store_payer_party_debtor_financial_account(deserializer.finish(reader)?)?
                }
                S::PayeePartyCreditorFinancialAccount(Some(deserializer)) => {
                    self.store_payee_party_creditor_financial_account(deserializer.finish(reader)?)?
                }
                S::PayeeSpecifiedCreditorFinancialInstitution(Some(deserializer)) => self
                    .store_payee_specified_creditor_financial_institution(
                        deserializer.finish(reader)?,
                    )?,
                _ => (),
            }
            Ok(())
        }
        fn store_type_code(&mut self, value: super::PaymentMeansCodeType) -> Result<(), Error> {
            if self.type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TypeCode",
                )))?;
            }
            self.type_code = Some(value);
            Ok(())
        }
        fn store_information(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.information.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Information",
                )))?;
            }
            self.information = Some(value);
            Ok(())
        }
        fn store_applicable_trade_settlement_financial_card(
            &mut self,
            value: super::TradeSettlementFinancialCardType,
        ) -> Result<(), Error> {
            if self.applicable_trade_settlement_financial_card.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ApplicableTradeSettlementFinancialCard",
                )))?;
            }
            self.applicable_trade_settlement_financial_card = Some(value);
            Ok(())
        }
        fn store_payer_party_debtor_financial_account(
            &mut self,
            value: super::DebtorFinancialAccountType,
        ) -> Result<(), Error> {
            if self.payer_party_debtor_financial_account.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PayerPartyDebtorFinancialAccount",
                )))?;
            }
            self.payer_party_debtor_financial_account = Some(value);
            Ok(())
        }
        fn store_payee_party_creditor_financial_account(
            &mut self,
            value: super::CreditorFinancialAccountType,
        ) -> Result<(), Error> {
            if self.payee_party_creditor_financial_account.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PayeePartyCreditorFinancialAccount",
                )))?;
            }
            self.payee_party_creditor_financial_account = Some(value);
            Ok(())
        }
        fn store_payee_specified_creditor_financial_institution(
            &mut self,
            value: super::CreditorFinancialInstitutionType,
        ) -> Result<(), Error> {
            if self
                .payee_specified_creditor_financial_institution
                .is_some()
            {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PayeeSpecifiedCreditorFinancialInstitution",
                )))?;
            }
            self.payee_specified_creditor_financial_institution = Some(value);
            Ok(())
        }
        fn handle_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PaymentMeansCodeType>,
            fallback: &mut Option<TradeSettlementPaymentMeansTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.type_code.is_some() {
                    fallback.get_or_insert(
                        TradeSettlementPaymentMeansTypeDeserializerState::TypeCode(None),
                    );
                    *self.state =
                        TradeSettlementPaymentMeansTypeDeserializerState::Information(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeSettlementPaymentMeansTypeDeserializerState::TypeCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_type_code(data)?;
                    *self.state =
                        TradeSettlementPaymentMeansTypeDeserializerState::Information(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeSettlementPaymentMeansTypeDeserializerState::TypeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeSettlementPaymentMeansTypeDeserializerState::Information(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeSettlementPaymentMeansTypeDeserializerState::TypeCode(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_information<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeSettlementPaymentMeansTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementPaymentMeansTypeDeserializerState::Information(None),
                );
                * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: ApplicableTradeSettlementFinancialCard (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_information(data)?;
                    * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: ApplicableTradeSettlementFinancialCard (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeSettlementPaymentMeansTypeDeserializerState::Information(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: ApplicableTradeSettlementFinancialCard (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeSettlementPaymentMeansTypeDeserializerState::Information(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_trade_settlement_financial_card<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeSettlementFinancialCardType>,
            fallback: &mut Option<TradeSettlementPaymentMeansTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (TradeSettlementPaymentMeansTypeDeserializerState :: ApplicableTradeSettlementFinancialCard (None)) ;
                * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayerPartyDebtorFinancialAccount (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_trade_settlement_financial_card(data)?;
                    * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayerPartyDebtorFinancialAccount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementPaymentMeansTypeDeserializerState :: ApplicableTradeSettlementFinancialCard (Some (deserializer))) ;
                            * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayerPartyDebtorFinancialAccount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: ApplicableTradeSettlementFinancialCard (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_payer_party_debtor_financial_account<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DebtorFinancialAccountType>,
            fallback: &mut Option<TradeSettlementPaymentMeansTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (TradeSettlementPaymentMeansTypeDeserializerState :: PayerPartyDebtorFinancialAccount (None)) ;
                * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayeePartyCreditorFinancialAccount (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_payer_party_debtor_financial_account(data)?;
                    * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayeePartyCreditorFinancialAccount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementPaymentMeansTypeDeserializerState :: PayerPartyDebtorFinancialAccount (Some (deserializer))) ;
                            * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayeePartyCreditorFinancialAccount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayerPartyDebtorFinancialAccount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_payee_party_creditor_financial_account<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CreditorFinancialAccountType>,
            fallback: &mut Option<TradeSettlementPaymentMeansTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (TradeSettlementPaymentMeansTypeDeserializerState :: PayeePartyCreditorFinancialAccount (None)) ;
                * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayeeSpecifiedCreditorFinancialInstitution (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_payee_party_creditor_financial_account(data)?;
                    * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayeeSpecifiedCreditorFinancialInstitution (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementPaymentMeansTypeDeserializerState :: PayeePartyCreditorFinancialAccount (Some (deserializer))) ;
                            * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayeeSpecifiedCreditorFinancialInstitution (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayeePartyCreditorFinancialAccount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_payee_specified_creditor_financial_institution<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CreditorFinancialInstitutionType>,
            fallback: &mut Option<TradeSettlementPaymentMeansTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (TradeSettlementPaymentMeansTypeDeserializerState :: PayeeSpecifiedCreditorFinancialInstitution (None)) ;
                *self.state = TradeSettlementPaymentMeansTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_payee_specified_creditor_financial_institution(data)?;
                    *self.state = TradeSettlementPaymentMeansTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementPaymentMeansTypeDeserializerState :: PayeeSpecifiedCreditorFinancialInstitution (Some (deserializer))) ;
                            *self.state = TradeSettlementPaymentMeansTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementPaymentMeansTypeDeserializerState :: PayeeSpecifiedCreditorFinancialInstitution (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeSettlementPaymentMeansType>
        for TradeSettlementPaymentMeansTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeSettlementPaymentMeansType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeSettlementPaymentMeansType>
        where
            R: DeserializeReader,
        {
            use TradeSettlementPaymentMeansTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Information(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_information(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableTradeSettlementFinancialCard(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_trade_settlement_financial_card(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PayerPartyDebtorFinancialAccount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_payer_party_debtor_financial_account(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PayeePartyCreditorFinancialAccount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_payee_party_creditor_financial_account(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PayeeSpecifiedCreditorFinancialInstitution(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_payee_specified_creditor_financial_institution(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TradeSettlementPaymentMeansTypeDeserializerState::TypeCode(None);
                        event
                    }
                    (S::TypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"TypeCode") {
                            let output = < super :: PaymentMeansCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Information(None);
                            event
                        }
                    }
                    (S::Information(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Information")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_information(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableTradeSettlementFinancialCard(None);
                            event
                        }
                    }
                    (
                        S::ApplicableTradeSettlementFinancialCard(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableTradeSettlementFinancialCard",
                        ) {
                            let output = < super :: TradeSettlementFinancialCardType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applicable_trade_settlement_financial_card(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PayerPartyDebtorFinancialAccount(None);
                            event
                        }
                    }
                    (
                        S::PayerPartyDebtorFinancialAccount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PayerPartyDebtorFinancialAccount",
                        ) {
                            let output = < super :: DebtorFinancialAccountType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_payer_party_debtor_financial_account(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PayeePartyCreditorFinancialAccount(None);
                            event
                        }
                    }
                    (
                        S::PayeePartyCreditorFinancialAccount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PayeePartyCreditorFinancialAccount",
                        ) {
                            let output = < super :: CreditorFinancialAccountType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_payee_party_creditor_financial_account(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PayeeSpecifiedCreditorFinancialInstitution(None);
                            event
                        }
                    }
                    (
                        S::PayeeSpecifiedCreditorFinancialInstitution(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PayeeSpecifiedCreditorFinancialInstitution",
                        ) {
                            let output = < super :: CreditorFinancialInstitutionType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_payee_specified_creditor_financial_institution(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeSettlementPaymentMeansType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeSettlementPaymentMeansTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeSettlementPaymentMeansType {
                type_code: self
                    .type_code
                    .ok_or_else(|| ErrorKind::MissingElement("TypeCode".into()))?,
                information: self.information,
                applicable_trade_settlement_financial_card: self
                    .applicable_trade_settlement_financial_card,
                payer_party_debtor_financial_account: self.payer_party_debtor_financial_account,
                payee_party_creditor_financial_account: self.payee_party_creditor_financial_account,
                payee_specified_creditor_financial_institution: self
                    .payee_specified_creditor_financial_institution,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeTaxTypeDeserializer {
        calculated_amount: Option<super::AmountType>,
        type_code: Option<super::TaxTypeCodeType>,
        exemption_reason: Option<super::TextType>,
        basis_amount: Option<super::AmountType>,
        line_total_basis_amount: Option<super::AmountType>,
        allowance_charge_basis_amount: Option<super::AmountType>,
        category_code: Option<super::TaxCategoryCodeType>,
        exemption_reason_code: Option<super::CodeType>,
        tax_point_date: Option<super::DateType>,
        due_date_type_code: Option<super::TimeReferenceCodeType>,
        rate_applicable_percent: Option<super::PercentType>,
        state: Box<TradeTaxTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeTaxTypeDeserializerState {
        Init__,
        CalculatedAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        TypeCode(Option<<super::TaxTypeCodeType as WithDeserializer>::Deserializer>),
        ExemptionReason(Option<<super::TextType as WithDeserializer>::Deserializer>),
        BasisAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        LineTotalBasisAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        AllowanceChargeBasisAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        CategoryCode(Option<<super::TaxCategoryCodeType as WithDeserializer>::Deserializer>),
        ExemptionReasonCode(Option<<super::CodeType as WithDeserializer>::Deserializer>),
        TaxPointDate(Option<<super::DateType as WithDeserializer>::Deserializer>),
        DueDateTypeCode(Option<<super::TimeReferenceCodeType as WithDeserializer>::Deserializer>),
        RateApplicablePercent(Option<<super::PercentType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeTaxTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                calculated_amount: None,
                type_code: None,
                exemption_reason: None,
                basis_amount: None,
                line_total_basis_amount: None,
                allowance_charge_basis_amount: None,
                category_code: None,
                exemption_reason_code: None,
                tax_point_date: None,
                due_date_type_code: None,
                rate_applicable_percent: None,
                state: Box::new(TradeTaxTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeTaxTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeTaxTypeDeserializerState as S;
            match state {
                S::CalculatedAmount(Some(deserializer)) => {
                    self.store_calculated_amount(deserializer.finish(reader)?)?
                }
                S::TypeCode(Some(deserializer)) => {
                    self.store_type_code(deserializer.finish(reader)?)?
                }
                S::ExemptionReason(Some(deserializer)) => {
                    self.store_exemption_reason(deserializer.finish(reader)?)?
                }
                S::BasisAmount(Some(deserializer)) => {
                    self.store_basis_amount(deserializer.finish(reader)?)?
                }
                S::LineTotalBasisAmount(Some(deserializer)) => {
                    self.store_line_total_basis_amount(deserializer.finish(reader)?)?
                }
                S::AllowanceChargeBasisAmount(Some(deserializer)) => {
                    self.store_allowance_charge_basis_amount(deserializer.finish(reader)?)?
                }
                S::CategoryCode(Some(deserializer)) => {
                    self.store_category_code(deserializer.finish(reader)?)?
                }
                S::ExemptionReasonCode(Some(deserializer)) => {
                    self.store_exemption_reason_code(deserializer.finish(reader)?)?
                }
                S::TaxPointDate(Some(deserializer)) => {
                    self.store_tax_point_date(deserializer.finish(reader)?)?
                }
                S::DueDateTypeCode(Some(deserializer)) => {
                    self.store_due_date_type_code(deserializer.finish(reader)?)?
                }
                S::RateApplicablePercent(Some(deserializer)) => {
                    self.store_rate_applicable_percent(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_calculated_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.calculated_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CalculatedAmount",
                )))?;
            }
            self.calculated_amount = Some(value);
            Ok(())
        }
        fn store_type_code(&mut self, value: super::TaxTypeCodeType) -> Result<(), Error> {
            if self.type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TypeCode",
                )))?;
            }
            self.type_code = Some(value);
            Ok(())
        }
        fn store_exemption_reason(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.exemption_reason.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ExemptionReason",
                )))?;
            }
            self.exemption_reason = Some(value);
            Ok(())
        }
        fn store_basis_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.basis_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisAmount",
                )))?;
            }
            self.basis_amount = Some(value);
            Ok(())
        }
        fn store_line_total_basis_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.line_total_basis_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineTotalBasisAmount",
                )))?;
            }
            self.line_total_basis_amount = Some(value);
            Ok(())
        }
        fn store_allowance_charge_basis_amount(
            &mut self,
            value: super::AmountType,
        ) -> Result<(), Error> {
            if self.allowance_charge_basis_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AllowanceChargeBasisAmount",
                )))?;
            }
            self.allowance_charge_basis_amount = Some(value);
            Ok(())
        }
        fn store_category_code(&mut self, value: super::TaxCategoryCodeType) -> Result<(), Error> {
            if self.category_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CategoryCode",
                )))?;
            }
            self.category_code = Some(value);
            Ok(())
        }
        fn store_exemption_reason_code(&mut self, value: super::CodeType) -> Result<(), Error> {
            if self.exemption_reason_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ExemptionReasonCode",
                )))?;
            }
            self.exemption_reason_code = Some(value);
            Ok(())
        }
        fn store_tax_point_date(&mut self, value: super::DateType) -> Result<(), Error> {
            if self.tax_point_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TaxPointDate",
                )))?;
            }
            self.tax_point_date = Some(value);
            Ok(())
        }
        fn store_due_date_type_code(
            &mut self,
            value: super::TimeReferenceCodeType,
        ) -> Result<(), Error> {
            if self.due_date_type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DueDateTypeCode",
                )))?;
            }
            self.due_date_type_code = Some(value);
            Ok(())
        }
        fn store_rate_applicable_percent(
            &mut self,
            value: super::PercentType,
        ) -> Result<(), Error> {
            if self.rate_applicable_percent.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"RateApplicablePercent",
                )))?;
            }
            self.rate_applicable_percent = Some(value);
            Ok(())
        }
        fn handle_calculated_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::CalculatedAmount(None));
                *self.state = TradeTaxTypeDeserializerState::TypeCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_calculated_amount(data)?;
                    *self.state = TradeTaxTypeDeserializerState::TypeCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeTaxTypeDeserializerState::CalculatedAmount(Some(deserializer)),
                            );
                            *self.state = TradeTaxTypeDeserializerState::TypeCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeTaxTypeDeserializerState::CalculatedAmount(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TaxTypeCodeType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.type_code.is_some() {
                    fallback.get_or_insert(TradeTaxTypeDeserializerState::TypeCode(None));
                    *self.state = TradeTaxTypeDeserializerState::ExemptionReason(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeTaxTypeDeserializerState::TypeCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_type_code(data)?;
                    *self.state = TradeTaxTypeDeserializerState::ExemptionReason(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeTaxTypeDeserializerState::TypeCode(Some(
                                deserializer,
                            )));
                            *self.state = TradeTaxTypeDeserializerState::ExemptionReason(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeTaxTypeDeserializerState::TypeCode(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_exemption_reason<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::ExemptionReason(None));
                *self.state = TradeTaxTypeDeserializerState::BasisAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_exemption_reason(data)?;
                    *self.state = TradeTaxTypeDeserializerState::BasisAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeTaxTypeDeserializerState::ExemptionReason(
                                Some(deserializer),
                            ));
                            *self.state = TradeTaxTypeDeserializerState::BasisAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeTaxTypeDeserializerState::ExemptionReason(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_basis_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::BasisAmount(None));
                *self.state = TradeTaxTypeDeserializerState::LineTotalBasisAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_amount(data)?;
                    *self.state = TradeTaxTypeDeserializerState::LineTotalBasisAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeTaxTypeDeserializerState::BasisAmount(
                                Some(deserializer),
                            ));
                            *self.state = TradeTaxTypeDeserializerState::LineTotalBasisAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeTaxTypeDeserializerState::BasisAmount(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_line_total_basis_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::LineTotalBasisAmount(None));
                *self.state = TradeTaxTypeDeserializerState::AllowanceChargeBasisAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_total_basis_amount(data)?;
                    *self.state = TradeTaxTypeDeserializerState::AllowanceChargeBasisAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeTaxTypeDeserializerState::LineTotalBasisAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeTaxTypeDeserializerState::AllowanceChargeBasisAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeTaxTypeDeserializerState::LineTotalBasisAmount(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_allowance_charge_basis_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::AllowanceChargeBasisAmount(
                    None,
                ));
                *self.state = TradeTaxTypeDeserializerState::CategoryCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_allowance_charge_basis_amount(data)?;
                    *self.state = TradeTaxTypeDeserializerState::CategoryCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeTaxTypeDeserializerState::AllowanceChargeBasisAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeTaxTypeDeserializerState::CategoryCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeTaxTypeDeserializerState::AllowanceChargeBasisAmount(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_category_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TaxCategoryCodeType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.category_code.is_some() {
                    fallback.get_or_insert(TradeTaxTypeDeserializerState::CategoryCode(None));
                    *self.state = TradeTaxTypeDeserializerState::ExemptionReasonCode(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeTaxTypeDeserializerState::CategoryCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_category_code(data)?;
                    *self.state = TradeTaxTypeDeserializerState::ExemptionReasonCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeTaxTypeDeserializerState::CategoryCode(
                                Some(deserializer),
                            ));
                            *self.state = TradeTaxTypeDeserializerState::ExemptionReasonCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeTaxTypeDeserializerState::CategoryCode(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_exemption_reason_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CodeType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::ExemptionReasonCode(None));
                *self.state = TradeTaxTypeDeserializerState::TaxPointDate(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_exemption_reason_code(data)?;
                    *self.state = TradeTaxTypeDeserializerState::TaxPointDate(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeTaxTypeDeserializerState::ExemptionReasonCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeTaxTypeDeserializerState::TaxPointDate(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeTaxTypeDeserializerState::ExemptionReasonCode(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_tax_point_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::TaxPointDate(None));
                *self.state = TradeTaxTypeDeserializerState::DueDateTypeCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_tax_point_date(data)?;
                    *self.state = TradeTaxTypeDeserializerState::DueDateTypeCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeTaxTypeDeserializerState::TaxPointDate(
                                Some(deserializer),
                            ));
                            *self.state = TradeTaxTypeDeserializerState::DueDateTypeCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeTaxTypeDeserializerState::TaxPointDate(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_due_date_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TimeReferenceCodeType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::DueDateTypeCode(None));
                *self.state = TradeTaxTypeDeserializerState::RateApplicablePercent(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_due_date_type_code(data)?;
                    *self.state = TradeTaxTypeDeserializerState::RateApplicablePercent(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeTaxTypeDeserializerState::DueDateTypeCode(
                                Some(deserializer),
                            ));
                            *self.state =
                                TradeTaxTypeDeserializerState::RateApplicablePercent(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeTaxTypeDeserializerState::DueDateTypeCode(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_rate_applicable_percent<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PercentType>,
            fallback: &mut Option<TradeTaxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeTaxTypeDeserializerState::RateApplicablePercent(None));
                *self.state = TradeTaxTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_rate_applicable_percent(data)?;
                    *self.state = TradeTaxTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeTaxTypeDeserializerState::RateApplicablePercent(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeTaxTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeTaxTypeDeserializerState::RateApplicablePercent(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeTaxType> for TradeTaxTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TradeTaxType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeTaxType>
        where
            R: DeserializeReader,
        {
            use TradeTaxTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CalculatedAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_calculated_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ExemptionReason(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_exemption_reason(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BasisAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LineTotalBasisAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_total_basis_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AllowanceChargeBasisAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_allowance_charge_basis_amount(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CategoryCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_category_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ExemptionReasonCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_exemption_reason_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TaxPointDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tax_point_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DueDateTypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_due_date_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::RateApplicablePercent(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_rate_applicable_percent(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradeTaxTypeDeserializerState::CalculatedAmount(None);
                        event
                    }
                    (S::CalculatedAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CalculatedAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_calculated_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TypeCode(None);
                            event
                        }
                    }
                    (S::TypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"TypeCode") {
                            let output =
                                <super::TaxTypeCodeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ExemptionReason(None);
                            event
                        }
                    }
                    (S::ExemptionReason(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ExemptionReason",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_exemption_reason(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BasisAmount(None);
                            event
                        }
                    }
                    (S::BasisAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"BasisAmount")
                        {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LineTotalBasisAmount(None);
                            event
                        }
                    }
                    (
                        S::LineTotalBasisAmount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"LineTotalBasisAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_line_total_basis_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AllowanceChargeBasisAmount(None);
                            event
                        }
                    }
                    (
                        S::AllowanceChargeBasisAmount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AllowanceChargeBasisAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_allowance_charge_basis_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CategoryCode(None);
                            event
                        }
                    }
                    (S::CategoryCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CategoryCode",
                        ) {
                            let output = < super :: TaxCategoryCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_category_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ExemptionReasonCode(None);
                            event
                        }
                    }
                    (S::ExemptionReasonCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ExemptionReasonCode",
                        ) {
                            let output = <super::CodeType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_exemption_reason_code(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TaxPointDate(None);
                            event
                        }
                    }
                    (S::TaxPointDate(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TaxPointDate",
                        ) {
                            let output = <super::DateType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_tax_point_date(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DueDateTypeCode(None);
                            event
                        }
                    }
                    (S::DueDateTypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DueDateTypeCode",
                        ) {
                            let output = < super :: TimeReferenceCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_due_date_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::RateApplicablePercent(None);
                            event
                        }
                    }
                    (
                        S::RateApplicablePercent(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"RateApplicablePercent",
                        ) {
                            let output =
                                <super::PercentType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_rate_applicable_percent(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeTaxType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, TradeTaxTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::TradeTaxType {
                calculated_amount: self.calculated_amount,
                type_code: self
                    .type_code
                    .ok_or_else(|| ErrorKind::MissingElement("TypeCode".into()))?,
                exemption_reason: self.exemption_reason,
                basis_amount: self.basis_amount,
                line_total_basis_amount: self.line_total_basis_amount,
                allowance_charge_basis_amount: self.allowance_charge_basis_amount,
                category_code: self
                    .category_code
                    .ok_or_else(|| ErrorKind::MissingElement("CategoryCode".into()))?,
                exemption_reason_code: self.exemption_reason_code,
                tax_point_date: self.tax_point_date,
                due_date_type_code: self.due_date_type_code,
                rate_applicable_percent: self.rate_applicable_percent,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeAllowanceChargeTypeDeserializer {
        charge_indicator: Option<super::IndicatorType>,
        sequence_numeric: Option<super::NumericType>,
        calculation_percent: Option<super::PercentType>,
        basis_amount: Option<super::AmountType>,
        basis_quantity: Option<super::QuantityType>,
        actual_amount: Option<super::AmountType>,
        reason_code: Option<super::AllowanceChargeReasonCodeType>,
        reason: Option<super::TextType>,
        category_trade_tax: Option<super::TradeTaxType>,
        state: Box<TradeAllowanceChargeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeAllowanceChargeTypeDeserializerState {
        Init__,
        ChargeIndicator(Option<<super::IndicatorType as WithDeserializer>::Deserializer>),
        SequenceNumeric(Option<<super::NumericType as WithDeserializer>::Deserializer>),
        CalculationPercent(Option<<super::PercentType as WithDeserializer>::Deserializer>),
        BasisAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        BasisQuantity(Option<<super::QuantityType as WithDeserializer>::Deserializer>),
        ActualAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        ReasonCode(
            Option<<super::AllowanceChargeReasonCodeType as WithDeserializer>::Deserializer>,
        ),
        Reason(Option<<super::TextType as WithDeserializer>::Deserializer>),
        CategoryTradeTax(Option<<super::TradeTaxType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeAllowanceChargeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                charge_indicator: None,
                sequence_numeric: None,
                calculation_percent: None,
                basis_amount: None,
                basis_quantity: None,
                actual_amount: None,
                reason_code: None,
                reason: None,
                category_trade_tax: None,
                state: Box::new(TradeAllowanceChargeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeAllowanceChargeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeAllowanceChargeTypeDeserializerState as S;
            match state {
                S::ChargeIndicator(Some(deserializer)) => {
                    self.store_charge_indicator(deserializer.finish(reader)?)?
                }
                S::SequenceNumeric(Some(deserializer)) => {
                    self.store_sequence_numeric(deserializer.finish(reader)?)?
                }
                S::CalculationPercent(Some(deserializer)) => {
                    self.store_calculation_percent(deserializer.finish(reader)?)?
                }
                S::BasisAmount(Some(deserializer)) => {
                    self.store_basis_amount(deserializer.finish(reader)?)?
                }
                S::BasisQuantity(Some(deserializer)) => {
                    self.store_basis_quantity(deserializer.finish(reader)?)?
                }
                S::ActualAmount(Some(deserializer)) => {
                    self.store_actual_amount(deserializer.finish(reader)?)?
                }
                S::ReasonCode(Some(deserializer)) => {
                    self.store_reason_code(deserializer.finish(reader)?)?
                }
                S::Reason(Some(deserializer)) => self.store_reason(deserializer.finish(reader)?)?,
                S::CategoryTradeTax(Some(deserializer)) => {
                    self.store_category_trade_tax(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_charge_indicator(&mut self, value: super::IndicatorType) -> Result<(), Error> {
            if self.charge_indicator.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ChargeIndicator",
                )))?;
            }
            self.charge_indicator = Some(value);
            Ok(())
        }
        fn store_sequence_numeric(&mut self, value: super::NumericType) -> Result<(), Error> {
            if self.sequence_numeric.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SequenceNumeric",
                )))?;
            }
            self.sequence_numeric = Some(value);
            Ok(())
        }
        fn store_calculation_percent(&mut self, value: super::PercentType) -> Result<(), Error> {
            if self.calculation_percent.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CalculationPercent",
                )))?;
            }
            self.calculation_percent = Some(value);
            Ok(())
        }
        fn store_basis_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.basis_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisAmount",
                )))?;
            }
            self.basis_amount = Some(value);
            Ok(())
        }
        fn store_basis_quantity(&mut self, value: super::QuantityType) -> Result<(), Error> {
            if self.basis_quantity.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisQuantity",
                )))?;
            }
            self.basis_quantity = Some(value);
            Ok(())
        }
        fn store_actual_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.actual_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ActualAmount",
                )))?;
            }
            self.actual_amount = Some(value);
            Ok(())
        }
        fn store_reason_code(
            &mut self,
            value: super::AllowanceChargeReasonCodeType,
        ) -> Result<(), Error> {
            if self.reason_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ReasonCode",
                )))?;
            }
            self.reason_code = Some(value);
            Ok(())
        }
        fn store_reason(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.reason.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Reason",
                )))?;
            }
            self.reason = Some(value);
            Ok(())
        }
        fn store_category_trade_tax(&mut self, value: super::TradeTaxType) -> Result<(), Error> {
            if self.category_trade_tax.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CategoryTradeTax",
                )))?;
            }
            self.category_trade_tax = Some(value);
            Ok(())
        }
        fn handle_charge_indicator<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IndicatorType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.charge_indicator.is_some() {
                    fallback.get_or_insert(
                        TradeAllowanceChargeTypeDeserializerState::ChargeIndicator(None),
                    );
                    *self.state = TradeAllowanceChargeTypeDeserializerState::SequenceNumeric(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeAllowanceChargeTypeDeserializerState::ChargeIndicator(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_charge_indicator(data)?;
                    *self.state = TradeAllowanceChargeTypeDeserializerState::SequenceNumeric(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::ChargeIndicator(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::SequenceNumeric(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::ChargeIndicator(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_sequence_numeric<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::NumericType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAllowanceChargeTypeDeserializerState::SequenceNumeric(
                    None,
                ));
                *self.state = TradeAllowanceChargeTypeDeserializerState::CalculationPercent(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_sequence_numeric(data)?;
                    *self.state =
                        TradeAllowanceChargeTypeDeserializerState::CalculationPercent(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::SequenceNumeric(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::CalculationPercent(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::SequenceNumeric(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_calculation_percent<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PercentType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeAllowanceChargeTypeDeserializerState::CalculationPercent(None),
                );
                *self.state = TradeAllowanceChargeTypeDeserializerState::BasisAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_calculation_percent(data)?;
                    *self.state = TradeAllowanceChargeTypeDeserializerState::BasisAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::CalculationPercent(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::BasisAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::CalculationPercent(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_basis_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(TradeAllowanceChargeTypeDeserializerState::BasisAmount(None));
                *self.state = TradeAllowanceChargeTypeDeserializerState::BasisQuantity(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_amount(data)?;
                    *self.state = TradeAllowanceChargeTypeDeserializerState::BasisQuantity(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::BasisAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::BasisQuantity(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeAllowanceChargeTypeDeserializerState::BasisAmount(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_basis_quantity<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::QuantityType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAllowanceChargeTypeDeserializerState::BasisQuantity(
                    None,
                ));
                *self.state = TradeAllowanceChargeTypeDeserializerState::ActualAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_quantity(data)?;
                    *self.state = TradeAllowanceChargeTypeDeserializerState::ActualAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::BasisQuantity(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::ActualAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeAllowanceChargeTypeDeserializerState::BasisQuantity(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_actual_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.actual_amount.is_some() {
                    fallback.get_or_insert(
                        TradeAllowanceChargeTypeDeserializerState::ActualAmount(None),
                    );
                    *self.state = TradeAllowanceChargeTypeDeserializerState::ReasonCode(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeAllowanceChargeTypeDeserializerState::ActualAmount(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actual_amount(data)?;
                    *self.state = TradeAllowanceChargeTypeDeserializerState::ReasonCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::ActualAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::ReasonCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeAllowanceChargeTypeDeserializerState::ActualAmount(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_reason_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AllowanceChargeReasonCodeType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAllowanceChargeTypeDeserializerState::ReasonCode(None));
                *self.state = TradeAllowanceChargeTypeDeserializerState::Reason(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reason_code(data)?;
                    *self.state = TradeAllowanceChargeTypeDeserializerState::Reason(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::ReasonCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeAllowanceChargeTypeDeserializerState::Reason(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeAllowanceChargeTypeDeserializerState::ReasonCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_reason<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAllowanceChargeTypeDeserializerState::Reason(None));
                *self.state = TradeAllowanceChargeTypeDeserializerState::CategoryTradeTax(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reason(data)?;
                    *self.state = TradeAllowanceChargeTypeDeserializerState::CategoryTradeTax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::Reason(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::CategoryTradeTax(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeAllowanceChargeTypeDeserializerState::Reason(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_category_trade_tax<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeTaxType>,
            fallback: &mut Option<TradeAllowanceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeAllowanceChargeTypeDeserializerState::CategoryTradeTax(None),
                );
                *self.state = TradeAllowanceChargeTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_category_trade_tax(data)?;
                    *self.state = TradeAllowanceChargeTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAllowanceChargeTypeDeserializerState::CategoryTradeTax(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeAllowanceChargeTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAllowanceChargeTypeDeserializerState::CategoryTradeTax(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeAllowanceChargeType>
        for TradeAllowanceChargeTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeAllowanceChargeType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeAllowanceChargeType>
        where
            R: DeserializeReader,
        {
            use TradeAllowanceChargeTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ChargeIndicator(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_charge_indicator(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SequenceNumeric(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_sequence_numeric(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CalculationPercent(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_calculation_percent(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BasisAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BasisQuantity(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_quantity(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ActualAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actual_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReasonCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reason_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Reason(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reason(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CategoryTradeTax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_category_trade_tax(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TradeAllowanceChargeTypeDeserializerState::ChargeIndicator(None);
                        event
                    }
                    (S::ChargeIndicator(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ChargeIndicator",
                        ) {
                            let output =
                                <super::IndicatorType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_charge_indicator(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SequenceNumeric(None);
                            event
                        }
                    }
                    (S::SequenceNumeric(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SequenceNumeric",
                        ) {
                            let output =
                                <super::NumericType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_sequence_numeric(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CalculationPercent(None);
                            event
                        }
                    }
                    (S::CalculationPercent(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CalculationPercent",
                        ) {
                            let output =
                                <super::PercentType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_calculation_percent(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BasisAmount(None);
                            event
                        }
                    }
                    (S::BasisAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"BasisAmount")
                        {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BasisQuantity(None);
                            event
                        }
                    }
                    (S::BasisQuantity(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BasisQuantity",
                        ) {
                            let output =
                                <super::QuantityType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_quantity(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ActualAmount(None);
                            event
                        }
                    }
                    (S::ActualAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ActualAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_actual_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReasonCode(None);
                            event
                        }
                    }
                    (S::ReasonCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ReasonCode")
                        {
                            let output = < super :: AllowanceChargeReasonCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_reason_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Reason(None);
                            event
                        }
                    }
                    (S::Reason(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Reason") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_reason(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CategoryTradeTax(None);
                            event
                        }
                    }
                    (S::CategoryTradeTax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CategoryTradeTax",
                        ) {
                            let output =
                                <super::TradeTaxType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_category_trade_tax(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeAllowanceChargeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeAllowanceChargeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeAllowanceChargeType {
                charge_indicator: self
                    .charge_indicator
                    .ok_or_else(|| ErrorKind::MissingElement("ChargeIndicator".into()))?,
                sequence_numeric: self.sequence_numeric,
                calculation_percent: self.calculation_percent,
                basis_amount: self.basis_amount,
                basis_quantity: self.basis_quantity,
                actual_amount: self
                    .actual_amount
                    .ok_or_else(|| ErrorKind::MissingElement("ActualAmount".into()))?,
                reason_code: self.reason_code,
                reason: self.reason,
                category_trade_tax: self.category_trade_tax,
            })
        }
    }
    #[derive(Debug)]
    pub struct LogisticsServiceChargeTypeDeserializer {
        description: Option<super::TextType>,
        applied_amount: Option<super::AmountType>,
        applied_trade_tax: Vec<super::TradeTaxType>,
        state: Box<LogisticsServiceChargeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LogisticsServiceChargeTypeDeserializerState {
        Init__,
        Description(Option<<super::TextType as WithDeserializer>::Deserializer>),
        AppliedAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        AppliedTradeTax(Option<<super::TradeTaxType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl LogisticsServiceChargeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                description: None,
                applied_amount: None,
                applied_trade_tax: Vec::new(),
                state: Box::new(LogisticsServiceChargeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LogisticsServiceChargeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use LogisticsServiceChargeTypeDeserializerState as S;
            match state {
                S::Description(Some(deserializer)) => {
                    self.store_description(deserializer.finish(reader)?)?
                }
                S::AppliedAmount(Some(deserializer)) => {
                    self.store_applied_amount(deserializer.finish(reader)?)?
                }
                S::AppliedTradeTax(Some(deserializer)) => {
                    self.store_applied_trade_tax(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_description(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.description.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Description",
                )))?;
            }
            self.description = Some(value);
            Ok(())
        }
        fn store_applied_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.applied_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AppliedAmount",
                )))?;
            }
            self.applied_amount = Some(value);
            Ok(())
        }
        fn store_applied_trade_tax(&mut self, value: super::TradeTaxType) -> Result<(), Error> {
            self.applied_trade_tax.push(value);
            Ok(())
        }
        fn handle_description<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<LogisticsServiceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.description.is_some() {
                    fallback.get_or_insert(
                        LogisticsServiceChargeTypeDeserializerState::Description(None),
                    );
                    *self.state = LogisticsServiceChargeTypeDeserializerState::AppliedAmount(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = LogisticsServiceChargeTypeDeserializerState::Description(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description(data)?;
                    *self.state = LogisticsServiceChargeTypeDeserializerState::AppliedAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LogisticsServiceChargeTypeDeserializerState::Description(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                LogisticsServiceChargeTypeDeserializerState::AppliedAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = LogisticsServiceChargeTypeDeserializerState::Description(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applied_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<LogisticsServiceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.applied_amount.is_some() {
                    fallback.get_or_insert(
                        LogisticsServiceChargeTypeDeserializerState::AppliedAmount(None),
                    );
                    *self.state =
                        LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = LogisticsServiceChargeTypeDeserializerState::AppliedAmount(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applied_amount(data)?;
                    *self.state =
                        LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LogisticsServiceChargeTypeDeserializerState::AppliedAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LogisticsServiceChargeTypeDeserializerState::AppliedAmount(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applied_trade_tax<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeTaxType>,
            fallback: &mut Option<LogisticsServiceChargeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.applied_trade_tax.len() < 1usize {
                    *self.state =
                        LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(None),
                    );
                    *self.state = LogisticsServiceChargeTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applied_trade_tax(data)?;
                    *self.state =
                        LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(Some(
                                    deserializer,
                                )),
                            );
                            if self.applied_trade_tax.len().saturating_add(1) < 1usize {
                                *self.state =
                                    LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(
                                        None,
                                    );
                            } else {
                                *self.state = LogisticsServiceChargeTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LogisticsServiceChargeTypeDeserializerState::AppliedTradeTax(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::LogisticsServiceChargeType>
        for LogisticsServiceChargeTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LogisticsServiceChargeType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LogisticsServiceChargeType>
        where
            R: DeserializeReader,
        {
            use LogisticsServiceChargeTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Description(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AppliedAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applied_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AppliedTradeTax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applied_trade_tax(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            LogisticsServiceChargeTypeDeserializerState::Description(None);
                        event
                    }
                    (S::Description(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Description")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_description(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AppliedAmount(None);
                            event
                        }
                    }
                    (S::AppliedAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AppliedAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_applied_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AppliedTradeTax(None);
                            event
                        }
                    }
                    (S::AppliedTradeTax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AppliedTradeTax",
                        ) {
                            let output =
                                <super::TradeTaxType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_applied_trade_tax(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LogisticsServiceChargeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LogisticsServiceChargeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LogisticsServiceChargeType {
                description: self
                    .description
                    .ok_or_else(|| ErrorKind::MissingElement("Description".into()))?,
                applied_amount: self
                    .applied_amount
                    .ok_or_else(|| ErrorKind::MissingElement("AppliedAmount".into()))?,
                applied_trade_tax: self.applied_trade_tax,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradePaymentTermsTypeDeserializer {
        description: Option<super::TextType>,
        due_date_date_time: Option<super::DateTimeType>,
        direct_debit_mandate_id: Option<super::IdType>,
        partial_payment_amount: Option<super::AmountType>,
        applicable_trade_payment_penalty_terms: Option<super::TradePaymentPenaltyTermsType>,
        applicable_trade_payment_discount_terms: Option<super::TradePaymentDiscountTermsType>,
        payee_trade_party: Option<super::TradePartyType>,
        state: Box<TradePaymentTermsTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradePaymentTermsTypeDeserializerState {
        Init__,
        Description(Option<<super::TextType as WithDeserializer>::Deserializer>),
        DueDateDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        DirectDebitMandateId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        PartialPaymentAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        ApplicableTradePaymentPenaltyTerms(
            Option<<super::TradePaymentPenaltyTermsType as WithDeserializer>::Deserializer>,
        ),
        ApplicableTradePaymentDiscountTerms(
            Option<<super::TradePaymentDiscountTermsType as WithDeserializer>::Deserializer>,
        ),
        PayeeTradeParty(Option<<super::TradePartyType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradePaymentTermsTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                description: None,
                due_date_date_time: None,
                direct_debit_mandate_id: None,
                partial_payment_amount: None,
                applicable_trade_payment_penalty_terms: None,
                applicable_trade_payment_discount_terms: None,
                payee_trade_party: None,
                state: Box::new(TradePaymentTermsTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradePaymentTermsTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradePaymentTermsTypeDeserializerState as S;
            match state {
                S::Description(Some(deserializer)) => {
                    self.store_description(deserializer.finish(reader)?)?
                }
                S::DueDateDateTime(Some(deserializer)) => {
                    self.store_due_date_date_time(deserializer.finish(reader)?)?
                }
                S::DirectDebitMandateId(Some(deserializer)) => {
                    self.store_direct_debit_mandate_id(deserializer.finish(reader)?)?
                }
                S::PartialPaymentAmount(Some(deserializer)) => {
                    self.store_partial_payment_amount(deserializer.finish(reader)?)?
                }
                S::ApplicableTradePaymentPenaltyTerms(Some(deserializer)) => {
                    self.store_applicable_trade_payment_penalty_terms(deserializer.finish(reader)?)?
                }
                S::ApplicableTradePaymentDiscountTerms(Some(deserializer)) => self
                    .store_applicable_trade_payment_discount_terms(deserializer.finish(reader)?)?,
                S::PayeeTradeParty(Some(deserializer)) => {
                    self.store_payee_trade_party(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_description(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.description.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Description",
                )))?;
            }
            self.description = Some(value);
            Ok(())
        }
        fn store_due_date_date_time(&mut self, value: super::DateTimeType) -> Result<(), Error> {
            if self.due_date_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DueDateDateTime",
                )))?;
            }
            self.due_date_date_time = Some(value);
            Ok(())
        }
        fn store_direct_debit_mandate_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.direct_debit_mandate_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DirectDebitMandateID",
                )))?;
            }
            self.direct_debit_mandate_id = Some(value);
            Ok(())
        }
        fn store_partial_payment_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.partial_payment_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PartialPaymentAmount",
                )))?;
            }
            self.partial_payment_amount = Some(value);
            Ok(())
        }
        fn store_applicable_trade_payment_penalty_terms(
            &mut self,
            value: super::TradePaymentPenaltyTermsType,
        ) -> Result<(), Error> {
            if self.applicable_trade_payment_penalty_terms.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ApplicableTradePaymentPenaltyTerms",
                )))?;
            }
            self.applicable_trade_payment_penalty_terms = Some(value);
            Ok(())
        }
        fn store_applicable_trade_payment_discount_terms(
            &mut self,
            value: super::TradePaymentDiscountTermsType,
        ) -> Result<(), Error> {
            if self.applicable_trade_payment_discount_terms.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ApplicableTradePaymentDiscountTerms",
                )))?;
            }
            self.applicable_trade_payment_discount_terms = Some(value);
            Ok(())
        }
        fn store_payee_trade_party(&mut self, value: super::TradePartyType) -> Result<(), Error> {
            if self.payee_trade_party.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PayeeTradeParty",
                )))?;
            }
            self.payee_trade_party = Some(value);
            Ok(())
        }
        fn handle_description<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradePaymentTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePaymentTermsTypeDeserializerState::Description(None));
                *self.state = TradePaymentTermsTypeDeserializerState::DueDateDateTime(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description(data)?;
                    *self.state = TradePaymentTermsTypeDeserializerState::DueDateDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentTermsTypeDeserializerState::Description(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePaymentTermsTypeDeserializerState::DueDateDateTime(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePaymentTermsTypeDeserializerState::Description(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_due_date_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<TradePaymentTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePaymentTermsTypeDeserializerState::DueDateDateTime(
                    None,
                ));
                *self.state = TradePaymentTermsTypeDeserializerState::DirectDebitMandateId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_due_date_date_time(data)?;
                    *self.state =
                        TradePaymentTermsTypeDeserializerState::DirectDebitMandateId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentTermsTypeDeserializerState::DueDateDateTime(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePaymentTermsTypeDeserializerState::DirectDebitMandateId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePaymentTermsTypeDeserializerState::DueDateDateTime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_direct_debit_mandate_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradePaymentTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentTermsTypeDeserializerState::DirectDebitMandateId(None),
                );
                *self.state = TradePaymentTermsTypeDeserializerState::PartialPaymentAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_direct_debit_mandate_id(data)?;
                    *self.state =
                        TradePaymentTermsTypeDeserializerState::PartialPaymentAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentTermsTypeDeserializerState::DirectDebitMandateId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePaymentTermsTypeDeserializerState::PartialPaymentAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentTermsTypeDeserializerState::DirectDebitMandateId(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_partial_payment_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradePaymentTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentTermsTypeDeserializerState::PartialPaymentAmount(None),
                );
                *self.state =
                    TradePaymentTermsTypeDeserializerState::ApplicableTradePaymentPenaltyTerms(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_partial_payment_amount(data)?;
                    *self.state =
                        TradePaymentTermsTypeDeserializerState::ApplicableTradePaymentPenaltyTerms(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentTermsTypeDeserializerState::PartialPaymentAmount(Some(
                                    deserializer,
                                )),
                            );
                            * self . state = TradePaymentTermsTypeDeserializerState :: ApplicableTradePaymentPenaltyTerms (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentTermsTypeDeserializerState::PartialPaymentAmount(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_trade_payment_penalty_terms<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePaymentPenaltyTermsType>,
            fallback: &mut Option<TradePaymentTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentTermsTypeDeserializerState::ApplicableTradePaymentPenaltyTerms(
                        None,
                    ),
                );
                *self.state =
                    TradePaymentTermsTypeDeserializerState::ApplicableTradePaymentDiscountTerms(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_trade_payment_penalty_terms(data)?;
                    *self.state =
                        TradePaymentTermsTypeDeserializerState::ApplicableTradePaymentDiscountTerms(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradePaymentTermsTypeDeserializerState :: ApplicableTradePaymentPenaltyTerms (Some (deserializer))) ;
                            * self . state = TradePaymentTermsTypeDeserializerState :: ApplicableTradePaymentDiscountTerms (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradePaymentTermsTypeDeserializerState :: ApplicableTradePaymentPenaltyTerms (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applicable_trade_payment_discount_terms<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePaymentDiscountTermsType>,
            fallback: &mut Option<TradePaymentTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentTermsTypeDeserializerState::ApplicableTradePaymentDiscountTerms(
                        None,
                    ),
                );
                *self.state = TradePaymentTermsTypeDeserializerState::PayeeTradeParty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applicable_trade_payment_discount_terms(data)?;
                    *self.state = TradePaymentTermsTypeDeserializerState::PayeeTradeParty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradePaymentTermsTypeDeserializerState :: ApplicableTradePaymentDiscountTerms (Some (deserializer))) ;
                            *self.state =
                                TradePaymentTermsTypeDeserializerState::PayeeTradeParty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradePaymentTermsTypeDeserializerState :: ApplicableTradePaymentDiscountTerms (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_payee_trade_party<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradePartyType>,
            fallback: &mut Option<TradePaymentTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePaymentTermsTypeDeserializerState::PayeeTradeParty(
                    None,
                ));
                *self.state = TradePaymentTermsTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_payee_trade_party(data)?;
                    *self.state = TradePaymentTermsTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentTermsTypeDeserializerState::PayeeTradeParty(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradePaymentTermsTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePaymentTermsTypeDeserializerState::PayeeTradeParty(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradePaymentTermsType> for TradePaymentTermsTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradePaymentTermsType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradePaymentTermsType>
        where
            R: DeserializeReader,
        {
            use TradePaymentTermsTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Description(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DueDateDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_due_date_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DirectDebitMandateId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_direct_debit_mandate_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PartialPaymentAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_partial_payment_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableTradePaymentPenaltyTerms(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_trade_payment_penalty_terms(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicableTradePaymentDiscountTerms(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applicable_trade_payment_discount_terms(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PayeeTradeParty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_payee_trade_party(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradePaymentTermsTypeDeserializerState::Description(None);
                        event
                    }
                    (S::Description(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Description")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_description(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DueDateDateTime(None);
                            event
                        }
                    }
                    (S::DueDateDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DueDateDateTime",
                        ) {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_due_date_date_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DirectDebitMandateId(None);
                            event
                        }
                    }
                    (
                        S::DirectDebitMandateId(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DirectDebitMandateID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_direct_debit_mandate_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PartialPaymentAmount(None);
                            event
                        }
                    }
                    (
                        S::PartialPaymentAmount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PartialPaymentAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_partial_payment_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableTradePaymentPenaltyTerms(None);
                            event
                        }
                    }
                    (
                        S::ApplicableTradePaymentPenaltyTerms(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableTradePaymentPenaltyTerms",
                        ) {
                            let output = < super :: TradePaymentPenaltyTermsType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applicable_trade_payment_penalty_terms(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ApplicableTradePaymentDiscountTerms(None);
                            event
                        }
                    }
                    (
                        S::ApplicableTradePaymentDiscountTerms(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ApplicableTradePaymentDiscountTerms",
                        ) {
                            let output = < super :: TradePaymentDiscountTermsType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applicable_trade_payment_discount_terms(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PayeeTradeParty(None);
                            event
                        }
                    }
                    (S::PayeeTradeParty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PayeeTradeParty",
                        ) {
                            let output =
                                <super::TradePartyType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_payee_trade_party(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradePaymentTermsType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradePaymentTermsTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradePaymentTermsType {
                description: self.description,
                due_date_date_time: self.due_date_date_time,
                direct_debit_mandate_id: self.direct_debit_mandate_id,
                partial_payment_amount: self.partial_payment_amount,
                applicable_trade_payment_penalty_terms: self.applicable_trade_payment_penalty_terms,
                applicable_trade_payment_discount_terms: self
                    .applicable_trade_payment_discount_terms,
                payee_trade_party: self.payee_trade_party,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeSettlementHeaderMonetarySummationTypeDeserializer {
        line_total_amount: Option<super::AmountType>,
        charge_total_amount: Option<super::AmountType>,
        allowance_total_amount: Option<super::AmountType>,
        tax_basis_total_amount: Option<super::AmountType>,
        tax_total_amount: Vec<super::AmountType>,
        rounding_amount: Option<super::AmountType>,
        grand_total_amount: Option<super::AmountType>,
        total_prepaid_amount: Option<super::AmountType>,
        due_payable_amount: Option<super::AmountType>,
        state: Box<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeSettlementHeaderMonetarySummationTypeDeserializerState {
        Init__,
        LineTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        ChargeTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        AllowanceTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        TaxBasisTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        TaxTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        RoundingAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        GrandTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        TotalPrepaidAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        DuePayableAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeSettlementHeaderMonetarySummationTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                line_total_amount: None,
                charge_total_amount: None,
                allowance_total_amount: None,
                tax_basis_total_amount: None,
                tax_total_amount: Vec::new(),
                rounding_amount: None,
                grand_total_amount: None,
                total_prepaid_amount: None,
                due_payable_amount: None,
                state: Box::new(
                    TradeSettlementHeaderMonetarySummationTypeDeserializerState::Init__,
                ),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeSettlementHeaderMonetarySummationTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeSettlementHeaderMonetarySummationTypeDeserializerState as S;
            match state {
                S::LineTotalAmount(Some(deserializer)) => {
                    self.store_line_total_amount(deserializer.finish(reader)?)?
                }
                S::ChargeTotalAmount(Some(deserializer)) => {
                    self.store_charge_total_amount(deserializer.finish(reader)?)?
                }
                S::AllowanceTotalAmount(Some(deserializer)) => {
                    self.store_allowance_total_amount(deserializer.finish(reader)?)?
                }
                S::TaxBasisTotalAmount(Some(deserializer)) => {
                    self.store_tax_basis_total_amount(deserializer.finish(reader)?)?
                }
                S::TaxTotalAmount(Some(deserializer)) => {
                    self.store_tax_total_amount(deserializer.finish(reader)?)?
                }
                S::RoundingAmount(Some(deserializer)) => {
                    self.store_rounding_amount(deserializer.finish(reader)?)?
                }
                S::GrandTotalAmount(Some(deserializer)) => {
                    self.store_grand_total_amount(deserializer.finish(reader)?)?
                }
                S::TotalPrepaidAmount(Some(deserializer)) => {
                    self.store_total_prepaid_amount(deserializer.finish(reader)?)?
                }
                S::DuePayableAmount(Some(deserializer)) => {
                    self.store_due_payable_amount(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_line_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.line_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineTotalAmount",
                )))?;
            }
            self.line_total_amount = Some(value);
            Ok(())
        }
        fn store_charge_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.charge_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ChargeTotalAmount",
                )))?;
            }
            self.charge_total_amount = Some(value);
            Ok(())
        }
        fn store_allowance_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.allowance_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AllowanceTotalAmount",
                )))?;
            }
            self.allowance_total_amount = Some(value);
            Ok(())
        }
        fn store_tax_basis_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.tax_basis_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TaxBasisTotalAmount",
                )))?;
            }
            self.tax_basis_total_amount = Some(value);
            Ok(())
        }
        fn store_tax_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            self.tax_total_amount.push(value);
            Ok(())
        }
        fn store_rounding_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.rounding_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"RoundingAmount",
                )))?;
            }
            self.rounding_amount = Some(value);
            Ok(())
        }
        fn store_grand_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.grand_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GrandTotalAmount",
                )))?;
            }
            self.grand_total_amount = Some(value);
            Ok(())
        }
        fn store_total_prepaid_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.total_prepaid_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TotalPrepaidAmount",
                )))?;
            }
            self.total_prepaid_amount = Some(value);
            Ok(())
        }
        fn store_due_payable_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.due_payable_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DuePayableAmount",
                )))?;
            }
            self.due_payable_amount = Some(value);
            Ok(())
        }
        fn handle_line_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.line_total_amount.is_some() {
                    fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: LineTotalAmount (None)) ;
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: ChargeTotalAmount (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: LineTotalAmount (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_total_amount(data)?;
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: ChargeTotalAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: LineTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: ChargeTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: LineTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_charge_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementHeaderMonetarySummationTypeDeserializerState::ChargeTotalAmount(
                        None,
                    ),
                );
                * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_charge_total_amount(data)?;
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: ChargeTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: ChargeTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_allowance_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (None)) ;
                * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxBasisTotalAmount (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_allowance_total_amount(data)?;
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxBasisTotalAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxBasisTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_tax_basis_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.tax_basis_total_amount.is_some() {
                    fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxBasisTotalAmount (None)) ;
                    *self.state =
                        TradeSettlementHeaderMonetarySummationTypeDeserializerState::TaxTotalAmount(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxBasisTotalAmount (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_tax_basis_total_amount(data)?;
                    *self.state =
                        TradeSettlementHeaderMonetarySummationTypeDeserializerState::TaxTotalAmount(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxBasisTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxBasisTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_tax_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementHeaderMonetarySummationTypeDeserializerState::TaxTotalAmount(
                        None,
                    ),
                );
                *self.state =
                    TradeSettlementHeaderMonetarySummationTypeDeserializerState::RoundingAmount(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_tax_total_amount(data)?;
                    if self.tax_total_amount.len() < 2usize {
                        * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxTotalAmount (None) ;
                    } else {
                        * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: RoundingAmount (None) ;
                    }
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TaxTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_rounding_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementHeaderMonetarySummationTypeDeserializerState::RoundingAmount(
                        None,
                    ),
                );
                *self.state =
                    TradeSettlementHeaderMonetarySummationTypeDeserializerState::GrandTotalAmount(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_rounding_amount(data)?;
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: GrandTotalAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: RoundingAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: GrandTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: RoundingAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_grand_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.grand_total_amount.is_some() {
                    fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: GrandTotalAmount (None)) ;
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TotalPrepaidAmount (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: GrandTotalAmount (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_grand_total_amount(data)?;
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TotalPrepaidAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: GrandTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TotalPrepaidAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: GrandTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_total_prepaid_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementHeaderMonetarySummationTypeDeserializerState::TotalPrepaidAmount(
                        None,
                    ),
                );
                *self.state =
                    TradeSettlementHeaderMonetarySummationTypeDeserializerState::DuePayableAmount(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_total_prepaid_amount(data)?;
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: DuePayableAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TotalPrepaidAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: DuePayableAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: TotalPrepaidAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_due_payable_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementHeaderMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.due_payable_amount.is_some() {
                    fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: DuePayableAmount (None)) ;
                    *self.state =
                        TradeSettlementHeaderMonetarySummationTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: DuePayableAmount (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_due_payable_amount(data)?;
                    *self.state =
                        TradeSettlementHeaderMonetarySummationTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementHeaderMonetarySummationTypeDeserializerState :: DuePayableAmount (Some (deserializer))) ;
                            *self.state =
                                TradeSettlementHeaderMonetarySummationTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: DuePayableAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeSettlementHeaderMonetarySummationType>
        for TradeSettlementHeaderMonetarySummationTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeSettlementHeaderMonetarySummationType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeSettlementHeaderMonetarySummationType>
        where
            R: DeserializeReader,
        {
            use TradeSettlementHeaderMonetarySummationTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::LineTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ChargeTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_charge_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AllowanceTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_allowance_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TaxBasisTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tax_basis_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TaxTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tax_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::RoundingAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_rounding_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::GrandTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_grand_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TotalPrepaidAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_total_prepaid_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DuePayableAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_due_payable_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = TradeSettlementHeaderMonetarySummationTypeDeserializerState :: LineTotalAmount (None) ;
                        event
                    }
                    (S::LineTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"LineTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_line_total_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ChargeTotalAmount(None);
                            event
                        }
                    }
                    (S::ChargeTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ChargeTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_charge_total_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AllowanceTotalAmount(None);
                            event
                        }
                    }
                    (
                        S::AllowanceTotalAmount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AllowanceTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_allowance_total_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TaxBasisTotalAmount(None);
                            event
                        }
                    }
                    (S::TaxBasisTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TaxBasisTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_tax_basis_total_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TaxTotalAmount(None);
                            event
                        }
                    }
                    (S::TaxTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TaxTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_tax_total_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::RoundingAmount(None);
                            event
                        }
                    }
                    (S::RoundingAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"RoundingAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_rounding_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::GrandTotalAmount(None);
                            event
                        }
                    }
                    (S::GrandTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"GrandTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_grand_total_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TotalPrepaidAmount(None);
                            event
                        }
                    }
                    (S::TotalPrepaidAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TotalPrepaidAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_total_prepaid_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DuePayableAmount(None);
                            event
                        }
                    }
                    (S::DuePayableAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DuePayableAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_due_payable_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::TradeSettlementHeaderMonetarySummationType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeSettlementHeaderMonetarySummationTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeSettlementHeaderMonetarySummationType {
                line_total_amount: self
                    .line_total_amount
                    .ok_or_else(|| ErrorKind::MissingElement("LineTotalAmount".into()))?,
                charge_total_amount: self.charge_total_amount,
                allowance_total_amount: self.allowance_total_amount,
                tax_basis_total_amount: self
                    .tax_basis_total_amount
                    .ok_or_else(|| ErrorKind::MissingElement("TaxBasisTotalAmount".into()))?,
                tax_total_amount: self.tax_total_amount,
                rounding_amount: self.rounding_amount,
                grand_total_amount: self
                    .grand_total_amount
                    .ok_or_else(|| ErrorKind::MissingElement("GrandTotalAmount".into()))?,
                total_prepaid_amount: self.total_prepaid_amount,
                due_payable_amount: self
                    .due_payable_amount
                    .ok_or_else(|| ErrorKind::MissingElement("DuePayableAmount".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeAccountingAccountTypeDeserializer {
        id: Option<super::IdType>,
        type_code: Option<super::AccountingAccountTypeCodeType>,
        state: Box<TradeAccountingAccountTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeAccountingAccountTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        TypeCode(Option<<super::AccountingAccountTypeCodeType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeAccountingAccountTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                type_code: None,
                state: Box::new(TradeAccountingAccountTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeAccountingAccountTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeAccountingAccountTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                S::TypeCode(Some(deserializer)) => {
                    self.store_type_code(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn store_type_code(
            &mut self,
            value: super::AccountingAccountTypeCodeType,
        ) -> Result<(), Error> {
            if self.type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TypeCode",
                )))?;
            }
            self.type_code = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeAccountingAccountTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.id.is_some() {
                    fallback.get_or_insert(TradeAccountingAccountTypeDeserializerState::Id(None));
                    *self.state = TradeAccountingAccountTypeDeserializerState::TypeCode(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeAccountingAccountTypeDeserializerState::Id(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = TradeAccountingAccountTypeDeserializerState::TypeCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAccountingAccountTypeDeserializerState::Id(Some(deserializer)),
                            );
                            *self.state =
                                TradeAccountingAccountTypeDeserializerState::TypeCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAccountingAccountTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AccountingAccountTypeCodeType>,
            fallback: &mut Option<TradeAccountingAccountTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAccountingAccountTypeDeserializerState::TypeCode(None));
                *self.state = TradeAccountingAccountTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_type_code(data)?;
                    *self.state = TradeAccountingAccountTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAccountingAccountTypeDeserializerState::TypeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeAccountingAccountTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeAccountingAccountTypeDeserializerState::TypeCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeAccountingAccountType>
        for TradeAccountingAccountTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeAccountingAccountType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeAccountingAccountType>
        where
            R: DeserializeReader,
        {
            use TradeAccountingAccountTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradeAccountingAccountTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TypeCode(None);
                            event
                        }
                    }
                    (S::TypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"TypeCode") {
                            let output = < super :: AccountingAccountTypeCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeAccountingAccountType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeAccountingAccountTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeAccountingAccountType {
                id: self
                    .id
                    .ok_or_else(|| ErrorKind::MissingElement("ID".into()))?,
                type_code: self.type_code,
            })
        }
    }
    #[derive(Debug)]
    pub struct AdvancePaymentTypeDeserializer {
        paid_amount: Option<super::AmountType>,
        formatted_received_date_time: Option<super::FormattedDateTimeType>,
        included_trade_tax: Vec<super::TradeTaxType>,
        invoice_specified_referenced_document: Option<super::ReferencedDocumentType>,
        state: Box<AdvancePaymentTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum AdvancePaymentTypeDeserializerState {
        Init__,
        PaidAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        FormattedReceivedDateTime(
            Option<<super::FormattedDateTimeType as WithDeserializer>::Deserializer>,
        ),
        IncludedTradeTax(Option<<super::TradeTaxType as WithDeserializer>::Deserializer>),
        InvoiceSpecifiedReferencedDocument(
            Option<<super::ReferencedDocumentType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl AdvancePaymentTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                paid_amount: None,
                formatted_received_date_time: None,
                included_trade_tax: Vec::new(),
                invoice_specified_referenced_document: None,
                state: Box::new(AdvancePaymentTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: AdvancePaymentTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use AdvancePaymentTypeDeserializerState as S;
            match state {
                S::PaidAmount(Some(deserializer)) => {
                    self.store_paid_amount(deserializer.finish(reader)?)?
                }
                S::FormattedReceivedDateTime(Some(deserializer)) => {
                    self.store_formatted_received_date_time(deserializer.finish(reader)?)?
                }
                S::IncludedTradeTax(Some(deserializer)) => {
                    self.store_included_trade_tax(deserializer.finish(reader)?)?
                }
                S::InvoiceSpecifiedReferencedDocument(Some(deserializer)) => {
                    self.store_invoice_specified_referenced_document(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_paid_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.paid_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PaidAmount",
                )))?;
            }
            self.paid_amount = Some(value);
            Ok(())
        }
        fn store_formatted_received_date_time(
            &mut self,
            value: super::FormattedDateTimeType,
        ) -> Result<(), Error> {
            if self.formatted_received_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FormattedReceivedDateTime",
                )))?;
            }
            self.formatted_received_date_time = Some(value);
            Ok(())
        }
        fn store_included_trade_tax(&mut self, value: super::TradeTaxType) -> Result<(), Error> {
            self.included_trade_tax.push(value);
            Ok(())
        }
        fn store_invoice_specified_referenced_document(
            &mut self,
            value: super::ReferencedDocumentType,
        ) -> Result<(), Error> {
            if self.invoice_specified_referenced_document.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"InvoiceSpecifiedReferencedDocument",
                )))?;
            }
            self.invoice_specified_referenced_document = Some(value);
            Ok(())
        }
        fn handle_paid_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<AdvancePaymentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.paid_amount.is_some() {
                    fallback.get_or_insert(AdvancePaymentTypeDeserializerState::PaidAmount(None));
                    *self.state =
                        AdvancePaymentTypeDeserializerState::FormattedReceivedDateTime(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = AdvancePaymentTypeDeserializerState::PaidAmount(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_paid_amount(data)?;
                    *self.state =
                        AdvancePaymentTypeDeserializerState::FormattedReceivedDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                AdvancePaymentTypeDeserializerState::PaidAmount(Some(deserializer)),
                            );
                            *self.state =
                                AdvancePaymentTypeDeserializerState::FormattedReceivedDateTime(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                AdvancePaymentTypeDeserializerState::PaidAmount(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_formatted_received_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::FormattedDateTimeType>,
            fallback: &mut Option<AdvancePaymentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    AdvancePaymentTypeDeserializerState::FormattedReceivedDateTime(None),
                );
                *self.state = AdvancePaymentTypeDeserializerState::IncludedTradeTax(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_formatted_received_date_time(data)?;
                    *self.state = AdvancePaymentTypeDeserializerState::IncludedTradeTax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                AdvancePaymentTypeDeserializerState::FormattedReceivedDateTime(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                AdvancePaymentTypeDeserializerState::IncludedTradeTax(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                AdvancePaymentTypeDeserializerState::FormattedReceivedDateTime(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_included_trade_tax<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeTaxType>,
            fallback: &mut Option<AdvancePaymentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.included_trade_tax.len() < 1usize {
                    *self.state = AdvancePaymentTypeDeserializerState::IncludedTradeTax(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(AdvancePaymentTypeDeserializerState::IncludedTradeTax(None));
                    *self.state =
                        AdvancePaymentTypeDeserializerState::InvoiceSpecifiedReferencedDocument(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_included_trade_tax(data)?;
                    *self.state = AdvancePaymentTypeDeserializerState::IncludedTradeTax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                AdvancePaymentTypeDeserializerState::IncludedTradeTax(Some(
                                    deserializer,
                                )),
                            );
                            if self.included_trade_tax.len().saturating_add(1) < 1usize {
                                *self.state =
                                    AdvancePaymentTypeDeserializerState::IncludedTradeTax(None);
                            } else {
                                * self . state = AdvancePaymentTypeDeserializerState :: InvoiceSpecifiedReferencedDocument (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = AdvancePaymentTypeDeserializerState::IncludedTradeTax(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_invoice_specified_referenced_document<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ReferencedDocumentType>,
            fallback: &mut Option<AdvancePaymentTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    AdvancePaymentTypeDeserializerState::InvoiceSpecifiedReferencedDocument(None),
                );
                *self.state = AdvancePaymentTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_invoice_specified_referenced_document(data)?;
                    *self.state = AdvancePaymentTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (AdvancePaymentTypeDeserializerState :: InvoiceSpecifiedReferencedDocument (Some (deserializer))) ;
                            *self.state = AdvancePaymentTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = AdvancePaymentTypeDeserializerState :: InvoiceSpecifiedReferencedDocument (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::AdvancePaymentType> for AdvancePaymentTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AdvancePaymentType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AdvancePaymentType>
        where
            R: DeserializeReader,
        {
            use AdvancePaymentTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::PaidAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_paid_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FormattedReceivedDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_formatted_received_date_time(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IncludedTradeTax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_included_trade_tax(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InvoiceSpecifiedReferencedDocument(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_invoice_specified_referenced_document(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = AdvancePaymentTypeDeserializerState::PaidAmount(None);
                        event
                    }
                    (S::PaidAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"PaidAmount")
                        {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_paid_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::FormattedReceivedDateTime(None);
                            event
                        }
                    }
                    (
                        S::FormattedReceivedDateTime(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"FormattedReceivedDateTime",
                        ) {
                            let output = < super :: FormattedDateTimeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_formatted_received_date_time(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IncludedTradeTax(None);
                            event
                        }
                    }
                    (S::IncludedTradeTax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IncludedTradeTax",
                        ) {
                            let output =
                                <super::TradeTaxType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_included_trade_tax(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InvoiceSpecifiedReferencedDocument(None);
                            event
                        }
                    }
                    (
                        S::InvoiceSpecifiedReferencedDocument(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"InvoiceSpecifiedReferencedDocument",
                        ) {
                            let output = < super :: ReferencedDocumentType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_invoice_specified_referenced_document(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::AdvancePaymentType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                AdvancePaymentTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::AdvancePaymentType {
                paid_amount: self
                    .paid_amount
                    .ok_or_else(|| ErrorKind::MissingElement("PaidAmount".into()))?,
                formatted_received_date_time: self.formatted_received_date_time,
                included_trade_tax: self.included_trade_tax,
                invoice_specified_referenced_document: self.invoice_specified_referenced_document,
            })
        }
    }
    #[derive(Debug)]
    pub struct LineStatusCodeTypeDeserializer {
        content: Option<String>,
        state: Box<LineStatusCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LineStatusCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl LineStatusCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(LineStatusCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LineStatusCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let LineStatusCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::LineStatusCodeType>
        where
            R: DeserializeReader,
        {
            use LineStatusCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::LineStatusCodeType> for LineStatusCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LineStatusCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LineStatusCodeType>
        where
            R: DeserializeReader,
        {
            use LineStatusCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LineStatusCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LineStatusCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LineStatusCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductCharacteristicTypeDeserializer {
        type_code: Option<super::CodeType>,
        description: Option<super::TextType>,
        value_measure: Option<super::MeasureType>,
        value: Option<super::TextType>,
        state: Box<ProductCharacteristicTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductCharacteristicTypeDeserializerState {
        Init__,
        TypeCode(Option<<super::CodeType as WithDeserializer>::Deserializer>),
        Description(Option<<super::TextType as WithDeserializer>::Deserializer>),
        ValueMeasure(Option<<super::MeasureType as WithDeserializer>::Deserializer>),
        Value(Option<<super::TextType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductCharacteristicTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                type_code: None,
                description: None,
                value_measure: None,
                value: None,
                state: Box::new(ProductCharacteristicTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductCharacteristicTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductCharacteristicTypeDeserializerState as S;
            match state {
                S::TypeCode(Some(deserializer)) => {
                    self.store_type_code(deserializer.finish(reader)?)?
                }
                S::Description(Some(deserializer)) => {
                    self.store_description(deserializer.finish(reader)?)?
                }
                S::ValueMeasure(Some(deserializer)) => {
                    self.store_value_measure(deserializer.finish(reader)?)?
                }
                S::Value(Some(deserializer)) => self.store_value(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_type_code(&mut self, value: super::CodeType) -> Result<(), Error> {
            if self.type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TypeCode",
                )))?;
            }
            self.type_code = Some(value);
            Ok(())
        }
        fn store_description(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.description.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Description",
                )))?;
            }
            self.description = Some(value);
            Ok(())
        }
        fn store_value_measure(&mut self, value: super::MeasureType) -> Result<(), Error> {
            if self.value_measure.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ValueMeasure",
                )))?;
            }
            self.value_measure = Some(value);
            Ok(())
        }
        fn store_value(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.value.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Value",
                )))?;
            }
            self.value = Some(value);
            Ok(())
        }
        fn handle_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CodeType>,
            fallback: &mut Option<ProductCharacteristicTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductCharacteristicTypeDeserializerState::TypeCode(None));
                *self.state = ProductCharacteristicTypeDeserializerState::Description(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_type_code(data)?;
                    *self.state = ProductCharacteristicTypeDeserializerState::Description(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductCharacteristicTypeDeserializerState::TypeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductCharacteristicTypeDeserializerState::Description(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductCharacteristicTypeDeserializerState::TypeCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_description<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<ProductCharacteristicTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.description.is_some() {
                    fallback.get_or_insert(
                        ProductCharacteristicTypeDeserializerState::Description(None),
                    );
                    *self.state = ProductCharacteristicTypeDeserializerState::ValueMeasure(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProductCharacteristicTypeDeserializerState::Description(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description(data)?;
                    *self.state = ProductCharacteristicTypeDeserializerState::ValueMeasure(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductCharacteristicTypeDeserializerState::Description(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductCharacteristicTypeDeserializerState::ValueMeasure(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductCharacteristicTypeDeserializerState::Description(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_value_measure<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MeasureType>,
            fallback: &mut Option<ProductCharacteristicTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductCharacteristicTypeDeserializerState::ValueMeasure(
                    None,
                ));
                *self.state = ProductCharacteristicTypeDeserializerState::Value(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_value_measure(data)?;
                    *self.state = ProductCharacteristicTypeDeserializerState::Value(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductCharacteristicTypeDeserializerState::ValueMeasure(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductCharacteristicTypeDeserializerState::Value(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductCharacteristicTypeDeserializerState::ValueMeasure(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_value<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<ProductCharacteristicTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.value.is_some() {
                    fallback.get_or_insert(ProductCharacteristicTypeDeserializerState::Value(None));
                    *self.state = ProductCharacteristicTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProductCharacteristicTypeDeserializerState::Value(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_value(data)?;
                    *self.state = ProductCharacteristicTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductCharacteristicTypeDeserializerState::Value(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductCharacteristicTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductCharacteristicTypeDeserializerState::Value(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductCharacteristicType>
        for ProductCharacteristicTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductCharacteristicType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductCharacteristicType>
        where
            R: DeserializeReader,
        {
            use ProductCharacteristicTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Description(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ValueMeasure(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_value_measure(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Value(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_value(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ProductCharacteristicTypeDeserializerState::TypeCode(None);
                        event
                    }
                    (S::TypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"TypeCode") {
                            let output = <super::CodeType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Description(None);
                            event
                        }
                    }
                    (S::Description(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Description")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_description(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ValueMeasure(None);
                            event
                        }
                    }
                    (S::ValueMeasure(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ValueMeasure",
                        ) {
                            let output =
                                <super::MeasureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_value_measure(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Value(None);
                            event
                        }
                    }
                    (S::Value(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Value") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_value(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductCharacteristicType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductCharacteristicTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductCharacteristicType {
                type_code: self.type_code,
                description: self
                    .description
                    .ok_or_else(|| ErrorKind::MissingElement("Description".into()))?,
                value_measure: self.value_measure,
                value: self
                    .value
                    .ok_or_else(|| ErrorKind::MissingElement("Value".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductClassificationTypeDeserializer {
        class_code: Option<super::CodeType>,
        class_name: Option<super::TextType>,
        state: Box<ProductClassificationTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductClassificationTypeDeserializerState {
        Init__,
        ClassCode(Option<<super::CodeType as WithDeserializer>::Deserializer>),
        ClassName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductClassificationTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                class_code: None,
                class_name: None,
                state: Box::new(ProductClassificationTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductClassificationTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductClassificationTypeDeserializerState as S;
            match state {
                S::ClassCode(Some(deserializer)) => {
                    self.store_class_code(deserializer.finish(reader)?)?
                }
                S::ClassName(Some(deserializer)) => {
                    self.store_class_name(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_class_code(&mut self, value: super::CodeType) -> Result<(), Error> {
            if self.class_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ClassCode",
                )))?;
            }
            self.class_code = Some(value);
            Ok(())
        }
        fn store_class_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.class_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ClassName",
                )))?;
            }
            self.class_name = Some(value);
            Ok(())
        }
        fn handle_class_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CodeType>,
            fallback: &mut Option<ProductClassificationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductClassificationTypeDeserializerState::ClassCode(None));
                *self.state = ProductClassificationTypeDeserializerState::ClassName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_class_code(data)?;
                    *self.state = ProductClassificationTypeDeserializerState::ClassName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductClassificationTypeDeserializerState::ClassCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductClassificationTypeDeserializerState::ClassName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductClassificationTypeDeserializerState::ClassCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_class_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<ProductClassificationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductClassificationTypeDeserializerState::ClassName(None));
                *self.state = ProductClassificationTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_class_name(data)?;
                    *self.state = ProductClassificationTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductClassificationTypeDeserializerState::ClassName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductClassificationTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductClassificationTypeDeserializerState::ClassName(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductClassificationType>
        for ProductClassificationTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductClassificationType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductClassificationType>
        where
            R: DeserializeReader,
        {
            use ProductClassificationTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ClassCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_class_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ClassName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_class_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ProductClassificationTypeDeserializerState::ClassCode(None);
                        event
                    }
                    (S::ClassCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ClassCode") {
                            let output = <super::CodeType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_class_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ClassName(None);
                            event
                        }
                    }
                    (S::ClassName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ClassName") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_class_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductClassificationType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductClassificationTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductClassificationType {
                class_code: self.class_code,
                class_name: self.class_name,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeProductInstanceTypeDeserializer {
        batch_id: Option<super::IdType>,
        supplier_assigned_serial_id: Option<super::IdType>,
        state: Box<TradeProductInstanceTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeProductInstanceTypeDeserializerState {
        Init__,
        BatchId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        SupplierAssignedSerialId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeProductInstanceTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                batch_id: None,
                supplier_assigned_serial_id: None,
                state: Box::new(TradeProductInstanceTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeProductInstanceTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeProductInstanceTypeDeserializerState as S;
            match state {
                S::BatchId(Some(deserializer)) => {
                    self.store_batch_id(deserializer.finish(reader)?)?
                }
                S::SupplierAssignedSerialId(Some(deserializer)) => {
                    self.store_supplier_assigned_serial_id(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_batch_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.batch_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BatchID",
                )))?;
            }
            self.batch_id = Some(value);
            Ok(())
        }
        fn store_supplier_assigned_serial_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.supplier_assigned_serial_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SupplierAssignedSerialID",
                )))?;
            }
            self.supplier_assigned_serial_id = Some(value);
            Ok(())
        }
        fn handle_batch_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductInstanceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeProductInstanceTypeDeserializerState::BatchId(None));
                *self.state =
                    TradeProductInstanceTypeDeserializerState::SupplierAssignedSerialId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_batch_id(data)?;
                    *self.state =
                        TradeProductInstanceTypeDeserializerState::SupplierAssignedSerialId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductInstanceTypeDeserializerState::BatchId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeProductInstanceTypeDeserializerState::SupplierAssignedSerialId(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeProductInstanceTypeDeserializerState::BatchId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_supplier_assigned_serial_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeProductInstanceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeProductInstanceTypeDeserializerState::SupplierAssignedSerialId(None),
                );
                *self.state = TradeProductInstanceTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_assigned_serial_id(data)?;
                    *self.state = TradeProductInstanceTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeProductInstanceTypeDeserializerState::SupplierAssignedSerialId(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = TradeProductInstanceTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeProductInstanceTypeDeserializerState::SupplierAssignedSerialId(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeProductInstanceType>
        for TradeProductInstanceTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeProductInstanceType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeProductInstanceType>
        where
            R: DeserializeReader,
        {
            use TradeProductInstanceTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BatchId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_batch_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SupplierAssignedSerialId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_assigned_serial_id(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradeProductInstanceTypeDeserializerState::BatchId(None);
                        event
                    }
                    (S::BatchId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"BatchID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_batch_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SupplierAssignedSerialId(None);
                            event
                        }
                    }
                    (
                        S::SupplierAssignedSerialId(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SupplierAssignedSerialID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_supplier_assigned_serial_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeProductInstanceType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeProductInstanceTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeProductInstanceType {
                batch_id: self.batch_id,
                supplier_assigned_serial_id: self.supplier_assigned_serial_id,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeCountryTypeDeserializer {
        id: Option<super::CountryIdType>,
        state: Box<TradeCountryTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeCountryTypeDeserializerState {
        Init__,
        Id(Option<<super::CountryIdType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeCountryTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                state: Box::new(TradeCountryTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeCountryTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeCountryTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::CountryIdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CountryIdType>,
            fallback: &mut Option<TradeCountryTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.id.is_some() {
                    fallback.get_or_insert(TradeCountryTypeDeserializerState::Id(None));
                    *self.state = TradeCountryTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeCountryTypeDeserializerState::Id(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = TradeCountryTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeCountryTypeDeserializerState::Id(Some(
                                deserializer,
                            )));
                            *self.state = TradeCountryTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeCountryTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeCountryType> for TradeCountryTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeCountryType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeCountryType>
        where
            R: DeserializeReader,
        {
            use TradeCountryTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradeCountryTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output =
                                <super::CountryIdType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeCountryType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeCountryTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeCountryType {
                id: self
                    .id
                    .ok_or_else(|| ErrorKind::MissingElement("ID".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ReferencedProductTypeDeserializer {
        id: Option<super::IdType>,
        global_id: Vec<super::IdType>,
        seller_assigned_id: Option<super::IdType>,
        buyer_assigned_id: Option<super::IdType>,
        industry_assigned_id: Option<super::IdType>,
        name: Option<super::TextType>,
        description: Option<super::TextType>,
        unit_quantity: Option<super::QuantityType>,
        state: Box<ReferencedProductTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ReferencedProductTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        GlobalId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        SellerAssignedId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        BuyerAssignedId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        IndustryAssignedId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Name(Option<<super::TextType as WithDeserializer>::Deserializer>),
        Description(Option<<super::TextType as WithDeserializer>::Deserializer>),
        UnitQuantity(Option<<super::QuantityType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ReferencedProductTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                global_id: Vec::new(),
                seller_assigned_id: None,
                buyer_assigned_id: None,
                industry_assigned_id: None,
                name: None,
                description: None,
                unit_quantity: None,
                state: Box::new(ReferencedProductTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ReferencedProductTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ReferencedProductTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                S::GlobalId(Some(deserializer)) => {
                    self.store_global_id(deserializer.finish(reader)?)?
                }
                S::SellerAssignedId(Some(deserializer)) => {
                    self.store_seller_assigned_id(deserializer.finish(reader)?)?
                }
                S::BuyerAssignedId(Some(deserializer)) => {
                    self.store_buyer_assigned_id(deserializer.finish(reader)?)?
                }
                S::IndustryAssignedId(Some(deserializer)) => {
                    self.store_industry_assigned_id(deserializer.finish(reader)?)?
                }
                S::Name(Some(deserializer)) => self.store_name(deserializer.finish(reader)?)?,
                S::Description(Some(deserializer)) => {
                    self.store_description(deserializer.finish(reader)?)?
                }
                S::UnitQuantity(Some(deserializer)) => {
                    self.store_unit_quantity(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn store_global_id(&mut self, value: super::IdType) -> Result<(), Error> {
            self.global_id.push(value);
            Ok(())
        }
        fn store_seller_assigned_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.seller_assigned_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SellerAssignedID",
                )))?;
            }
            self.seller_assigned_id = Some(value);
            Ok(())
        }
        fn store_buyer_assigned_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.buyer_assigned_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BuyerAssignedID",
                )))?;
            }
            self.buyer_assigned_id = Some(value);
            Ok(())
        }
        fn store_industry_assigned_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.industry_assigned_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"IndustryAssignedID",
                )))?;
            }
            self.industry_assigned_id = Some(value);
            Ok(())
        }
        fn store_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Name")))?;
            }
            self.name = Some(value);
            Ok(())
        }
        fn store_description(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.description.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Description",
                )))?;
            }
            self.description = Some(value);
            Ok(())
        }
        fn store_unit_quantity(&mut self, value: super::QuantityType) -> Result<(), Error> {
            if self.unit_quantity.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UnitQuantity",
                )))?;
            }
            self.unit_quantity = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ReferencedProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedProductTypeDeserializerState::Id(None));
                *self.state = ReferencedProductTypeDeserializerState::GlobalId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = ReferencedProductTypeDeserializerState::GlobalId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ReferencedProductTypeDeserializerState::Id(
                                Some(deserializer),
                            ));
                            *self.state = ReferencedProductTypeDeserializerState::GlobalId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedProductTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_global_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ReferencedProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedProductTypeDeserializerState::GlobalId(None));
                *self.state = ReferencedProductTypeDeserializerState::SellerAssignedId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_global_id(data)?;
                    *self.state = ReferencedProductTypeDeserializerState::GlobalId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedProductTypeDeserializerState::GlobalId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ReferencedProductTypeDeserializerState::GlobalId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ReferencedProductTypeDeserializerState::GlobalId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_seller_assigned_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ReferencedProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedProductTypeDeserializerState::SellerAssignedId(
                    None,
                ));
                *self.state = ReferencedProductTypeDeserializerState::BuyerAssignedId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_seller_assigned_id(data)?;
                    *self.state = ReferencedProductTypeDeserializerState::BuyerAssignedId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedProductTypeDeserializerState::SellerAssignedId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ReferencedProductTypeDeserializerState::BuyerAssignedId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ReferencedProductTypeDeserializerState::SellerAssignedId(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_assigned_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ReferencedProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedProductTypeDeserializerState::BuyerAssignedId(
                    None,
                ));
                *self.state = ReferencedProductTypeDeserializerState::IndustryAssignedId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_assigned_id(data)?;
                    *self.state = ReferencedProductTypeDeserializerState::IndustryAssignedId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedProductTypeDeserializerState::BuyerAssignedId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ReferencedProductTypeDeserializerState::IndustryAssignedId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ReferencedProductTypeDeserializerState::BuyerAssignedId(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_industry_assigned_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<ReferencedProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedProductTypeDeserializerState::IndustryAssignedId(
                    None,
                ));
                *self.state = ReferencedProductTypeDeserializerState::Name(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_industry_assigned_id(data)?;
                    *self.state = ReferencedProductTypeDeserializerState::Name(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedProductTypeDeserializerState::IndustryAssignedId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ReferencedProductTypeDeserializerState::Name(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedProductTypeDeserializerState::IndustryAssignedId(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<ReferencedProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.name.is_some() {
                    fallback.get_or_insert(ReferencedProductTypeDeserializerState::Name(None));
                    *self.state = ReferencedProductTypeDeserializerState::Description(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ReferencedProductTypeDeserializerState::Name(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_name(data)?;
                    *self.state = ReferencedProductTypeDeserializerState::Description(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ReferencedProductTypeDeserializerState::Name(
                                Some(deserializer),
                            ));
                            *self.state = ReferencedProductTypeDeserializerState::Description(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ReferencedProductTypeDeserializerState::Name(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_description<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<ReferencedProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedProductTypeDeserializerState::Description(None));
                *self.state = ReferencedProductTypeDeserializerState::UnitQuantity(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description(data)?;
                    *self.state = ReferencedProductTypeDeserializerState::UnitQuantity(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedProductTypeDeserializerState::Description(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ReferencedProductTypeDeserializerState::UnitQuantity(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ReferencedProductTypeDeserializerState::Description(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_unit_quantity<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::QuantityType>,
            fallback: &mut Option<ReferencedProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ReferencedProductTypeDeserializerState::UnitQuantity(None));
                *self.state = ReferencedProductTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_unit_quantity(data)?;
                    *self.state = ReferencedProductTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ReferencedProductTypeDeserializerState::UnitQuantity(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ReferencedProductTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ReferencedProductTypeDeserializerState::UnitQuantity(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ReferencedProductType> for ReferencedProductTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ReferencedProductType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ReferencedProductType>
        where
            R: DeserializeReader,
        {
            use ReferencedProductTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::GlobalId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_global_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SellerAssignedId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_seller_assigned_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerAssignedId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_assigned_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IndustryAssignedId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_industry_assigned_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Name(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Description(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UnitQuantity(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_unit_quantity(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ReferencedProductTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::GlobalId(None);
                            event
                        }
                    }
                    (S::GlobalId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"GlobalID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_global_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SellerAssignedId(None);
                            event
                        }
                    }
                    (S::SellerAssignedId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"SellerAssignedID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_seller_assigned_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerAssignedId(None);
                            event
                        }
                    }
                    (S::BuyerAssignedId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BuyerAssignedID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_buyer_assigned_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IndustryAssignedId(None);
                            event
                        }
                    }
                    (S::IndustryAssignedId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IndustryAssignedID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_industry_assigned_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Name(None);
                            event
                        }
                    }
                    (S::Name(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Name") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Description(None);
                            event
                        }
                    }
                    (S::Description(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"Description")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_description(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UnitQuantity(None);
                            event
                        }
                    }
                    (S::UnitQuantity(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"UnitQuantity",
                        ) {
                            let output =
                                <super::QuantityType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_unit_quantity(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ReferencedProductType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ReferencedProductTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ReferencedProductType {
                id: self.id,
                global_id: self.global_id,
                seller_assigned_id: self.seller_assigned_id,
                buyer_assigned_id: self.buyer_assigned_id,
                industry_assigned_id: self.industry_assigned_id,
                name: self
                    .name
                    .ok_or_else(|| ErrorKind::MissingElement("Name".into()))?,
                description: self.description,
                unit_quantity: self.unit_quantity,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradePriceTypeDeserializer {
        charge_amount: Option<super::AmountType>,
        basis_quantity: Option<super::QuantityType>,
        applied_trade_allowance_charge: Vec<super::TradeAllowanceChargeType>,
        included_trade_tax: Option<super::TradeTaxType>,
        state: Box<TradePriceTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradePriceTypeDeserializerState {
        Init__,
        ChargeAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        BasisQuantity(Option<<super::QuantityType as WithDeserializer>::Deserializer>),
        AppliedTradeAllowanceCharge(
            Option<<super::TradeAllowanceChargeType as WithDeserializer>::Deserializer>,
        ),
        IncludedTradeTax(Option<<super::TradeTaxType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradePriceTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                charge_amount: None,
                basis_quantity: None,
                applied_trade_allowance_charge: Vec::new(),
                included_trade_tax: None,
                state: Box::new(TradePriceTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradePriceTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradePriceTypeDeserializerState as S;
            match state {
                S::ChargeAmount(Some(deserializer)) => {
                    self.store_charge_amount(deserializer.finish(reader)?)?
                }
                S::BasisQuantity(Some(deserializer)) => {
                    self.store_basis_quantity(deserializer.finish(reader)?)?
                }
                S::AppliedTradeAllowanceCharge(Some(deserializer)) => {
                    self.store_applied_trade_allowance_charge(deserializer.finish(reader)?)?
                }
                S::IncludedTradeTax(Some(deserializer)) => {
                    self.store_included_trade_tax(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_charge_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.charge_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ChargeAmount",
                )))?;
            }
            self.charge_amount = Some(value);
            Ok(())
        }
        fn store_basis_quantity(&mut self, value: super::QuantityType) -> Result<(), Error> {
            if self.basis_quantity.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisQuantity",
                )))?;
            }
            self.basis_quantity = Some(value);
            Ok(())
        }
        fn store_applied_trade_allowance_charge(
            &mut self,
            value: super::TradeAllowanceChargeType,
        ) -> Result<(), Error> {
            self.applied_trade_allowance_charge.push(value);
            Ok(())
        }
        fn store_included_trade_tax(&mut self, value: super::TradeTaxType) -> Result<(), Error> {
            if self.included_trade_tax.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"IncludedTradeTax",
                )))?;
            }
            self.included_trade_tax = Some(value);
            Ok(())
        }
        fn handle_charge_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradePriceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.charge_amount.is_some() {
                    fallback.get_or_insert(TradePriceTypeDeserializerState::ChargeAmount(None));
                    *self.state = TradePriceTypeDeserializerState::BasisQuantity(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradePriceTypeDeserializerState::ChargeAmount(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_charge_amount(data)?;
                    *self.state = TradePriceTypeDeserializerState::BasisQuantity(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradePriceTypeDeserializerState::ChargeAmount(
                                Some(deserializer),
                            ));
                            *self.state = TradePriceTypeDeserializerState::BasisQuantity(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePriceTypeDeserializerState::ChargeAmount(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_basis_quantity<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::QuantityType>,
            fallback: &mut Option<TradePriceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePriceTypeDeserializerState::BasisQuantity(None));
                *self.state = TradePriceTypeDeserializerState::AppliedTradeAllowanceCharge(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_quantity(data)?;
                    *self.state =
                        TradePriceTypeDeserializerState::AppliedTradeAllowanceCharge(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradePriceTypeDeserializerState::BasisQuantity(
                                Some(deserializer),
                            ));
                            *self.state =
                                TradePriceTypeDeserializerState::AppliedTradeAllowanceCharge(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePriceTypeDeserializerState::BasisQuantity(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_applied_trade_allowance_charge<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeAllowanceChargeType>,
            fallback: &mut Option<TradePriceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePriceTypeDeserializerState::AppliedTradeAllowanceCharge(None),
                );
                *self.state = TradePriceTypeDeserializerState::IncludedTradeTax(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_applied_trade_allowance_charge(data)?;
                    *self.state =
                        TradePriceTypeDeserializerState::AppliedTradeAllowanceCharge(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePriceTypeDeserializerState::AppliedTradeAllowanceCharge(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePriceTypeDeserializerState::AppliedTradeAllowanceCharge(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePriceTypeDeserializerState::AppliedTradeAllowanceCharge(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_included_trade_tax<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeTaxType>,
            fallback: &mut Option<TradePriceTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePriceTypeDeserializerState::IncludedTradeTax(None));
                *self.state = TradePriceTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_included_trade_tax(data)?;
                    *self.state = TradePriceTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePriceTypeDeserializerState::IncludedTradeTax(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradePriceTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradePriceTypeDeserializerState::IncludedTradeTax(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradePriceType> for TradePriceTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TradePriceType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradePriceType>
        where
            R: DeserializeReader,
        {
            use TradePriceTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ChargeAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_charge_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BasisQuantity(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_quantity(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AppliedTradeAllowanceCharge(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_applied_trade_allowance_charge(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::IncludedTradeTax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_included_trade_tax(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradePriceTypeDeserializerState::ChargeAmount(None);
                        event
                    }
                    (S::ChargeAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ChargeAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_charge_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BasisQuantity(None);
                            event
                        }
                    }
                    (S::BasisQuantity(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BasisQuantity",
                        ) {
                            let output =
                                <super::QuantityType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_quantity(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AppliedTradeAllowanceCharge(None);
                            event
                        }
                    }
                    (
                        S::AppliedTradeAllowanceCharge(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AppliedTradeAllowanceCharge",
                        ) {
                            let output = < super :: TradeAllowanceChargeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_applied_trade_allowance_charge(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::IncludedTradeTax(None);
                            event
                        }
                    }
                    (S::IncludedTradeTax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"IncludedTradeTax",
                        ) {
                            let output =
                                <super::TradeTaxType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_included_trade_tax(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradePriceType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, TradePriceTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::TradePriceType {
                charge_amount: self
                    .charge_amount
                    .ok_or_else(|| ErrorKind::MissingElement("ChargeAmount".into()))?,
                basis_quantity: self.basis_quantity,
                applied_trade_allowance_charge: self.applied_trade_allowance_charge,
                included_trade_tax: self.included_trade_tax,
            })
        }
    }
    #[derive(Debug)]
    pub struct QuantityTypeDeserializer {
        unit_code: Option<String>,
        content: Option<f64>,
        state: Box<QuantityTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum QuantityTypeDeserializerState {
        Init__,
        Content__(<f64 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl QuantityTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut unit_code: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"unitCode")
                ) {
                    reader.read_attrib(&mut unit_code, b"unitCode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                unit_code: unit_code,
                content: None,
                state: Box::new(QuantityTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: QuantityTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let QuantityTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: f64) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
        ) -> DeserializerResult<'de, super::QuantityType>
        where
            R: DeserializeReader,
        {
            use QuantityTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::QuantityType> for QuantityTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::QuantityType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::QuantityType>
        where
            R: DeserializeReader,
        {
            use QuantityTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::QuantityType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, QuantityTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::QuantityType {
                unit_code: self.unit_code,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeSettlementLineMonetarySummationTypeDeserializer {
        line_total_amount: Option<super::AmountType>,
        charge_total_amount: Option<super::AmountType>,
        allowance_total_amount: Option<super::AmountType>,
        tax_total_amount: Option<super::AmountType>,
        grand_total_amount: Option<super::AmountType>,
        total_allowance_charge_amount: Option<super::AmountType>,
        state: Box<TradeSettlementLineMonetarySummationTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeSettlementLineMonetarySummationTypeDeserializerState {
        Init__,
        LineTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        ChargeTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        AllowanceTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        TaxTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        GrandTotalAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        TotalAllowanceChargeAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeSettlementLineMonetarySummationTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                line_total_amount: None,
                charge_total_amount: None,
                allowance_total_amount: None,
                tax_total_amount: None,
                grand_total_amount: None,
                total_allowance_charge_amount: None,
                state: Box::new(TradeSettlementLineMonetarySummationTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeSettlementLineMonetarySummationTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeSettlementLineMonetarySummationTypeDeserializerState as S;
            match state {
                S::LineTotalAmount(Some(deserializer)) => {
                    self.store_line_total_amount(deserializer.finish(reader)?)?
                }
                S::ChargeTotalAmount(Some(deserializer)) => {
                    self.store_charge_total_amount(deserializer.finish(reader)?)?
                }
                S::AllowanceTotalAmount(Some(deserializer)) => {
                    self.store_allowance_total_amount(deserializer.finish(reader)?)?
                }
                S::TaxTotalAmount(Some(deserializer)) => {
                    self.store_tax_total_amount(deserializer.finish(reader)?)?
                }
                S::GrandTotalAmount(Some(deserializer)) => {
                    self.store_grand_total_amount(deserializer.finish(reader)?)?
                }
                S::TotalAllowanceChargeAmount(Some(deserializer)) => {
                    self.store_total_allowance_charge_amount(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_line_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.line_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineTotalAmount",
                )))?;
            }
            self.line_total_amount = Some(value);
            Ok(())
        }
        fn store_charge_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.charge_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ChargeTotalAmount",
                )))?;
            }
            self.charge_total_amount = Some(value);
            Ok(())
        }
        fn store_allowance_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.allowance_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AllowanceTotalAmount",
                )))?;
            }
            self.allowance_total_amount = Some(value);
            Ok(())
        }
        fn store_tax_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.tax_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TaxTotalAmount",
                )))?;
            }
            self.tax_total_amount = Some(value);
            Ok(())
        }
        fn store_grand_total_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.grand_total_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GrandTotalAmount",
                )))?;
            }
            self.grand_total_amount = Some(value);
            Ok(())
        }
        fn store_total_allowance_charge_amount(
            &mut self,
            value: super::AmountType,
        ) -> Result<(), Error> {
            if self.total_allowance_charge_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TotalAllowanceChargeAmount",
                )))?;
            }
            self.total_allowance_charge_amount = Some(value);
            Ok(())
        }
        fn handle_line_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementLineMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.line_total_amount.is_some() {
                    fallback.get_or_insert(
                        TradeSettlementLineMonetarySummationTypeDeserializerState::LineTotalAmount(
                            None,
                        ),
                    );
                    * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: ChargeTotalAmount (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TradeSettlementLineMonetarySummationTypeDeserializerState::LineTotalAmount(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_total_amount(data)?;
                    * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: ChargeTotalAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementLineMonetarySummationTypeDeserializerState :: LineTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: ChargeTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: LineTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_charge_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementLineMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementLineMonetarySummationTypeDeserializerState::ChargeTotalAmount(
                        None,
                    ),
                );
                *self.state =
                    TradeSettlementLineMonetarySummationTypeDeserializerState::AllowanceTotalAmount(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_charge_total_amount(data)?;
                    * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementLineMonetarySummationTypeDeserializerState :: ChargeTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: ChargeTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_allowance_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementLineMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementLineMonetarySummationTypeDeserializerState::AllowanceTotalAmount(
                        None,
                    ),
                );
                *self.state =
                    TradeSettlementLineMonetarySummationTypeDeserializerState::TaxTotalAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_allowance_total_amount(data)?;
                    *self.state =
                        TradeSettlementLineMonetarySummationTypeDeserializerState::TaxTotalAmount(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementLineMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: TaxTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: AllowanceTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_tax_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementLineMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementLineMonetarySummationTypeDeserializerState::TaxTotalAmount(None),
                );
                *self.state =
                    TradeSettlementLineMonetarySummationTypeDeserializerState::GrandTotalAmount(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_tax_total_amount(data)?;
                    *self.state =
                        TradeSettlementLineMonetarySummationTypeDeserializerState::GrandTotalAmount(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementLineMonetarySummationTypeDeserializerState :: TaxTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: GrandTotalAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: TaxTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_grand_total_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementLineMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementLineMonetarySummationTypeDeserializerState::GrandTotalAmount(
                        None,
                    ),
                );
                * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: TotalAllowanceChargeAmount (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_grand_total_amount(data)?;
                    * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: TotalAllowanceChargeAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementLineMonetarySummationTypeDeserializerState :: GrandTotalAmount (Some (deserializer))) ;
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: TotalAllowanceChargeAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: GrandTotalAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_total_allowance_charge_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradeSettlementLineMonetarySummationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (TradeSettlementLineMonetarySummationTypeDeserializerState :: TotalAllowanceChargeAmount (None)) ;
                *self.state = TradeSettlementLineMonetarySummationTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_total_allowance_charge_amount(data)?;
                    *self.state = TradeSettlementLineMonetarySummationTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradeSettlementLineMonetarySummationTypeDeserializerState :: TotalAllowanceChargeAmount (Some (deserializer))) ;
                            *self.state =
                                TradeSettlementLineMonetarySummationTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: TotalAllowanceChargeAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeSettlementLineMonetarySummationType>
        for TradeSettlementLineMonetarySummationTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeSettlementLineMonetarySummationType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeSettlementLineMonetarySummationType>
        where
            R: DeserializeReader,
        {
            use TradeSettlementLineMonetarySummationTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::LineTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ChargeTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_charge_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AllowanceTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_allowance_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TaxTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tax_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::GrandTotalAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_grand_total_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TotalAllowanceChargeAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_total_allowance_charge_amount(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = TradeSettlementLineMonetarySummationTypeDeserializerState :: LineTotalAmount (None) ;
                        event
                    }
                    (S::LineTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"LineTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_line_total_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ChargeTotalAmount(None);
                            event
                        }
                    }
                    (S::ChargeTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ChargeTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_charge_total_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AllowanceTotalAmount(None);
                            event
                        }
                    }
                    (
                        S::AllowanceTotalAmount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"AllowanceTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_allowance_total_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TaxTotalAmount(None);
                            event
                        }
                    }
                    (S::TaxTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TaxTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_tax_total_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::GrandTotalAmount(None);
                            event
                        }
                    }
                    (S::GrandTotalAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"GrandTotalAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_grand_total_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TotalAllowanceChargeAmount(None);
                            event
                        }
                    }
                    (
                        S::TotalAllowanceChargeAmount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TotalAllowanceChargeAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_total_allowance_charge_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::TradeSettlementLineMonetarySummationType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeSettlementLineMonetarySummationTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeSettlementLineMonetarySummationType {
                line_total_amount: self
                    .line_total_amount
                    .ok_or_else(|| ErrorKind::MissingElement("LineTotalAmount".into()))?,
                charge_total_amount: self.charge_total_amount,
                allowance_total_amount: self.allowance_total_amount,
                tax_total_amount: self.tax_total_amount,
                grand_total_amount: self.grand_total_amount,
                total_allowance_charge_amount: self.total_allowance_charge_amount,
            })
        }
    }
    #[derive(Debug)]
    pub struct PartyRoleCodeTypeDeserializer {
        content: Option<String>,
        state: Box<PartyRoleCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PartyRoleCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl PartyRoleCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(PartyRoleCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PartyRoleCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let PartyRoleCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::PartyRoleCodeType>
        where
            R: DeserializeReader,
        {
            use PartyRoleCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::PartyRoleCodeType> for PartyRoleCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PartyRoleCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PartyRoleCodeType>
        where
            R: DeserializeReader,
        {
            use PartyRoleCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PartyRoleCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PartyRoleCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PartyRoleCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct LegalOrganizationTypeDeserializer {
        id: Option<super::IdType>,
        trading_business_name: Option<super::TextType>,
        postal_trade_address: Option<super::TradeAddressType>,
        state: Box<LegalOrganizationTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LegalOrganizationTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        TradingBusinessName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        PostalTradeAddress(Option<<super::TradeAddressType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl LegalOrganizationTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                trading_business_name: None,
                postal_trade_address: None,
                state: Box::new(LegalOrganizationTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LegalOrganizationTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use LegalOrganizationTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                S::TradingBusinessName(Some(deserializer)) => {
                    self.store_trading_business_name(deserializer.finish(reader)?)?
                }
                S::PostalTradeAddress(Some(deserializer)) => {
                    self.store_postal_trade_address(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn store_trading_business_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.trading_business_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TradingBusinessName",
                )))?;
            }
            self.trading_business_name = Some(value);
            Ok(())
        }
        fn store_postal_trade_address(
            &mut self,
            value: super::TradeAddressType,
        ) -> Result<(), Error> {
            if self.postal_trade_address.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PostalTradeAddress",
                )))?;
            }
            self.postal_trade_address = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<LegalOrganizationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(LegalOrganizationTypeDeserializerState::Id(None));
                *self.state = LegalOrganizationTypeDeserializerState::TradingBusinessName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = LegalOrganizationTypeDeserializerState::TradingBusinessName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(LegalOrganizationTypeDeserializerState::Id(
                                Some(deserializer),
                            ));
                            *self.state =
                                LegalOrganizationTypeDeserializerState::TradingBusinessName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LegalOrganizationTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_trading_business_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<LegalOrganizationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    LegalOrganizationTypeDeserializerState::TradingBusinessName(None),
                );
                *self.state = LegalOrganizationTypeDeserializerState::PostalTradeAddress(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_trading_business_name(data)?;
                    *self.state = LegalOrganizationTypeDeserializerState::PostalTradeAddress(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LegalOrganizationTypeDeserializerState::TradingBusinessName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                LegalOrganizationTypeDeserializerState::PostalTradeAddress(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LegalOrganizationTypeDeserializerState::TradingBusinessName(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_postal_trade_address<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TradeAddressType>,
            fallback: &mut Option<LegalOrganizationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(LegalOrganizationTypeDeserializerState::PostalTradeAddress(
                    None,
                ));
                *self.state = LegalOrganizationTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_postal_trade_address(data)?;
                    *self.state = LegalOrganizationTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LegalOrganizationTypeDeserializerState::PostalTradeAddress(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = LegalOrganizationTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                LegalOrganizationTypeDeserializerState::PostalTradeAddress(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::LegalOrganizationType> for LegalOrganizationTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LegalOrganizationType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LegalOrganizationType>
        where
            R: DeserializeReader,
        {
            use LegalOrganizationTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TradingBusinessName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_trading_business_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PostalTradeAddress(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_postal_trade_address(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = LegalOrganizationTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TradingBusinessName(None);
                            event
                        }
                    }
                    (S::TradingBusinessName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TradingBusinessName",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_trading_business_name(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PostalTradeAddress(None);
                            event
                        }
                    }
                    (S::PostalTradeAddress(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PostalTradeAddress",
                        ) {
                            let output =
                                <super::TradeAddressType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_postal_trade_address(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LegalOrganizationType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LegalOrganizationTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LegalOrganizationType {
                id: self.id,
                trading_business_name: self.trading_business_name,
                postal_trade_address: self.postal_trade_address,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeContactTypeDeserializer {
        person_name: Option<super::TextType>,
        department_name: Option<super::TextType>,
        type_code: Option<super::ContactTypeCodeType>,
        telephone_universal_communication: Option<super::UniversalCommunicationType>,
        fax_universal_communication: Option<super::UniversalCommunicationType>,
        email_uri_universal_communication: Option<super::UniversalCommunicationType>,
        state: Box<TradeContactTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeContactTypeDeserializerState {
        Init__,
        PersonName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        DepartmentName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        TypeCode(Option<<super::ContactTypeCodeType as WithDeserializer>::Deserializer>),
        TelephoneUniversalCommunication(
            Option<<super::UniversalCommunicationType as WithDeserializer>::Deserializer>,
        ),
        FaxUniversalCommunication(
            Option<<super::UniversalCommunicationType as WithDeserializer>::Deserializer>,
        ),
        EmailUriUniversalCommunication(
            Option<<super::UniversalCommunicationType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TradeContactTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                person_name: None,
                department_name: None,
                type_code: None,
                telephone_universal_communication: None,
                fax_universal_communication: None,
                email_uri_universal_communication: None,
                state: Box::new(TradeContactTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeContactTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeContactTypeDeserializerState as S;
            match state {
                S::PersonName(Some(deserializer)) => {
                    self.store_person_name(deserializer.finish(reader)?)?
                }
                S::DepartmentName(Some(deserializer)) => {
                    self.store_department_name(deserializer.finish(reader)?)?
                }
                S::TypeCode(Some(deserializer)) => {
                    self.store_type_code(deserializer.finish(reader)?)?
                }
                S::TelephoneUniversalCommunication(Some(deserializer)) => {
                    self.store_telephone_universal_communication(deserializer.finish(reader)?)?
                }
                S::FaxUniversalCommunication(Some(deserializer)) => {
                    self.store_fax_universal_communication(deserializer.finish(reader)?)?
                }
                S::EmailUriUniversalCommunication(Some(deserializer)) => {
                    self.store_email_uri_universal_communication(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_person_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.person_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PersonName",
                )))?;
            }
            self.person_name = Some(value);
            Ok(())
        }
        fn store_department_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.department_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DepartmentName",
                )))?;
            }
            self.department_name = Some(value);
            Ok(())
        }
        fn store_type_code(&mut self, value: super::ContactTypeCodeType) -> Result<(), Error> {
            if self.type_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TypeCode",
                )))?;
            }
            self.type_code = Some(value);
            Ok(())
        }
        fn store_telephone_universal_communication(
            &mut self,
            value: super::UniversalCommunicationType,
        ) -> Result<(), Error> {
            if self.telephone_universal_communication.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TelephoneUniversalCommunication",
                )))?;
            }
            self.telephone_universal_communication = Some(value);
            Ok(())
        }
        fn store_fax_universal_communication(
            &mut self,
            value: super::UniversalCommunicationType,
        ) -> Result<(), Error> {
            if self.fax_universal_communication.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FaxUniversalCommunication",
                )))?;
            }
            self.fax_universal_communication = Some(value);
            Ok(())
        }
        fn store_email_uri_universal_communication(
            &mut self,
            value: super::UniversalCommunicationType,
        ) -> Result<(), Error> {
            if self.email_uri_universal_communication.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"EmailURIUniversalCommunication",
                )))?;
            }
            self.email_uri_universal_communication = Some(value);
            Ok(())
        }
        fn handle_person_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeContactTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeContactTypeDeserializerState::PersonName(None));
                *self.state = TradeContactTypeDeserializerState::DepartmentName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_person_name(data)?;
                    *self.state = TradeContactTypeDeserializerState::DepartmentName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeContactTypeDeserializerState::PersonName(
                                Some(deserializer),
                            ));
                            *self.state = TradeContactTypeDeserializerState::DepartmentName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeContactTypeDeserializerState::PersonName(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_department_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeContactTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeContactTypeDeserializerState::DepartmentName(None));
                *self.state = TradeContactTypeDeserializerState::TypeCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_department_name(data)?;
                    *self.state = TradeContactTypeDeserializerState::TypeCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeContactTypeDeserializerState::DepartmentName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeContactTypeDeserializerState::TypeCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeContactTypeDeserializerState::DepartmentName(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_type_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ContactTypeCodeType>,
            fallback: &mut Option<TradeContactTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeContactTypeDeserializerState::TypeCode(None));
                *self.state =
                    TradeContactTypeDeserializerState::TelephoneUniversalCommunication(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_type_code(data)?;
                    *self.state =
                        TradeContactTypeDeserializerState::TelephoneUniversalCommunication(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeContactTypeDeserializerState::TypeCode(
                                Some(deserializer),
                            ));
                            *self.state =
                                TradeContactTypeDeserializerState::TelephoneUniversalCommunication(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeContactTypeDeserializerState::TypeCode(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_telephone_universal_communication<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UniversalCommunicationType>,
            fallback: &mut Option<TradeContactTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeContactTypeDeserializerState::TelephoneUniversalCommunication(None),
                );
                *self.state = TradeContactTypeDeserializerState::FaxUniversalCommunication(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_telephone_universal_communication(data)?;
                    *self.state =
                        TradeContactTypeDeserializerState::FaxUniversalCommunication(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeContactTypeDeserializerState::TelephoneUniversalCommunication(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradeContactTypeDeserializerState::FaxUniversalCommunication(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeContactTypeDeserializerState::TelephoneUniversalCommunication(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_fax_universal_communication<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UniversalCommunicationType>,
            fallback: &mut Option<TradeContactTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeContactTypeDeserializerState::FaxUniversalCommunication(None),
                );
                *self.state =
                    TradeContactTypeDeserializerState::EmailUriUniversalCommunication(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fax_universal_communication(data)?;
                    *self.state =
                        TradeContactTypeDeserializerState::EmailUriUniversalCommunication(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeContactTypeDeserializerState::FaxUniversalCommunication(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeContactTypeDeserializerState::EmailUriUniversalCommunication(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeContactTypeDeserializerState::FaxUniversalCommunication(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_email_uri_universal_communication<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UniversalCommunicationType>,
            fallback: &mut Option<TradeContactTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeContactTypeDeserializerState::EmailUriUniversalCommunication(None),
                );
                *self.state = TradeContactTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_email_uri_universal_communication(data)?;
                    *self.state = TradeContactTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeContactTypeDeserializerState::EmailUriUniversalCommunication(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = TradeContactTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeContactTypeDeserializerState::EmailUriUniversalCommunication(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeContactType> for TradeContactTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeContactType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeContactType>
        where
            R: DeserializeReader,
        {
            use TradeContactTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::PersonName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_person_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DepartmentName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_department_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TypeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_type_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TelephoneUniversalCommunication(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_telephone_universal_communication(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FaxUniversalCommunication(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fax_universal_communication(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::EmailUriUniversalCommunication(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_email_uri_universal_communication(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradeContactTypeDeserializerState::PersonName(None);
                        event
                    }
                    (S::PersonName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"PersonName")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_person_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DepartmentName(None);
                            event
                        }
                    }
                    (S::DepartmentName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"DepartmentName",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_department_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TypeCode(None);
                            event
                        }
                    }
                    (S::TypeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"TypeCode") {
                            let output = < super :: ContactTypeCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_type_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::TelephoneUniversalCommunication(None);
                            event
                        }
                    }
                    (
                        S::TelephoneUniversalCommunication(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"TelephoneUniversalCommunication",
                        ) {
                            let output = < super :: UniversalCommunicationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_telephone_universal_communication(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::FaxUniversalCommunication(None);
                            event
                        }
                    }
                    (
                        S::FaxUniversalCommunication(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"FaxUniversalCommunication",
                        ) {
                            let output = < super :: UniversalCommunicationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_fax_universal_communication(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::EmailUriUniversalCommunication(None);
                            event
                        }
                    }
                    (
                        S::EmailUriUniversalCommunication(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"EmailURIUniversalCommunication",
                        ) {
                            let output = < super :: UniversalCommunicationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_email_uri_universal_communication(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeContactType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeContactTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeContactType {
                person_name: self.person_name,
                department_name: self.department_name,
                type_code: self.type_code,
                telephone_universal_communication: self.telephone_universal_communication,
                fax_universal_communication: self.fax_universal_communication,
                email_uri_universal_communication: self.email_uri_universal_communication,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeAddressTypeDeserializer {
        postcode_code: Option<super::CodeType>,
        line_one: Option<super::TextType>,
        line_two: Option<super::TextType>,
        line_three: Option<super::TextType>,
        city_name: Option<super::TextType>,
        country_id: Option<super::CountryIdType>,
        country_sub_division_name: Option<super::TextType>,
        state: Box<TradeAddressTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeAddressTypeDeserializerState {
        Init__,
        PostcodeCode(Option<<super::CodeType as WithDeserializer>::Deserializer>),
        LineOne(Option<<super::TextType as WithDeserializer>::Deserializer>),
        LineTwo(Option<<super::TextType as WithDeserializer>::Deserializer>),
        LineThree(Option<<super::TextType as WithDeserializer>::Deserializer>),
        CityName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        CountryId(Option<<super::CountryIdType as WithDeserializer>::Deserializer>),
        CountrySubDivisionName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeAddressTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                postcode_code: None,
                line_one: None,
                line_two: None,
                line_three: None,
                city_name: None,
                country_id: None,
                country_sub_division_name: None,
                state: Box::new(TradeAddressTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeAddressTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeAddressTypeDeserializerState as S;
            match state {
                S::PostcodeCode(Some(deserializer)) => {
                    self.store_postcode_code(deserializer.finish(reader)?)?
                }
                S::LineOne(Some(deserializer)) => {
                    self.store_line_one(deserializer.finish(reader)?)?
                }
                S::LineTwo(Some(deserializer)) => {
                    self.store_line_two(deserializer.finish(reader)?)?
                }
                S::LineThree(Some(deserializer)) => {
                    self.store_line_three(deserializer.finish(reader)?)?
                }
                S::CityName(Some(deserializer)) => {
                    self.store_city_name(deserializer.finish(reader)?)?
                }
                S::CountryId(Some(deserializer)) => {
                    self.store_country_id(deserializer.finish(reader)?)?
                }
                S::CountrySubDivisionName(Some(deserializer)) => {
                    self.store_country_sub_division_name(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_postcode_code(&mut self, value: super::CodeType) -> Result<(), Error> {
            if self.postcode_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PostcodeCode",
                )))?;
            }
            self.postcode_code = Some(value);
            Ok(())
        }
        fn store_line_one(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.line_one.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineOne",
                )))?;
            }
            self.line_one = Some(value);
            Ok(())
        }
        fn store_line_two(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.line_two.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineTwo",
                )))?;
            }
            self.line_two = Some(value);
            Ok(())
        }
        fn store_line_three(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.line_three.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LineThree",
                )))?;
            }
            self.line_three = Some(value);
            Ok(())
        }
        fn store_city_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.city_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CityName",
                )))?;
            }
            self.city_name = Some(value);
            Ok(())
        }
        fn store_country_id(&mut self, value: super::CountryIdType) -> Result<(), Error> {
            if self.country_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CountryID",
                )))?;
            }
            self.country_id = Some(value);
            Ok(())
        }
        fn store_country_sub_division_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.country_sub_division_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CountrySubDivisionName",
                )))?;
            }
            self.country_sub_division_name = Some(value);
            Ok(())
        }
        fn handle_postcode_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CodeType>,
            fallback: &mut Option<TradeAddressTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAddressTypeDeserializerState::PostcodeCode(None));
                *self.state = TradeAddressTypeDeserializerState::LineOne(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_postcode_code(data)?;
                    *self.state = TradeAddressTypeDeserializerState::LineOne(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAddressTypeDeserializerState::PostcodeCode(Some(deserializer)),
                            );
                            *self.state = TradeAddressTypeDeserializerState::LineOne(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAddressTypeDeserializerState::PostcodeCode(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_line_one<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeAddressTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAddressTypeDeserializerState::LineOne(None));
                *self.state = TradeAddressTypeDeserializerState::LineTwo(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_one(data)?;
                    *self.state = TradeAddressTypeDeserializerState::LineTwo(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeAddressTypeDeserializerState::LineOne(
                                Some(deserializer),
                            ));
                            *self.state = TradeAddressTypeDeserializerState::LineTwo(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAddressTypeDeserializerState::LineOne(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_line_two<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeAddressTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAddressTypeDeserializerState::LineTwo(None));
                *self.state = TradeAddressTypeDeserializerState::LineThree(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_two(data)?;
                    *self.state = TradeAddressTypeDeserializerState::LineThree(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeAddressTypeDeserializerState::LineTwo(
                                Some(deserializer),
                            ));
                            *self.state = TradeAddressTypeDeserializerState::LineThree(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAddressTypeDeserializerState::LineTwo(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_line_three<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeAddressTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAddressTypeDeserializerState::LineThree(None));
                *self.state = TradeAddressTypeDeserializerState::CityName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_line_three(data)?;
                    *self.state = TradeAddressTypeDeserializerState::CityName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeAddressTypeDeserializerState::LineThree(
                                Some(deserializer),
                            ));
                            *self.state = TradeAddressTypeDeserializerState::CityName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAddressTypeDeserializerState::LineThree(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_city_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeAddressTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAddressTypeDeserializerState::CityName(None));
                *self.state = TradeAddressTypeDeserializerState::CountryId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_city_name(data)?;
                    *self.state = TradeAddressTypeDeserializerState::CountryId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeAddressTypeDeserializerState::CityName(
                                Some(deserializer),
                            ));
                            *self.state = TradeAddressTypeDeserializerState::CountryId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAddressTypeDeserializerState::CityName(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_country_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CountryIdType>,
            fallback: &mut Option<TradeAddressTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.country_id.is_some() {
                    fallback.get_or_insert(TradeAddressTypeDeserializerState::CountryId(None));
                    *self.state = TradeAddressTypeDeserializerState::CountrySubDivisionName(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeAddressTypeDeserializerState::CountryId(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_country_id(data)?;
                    *self.state = TradeAddressTypeDeserializerState::CountrySubDivisionName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TradeAddressTypeDeserializerState::CountryId(
                                Some(deserializer),
                            ));
                            *self.state =
                                TradeAddressTypeDeserializerState::CountrySubDivisionName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeAddressTypeDeserializerState::CountryId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_country_sub_division_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeAddressTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradeAddressTypeDeserializerState::CountrySubDivisionName(
                    None,
                ));
                *self.state = TradeAddressTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_country_sub_division_name(data)?;
                    *self.state = TradeAddressTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeAddressTypeDeserializerState::CountrySubDivisionName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = TradeAddressTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeAddressTypeDeserializerState::CountrySubDivisionName(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeAddressType> for TradeAddressTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeAddressType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeAddressType>
        where
            R: DeserializeReader,
        {
            use TradeAddressTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::PostcodeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_postcode_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LineOne(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_one(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LineTwo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_two(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LineThree(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line_three(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CityName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_city_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CountryId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_country_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CountrySubDivisionName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_country_sub_division_name(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradeAddressTypeDeserializerState::PostcodeCode(None);
                        event
                    }
                    (S::PostcodeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"PostcodeCode",
                        ) {
                            let output = <super::CodeType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_postcode_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LineOne(None);
                            event
                        }
                    }
                    (S::LineOne(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"LineOne") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_line_one(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LineTwo(None);
                            event
                        }
                    }
                    (S::LineTwo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"LineTwo") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_line_two(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LineThree(None);
                            event
                        }
                    }
                    (S::LineThree(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"LineThree") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_line_three(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CityName(None);
                            event
                        }
                    }
                    (S::CityName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"CityName") {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_city_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CountryId(None);
                            event
                        }
                    }
                    (S::CountryId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"CountryID") {
                            let output =
                                <super::CountryIdType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_country_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CountrySubDivisionName(None);
                            event
                        }
                    }
                    (
                        S::CountrySubDivisionName(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CountrySubDivisionName",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_country_sub_division_name(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeAddressType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeAddressTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeAddressType {
                postcode_code: self.postcode_code,
                line_one: self.line_one,
                line_two: self.line_two,
                line_three: self.line_three,
                city_name: self.city_name,
                country_id: self
                    .country_id
                    .ok_or_else(|| ErrorKind::MissingElement("CountryID".into()))?,
                country_sub_division_name: self.country_sub_division_name,
            })
        }
    }
    #[derive(Debug)]
    pub struct UniversalCommunicationTypeDeserializer {
        uriid: Option<super::IdType>,
        complete_number: Option<super::TextType>,
        state: Box<UniversalCommunicationTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UniversalCommunicationTypeDeserializerState {
        Init__,
        Uriid(Option<<super::IdType as WithDeserializer>::Deserializer>),
        CompleteNumber(Option<<super::TextType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UniversalCommunicationTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                uriid: None,
                complete_number: None,
                state: Box::new(UniversalCommunicationTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UniversalCommunicationTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UniversalCommunicationTypeDeserializerState as S;
            match state {
                S::Uriid(Some(deserializer)) => self.store_uriid(deserializer.finish(reader)?)?,
                S::CompleteNumber(Some(deserializer)) => {
                    self.store_complete_number(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_uriid(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.uriid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"URIID",
                )))?;
            }
            self.uriid = Some(value);
            Ok(())
        }
        fn store_complete_number(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.complete_number.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompleteNumber",
                )))?;
            }
            self.complete_number = Some(value);
            Ok(())
        }
        fn handle_uriid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<UniversalCommunicationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UniversalCommunicationTypeDeserializerState::Uriid(None));
                *self.state = UniversalCommunicationTypeDeserializerState::CompleteNumber(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_uriid(data)?;
                    *self.state = UniversalCommunicationTypeDeserializerState::CompleteNumber(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UniversalCommunicationTypeDeserializerState::Uriid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UniversalCommunicationTypeDeserializerState::CompleteNumber(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UniversalCommunicationTypeDeserializerState::Uriid(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_complete_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<UniversalCommunicationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UniversalCommunicationTypeDeserializerState::CompleteNumber(None),
                );
                *self.state = UniversalCommunicationTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_complete_number(data)?;
                    *self.state = UniversalCommunicationTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UniversalCommunicationTypeDeserializerState::CompleteNumber(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UniversalCommunicationTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UniversalCommunicationTypeDeserializerState::CompleteNumber(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UniversalCommunicationType>
        for UniversalCommunicationTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UniversalCommunicationType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UniversalCommunicationType>
        where
            R: DeserializeReader,
        {
            use UniversalCommunicationTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Uriid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_uriid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CompleteNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_complete_number(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = UniversalCommunicationTypeDeserializerState::Uriid(None);
                        event
                    }
                    (S::Uriid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"URIID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_uriid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CompleteNumber(None);
                            event
                        }
                    }
                    (S::CompleteNumber(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CompleteNumber",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_complete_number(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UniversalCommunicationType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UniversalCommunicationTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UniversalCommunicationType {
                uriid: self.uriid,
                complete_number: self.complete_number,
            })
        }
    }
    #[derive(Debug)]
    pub struct TaxRegistrationTypeDeserializer {
        id: Option<super::IdType>,
        state: Box<TaxRegistrationTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TaxRegistrationTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TaxRegistrationTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                state: Box::new(TaxRegistrationTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TaxRegistrationTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TaxRegistrationTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TaxRegistrationTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.id.is_some() {
                    fallback.get_or_insert(TaxRegistrationTypeDeserializerState::Id(None));
                    *self.state = TaxRegistrationTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TaxRegistrationTypeDeserializerState::Id(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state = TaxRegistrationTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(TaxRegistrationTypeDeserializerState::Id(Some(
                                deserializer,
                            )));
                            *self.state = TaxRegistrationTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TaxRegistrationTypeDeserializerState::Id(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TaxRegistrationType> for TaxRegistrationTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TaxRegistrationType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TaxRegistrationType>
        where
            R: DeserializeReader,
        {
            use TaxRegistrationTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TaxRegistrationTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TaxRegistrationType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TaxRegistrationTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TaxRegistrationType {
                id: self
                    .id
                    .ok_or_else(|| ErrorKind::MissingElement("ID".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DeliveryTermsCodeTypeDeserializer {
        content: Option<String>,
        state: Box<DeliveryTermsCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DeliveryTermsCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DeliveryTermsCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(DeliveryTermsCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DeliveryTermsCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DeliveryTermsCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::DeliveryTermsCodeType>
        where
            R: DeserializeReader,
        {
            use DeliveryTermsCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::DeliveryTermsCodeType> for DeliveryTermsCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DeliveryTermsCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DeliveryTermsCodeType>
        where
            R: DeserializeReader,
        {
            use DeliveryTermsCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DeliveryTermsCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DeliveryTermsCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DeliveryTermsCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct BinaryObjectTypeDeserializer {
        mime_code: String,
        filename: String,
        content: Option<String>,
        state: Box<BinaryObjectTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum BinaryObjectTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl BinaryObjectTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut mime_code: Option<String> = None;
            let mut filename: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"mimeCode")
                ) {
                    reader.read_attrib(&mut mime_code, b"mimeCode", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"filename")
                ) {
                    reader.read_attrib(&mut filename, b"filename", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                mime_code: mime_code.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("mimeCode".into()))
                })?,
                filename: filename.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("filename".into()))
                })?,
                content: None,
                state: Box::new(BinaryObjectTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: BinaryObjectTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let BinaryObjectTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::BinaryObjectType>
        where
            R: DeserializeReader,
        {
            use BinaryObjectTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::BinaryObjectType> for BinaryObjectTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BinaryObjectType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BinaryObjectType>
        where
            R: DeserializeReader,
        {
            use BinaryObjectTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::BinaryObjectType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                BinaryObjectTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::BinaryObjectType {
                mime_code: self.mime_code,
                filename: self.filename,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ReferenceCodeTypeDeserializer {
        content: Option<String>,
        state: Box<ReferenceCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ReferenceCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl ReferenceCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(ReferenceCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ReferenceCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let ReferenceCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::ReferenceCodeType>
        where
            R: DeserializeReader,
        {
            use ReferenceCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::ReferenceCodeType> for ReferenceCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ReferenceCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ReferenceCodeType>
        where
            R: DeserializeReader,
        {
            use ReferenceCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ReferenceCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ReferenceCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ReferenceCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct FormattedDateTimeTypeDeserializer {
        date_time_string: Option<super::FormattedDateTimeTypeDateTimeStringType>,
        state: Box<FormattedDateTimeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum FormattedDateTimeTypeDeserializerState {
        Init__,
        DateTimeString(
            Option<
                <super::FormattedDateTimeTypeDateTimeStringType as WithDeserializer>::Deserializer,
            >,
        ),
        Done__,
        Unknown__,
    }
    impl FormattedDateTimeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                date_time_string: None,
                state: Box::new(FormattedDateTimeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: FormattedDateTimeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use FormattedDateTimeTypeDeserializerState as S;
            match state {
                S::DateTimeString(Some(deserializer)) => {
                    self.store_date_time_string(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_date_time_string(
            &mut self,
            value: super::FormattedDateTimeTypeDateTimeStringType,
        ) -> Result<(), Error> {
            if self.date_time_string.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DateTimeString",
                )))?;
            }
            self.date_time_string = Some(value);
            Ok(())
        }
        fn handle_date_time_string<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::FormattedDateTimeTypeDateTimeStringType>,
            fallback: &mut Option<FormattedDateTimeTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.date_time_string.is_some() {
                    fallback.get_or_insert(FormattedDateTimeTypeDeserializerState::DateTimeString(
                        None,
                    ));
                    *self.state = FormattedDateTimeTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = FormattedDateTimeTypeDeserializerState::DateTimeString(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_date_time_string(data)?;
                    *self.state = FormattedDateTimeTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                FormattedDateTimeTypeDeserializerState::DateTimeString(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = FormattedDateTimeTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = FormattedDateTimeTypeDeserializerState::DateTimeString(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::FormattedDateTimeType> for FormattedDateTimeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::FormattedDateTimeType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::FormattedDateTimeType>
        where
            R: DeserializeReader,
        {
            use FormattedDateTimeTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DateTimeString(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_date_time_string(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = FormattedDateTimeTypeDeserializerState::DateTimeString(None);
                        event
                    }
                    (S::DateTimeString(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_QDT),
                            b"DateTimeString",
                        ) {
                            let output = < super :: FormattedDateTimeTypeDateTimeStringType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_date_time_string(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::FormattedDateTimeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                FormattedDateTimeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::FormattedDateTimeType {
                date_time_string: self
                    .date_time_string
                    .ok_or_else(|| ErrorKind::MissingElement("DateTimeString".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct LogisticsTransportMovementTypeDeserializer {
        mode_code: Option<super::TransportModeCodeType>,
        state: Box<LogisticsTransportMovementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LogisticsTransportMovementTypeDeserializerState {
        Init__,
        ModeCode(Option<<super::TransportModeCodeType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl LogisticsTransportMovementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                mode_code: None,
                state: Box::new(LogisticsTransportMovementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LogisticsTransportMovementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use LogisticsTransportMovementTypeDeserializerState as S;
            match state {
                S::ModeCode(Some(deserializer)) => {
                    self.store_mode_code(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_mode_code(&mut self, value: super::TransportModeCodeType) -> Result<(), Error> {
            if self.mode_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ModeCode",
                )))?;
            }
            self.mode_code = Some(value);
            Ok(())
        }
        fn handle_mode_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TransportModeCodeType>,
            fallback: &mut Option<LogisticsTransportMovementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.mode_code.is_some() {
                    fallback.get_or_insert(
                        LogisticsTransportMovementTypeDeserializerState::ModeCode(None),
                    );
                    *self.state = LogisticsTransportMovementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = LogisticsTransportMovementTypeDeserializerState::ModeCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mode_code(data)?;
                    *self.state = LogisticsTransportMovementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                LogisticsTransportMovementTypeDeserializerState::ModeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = LogisticsTransportMovementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = LogisticsTransportMovementTypeDeserializerState::ModeCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::LogisticsTransportMovementType>
        for LogisticsTransportMovementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LogisticsTransportMovementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LogisticsTransportMovementType>
        where
            R: DeserializeReader,
        {
            use LogisticsTransportMovementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ModeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mode_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            LogisticsTransportMovementTypeDeserializerState::ModeCode(None);
                        event
                    }
                    (S::ModeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ModeCode") {
                            let output = < super :: TransportModeCodeType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_mode_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LogisticsTransportMovementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LogisticsTransportMovementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LogisticsTransportMovementType {
                mode_code: self
                    .mode_code
                    .ok_or_else(|| ErrorKind::MissingElement("ModeCode".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct RateTypeDeserializer {
        content: Option<f64>,
        state: Box<RateTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum RateTypeDeserializerState {
        Init__,
        Content__(<f64 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl RateTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(RateTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: RateTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let RateTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: f64) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
        ) -> DeserializerResult<'de, super::RateType>
        where
            R: DeserializeReader,
        {
            use RateTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::RateType> for RateTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::RateType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::RateType>
        where
            R: DeserializeReader,
        {
            use RateTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::RateType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, RateTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::RateType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct PaymentMeansCodeTypeDeserializer {
        content: Option<String>,
        state: Box<PaymentMeansCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PaymentMeansCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl PaymentMeansCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(PaymentMeansCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PaymentMeansCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let PaymentMeansCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::PaymentMeansCodeType>
        where
            R: DeserializeReader,
        {
            use PaymentMeansCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::PaymentMeansCodeType> for PaymentMeansCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PaymentMeansCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PaymentMeansCodeType>
        where
            R: DeserializeReader,
        {
            use PaymentMeansCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PaymentMeansCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PaymentMeansCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PaymentMeansCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradeSettlementFinancialCardTypeDeserializer {
        id: Option<super::IdType>,
        cardholder_name: Option<super::TextType>,
        state: Box<TradeSettlementFinancialCardTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradeSettlementFinancialCardTypeDeserializerState {
        Init__,
        Id(Option<<super::IdType as WithDeserializer>::Deserializer>),
        CardholderName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradeSettlementFinancialCardTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                id: None,
                cardholder_name: None,
                state: Box::new(TradeSettlementFinancialCardTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradeSettlementFinancialCardTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradeSettlementFinancialCardTypeDeserializerState as S;
            match state {
                S::Id(Some(deserializer)) => self.store_id(deserializer.finish(reader)?)?,
                S::CardholderName(Some(deserializer)) => {
                    self.store_cardholder_name(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"ID")))?;
            }
            self.id = Some(value);
            Ok(())
        }
        fn store_cardholder_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.cardholder_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CardholderName",
                )))?;
            }
            self.cardholder_name = Some(value);
            Ok(())
        }
        fn handle_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<TradeSettlementFinancialCardTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.id.is_some() {
                    fallback
                        .get_or_insert(TradeSettlementFinancialCardTypeDeserializerState::Id(None));
                    *self.state =
                        TradeSettlementFinancialCardTypeDeserializerState::CardholderName(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TradeSettlementFinancialCardTypeDeserializerState::Id(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_id(data)?;
                    *self.state =
                        TradeSettlementFinancialCardTypeDeserializerState::CardholderName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeSettlementFinancialCardTypeDeserializerState::Id(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradeSettlementFinancialCardTypeDeserializerState::CardholderName(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TradeSettlementFinancialCardTypeDeserializerState::Id(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_cardholder_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<TradeSettlementFinancialCardTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradeSettlementFinancialCardTypeDeserializerState::CardholderName(None),
                );
                *self.state = TradeSettlementFinancialCardTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_cardholder_name(data)?;
                    *self.state = TradeSettlementFinancialCardTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradeSettlementFinancialCardTypeDeserializerState::CardholderName(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = TradeSettlementFinancialCardTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradeSettlementFinancialCardTypeDeserializerState::CardholderName(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradeSettlementFinancialCardType>
        for TradeSettlementFinancialCardTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeSettlementFinancialCardType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradeSettlementFinancialCardType>
        where
            R: DeserializeReader,
        {
            use TradeSettlementFinancialCardTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Id(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CardholderName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_cardholder_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TradeSettlementFinancialCardTypeDeserializerState::Id(None);
                        event
                    }
                    (S::Id(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"ID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CardholderName(None);
                            event
                        }
                    }
                    (S::CardholderName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CardholderName",
                        ) {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_cardholder_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradeSettlementFinancialCardType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradeSettlementFinancialCardTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradeSettlementFinancialCardType {
                id: self
                    .id
                    .ok_or_else(|| ErrorKind::MissingElement("ID".into()))?,
                cardholder_name: self.cardholder_name,
            })
        }
    }
    #[derive(Debug)]
    pub struct DebtorFinancialAccountTypeDeserializer {
        ibanid: Option<super::IdType>,
        state: Box<DebtorFinancialAccountTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DebtorFinancialAccountTypeDeserializerState {
        Init__,
        Ibanid(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DebtorFinancialAccountTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                ibanid: None,
                state: Box::new(DebtorFinancialAccountTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DebtorFinancialAccountTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DebtorFinancialAccountTypeDeserializerState as S;
            match state {
                S::Ibanid(Some(deserializer)) => self.store_ibanid(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_ibanid(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.ibanid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"IBANID",
                )))?;
            }
            self.ibanid = Some(value);
            Ok(())
        }
        fn handle_ibanid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<DebtorFinancialAccountTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.ibanid.is_some() {
                    fallback
                        .get_or_insert(DebtorFinancialAccountTypeDeserializerState::Ibanid(None));
                    *self.state = DebtorFinancialAccountTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DebtorFinancialAccountTypeDeserializerState::Ibanid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ibanid(data)?;
                    *self.state = DebtorFinancialAccountTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DebtorFinancialAccountTypeDeserializerState::Ibanid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DebtorFinancialAccountTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DebtorFinancialAccountTypeDeserializerState::Ibanid(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DebtorFinancialAccountType>
        for DebtorFinancialAccountTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DebtorFinancialAccountType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DebtorFinancialAccountType>
        where
            R: DeserializeReader,
        {
            use DebtorFinancialAccountTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Ibanid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ibanid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = DebtorFinancialAccountTypeDeserializerState::Ibanid(None);
                        event
                    }
                    (S::Ibanid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"IBANID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_ibanid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DebtorFinancialAccountType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DebtorFinancialAccountTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DebtorFinancialAccountType {
                ibanid: self
                    .ibanid
                    .ok_or_else(|| ErrorKind::MissingElement("IBANID".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CreditorFinancialAccountTypeDeserializer {
        ibanid: Option<super::IdType>,
        account_name: Option<super::TextType>,
        proprietary_id: Option<super::IdType>,
        state: Box<CreditorFinancialAccountTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CreditorFinancialAccountTypeDeserializerState {
        Init__,
        Ibanid(Option<<super::IdType as WithDeserializer>::Deserializer>),
        AccountName(Option<<super::TextType as WithDeserializer>::Deserializer>),
        ProprietaryId(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CreditorFinancialAccountTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                ibanid: None,
                account_name: None,
                proprietary_id: None,
                state: Box::new(CreditorFinancialAccountTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CreditorFinancialAccountTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CreditorFinancialAccountTypeDeserializerState as S;
            match state {
                S::Ibanid(Some(deserializer)) => self.store_ibanid(deserializer.finish(reader)?)?,
                S::AccountName(Some(deserializer)) => {
                    self.store_account_name(deserializer.finish(reader)?)?
                }
                S::ProprietaryId(Some(deserializer)) => {
                    self.store_proprietary_id(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_ibanid(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.ibanid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"IBANID",
                )))?;
            }
            self.ibanid = Some(value);
            Ok(())
        }
        fn store_account_name(&mut self, value: super::TextType) -> Result<(), Error> {
            if self.account_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AccountName",
                )))?;
            }
            self.account_name = Some(value);
            Ok(())
        }
        fn store_proprietary_id(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.proprietary_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ProprietaryID",
                )))?;
            }
            self.proprietary_id = Some(value);
            Ok(())
        }
        fn handle_ibanid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<CreditorFinancialAccountTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CreditorFinancialAccountTypeDeserializerState::Ibanid(None));
                *self.state = CreditorFinancialAccountTypeDeserializerState::AccountName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_ibanid(data)?;
                    *self.state = CreditorFinancialAccountTypeDeserializerState::AccountName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CreditorFinancialAccountTypeDeserializerState::Ibanid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CreditorFinancialAccountTypeDeserializerState::AccountName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CreditorFinancialAccountTypeDeserializerState::Ibanid(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_account_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TextType>,
            fallback: &mut Option<CreditorFinancialAccountTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CreditorFinancialAccountTypeDeserializerState::AccountName(
                    None,
                ));
                *self.state = CreditorFinancialAccountTypeDeserializerState::ProprietaryId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_account_name(data)?;
                    *self.state =
                        CreditorFinancialAccountTypeDeserializerState::ProprietaryId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CreditorFinancialAccountTypeDeserializerState::AccountName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CreditorFinancialAccountTypeDeserializerState::ProprietaryId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CreditorFinancialAccountTypeDeserializerState::AccountName(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_proprietary_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<CreditorFinancialAccountTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CreditorFinancialAccountTypeDeserializerState::ProprietaryId(None),
                );
                *self.state = CreditorFinancialAccountTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_proprietary_id(data)?;
                    *self.state = CreditorFinancialAccountTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CreditorFinancialAccountTypeDeserializerState::ProprietaryId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CreditorFinancialAccountTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CreditorFinancialAccountTypeDeserializerState::ProprietaryId(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CreditorFinancialAccountType>
        for CreditorFinancialAccountTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CreditorFinancialAccountType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CreditorFinancialAccountType>
        where
            R: DeserializeReader,
        {
            use CreditorFinancialAccountTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Ibanid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ibanid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AccountName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_account_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProprietaryId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_proprietary_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CreditorFinancialAccountTypeDeserializerState::Ibanid(None);
                        event
                    }
                    (S::Ibanid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"IBANID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_ibanid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::AccountName(None);
                            event
                        }
                    }
                    (S::AccountName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"AccountName")
                        {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_account_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProprietaryId(None);
                            event
                        }
                    }
                    (S::ProprietaryId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ProprietaryID",
                        ) {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_proprietary_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CreditorFinancialAccountType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CreditorFinancialAccountTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CreditorFinancialAccountType {
                ibanid: self.ibanid,
                account_name: self.account_name,
                proprietary_id: self.proprietary_id,
            })
        }
    }
    #[derive(Debug)]
    pub struct CreditorFinancialInstitutionTypeDeserializer {
        bicid: Option<super::IdType>,
        state: Box<CreditorFinancialInstitutionTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CreditorFinancialInstitutionTypeDeserializerState {
        Init__,
        Bicid(Option<<super::IdType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CreditorFinancialInstitutionTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                bicid: None,
                state: Box::new(CreditorFinancialInstitutionTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CreditorFinancialInstitutionTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CreditorFinancialInstitutionTypeDeserializerState as S;
            match state {
                S::Bicid(Some(deserializer)) => self.store_bicid(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_bicid(&mut self, value: super::IdType) -> Result<(), Error> {
            if self.bicid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BICID",
                )))?;
            }
            self.bicid = Some(value);
            Ok(())
        }
        fn handle_bicid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::IdType>,
            fallback: &mut Option<CreditorFinancialInstitutionTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.bicid.is_some() {
                    fallback.get_or_insert(
                        CreditorFinancialInstitutionTypeDeserializerState::Bicid(None),
                    );
                    *self.state = CreditorFinancialInstitutionTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CreditorFinancialInstitutionTypeDeserializerState::Bicid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_bicid(data)?;
                    *self.state = CreditorFinancialInstitutionTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CreditorFinancialInstitutionTypeDeserializerState::Bicid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CreditorFinancialInstitutionTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CreditorFinancialInstitutionTypeDeserializerState::Bicid(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CreditorFinancialInstitutionType>
        for CreditorFinancialInstitutionTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CreditorFinancialInstitutionType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CreditorFinancialInstitutionType>
        where
            R: DeserializeReader,
        {
            use CreditorFinancialInstitutionTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Bicid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_bicid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CreditorFinancialInstitutionTypeDeserializerState::Bicid(None);
                        event
                    }
                    (S::Bicid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"BICID") {
                            let output = <super::IdType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_bicid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CreditorFinancialInstitutionType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CreditorFinancialInstitutionTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CreditorFinancialInstitutionType {
                bicid: self
                    .bicid
                    .ok_or_else(|| ErrorKind::MissingElement("BICID".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct AmountTypeDeserializer {
        currency_id: Option<String>,
        content: Option<f64>,
        state: Box<AmountTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum AmountTypeDeserializerState {
        Init__,
        Content__(<f64 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl AmountTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut currency_id: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"currencyID")
                ) {
                    reader.read_attrib(&mut currency_id, b"currencyID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                currency_id: currency_id,
                content: None,
                state: Box::new(AmountTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: AmountTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let AmountTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: f64) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
        ) -> DeserializerResult<'de, super::AmountType>
        where
            R: DeserializeReader,
        {
            use AmountTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::AmountType> for AmountTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::AmountType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AmountType>
        where
            R: DeserializeReader,
        {
            use AmountTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::AmountType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, AmountTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::AmountType {
                currency_id: self.currency_id,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TaxTypeCodeTypeDeserializer {
        content: Option<String>,
        state: Box<TaxTypeCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TaxTypeCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl TaxTypeCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(TaxTypeCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TaxTypeCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let TaxTypeCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::TaxTypeCodeType>
        where
            R: DeserializeReader,
        {
            use TaxTypeCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::TaxTypeCodeType> for TaxTypeCodeTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TaxTypeCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TaxTypeCodeType>
        where
            R: DeserializeReader,
        {
            use TaxTypeCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TaxTypeCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TaxTypeCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TaxTypeCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TaxCategoryCodeTypeDeserializer {
        content: Option<String>,
        state: Box<TaxCategoryCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TaxCategoryCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl TaxCategoryCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(TaxCategoryCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TaxCategoryCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let TaxCategoryCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::TaxCategoryCodeType>
        where
            R: DeserializeReader,
        {
            use TaxCategoryCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::TaxCategoryCodeType> for TaxCategoryCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TaxCategoryCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TaxCategoryCodeType>
        where
            R: DeserializeReader,
        {
            use TaxCategoryCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TaxCategoryCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TaxCategoryCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TaxCategoryCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DateTypeDeserializer {
        content: Option<super::DateTypeContent>,
        state: Box<DateTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DateTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::DateTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DateTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(DateTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DateTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DateTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::DateTypeContent) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTypeContent>,
            fallback: &mut Option<DateTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback.take().unwrap_or(DateTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = DateTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = DateTypeDeserializerState::Content__(deserializer);
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DateType> for DateTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::DateType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateType>
        where
            R: DeserializeReader,
        {
            use DateTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output =
                            <super::DateTypeContent as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DateType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, DateTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::DateType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DateTypeContentDeserializer {
        state: Box<DateTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum DateTypeContentDeserializerState {
        Init__,
        DateString(
            Option<super::DateTypeDateStringType>,
            Option<<super::DateTypeDateStringType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::DateTypeContent),
        Unknown__,
    }
    impl DateTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<DateTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(DateTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_UDT),
                Some(b"DateString")
            ) {
                let output =
                    <super::DateTypeDateStringType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                return self.handle_date_string(reader, Default::default(), output, &mut *fallback);
            }
            *self.state = fallback
                .take()
                .unwrap_or(DateTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: DateTypeContentDeserializerState,
        ) -> Result<super::DateTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use DateTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::DateString(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_date_string(&mut values, value)?;
                    }
                    Ok(super::DateTypeContent::DateString(values.ok_or_else(
                        || ErrorKind::MissingElement("DateString".into()),
                    )?))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_date_string(
            values: &mut Option<super::DateTypeDateStringType>,
            value: super::DateTypeDateStringType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DateString",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_date_string<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::DateTypeDateStringType>,
            output: DeserializerOutput<'de, super::DateTypeDateStringType>,
            fallback: &mut Option<DateTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => DateTypeContentDeserializerState::DateString(values, None),
                    Some(DateTypeContentDeserializerState::DateString(_, Some(deserializer))) => {
                        DateTypeContentDeserializerState::DateString(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(DateTypeContentDeserializerState::DateString(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_date_string(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_date_string(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        DateTypeContentDeserializerState::DateString(values, None),
                    )?;
                    *self.state = DateTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        DateTypeContentDeserializerState::DateString(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DateTypeContent> for DateTypeContentDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::DateTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(DateTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, DateTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateTypeContent>
        where
            R: DeserializeReader,
        {
            use DateTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DateString(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_date_string(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::DateString(values, None), event) => {
                        let output = < super :: DateTypeDateStringType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_date_string(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::DateTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct TimeReferenceCodeTypeDeserializer {
        content: Option<String>,
        state: Box<TimeReferenceCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TimeReferenceCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl TimeReferenceCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(TimeReferenceCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TimeReferenceCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let TimeReferenceCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::TimeReferenceCodeType>
        where
            R: DeserializeReader,
        {
            use TimeReferenceCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::TimeReferenceCodeType> for TimeReferenceCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TimeReferenceCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TimeReferenceCodeType>
        where
            R: DeserializeReader,
        {
            use TimeReferenceCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TimeReferenceCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TimeReferenceCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TimeReferenceCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct PercentTypeDeserializer {
        content: Option<f64>,
        state: Box<PercentTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PercentTypeDeserializerState {
        Init__,
        Content__(<f64 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl PercentTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(PercentTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PercentTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let PercentTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: f64) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
        ) -> DeserializerResult<'de, super::PercentType>
        where
            R: DeserializeReader,
        {
            use PercentTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::PercentType> for PercentTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::PercentType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PercentType>
        where
            R: DeserializeReader,
        {
            use PercentTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PercentType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, PercentTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::PercentType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct NumericTypeDeserializer {
        content: Option<f64>,
        state: Box<NumericTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum NumericTypeDeserializerState {
        Init__,
        Content__(<f64 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl NumericTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(NumericTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: NumericTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let NumericTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: f64) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
        ) -> DeserializerResult<'de, super::NumericType>
        where
            R: DeserializeReader,
        {
            use NumericTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::NumericType> for NumericTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::NumericType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::NumericType>
        where
            R: DeserializeReader,
        {
            use NumericTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::NumericType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, NumericTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::NumericType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct AllowanceChargeReasonCodeTypeDeserializer {
        content: Option<String>,
        state: Box<AllowanceChargeReasonCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum AllowanceChargeReasonCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl AllowanceChargeReasonCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(AllowanceChargeReasonCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: AllowanceChargeReasonCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let AllowanceChargeReasonCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::AllowanceChargeReasonCodeType>
        where
            R: DeserializeReader,
        {
            use AllowanceChargeReasonCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::AllowanceChargeReasonCodeType>
        for AllowanceChargeReasonCodeTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AllowanceChargeReasonCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AllowanceChargeReasonCodeType>
        where
            R: DeserializeReader,
        {
            use AllowanceChargeReasonCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::AllowanceChargeReasonCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                AllowanceChargeReasonCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::AllowanceChargeReasonCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradePaymentPenaltyTermsTypeDeserializer {
        basis_date_time: Option<super::DateTimeType>,
        basis_period_measure: Option<super::MeasureType>,
        basis_amount: Option<super::AmountType>,
        calculation_percent: Option<super::PercentType>,
        actual_penalty_amount: Option<super::AmountType>,
        state: Box<TradePaymentPenaltyTermsTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradePaymentPenaltyTermsTypeDeserializerState {
        Init__,
        BasisDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        BasisPeriodMeasure(Option<<super::MeasureType as WithDeserializer>::Deserializer>),
        BasisAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        CalculationPercent(Option<<super::PercentType as WithDeserializer>::Deserializer>),
        ActualPenaltyAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradePaymentPenaltyTermsTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                basis_date_time: None,
                basis_period_measure: None,
                basis_amount: None,
                calculation_percent: None,
                actual_penalty_amount: None,
                state: Box::new(TradePaymentPenaltyTermsTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradePaymentPenaltyTermsTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradePaymentPenaltyTermsTypeDeserializerState as S;
            match state {
                S::BasisDateTime(Some(deserializer)) => {
                    self.store_basis_date_time(deserializer.finish(reader)?)?
                }
                S::BasisPeriodMeasure(Some(deserializer)) => {
                    self.store_basis_period_measure(deserializer.finish(reader)?)?
                }
                S::BasisAmount(Some(deserializer)) => {
                    self.store_basis_amount(deserializer.finish(reader)?)?
                }
                S::CalculationPercent(Some(deserializer)) => {
                    self.store_calculation_percent(deserializer.finish(reader)?)?
                }
                S::ActualPenaltyAmount(Some(deserializer)) => {
                    self.store_actual_penalty_amount(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_basis_date_time(&mut self, value: super::DateTimeType) -> Result<(), Error> {
            if self.basis_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisDateTime",
                )))?;
            }
            self.basis_date_time = Some(value);
            Ok(())
        }
        fn store_basis_period_measure(&mut self, value: super::MeasureType) -> Result<(), Error> {
            if self.basis_period_measure.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisPeriodMeasure",
                )))?;
            }
            self.basis_period_measure = Some(value);
            Ok(())
        }
        fn store_basis_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.basis_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisAmount",
                )))?;
            }
            self.basis_amount = Some(value);
            Ok(())
        }
        fn store_calculation_percent(&mut self, value: super::PercentType) -> Result<(), Error> {
            if self.calculation_percent.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CalculationPercent",
                )))?;
            }
            self.calculation_percent = Some(value);
            Ok(())
        }
        fn store_actual_penalty_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.actual_penalty_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ActualPenaltyAmount",
                )))?;
            }
            self.actual_penalty_amount = Some(value);
            Ok(())
        }
        fn handle_basis_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<TradePaymentPenaltyTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentPenaltyTermsTypeDeserializerState::BasisDateTime(None),
                );
                *self.state =
                    TradePaymentPenaltyTermsTypeDeserializerState::BasisPeriodMeasure(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_date_time(data)?;
                    *self.state =
                        TradePaymentPenaltyTermsTypeDeserializerState::BasisPeriodMeasure(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentPenaltyTermsTypeDeserializerState::BasisDateTime(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::BasisPeriodMeasure(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::BasisDateTime(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_basis_period_measure<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MeasureType>,
            fallback: &mut Option<TradePaymentPenaltyTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentPenaltyTermsTypeDeserializerState::BasisPeriodMeasure(None),
                );
                *self.state = TradePaymentPenaltyTermsTypeDeserializerState::BasisAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_period_measure(data)?;
                    *self.state = TradePaymentPenaltyTermsTypeDeserializerState::BasisAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentPenaltyTermsTypeDeserializerState::BasisPeriodMeasure(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::BasisAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::BasisPeriodMeasure(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_basis_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradePaymentPenaltyTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TradePaymentPenaltyTermsTypeDeserializerState::BasisAmount(
                    None,
                ));
                *self.state =
                    TradePaymentPenaltyTermsTypeDeserializerState::CalculationPercent(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_amount(data)?;
                    *self.state =
                        TradePaymentPenaltyTermsTypeDeserializerState::CalculationPercent(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentPenaltyTermsTypeDeserializerState::BasisAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::CalculationPercent(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::BasisAmount(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_calculation_percent<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PercentType>,
            fallback: &mut Option<TradePaymentPenaltyTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentPenaltyTermsTypeDeserializerState::CalculationPercent(None),
                );
                *self.state =
                    TradePaymentPenaltyTermsTypeDeserializerState::ActualPenaltyAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_calculation_percent(data)?;
                    *self.state =
                        TradePaymentPenaltyTermsTypeDeserializerState::ActualPenaltyAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentPenaltyTermsTypeDeserializerState::CalculationPercent(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::ActualPenaltyAmount(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::CalculationPercent(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_actual_penalty_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradePaymentPenaltyTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentPenaltyTermsTypeDeserializerState::ActualPenaltyAmount(None),
                );
                *self.state = TradePaymentPenaltyTermsTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actual_penalty_amount(data)?;
                    *self.state = TradePaymentPenaltyTermsTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentPenaltyTermsTypeDeserializerState::ActualPenaltyAmount(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = TradePaymentPenaltyTermsTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentPenaltyTermsTypeDeserializerState::ActualPenaltyAmount(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradePaymentPenaltyTermsType>
        for TradePaymentPenaltyTermsTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradePaymentPenaltyTermsType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradePaymentPenaltyTermsType>
        where
            R: DeserializeReader,
        {
            use TradePaymentPenaltyTermsTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BasisDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BasisPeriodMeasure(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_period_measure(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BasisAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CalculationPercent(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_calculation_percent(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ActualPenaltyAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actual_penalty_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TradePaymentPenaltyTermsTypeDeserializerState::BasisDateTime(None);
                        event
                    }
                    (S::BasisDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BasisDateTime",
                        ) {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_date_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BasisPeriodMeasure(None);
                            event
                        }
                    }
                    (S::BasisPeriodMeasure(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BasisPeriodMeasure",
                        ) {
                            let output =
                                <super::MeasureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_period_measure(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BasisAmount(None);
                            event
                        }
                    }
                    (S::BasisAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"BasisAmount")
                        {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CalculationPercent(None);
                            event
                        }
                    }
                    (S::CalculationPercent(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CalculationPercent",
                        ) {
                            let output =
                                <super::PercentType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_calculation_percent(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ActualPenaltyAmount(None);
                            event
                        }
                    }
                    (S::ActualPenaltyAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ActualPenaltyAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_actual_penalty_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradePaymentPenaltyTermsType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradePaymentPenaltyTermsTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradePaymentPenaltyTermsType {
                basis_date_time: self.basis_date_time,
                basis_period_measure: self.basis_period_measure,
                basis_amount: self.basis_amount,
                calculation_percent: self.calculation_percent,
                actual_penalty_amount: self.actual_penalty_amount,
            })
        }
    }
    #[derive(Debug)]
    pub struct TradePaymentDiscountTermsTypeDeserializer {
        basis_date_time: Option<super::DateTimeType>,
        basis_period_measure: Option<super::MeasureType>,
        basis_amount: Option<super::AmountType>,
        calculation_percent: Option<super::PercentType>,
        actual_discount_amount: Option<super::AmountType>,
        state: Box<TradePaymentDiscountTermsTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TradePaymentDiscountTermsTypeDeserializerState {
        Init__,
        BasisDateTime(Option<<super::DateTimeType as WithDeserializer>::Deserializer>),
        BasisPeriodMeasure(Option<<super::MeasureType as WithDeserializer>::Deserializer>),
        BasisAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        CalculationPercent(Option<<super::PercentType as WithDeserializer>::Deserializer>),
        ActualDiscountAmount(Option<<super::AmountType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TradePaymentDiscountTermsTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                basis_date_time: None,
                basis_period_measure: None,
                basis_amount: None,
                calculation_percent: None,
                actual_discount_amount: None,
                state: Box::new(TradePaymentDiscountTermsTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TradePaymentDiscountTermsTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TradePaymentDiscountTermsTypeDeserializerState as S;
            match state {
                S::BasisDateTime(Some(deserializer)) => {
                    self.store_basis_date_time(deserializer.finish(reader)?)?
                }
                S::BasisPeriodMeasure(Some(deserializer)) => {
                    self.store_basis_period_measure(deserializer.finish(reader)?)?
                }
                S::BasisAmount(Some(deserializer)) => {
                    self.store_basis_amount(deserializer.finish(reader)?)?
                }
                S::CalculationPercent(Some(deserializer)) => {
                    self.store_calculation_percent(deserializer.finish(reader)?)?
                }
                S::ActualDiscountAmount(Some(deserializer)) => {
                    self.store_actual_discount_amount(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_basis_date_time(&mut self, value: super::DateTimeType) -> Result<(), Error> {
            if self.basis_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisDateTime",
                )))?;
            }
            self.basis_date_time = Some(value);
            Ok(())
        }
        fn store_basis_period_measure(&mut self, value: super::MeasureType) -> Result<(), Error> {
            if self.basis_period_measure.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisPeriodMeasure",
                )))?;
            }
            self.basis_period_measure = Some(value);
            Ok(())
        }
        fn store_basis_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.basis_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BasisAmount",
                )))?;
            }
            self.basis_amount = Some(value);
            Ok(())
        }
        fn store_calculation_percent(&mut self, value: super::PercentType) -> Result<(), Error> {
            if self.calculation_percent.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CalculationPercent",
                )))?;
            }
            self.calculation_percent = Some(value);
            Ok(())
        }
        fn store_actual_discount_amount(&mut self, value: super::AmountType) -> Result<(), Error> {
            if self.actual_discount_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ActualDiscountAmount",
                )))?;
            }
            self.actual_discount_amount = Some(value);
            Ok(())
        }
        fn handle_basis_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DateTimeType>,
            fallback: &mut Option<TradePaymentDiscountTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentDiscountTermsTypeDeserializerState::BasisDateTime(None),
                );
                *self.state =
                    TradePaymentDiscountTermsTypeDeserializerState::BasisPeriodMeasure(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_date_time(data)?;
                    *self.state =
                        TradePaymentDiscountTermsTypeDeserializerState::BasisPeriodMeasure(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentDiscountTermsTypeDeserializerState::BasisDateTime(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradePaymentDiscountTermsTypeDeserializerState::BasisPeriodMeasure(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentDiscountTermsTypeDeserializerState::BasisDateTime(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_basis_period_measure<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MeasureType>,
            fallback: &mut Option<TradePaymentDiscountTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentDiscountTermsTypeDeserializerState::BasisPeriodMeasure(None),
                );
                *self.state = TradePaymentDiscountTermsTypeDeserializerState::BasisAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_period_measure(data)?;
                    *self.state = TradePaymentDiscountTermsTypeDeserializerState::BasisAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentDiscountTermsTypeDeserializerState::BasisPeriodMeasure(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TradePaymentDiscountTermsTypeDeserializerState::BasisAmount(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentDiscountTermsTypeDeserializerState::BasisPeriodMeasure(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_basis_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradePaymentDiscountTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentDiscountTermsTypeDeserializerState::BasisAmount(None),
                );
                *self.state =
                    TradePaymentDiscountTermsTypeDeserializerState::CalculationPercent(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_basis_amount(data)?;
                    *self.state =
                        TradePaymentDiscountTermsTypeDeserializerState::CalculationPercent(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentDiscountTermsTypeDeserializerState::BasisAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TradePaymentDiscountTermsTypeDeserializerState::CalculationPercent(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentDiscountTermsTypeDeserializerState::BasisAmount(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_calculation_percent<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PercentType>,
            fallback: &mut Option<TradePaymentDiscountTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentDiscountTermsTypeDeserializerState::CalculationPercent(None),
                );
                *self.state =
                    TradePaymentDiscountTermsTypeDeserializerState::ActualDiscountAmount(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_calculation_percent(data)?;
                    *self.state =
                        TradePaymentDiscountTermsTypeDeserializerState::ActualDiscountAmount(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TradePaymentDiscountTermsTypeDeserializerState::CalculationPercent(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = TradePaymentDiscountTermsTypeDeserializerState :: ActualDiscountAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TradePaymentDiscountTermsTypeDeserializerState::CalculationPercent(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_actual_discount_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AmountType>,
            fallback: &mut Option<TradePaymentDiscountTermsTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TradePaymentDiscountTermsTypeDeserializerState::ActualDiscountAmount(None),
                );
                *self.state = TradePaymentDiscountTermsTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actual_discount_amount(data)?;
                    *self.state = TradePaymentDiscountTermsTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TradePaymentDiscountTermsTypeDeserializerState :: ActualDiscountAmount (Some (deserializer))) ;
                            *self.state = TradePaymentDiscountTermsTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TradePaymentDiscountTermsTypeDeserializerState :: ActualDiscountAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TradePaymentDiscountTermsType>
        for TradePaymentDiscountTermsTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradePaymentDiscountTermsType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TradePaymentDiscountTermsType>
        where
            R: DeserializeReader,
        {
            use TradePaymentDiscountTermsTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BasisDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BasisPeriodMeasure(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_period_measure(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BasisAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_basis_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CalculationPercent(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_calculation_percent(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ActualDiscountAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actual_discount_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TradePaymentDiscountTermsTypeDeserializerState::BasisDateTime(None);
                        event
                    }
                    (S::BasisDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BasisDateTime",
                        ) {
                            let output =
                                <super::DateTimeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_date_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BasisPeriodMeasure(None);
                            event
                        }
                    }
                    (S::BasisPeriodMeasure(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"BasisPeriodMeasure",
                        ) {
                            let output =
                                <super::MeasureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_period_measure(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BasisAmount(None);
                            event
                        }
                    }
                    (S::BasisAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_RAM), b"BasisAmount")
                        {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_basis_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CalculationPercent(None);
                            event
                        }
                    }
                    (S::CalculationPercent(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"CalculationPercent",
                        ) {
                            let output =
                                <super::PercentType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_calculation_percent(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ActualDiscountAmount(None);
                            event
                        }
                    }
                    (
                        S::ActualDiscountAmount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_RAM),
                            b"ActualDiscountAmount",
                        ) {
                            let output =
                                <super::AmountType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_actual_discount_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TradePaymentDiscountTermsType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TradePaymentDiscountTermsTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TradePaymentDiscountTermsType {
                basis_date_time: self.basis_date_time,
                basis_period_measure: self.basis_period_measure,
                basis_amount: self.basis_amount,
                calculation_percent: self.calculation_percent,
                actual_discount_amount: self.actual_discount_amount,
            })
        }
    }
    #[derive(Debug)]
    pub struct AccountingAccountTypeCodeTypeDeserializer {
        content: Option<String>,
        state: Box<AccountingAccountTypeCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum AccountingAccountTypeCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl AccountingAccountTypeCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(AccountingAccountTypeCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: AccountingAccountTypeCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let AccountingAccountTypeCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::AccountingAccountTypeCodeType>
        where
            R: DeserializeReader,
        {
            use AccountingAccountTypeCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::AccountingAccountTypeCodeType>
        for AccountingAccountTypeCodeTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AccountingAccountTypeCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AccountingAccountTypeCodeType>
        where
            R: DeserializeReader,
        {
            use AccountingAccountTypeCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::AccountingAccountTypeCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                AccountingAccountTypeCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::AccountingAccountTypeCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct MeasureTypeDeserializer {
        unit_code: Option<String>,
        content: Option<f64>,
        state: Box<MeasureTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum MeasureTypeDeserializerState {
        Init__,
        Content__(<f64 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl MeasureTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut unit_code: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"unitCode")
                ) {
                    reader.read_attrib(&mut unit_code, b"unitCode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                unit_code: unit_code,
                content: None,
                state: Box::new(MeasureTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: MeasureTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let MeasureTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: f64) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
        ) -> DeserializerResult<'de, super::MeasureType>
        where
            R: DeserializeReader,
        {
            use MeasureTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::MeasureType> for MeasureTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::MeasureType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::MeasureType>
        where
            R: DeserializeReader,
        {
            use MeasureTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::MeasureType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, MeasureTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::MeasureType {
                unit_code: self.unit_code,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CountryIdTypeDeserializer {
        content: Option<String>,
        state: Box<CountryIdTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CountryIdTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CountryIdTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(CountryIdTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CountryIdTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CountryIdTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::CountryIdType>
        where
            R: DeserializeReader,
        {
            use CountryIdTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::CountryIdType> for CountryIdTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CountryIdType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CountryIdType>
        where
            R: DeserializeReader,
        {
            use CountryIdTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CountryIdType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CountryIdTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CountryIdType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ContactTypeCodeTypeDeserializer {
        content: Option<String>,
        state: Box<ContactTypeCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ContactTypeCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl ContactTypeCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(ContactTypeCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ContactTypeCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let ContactTypeCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::ContactTypeCodeType>
        where
            R: DeserializeReader,
        {
            use ContactTypeCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::ContactTypeCodeType> for ContactTypeCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ContactTypeCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ContactTypeCodeType>
        where
            R: DeserializeReader,
        {
            use ContactTypeCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ContactTypeCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ContactTypeCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ContactTypeCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct FormattedDateTimeTypeDateTimeStringTypeDeserializer {
        format: String,
        content: Option<String>,
        state: Box<FormattedDateTimeTypeDateTimeStringTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum FormattedDateTimeTypeDateTimeStringTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl FormattedDateTimeTypeDateTimeStringTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut format: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_QDT),
                    Some(b"format")
                ) {
                    reader.read_attrib(&mut format, b"format", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                format: format.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("format".into()))
                })?,
                content: None,
                state: Box::new(FormattedDateTimeTypeDateTimeStringTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: FormattedDateTimeTypeDateTimeStringTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let FormattedDateTimeTypeDateTimeStringTypeDeserializerState::Content__(
                deserializer,
            ) = state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::FormattedDateTimeTypeDateTimeStringType>
        where
            R: DeserializeReader,
        {
            use FormattedDateTimeTypeDateTimeStringTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::FormattedDateTimeTypeDateTimeStringType>
        for FormattedDateTimeTypeDateTimeStringTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::FormattedDateTimeTypeDateTimeStringType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::FormattedDateTimeTypeDateTimeStringType>
        where
            R: DeserializeReader,
        {
            use FormattedDateTimeTypeDateTimeStringTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::FormattedDateTimeTypeDateTimeStringType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                FormattedDateTimeTypeDateTimeStringTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::FormattedDateTimeTypeDateTimeStringType {
                format: self.format,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TransportModeCodeTypeDeserializer {
        content: Option<String>,
        state: Box<TransportModeCodeTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TransportModeCodeTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl TransportModeCodeTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: None,
                state: Box::new(TransportModeCodeTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TransportModeCodeTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let TransportModeCodeTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::TransportModeCodeType>
        where
            R: DeserializeReader,
        {
            use TransportModeCodeTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::TransportModeCodeType> for TransportModeCodeTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TransportModeCodeType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TransportModeCodeType>
        where
            R: DeserializeReader,
        {
            use TransportModeCodeTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TransportModeCodeType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TransportModeCodeTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TransportModeCodeType {
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DateTypeDateStringTypeDeserializer {
        format: String,
        content: Option<String>,
        state: Box<DateTypeDateStringTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DateTypeDateStringTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DateTypeDateStringTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut format: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_UDT),
                    Some(b"format")
                ) {
                    reader.read_attrib(&mut format, b"format", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                format: format.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("format".into()))
                })?,
                content: None,
                state: Box::new(DateTypeDateStringTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DateTypeDateStringTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DateTypeDateStringTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::DateTypeDateStringType>
        where
            R: DeserializeReader,
        {
            use DateTypeDateStringTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::DateTypeDateStringType> for DateTypeDateStringTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateTypeDateStringType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DateTypeDateStringType>
        where
            R: DeserializeReader,
        {
            use DateTypeDateStringTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DateTypeDateStringType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DateTypeDateStringTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DateTypeDateStringType {
                format: self.format,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
}
pub mod quick_xml_serialize {
    use core::iter::Iterator;
    use xsd_parser::quick_xml::{
        write_attrib, write_attrib_opt, BytesEnd, BytesStart, Error, Event, IterSerializer,
        WithSerializer,
    };
    #[derive(Debug)]
    pub struct CrossIndustryInvoiceTypeSerializer<'ser> {
        pub(super) value: &'ser super::CrossIndustryInvoiceType,
        pub(super) state: Box<CrossIndustryInvoiceTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CrossIndustryInvoiceTypeSerializerState<'ser> {
        Init__,
        ExchangedDocumentContext(
            <super::ExchangedDocumentContextType as WithSerializer>::Serializer<'ser>,
        ),
        ExchangedDocument(<super::ExchangedDocumentType as WithSerializer>::Serializer<'ser>),
        SupplyChainTradeTransaction(
            <super::SupplyChainTradeTransactionType as WithSerializer>::Serializer<'ser>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CrossIndustryInvoiceTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CrossIndustryInvoiceTypeSerializerState::Init__ => {
                        *self.state =
                            CrossIndustryInvoiceTypeSerializerState::ExchangedDocumentContext(
                                WithSerializer::serializer(
                                    &self.value.exchanged_document_context,
                                    Some("rsm:ExchangedDocumentContext"),
                                    false,
                                )?,
                            );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CrossIndustryInvoiceTypeSerializerState::ExchangedDocumentContext(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CrossIndustryInvoiceTypeSerializerState::ExchangedDocument(
                                        WithSerializer::serializer(
                                            &self.value.exchanged_document,
                                            Some("rsm:ExchangedDocument"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    CrossIndustryInvoiceTypeSerializerState::ExchangedDocument(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CrossIndustryInvoiceTypeSerializerState::SupplyChainTradeTransaction(
                                    WithSerializer::serializer(
                                        &self.value.supply_chain_trade_transaction,
                                        Some("rsm:SupplyChainTradeTransaction"),
                                        false,
                                    )?,
                                )
                        }
                    },
                    CrossIndustryInvoiceTypeSerializerState::SupplyChainTradeTransaction(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CrossIndustryInvoiceTypeSerializerState::End__,
                        }
                    }
                    CrossIndustryInvoiceTypeSerializerState::End__ => {
                        *self.state = CrossIndustryInvoiceTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CrossIndustryInvoiceTypeSerializerState::Done__ => return Ok(None),
                    CrossIndustryInvoiceTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CrossIndustryInvoiceTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CrossIndustryInvoiceTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ExchangedDocumentContextTypeSerializer<'ser> {
        pub(super) value: &'ser super::ExchangedDocumentContextType,
        pub(super) state: Box<ExchangedDocumentContextTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ExchangedDocumentContextTypeSerializerState<'ser> {
        Init__,
        TestIndicator(
            IterSerializer<'ser, Option<&'ser super::IndicatorType>, super::IndicatorType>,
        ),
        BusinessProcessSpecifiedDocumentContextParameter(
            IterSerializer<
                'ser,
                Option<&'ser super::DocumentContextParameterType>,
                super::DocumentContextParameterType,
            >,
        ),
        GuidelineSpecifiedDocumentContextParameter(
            <super::DocumentContextParameterType as WithSerializer>::Serializer<'ser>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ExchangedDocumentContextTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { ExchangedDocumentContextTypeSerializerState :: Init__ => { * self . state = ExchangedDocumentContextTypeSerializerState :: TestIndicator (IterSerializer :: new (self . value . test_indicator . as_ref () , Some ("ram:TestIndicator") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } ExchangedDocumentContextTypeSerializerState :: TestIndicator (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ExchangedDocumentContextTypeSerializerState :: BusinessProcessSpecifiedDocumentContextParameter (IterSerializer :: new (self . value . business_process_specified_document_context_parameter . as_ref () , Some ("ram:BusinessProcessSpecifiedDocumentContextParameter") , false)) , } ExchangedDocumentContextTypeSerializerState :: BusinessProcessSpecifiedDocumentContextParameter (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ExchangedDocumentContextTypeSerializerState :: GuidelineSpecifiedDocumentContextParameter (WithSerializer :: serializer (& self . value . guideline_specified_document_context_parameter , Some ("ram:GuidelineSpecifiedDocumentContextParameter") , false) ?) , } ExchangedDocumentContextTypeSerializerState :: GuidelineSpecifiedDocumentContextParameter (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ExchangedDocumentContextTypeSerializerState :: End__ , } ExchangedDocumentContextTypeSerializerState :: End__ => { * self . state = ExchangedDocumentContextTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } ExchangedDocumentContextTypeSerializerState :: Done__ => return Ok (None) , ExchangedDocumentContextTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for ExchangedDocumentContextTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ExchangedDocumentContextTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ExchangedDocumentTypeSerializer<'ser> {
        pub(super) value: &'ser super::ExchangedDocumentType,
        pub(super) state: Box<ExchangedDocumentTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ExchangedDocumentTypeSerializerState<'ser> {
        Init__,
        Id(<super::IdType as WithSerializer>::Serializer<'ser>),
        Name(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        TypeCode(<super::DocumentCodeType as WithSerializer>::Serializer<'ser>),
        IssueDateTime(<super::DateTimeType as WithSerializer>::Serializer<'ser>),
        CopyIndicator(
            IterSerializer<'ser, Option<&'ser super::IndicatorType>, super::IndicatorType>,
        ),
        LanguageId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        IncludedNote(IterSerializer<'ser, &'ser [super::NoteType], super::NoteType>),
        EffectiveSpecifiedPeriod(
            IterSerializer<
                'ser,
                Option<&'ser super::SpecifiedPeriodType>,
                super::SpecifiedPeriodType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ExchangedDocumentTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ExchangedDocumentTypeSerializerState::Init__ => {
                        *self.state = ExchangedDocumentTypeSerializerState::Id(
                            WithSerializer::serializer(&self.value.id, Some("ram:ID"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ExchangedDocumentTypeSerializerState::Id(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                ExchangedDocumentTypeSerializerState::Name(IterSerializer::new(
                                    self.value.name.as_ref(),
                                    Some("ram:Name"),
                                    false,
                                ))
                        }
                    },
                    ExchangedDocumentTypeSerializerState::Name(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = ExchangedDocumentTypeSerializerState::TypeCode(
                                WithSerializer::serializer(
                                    &self.value.type_code,
                                    Some("ram:TypeCode"),
                                    false,
                                )?,
                            )
                        }
                    },
                    ExchangedDocumentTypeSerializerState::TypeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ExchangedDocumentTypeSerializerState::IssueDateTime(
                                    WithSerializer::serializer(
                                        &self.value.issue_date_time,
                                        Some("ram:IssueDateTime"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    ExchangedDocumentTypeSerializerState::IssueDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ExchangedDocumentTypeSerializerState::CopyIndicator(
                                    IterSerializer::new(
                                        self.value.copy_indicator.as_ref(),
                                        Some("ram:CopyIndicator"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ExchangedDocumentTypeSerializerState::CopyIndicator(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ExchangedDocumentTypeSerializerState::LanguageId(
                                    IterSerializer::new(
                                        self.value.language_id.as_ref(),
                                        Some("ram:LanguageID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ExchangedDocumentTypeSerializerState::LanguageId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ExchangedDocumentTypeSerializerState::IncludedNote(
                                    IterSerializer::new(
                                        &self.value.included_note[..],
                                        Some("ram:IncludedNote"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ExchangedDocumentTypeSerializerState::IncludedNote(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ExchangedDocumentTypeSerializerState::EffectiveSpecifiedPeriod(
                                        IterSerializer::new(
                                            self.value.effective_specified_period.as_ref(),
                                            Some("ram:EffectiveSpecifiedPeriod"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ExchangedDocumentTypeSerializerState::EffectiveSpecifiedPeriod(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ExchangedDocumentTypeSerializerState::End__,
                        }
                    }
                    ExchangedDocumentTypeSerializerState::End__ => {
                        *self.state = ExchangedDocumentTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ExchangedDocumentTypeSerializerState::Done__ => return Ok(None),
                    ExchangedDocumentTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ExchangedDocumentTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ExchangedDocumentTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplyChainTradeTransactionTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplyChainTradeTransactionType,
        pub(super) state: Box<SupplyChainTradeTransactionTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplyChainTradeTransactionTypeSerializerState<'ser> {
        Init__,
        IncludedSupplyChainTradeLineItem(
            IterSerializer<
                'ser,
                &'ser [super::SupplyChainTradeLineItemType],
                super::SupplyChainTradeLineItemType,
            >,
        ),
        ApplicableHeaderTradeAgreement(
            <super::HeaderTradeAgreementType as WithSerializer>::Serializer<'ser>,
        ),
        ApplicableHeaderTradeDelivery(
            <super::HeaderTradeDeliveryType as WithSerializer>::Serializer<'ser>,
        ),
        ApplicableHeaderTradeSettlement(
            <super::HeaderTradeSettlementType as WithSerializer>::Serializer<'ser>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplyChainTradeTransactionTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { SupplyChainTradeTransactionTypeSerializerState :: Init__ => { * self . state = SupplyChainTradeTransactionTypeSerializerState :: IncludedSupplyChainTradeLineItem (IterSerializer :: new (& self . value . included_supply_chain_trade_line_item [..] , Some ("ram:IncludedSupplyChainTradeLineItem") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } SupplyChainTradeTransactionTypeSerializerState :: IncludedSupplyChainTradeLineItem (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeTransactionTypeSerializerState :: ApplicableHeaderTradeAgreement (WithSerializer :: serializer (& self . value . applicable_header_trade_agreement , Some ("ram:ApplicableHeaderTradeAgreement") , false) ?) , } SupplyChainTradeTransactionTypeSerializerState :: ApplicableHeaderTradeAgreement (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeTransactionTypeSerializerState :: ApplicableHeaderTradeDelivery (WithSerializer :: serializer (& self . value . applicable_header_trade_delivery , Some ("ram:ApplicableHeaderTradeDelivery") , false) ?) , } SupplyChainTradeTransactionTypeSerializerState :: ApplicableHeaderTradeDelivery (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeTransactionTypeSerializerState :: ApplicableHeaderTradeSettlement (WithSerializer :: serializer (& self . value . applicable_header_trade_settlement , Some ("ram:ApplicableHeaderTradeSettlement") , false) ?) , } SupplyChainTradeTransactionTypeSerializerState :: ApplicableHeaderTradeSettlement (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeTransactionTypeSerializerState :: End__ , } SupplyChainTradeTransactionTypeSerializerState :: End__ => { * self . state = SupplyChainTradeTransactionTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } SupplyChainTradeTransactionTypeSerializerState :: Done__ => return Ok (None) , SupplyChainTradeTransactionTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for SupplyChainTradeTransactionTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplyChainTradeTransactionTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct IndicatorTypeSerializer<'ser> {
        pub(super) value: &'ser super::IndicatorType,
        pub(super) state: Box<IndicatorTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum IndicatorTypeSerializerState<'ser> {
        Init__,
        Content__(<super::IndicatorTypeContent as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> IndicatorTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    IndicatorTypeSerializerState::Init__ => {
                        *self.state = IndicatorTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    IndicatorTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = IndicatorTypeSerializerState::End__,
                    },
                    IndicatorTypeSerializerState::End__ => {
                        *self.state = IndicatorTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    IndicatorTypeSerializerState::Done__ => return Ok(None),
                    IndicatorTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for IndicatorTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = IndicatorTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct IndicatorTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::IndicatorTypeContent,
        pub(super) state: Box<IndicatorTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum IndicatorTypeContentSerializerState<'ser> {
        Init__,
        Indicator(<bool as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> IndicatorTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    IndicatorTypeContentSerializerState::Init__ => match self.value {
                        super::IndicatorTypeContent::Indicator(x) => {
                            *self.state = IndicatorTypeContentSerializerState::Indicator(
                                WithSerializer::serializer(x, Some("udt:Indicator"), false)?,
                            )
                        }
                    },
                    IndicatorTypeContentSerializerState::Indicator(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = IndicatorTypeContentSerializerState::Done__,
                        }
                    }
                    IndicatorTypeContentSerializerState::Done__ => return Ok(None),
                    IndicatorTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for IndicatorTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = IndicatorTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentContextParameterTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentContextParameterType,
        pub(super) state: Box<DocumentContextParameterTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentContextParameterTypeSerializerState<'ser> {
        Init__,
        Id(<super::IdType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentContextParameterTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentContextParameterTypeSerializerState::Init__ => {
                        *self.state = DocumentContextParameterTypeSerializerState::Id(
                            WithSerializer::serializer(&self.value.id, Some("ram:ID"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocumentContextParameterTypeSerializerState::Id(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DocumentContextParameterTypeSerializerState::End__,
                    },
                    DocumentContextParameterTypeSerializerState::End__ => {
                        *self.state = DocumentContextParameterTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocumentContextParameterTypeSerializerState::Done__ => return Ok(None),
                    DocumentContextParameterTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentContextParameterTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentContextParameterTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct IdTypeSerializer<'ser> {
        pub(super) value: &'ser super::IdType,
        pub(super) state: Box<IdTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum IdTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> IdTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    IdTypeSerializerState::Init__ => {
                        *self.state = IdTypeSerializerState::Content__(WithSerializer::serializer(
                            &self.value.content,
                            None,
                            false,
                        )?);
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib_opt(&mut bytes, "udt:schemeID", &self.value.scheme_id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    IdTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = IdTypeSerializerState::End__,
                    },
                    IdTypeSerializerState::End__ => {
                        *self.state = IdTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    IdTypeSerializerState::Done__ => return Ok(None),
                    IdTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for IdTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = IdTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TextTypeSerializer<'ser> {
        pub(super) value: &'ser super::TextType,
        pub(super) state: Box<TextTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TextTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TextTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TextTypeSerializerState::Init__ => {
                        *self.state = TextTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TextTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = TextTypeSerializerState::End__,
                    },
                    TextTypeSerializerState::End__ => {
                        *self.state = TextTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TextTypeSerializerState::Done__ => return Ok(None),
                    TextTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TextTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TextTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentCodeType,
        pub(super) state: Box<DocumentCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentCodeTypeSerializerState::Init__ => {
                        *self.state = DocumentCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocumentCodeTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DocumentCodeTypeSerializerState::End__,
                    },
                    DocumentCodeTypeSerializerState::End__ => {
                        *self.state = DocumentCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocumentCodeTypeSerializerState::Done__ => return Ok(None),
                    DocumentCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DateTimeTypeSerializer<'ser> {
        pub(super) value: &'ser super::DateTimeType,
        pub(super) state: Box<DateTimeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DateTimeTypeSerializerState<'ser> {
        Init__,
        Content__(<super::DateTimeTypeContent as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DateTimeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DateTimeTypeSerializerState::Init__ => {
                        *self.state = DateTimeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DateTimeTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DateTimeTypeSerializerState::End__,
                    },
                    DateTimeTypeSerializerState::End__ => {
                        *self.state = DateTimeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DateTimeTypeSerializerState::Done__ => return Ok(None),
                    DateTimeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DateTimeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DateTimeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DateTimeTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::DateTimeTypeContent,
        pub(super) state: Box<DateTimeTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum DateTimeTypeContentSerializerState<'ser> {
        Init__,
        DateTimeString(<super::DateTimeTypeDateTimeStringType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DateTimeTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DateTimeTypeContentSerializerState::Init__ => match self.value {
                        super::DateTimeTypeContent::DateTimeString(x) => {
                            *self.state = DateTimeTypeContentSerializerState::DateTimeString(
                                WithSerializer::serializer(x, Some("udt:DateTimeString"), false)?,
                            )
                        }
                    },
                    DateTimeTypeContentSerializerState::DateTimeString(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DateTimeTypeContentSerializerState::Done__,
                        }
                    }
                    DateTimeTypeContentSerializerState::Done__ => return Ok(None),
                    DateTimeTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DateTimeTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DateTimeTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct NoteTypeSerializer<'ser> {
        pub(super) value: &'ser super::NoteType,
        pub(super) state: Box<NoteTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum NoteTypeSerializerState<'ser> {
        Init__,
        ContentCode(IterSerializer<'ser, Option<&'ser super::CodeType>, super::CodeType>),
        Content(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        SubjectCode(IterSerializer<'ser, Option<&'ser super::CodeType>, super::CodeType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> NoteTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    NoteTypeSerializerState::Init__ => {
                        *self.state = NoteTypeSerializerState::ContentCode(IterSerializer::new(
                            self.value.content_code.as_ref(),
                            Some("ram:ContentCode"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    NoteTypeSerializerState::ContentCode(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = NoteTypeSerializerState::Content(IterSerializer::new(
                                self.value.content.as_ref(),
                                Some("ram:Content"),
                                false,
                            ))
                        }
                    },
                    NoteTypeSerializerState::Content(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = NoteTypeSerializerState::SubjectCode(IterSerializer::new(
                                self.value.subject_code.as_ref(),
                                Some("ram:SubjectCode"),
                                false,
                            ))
                        }
                    },
                    NoteTypeSerializerState::SubjectCode(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = NoteTypeSerializerState::End__,
                    },
                    NoteTypeSerializerState::End__ => {
                        *self.state = NoteTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    NoteTypeSerializerState::Done__ => return Ok(None),
                    NoteTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for NoteTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = NoteTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SpecifiedPeriodTypeSerializer<'ser> {
        pub(super) value: &'ser super::SpecifiedPeriodType,
        pub(super) state: Box<SpecifiedPeriodTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SpecifiedPeriodTypeSerializerState<'ser> {
        Init__,
        Description(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        StartDateTime(IterSerializer<'ser, Option<&'ser super::DateTimeType>, super::DateTimeType>),
        EndDateTime(IterSerializer<'ser, Option<&'ser super::DateTimeType>, super::DateTimeType>),
        CompleteDateTime(
            IterSerializer<'ser, Option<&'ser super::DateTimeType>, super::DateTimeType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SpecifiedPeriodTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SpecifiedPeriodTypeSerializerState::Init__ => {
                        *self.state =
                            SpecifiedPeriodTypeSerializerState::Description(IterSerializer::new(
                                self.value.description.as_ref(),
                                Some("ram:Description"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SpecifiedPeriodTypeSerializerState::Description(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SpecifiedPeriodTypeSerializerState::StartDateTime(
                                    IterSerializer::new(
                                        self.value.start_date_time.as_ref(),
                                        Some("ram:StartDateTime"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SpecifiedPeriodTypeSerializerState::StartDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SpecifiedPeriodTypeSerializerState::EndDateTime(
                                    IterSerializer::new(
                                        self.value.end_date_time.as_ref(),
                                        Some("ram:EndDateTime"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SpecifiedPeriodTypeSerializerState::EndDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SpecifiedPeriodTypeSerializerState::CompleteDateTime(
                                    IterSerializer::new(
                                        self.value.complete_date_time.as_ref(),
                                        Some("ram:CompleteDateTime"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SpecifiedPeriodTypeSerializerState::CompleteDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SpecifiedPeriodTypeSerializerState::End__,
                        }
                    }
                    SpecifiedPeriodTypeSerializerState::End__ => {
                        *self.state = SpecifiedPeriodTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SpecifiedPeriodTypeSerializerState::Done__ => return Ok(None),
                    SpecifiedPeriodTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SpecifiedPeriodTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SpecifiedPeriodTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplyChainTradeLineItemTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplyChainTradeLineItemType,
        pub(super) state: Box<SupplyChainTradeLineItemTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplyChainTradeLineItemTypeSerializerState<'ser> {
        Init__,
        AssociatedDocumentLineDocument(
            <super::DocumentLineDocumentType as WithSerializer>::Serializer<'ser>,
        ),
        SpecifiedTradeProduct(<super::TradeProductType as WithSerializer>::Serializer<'ser>),
        SpecifiedLineTradeAgreement(
            <super::LineTradeAgreementType as WithSerializer>::Serializer<'ser>,
        ),
        SpecifiedLineTradeDelivery(
            <super::LineTradeDeliveryType as WithSerializer>::Serializer<'ser>,
        ),
        SpecifiedLineTradeSettlement(
            <super::LineTradeSettlementType as WithSerializer>::Serializer<'ser>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplyChainTradeLineItemTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { SupplyChainTradeLineItemTypeSerializerState :: Init__ => { * self . state = SupplyChainTradeLineItemTypeSerializerState :: AssociatedDocumentLineDocument (WithSerializer :: serializer (& self . value . associated_document_line_document , Some ("ram:AssociatedDocumentLineDocument") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } SupplyChainTradeLineItemTypeSerializerState :: AssociatedDocumentLineDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeLineItemTypeSerializerState :: SpecifiedTradeProduct (WithSerializer :: serializer (& self . value . specified_trade_product , Some ("ram:SpecifiedTradeProduct") , false) ?) , } SupplyChainTradeLineItemTypeSerializerState :: SpecifiedTradeProduct (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeLineItemTypeSerializerState :: SpecifiedLineTradeAgreement (WithSerializer :: serializer (& self . value . specified_line_trade_agreement , Some ("ram:SpecifiedLineTradeAgreement") , false) ?) , } SupplyChainTradeLineItemTypeSerializerState :: SpecifiedLineTradeAgreement (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeLineItemTypeSerializerState :: SpecifiedLineTradeDelivery (WithSerializer :: serializer (& self . value . specified_line_trade_delivery , Some ("ram:SpecifiedLineTradeDelivery") , false) ?) , } SupplyChainTradeLineItemTypeSerializerState :: SpecifiedLineTradeDelivery (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeLineItemTypeSerializerState :: SpecifiedLineTradeSettlement (WithSerializer :: serializer (& self . value . specified_line_trade_settlement , Some ("ram:SpecifiedLineTradeSettlement") , false) ?) , } SupplyChainTradeLineItemTypeSerializerState :: SpecifiedLineTradeSettlement (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainTradeLineItemTypeSerializerState :: End__ , } SupplyChainTradeLineItemTypeSerializerState :: End__ => { * self . state = SupplyChainTradeLineItemTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } SupplyChainTradeLineItemTypeSerializerState :: Done__ => return Ok (None) , SupplyChainTradeLineItemTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for SupplyChainTradeLineItemTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplyChainTradeLineItemTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct HeaderTradeAgreementTypeSerializer<'ser> {
        pub(super) value: &'ser super::HeaderTradeAgreementType,
        pub(super) state: Box<HeaderTradeAgreementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum HeaderTradeAgreementTypeSerializerState<'ser> {
        Init__,
        BuyerReference(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        SellerTradeParty(<super::TradePartyType as WithSerializer>::Serializer<'ser>),
        BuyerTradeParty(<super::TradePartyType as WithSerializer>::Serializer<'ser>),
        SalesAgentTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        BuyerTaxRepresentativeTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        SellerTaxRepresentativeTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        ProductEndUserTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        ApplicableTradeDeliveryTerms(
            IterSerializer<
                'ser,
                Option<&'ser super::TradeDeliveryTermsType>,
                super::TradeDeliveryTermsType,
            >,
        ),
        SellerOrderReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        BuyerOrderReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        QuotationReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        ContractReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        AdditionalReferencedDocument(
            IterSerializer<
                'ser,
                &'ser [super::ReferencedDocumentType],
                super::ReferencedDocumentType,
            >,
        ),
        BuyerAgentTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        SpecifiedProcuringProject(
            IterSerializer<
                'ser,
                Option<&'ser super::ProcuringProjectType>,
                super::ProcuringProjectType,
            >,
        ),
        UltimateCustomerOrderReferencedDocument(
            IterSerializer<
                'ser,
                &'ser [super::ReferencedDocumentType],
                super::ReferencedDocumentType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> HeaderTradeAgreementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { HeaderTradeAgreementTypeSerializerState :: Init__ => { * self . state = HeaderTradeAgreementTypeSerializerState :: BuyerReference (IterSerializer :: new (self . value . buyer_reference . as_ref () , Some ("ram:BuyerReference") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } HeaderTradeAgreementTypeSerializerState :: BuyerReference (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: SellerTradeParty (WithSerializer :: serializer (& self . value . seller_trade_party , Some ("ram:SellerTradeParty") , false) ?) , } HeaderTradeAgreementTypeSerializerState :: SellerTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: BuyerTradeParty (WithSerializer :: serializer (& self . value . buyer_trade_party , Some ("ram:BuyerTradeParty") , false) ?) , } HeaderTradeAgreementTypeSerializerState :: BuyerTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: SalesAgentTradeParty (IterSerializer :: new (self . value . sales_agent_trade_party . as_ref () , Some ("ram:SalesAgentTradeParty") , false)) , } HeaderTradeAgreementTypeSerializerState :: SalesAgentTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: BuyerTaxRepresentativeTradeParty (IterSerializer :: new (self . value . buyer_tax_representative_trade_party . as_ref () , Some ("ram:BuyerTaxRepresentativeTradeParty") , false)) , } HeaderTradeAgreementTypeSerializerState :: BuyerTaxRepresentativeTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: SellerTaxRepresentativeTradeParty (IterSerializer :: new (self . value . seller_tax_representative_trade_party . as_ref () , Some ("ram:SellerTaxRepresentativeTradeParty") , false)) , } HeaderTradeAgreementTypeSerializerState :: SellerTaxRepresentativeTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: ProductEndUserTradeParty (IterSerializer :: new (self . value . product_end_user_trade_party . as_ref () , Some ("ram:ProductEndUserTradeParty") , false)) , } HeaderTradeAgreementTypeSerializerState :: ProductEndUserTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: ApplicableTradeDeliveryTerms (IterSerializer :: new (self . value . applicable_trade_delivery_terms . as_ref () , Some ("ram:ApplicableTradeDeliveryTerms") , false)) , } HeaderTradeAgreementTypeSerializerState :: ApplicableTradeDeliveryTerms (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: SellerOrderReferencedDocument (IterSerializer :: new (self . value . seller_order_referenced_document . as_ref () , Some ("ram:SellerOrderReferencedDocument") , false)) , } HeaderTradeAgreementTypeSerializerState :: SellerOrderReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: BuyerOrderReferencedDocument (IterSerializer :: new (self . value . buyer_order_referenced_document . as_ref () , Some ("ram:BuyerOrderReferencedDocument") , false)) , } HeaderTradeAgreementTypeSerializerState :: BuyerOrderReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: QuotationReferencedDocument (IterSerializer :: new (self . value . quotation_referenced_document . as_ref () , Some ("ram:QuotationReferencedDocument") , false)) , } HeaderTradeAgreementTypeSerializerState :: QuotationReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: ContractReferencedDocument (IterSerializer :: new (self . value . contract_referenced_document . as_ref () , Some ("ram:ContractReferencedDocument") , false)) , } HeaderTradeAgreementTypeSerializerState :: ContractReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: AdditionalReferencedDocument (IterSerializer :: new (& self . value . additional_referenced_document [..] , Some ("ram:AdditionalReferencedDocument") , false)) , } HeaderTradeAgreementTypeSerializerState :: AdditionalReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: BuyerAgentTradeParty (IterSerializer :: new (self . value . buyer_agent_trade_party . as_ref () , Some ("ram:BuyerAgentTradeParty") , false)) , } HeaderTradeAgreementTypeSerializerState :: BuyerAgentTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: SpecifiedProcuringProject (IterSerializer :: new (self . value . specified_procuring_project . as_ref () , Some ("ram:SpecifiedProcuringProject") , false)) , } HeaderTradeAgreementTypeSerializerState :: SpecifiedProcuringProject (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: UltimateCustomerOrderReferencedDocument (IterSerializer :: new (& self . value . ultimate_customer_order_referenced_document [..] , Some ("ram:UltimateCustomerOrderReferencedDocument") , false)) , } HeaderTradeAgreementTypeSerializerState :: UltimateCustomerOrderReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeAgreementTypeSerializerState :: End__ , } HeaderTradeAgreementTypeSerializerState :: End__ => { * self . state = HeaderTradeAgreementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } HeaderTradeAgreementTypeSerializerState :: Done__ => return Ok (None) , HeaderTradeAgreementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for HeaderTradeAgreementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = HeaderTradeAgreementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct HeaderTradeDeliveryTypeSerializer<'ser> {
        pub(super) value: &'ser super::HeaderTradeDeliveryType,
        pub(super) state: Box<HeaderTradeDeliveryTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum HeaderTradeDeliveryTypeSerializerState<'ser> {
        Init__,
        RelatedSupplyChainConsignment(
            IterSerializer<
                'ser,
                Option<&'ser super::SupplyChainConsignmentType>,
                super::SupplyChainConsignmentType,
            >,
        ),
        ShipToTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        UltimateShipToTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        ShipFromTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        ActualDeliverySupplyChainEvent(
            IterSerializer<
                'ser,
                Option<&'ser super::SupplyChainEventType>,
                super::SupplyChainEventType,
            >,
        ),
        DespatchAdviceReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        ReceivingAdviceReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        DeliveryNoteReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> HeaderTradeDeliveryTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { HeaderTradeDeliveryTypeSerializerState :: Init__ => { * self . state = HeaderTradeDeliveryTypeSerializerState :: RelatedSupplyChainConsignment (IterSerializer :: new (self . value . related_supply_chain_consignment . as_ref () , Some ("ram:RelatedSupplyChainConsignment") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } HeaderTradeDeliveryTypeSerializerState :: RelatedSupplyChainConsignment (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeDeliveryTypeSerializerState :: ShipToTradeParty (IterSerializer :: new (self . value . ship_to_trade_party . as_ref () , Some ("ram:ShipToTradeParty") , false)) , } HeaderTradeDeliveryTypeSerializerState :: ShipToTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeDeliveryTypeSerializerState :: UltimateShipToTradeParty (IterSerializer :: new (self . value . ultimate_ship_to_trade_party . as_ref () , Some ("ram:UltimateShipToTradeParty") , false)) , } HeaderTradeDeliveryTypeSerializerState :: UltimateShipToTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeDeliveryTypeSerializerState :: ShipFromTradeParty (IterSerializer :: new (self . value . ship_from_trade_party . as_ref () , Some ("ram:ShipFromTradeParty") , false)) , } HeaderTradeDeliveryTypeSerializerState :: ShipFromTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeDeliveryTypeSerializerState :: ActualDeliverySupplyChainEvent (IterSerializer :: new (self . value . actual_delivery_supply_chain_event . as_ref () , Some ("ram:ActualDeliverySupplyChainEvent") , false)) , } HeaderTradeDeliveryTypeSerializerState :: ActualDeliverySupplyChainEvent (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeDeliveryTypeSerializerState :: DespatchAdviceReferencedDocument (IterSerializer :: new (self . value . despatch_advice_referenced_document . as_ref () , Some ("ram:DespatchAdviceReferencedDocument") , false)) , } HeaderTradeDeliveryTypeSerializerState :: DespatchAdviceReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeDeliveryTypeSerializerState :: ReceivingAdviceReferencedDocument (IterSerializer :: new (self . value . receiving_advice_referenced_document . as_ref () , Some ("ram:ReceivingAdviceReferencedDocument") , false)) , } HeaderTradeDeliveryTypeSerializerState :: ReceivingAdviceReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeDeliveryTypeSerializerState :: DeliveryNoteReferencedDocument (IterSerializer :: new (self . value . delivery_note_referenced_document . as_ref () , Some ("ram:DeliveryNoteReferencedDocument") , false)) , } HeaderTradeDeliveryTypeSerializerState :: DeliveryNoteReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeDeliveryTypeSerializerState :: End__ , } HeaderTradeDeliveryTypeSerializerState :: End__ => { * self . state = HeaderTradeDeliveryTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } HeaderTradeDeliveryTypeSerializerState :: Done__ => return Ok (None) , HeaderTradeDeliveryTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for HeaderTradeDeliveryTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = HeaderTradeDeliveryTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct HeaderTradeSettlementTypeSerializer<'ser> {
        pub(super) value: &'ser super::HeaderTradeSettlementType,
        pub(super) state: Box<HeaderTradeSettlementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum HeaderTradeSettlementTypeSerializerState<'ser> {
        Init__,
        CreditorReferenceId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        PaymentReference(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        TaxCurrencyCode(
            IterSerializer<'ser, Option<&'ser super::CurrencyCodeType>, super::CurrencyCodeType>,
        ),
        InvoiceCurrencyCode(<super::CurrencyCodeType as WithSerializer>::Serializer<'ser>),
        InvoiceIssuerReference(
            IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>,
        ),
        InvoicerTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        InvoiceeTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        PayeeTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        PayerTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        TaxApplicableTradeCurrencyExchange(
            IterSerializer<
                'ser,
                Option<&'ser super::TradeCurrencyExchangeType>,
                super::TradeCurrencyExchangeType,
            >,
        ),
        SpecifiedTradeSettlementPaymentMeans(
            IterSerializer<
                'ser,
                &'ser [super::TradeSettlementPaymentMeansType],
                super::TradeSettlementPaymentMeansType,
            >,
        ),
        ApplicableTradeTax(IterSerializer<'ser, &'ser [super::TradeTaxType], super::TradeTaxType>),
        BillingSpecifiedPeriod(
            IterSerializer<
                'ser,
                Option<&'ser super::SpecifiedPeriodType>,
                super::SpecifiedPeriodType,
            >,
        ),
        SpecifiedTradeAllowanceCharge(
            IterSerializer<
                'ser,
                &'ser [super::TradeAllowanceChargeType],
                super::TradeAllowanceChargeType,
            >,
        ),
        SpecifiedLogisticsServiceCharge(
            IterSerializer<
                'ser,
                &'ser [super::LogisticsServiceChargeType],
                super::LogisticsServiceChargeType,
            >,
        ),
        SpecifiedTradePaymentTerms(
            IterSerializer<
                'ser,
                &'ser [super::TradePaymentTermsType],
                super::TradePaymentTermsType,
            >,
        ),
        SpecifiedTradeSettlementHeaderMonetarySummation(
            <super::TradeSettlementHeaderMonetarySummationType as WithSerializer>::Serializer<'ser>,
        ),
        InvoiceReferencedDocument(
            IterSerializer<
                'ser,
                &'ser [super::ReferencedDocumentType],
                super::ReferencedDocumentType,
            >,
        ),
        ReceivableSpecifiedTradeAccountingAccount(
            IterSerializer<
                'ser,
                &'ser [super::TradeAccountingAccountType],
                super::TradeAccountingAccountType,
            >,
        ),
        SpecifiedAdvancePayment(
            IterSerializer<'ser, &'ser [super::AdvancePaymentType], super::AdvancePaymentType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> HeaderTradeSettlementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { HeaderTradeSettlementTypeSerializerState :: Init__ => { * self . state = HeaderTradeSettlementTypeSerializerState :: CreditorReferenceId (IterSerializer :: new (self . value . creditor_reference_id . as_ref () , Some ("ram:CreditorReferenceID") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } HeaderTradeSettlementTypeSerializerState :: CreditorReferenceId (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: PaymentReference (IterSerializer :: new (self . value . payment_reference . as_ref () , Some ("ram:PaymentReference") , false)) , } HeaderTradeSettlementTypeSerializerState :: PaymentReference (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: TaxCurrencyCode (IterSerializer :: new (self . value . tax_currency_code . as_ref () , Some ("ram:TaxCurrencyCode") , false)) , } HeaderTradeSettlementTypeSerializerState :: TaxCurrencyCode (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: InvoiceCurrencyCode (WithSerializer :: serializer (& self . value . invoice_currency_code , Some ("ram:InvoiceCurrencyCode") , false) ?) , } HeaderTradeSettlementTypeSerializerState :: InvoiceCurrencyCode (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: InvoiceIssuerReference (IterSerializer :: new (self . value . invoice_issuer_reference . as_ref () , Some ("ram:InvoiceIssuerReference") , false)) , } HeaderTradeSettlementTypeSerializerState :: InvoiceIssuerReference (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: InvoicerTradeParty (IterSerializer :: new (self . value . invoicer_trade_party . as_ref () , Some ("ram:InvoicerTradeParty") , false)) , } HeaderTradeSettlementTypeSerializerState :: InvoicerTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: InvoiceeTradeParty (IterSerializer :: new (self . value . invoicee_trade_party . as_ref () , Some ("ram:InvoiceeTradeParty") , false)) , } HeaderTradeSettlementTypeSerializerState :: InvoiceeTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: PayeeTradeParty (IterSerializer :: new (self . value . payee_trade_party . as_ref () , Some ("ram:PayeeTradeParty") , false)) , } HeaderTradeSettlementTypeSerializerState :: PayeeTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: PayerTradeParty (IterSerializer :: new (self . value . payer_trade_party . as_ref () , Some ("ram:PayerTradeParty") , false)) , } HeaderTradeSettlementTypeSerializerState :: PayerTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: TaxApplicableTradeCurrencyExchange (IterSerializer :: new (self . value . tax_applicable_trade_currency_exchange . as_ref () , Some ("ram:TaxApplicableTradeCurrencyExchange") , false)) , } HeaderTradeSettlementTypeSerializerState :: TaxApplicableTradeCurrencyExchange (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: SpecifiedTradeSettlementPaymentMeans (IterSerializer :: new (& self . value . specified_trade_settlement_payment_means [..] , Some ("ram:SpecifiedTradeSettlementPaymentMeans") , false)) , } HeaderTradeSettlementTypeSerializerState :: SpecifiedTradeSettlementPaymentMeans (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: ApplicableTradeTax (IterSerializer :: new (& self . value . applicable_trade_tax [..] , Some ("ram:ApplicableTradeTax") , false)) , } HeaderTradeSettlementTypeSerializerState :: ApplicableTradeTax (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: BillingSpecifiedPeriod (IterSerializer :: new (self . value . billing_specified_period . as_ref () , Some ("ram:BillingSpecifiedPeriod") , false)) , } HeaderTradeSettlementTypeSerializerState :: BillingSpecifiedPeriod (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: SpecifiedTradeAllowanceCharge (IterSerializer :: new (& self . value . specified_trade_allowance_charge [..] , Some ("ram:SpecifiedTradeAllowanceCharge") , false)) , } HeaderTradeSettlementTypeSerializerState :: SpecifiedTradeAllowanceCharge (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: SpecifiedLogisticsServiceCharge (IterSerializer :: new (& self . value . specified_logistics_service_charge [..] , Some ("ram:SpecifiedLogisticsServiceCharge") , false)) , } HeaderTradeSettlementTypeSerializerState :: SpecifiedLogisticsServiceCharge (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: SpecifiedTradePaymentTerms (IterSerializer :: new (& self . value . specified_trade_payment_terms [..] , Some ("ram:SpecifiedTradePaymentTerms") , false)) , } HeaderTradeSettlementTypeSerializerState :: SpecifiedTradePaymentTerms (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: SpecifiedTradeSettlementHeaderMonetarySummation (WithSerializer :: serializer (& self . value . specified_trade_settlement_header_monetary_summation , Some ("ram:SpecifiedTradeSettlementHeaderMonetarySummation") , false) ?) , } HeaderTradeSettlementTypeSerializerState :: SpecifiedTradeSettlementHeaderMonetarySummation (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: InvoiceReferencedDocument (IterSerializer :: new (& self . value . invoice_referenced_document [..] , Some ("ram:InvoiceReferencedDocument") , false)) , } HeaderTradeSettlementTypeSerializerState :: InvoiceReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: ReceivableSpecifiedTradeAccountingAccount (IterSerializer :: new (& self . value . receivable_specified_trade_accounting_account [..] , Some ("ram:ReceivableSpecifiedTradeAccountingAccount") , false)) , } HeaderTradeSettlementTypeSerializerState :: ReceivableSpecifiedTradeAccountingAccount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: SpecifiedAdvancePayment (IterSerializer :: new (& self . value . specified_advance_payment [..] , Some ("ram:SpecifiedAdvancePayment") , false)) , } HeaderTradeSettlementTypeSerializerState :: SpecifiedAdvancePayment (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = HeaderTradeSettlementTypeSerializerState :: End__ , } HeaderTradeSettlementTypeSerializerState :: End__ => { * self . state = HeaderTradeSettlementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } HeaderTradeSettlementTypeSerializerState :: Done__ => return Ok (None) , HeaderTradeSettlementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for HeaderTradeSettlementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = HeaderTradeSettlementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DateTimeTypeDateTimeStringTypeSerializer<'ser> {
        pub(super) value: &'ser super::DateTimeTypeDateTimeStringType,
        pub(super) state: Box<DateTimeTypeDateTimeStringTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DateTimeTypeDateTimeStringTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DateTimeTypeDateTimeStringTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DateTimeTypeDateTimeStringTypeSerializerState::Init__ => {
                        *self.state = DateTimeTypeDateTimeStringTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib(&mut bytes, "udt:format", &self.value.format)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DateTimeTypeDateTimeStringTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DateTimeTypeDateTimeStringTypeSerializerState::End__,
                    },
                    DateTimeTypeDateTimeStringTypeSerializerState::End__ => {
                        *self.state = DateTimeTypeDateTimeStringTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DateTimeTypeDateTimeStringTypeSerializerState::Done__ => return Ok(None),
                    DateTimeTypeDateTimeStringTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DateTimeTypeDateTimeStringTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DateTimeTypeDateTimeStringTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::CodeType,
        pub(super) state: Box<CodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CodeTypeSerializerState::Init__ => {
                        *self.state = CodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib_opt(&mut bytes, "udt:listID", &self.value.list_id)?;
                        write_attrib_opt(
                            &mut bytes,
                            "udt:listVersionID",
                            &self.value.list_version_id,
                        )?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CodeTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CodeTypeSerializerState::End__,
                    },
                    CodeTypeSerializerState::End__ => {
                        *self.state = CodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CodeTypeSerializerState::Done__ => return Ok(None),
                    CodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentLineDocumentTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentLineDocumentType,
        pub(super) state: Box<DocumentLineDocumentTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentLineDocumentTypeSerializerState<'ser> {
        Init__,
        LineId(<super::IdType as WithSerializer>::Serializer<'ser>),
        ParentLineId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        LineStatusCode(
            IterSerializer<
                'ser,
                Option<&'ser super::LineStatusCodeType>,
                super::LineStatusCodeType,
            >,
        ),
        LineStatusReasonCode(IterSerializer<'ser, Option<&'ser super::CodeType>, super::CodeType>),
        IncludedNote(IterSerializer<'ser, &'ser [super::NoteType], super::NoteType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentLineDocumentTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentLineDocumentTypeSerializerState::Init__ => {
                        *self.state = DocumentLineDocumentTypeSerializerState::LineId(
                            WithSerializer::serializer(
                                &self.value.line_id,
                                Some("ram:LineID"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocumentLineDocumentTypeSerializerState::LineId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentLineDocumentTypeSerializerState::ParentLineId(
                                    IterSerializer::new(
                                        self.value.parent_line_id.as_ref(),
                                        Some("ram:ParentLineID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentLineDocumentTypeSerializerState::ParentLineId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    DocumentLineDocumentTypeSerializerState::LineStatusCode(
                                        IterSerializer::new(
                                            self.value.line_status_code.as_ref(),
                                            Some("ram:LineStatusCode"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    DocumentLineDocumentTypeSerializerState::LineStatusCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    DocumentLineDocumentTypeSerializerState::LineStatusReasonCode(
                                        IterSerializer::new(
                                            self.value.line_status_reason_code.as_ref(),
                                            Some("ram:LineStatusReasonCode"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    DocumentLineDocumentTypeSerializerState::LineStatusReasonCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentLineDocumentTypeSerializerState::IncludedNote(
                                    IterSerializer::new(
                                        &self.value.included_note[..],
                                        Some("ram:IncludedNote"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentLineDocumentTypeSerializerState::IncludedNote(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DocumentLineDocumentTypeSerializerState::End__,
                        }
                    }
                    DocumentLineDocumentTypeSerializerState::End__ => {
                        *self.state = DocumentLineDocumentTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocumentLineDocumentTypeSerializerState::Done__ => return Ok(None),
                    DocumentLineDocumentTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentLineDocumentTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentLineDocumentTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeProductTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeProductType,
        pub(super) state: Box<TradeProductTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeProductTypeSerializerState<'ser> {
        Init__,
        Id(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        GlobalId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        SellerAssignedId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        BuyerAssignedId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        IndustryAssignedId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        ModelId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        Name(<super::TextType as WithSerializer>::Serializer<'ser>),
        Description(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        BatchId(IterSerializer<'ser, &'ser [super::IdType], super::IdType>),
        BrandName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        ModelName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        ApplicableProductCharacteristic(
            IterSerializer<
                'ser,
                &'ser [super::ProductCharacteristicType],
                super::ProductCharacteristicType,
            >,
        ),
        DesignatedProductClassification(
            IterSerializer<
                'ser,
                &'ser [super::ProductClassificationType],
                super::ProductClassificationType,
            >,
        ),
        IndividualTradeProductInstance(
            IterSerializer<
                'ser,
                &'ser [super::TradeProductInstanceType],
                super::TradeProductInstanceType,
            >,
        ),
        OriginTradeCountry(
            IterSerializer<'ser, Option<&'ser super::TradeCountryType>, super::TradeCountryType>,
        ),
        IncludedReferencedProduct(
            IterSerializer<
                'ser,
                &'ser [super::ReferencedProductType],
                super::ReferencedProductType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeProductTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeProductTypeSerializerState::Init__ => {
                        *self.state = TradeProductTypeSerializerState::Id(IterSerializer::new(
                            self.value.id.as_ref(),
                            Some("ram:ID"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeProductTypeSerializerState::Id(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeProductTypeSerializerState::GlobalId(IterSerializer::new(
                                    self.value.global_id.as_ref(),
                                    Some("ram:GlobalID"),
                                    false,
                                ))
                        }
                    },
                    TradeProductTypeSerializerState::GlobalId(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = TradeProductTypeSerializerState::SellerAssignedId(
                                IterSerializer::new(
                                    self.value.seller_assigned_id.as_ref(),
                                    Some("ram:SellerAssignedID"),
                                    false,
                                ),
                            )
                        }
                    },
                    TradeProductTypeSerializerState::SellerAssignedId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeProductTypeSerializerState::BuyerAssignedId(
                                    IterSerializer::new(
                                        self.value.buyer_assigned_id.as_ref(),
                                        Some("ram:BuyerAssignedID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeProductTypeSerializerState::BuyerAssignedId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeProductTypeSerializerState::IndustryAssignedId(
                                    IterSerializer::new(
                                        self.value.industry_assigned_id.as_ref(),
                                        Some("ram:IndustryAssignedID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeProductTypeSerializerState::IndustryAssignedId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeProductTypeSerializerState::ModelId(IterSerializer::new(
                                        self.value.model_id.as_ref(),
                                        Some("ram:ModelID"),
                                        false,
                                    ))
                            }
                        }
                    }
                    TradeProductTypeSerializerState::ModelId(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeProductTypeSerializerState::Name(WithSerializer::serializer(
                                    &self.value.name,
                                    Some("ram:Name"),
                                    false,
                                )?)
                        }
                    },
                    TradeProductTypeSerializerState::Name(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeProductTypeSerializerState::Description(IterSerializer::new(
                                    self.value.description.as_ref(),
                                    Some("ram:Description"),
                                    false,
                                ))
                        }
                    },
                    TradeProductTypeSerializerState::Description(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeProductTypeSerializerState::BatchId(IterSerializer::new(
                                        &self.value.batch_id[..],
                                        Some("ram:BatchID"),
                                        false,
                                    ))
                            }
                        }
                    }
                    TradeProductTypeSerializerState::BatchId(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeProductTypeSerializerState::BrandName(IterSerializer::new(
                                    self.value.brand_name.as_ref(),
                                    Some("ram:BrandName"),
                                    false,
                                ))
                        }
                    },
                    TradeProductTypeSerializerState::BrandName(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeProductTypeSerializerState::ModelName(IterSerializer::new(
                                    self.value.model_name.as_ref(),
                                    Some("ram:ModelName"),
                                    false,
                                ))
                        }
                    },
                    TradeProductTypeSerializerState::ModelName(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeProductTypeSerializerState::ApplicableProductCharacteristic(
                                    IterSerializer::new(
                                        &self.value.applicable_product_characteristic[..],
                                        Some("ram:ApplicableProductCharacteristic"),
                                        false,
                                    ),
                                )
                        }
                    },
                    TradeProductTypeSerializerState::ApplicableProductCharacteristic(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeProductTypeSerializerState::DesignatedProductClassification(
                                        IterSerializer::new(
                                            &self.value.designated_product_classification[..],
                                            Some("ram:DesignatedProductClassification"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeProductTypeSerializerState::DesignatedProductClassification(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeProductTypeSerializerState::IndividualTradeProductInstance(
                                        IterSerializer::new(
                                            &self.value.individual_trade_product_instance[..],
                                            Some("ram:IndividualTradeProductInstance"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeProductTypeSerializerState::IndividualTradeProductInstance(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeProductTypeSerializerState::OriginTradeCountry(
                                    IterSerializer::new(
                                        self.value.origin_trade_country.as_ref(),
                                        Some("ram:OriginTradeCountry"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeProductTypeSerializerState::OriginTradeCountry(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeProductTypeSerializerState::IncludedReferencedProduct(
                                        IterSerializer::new(
                                            &self.value.included_referenced_product[..],
                                            Some("ram:IncludedReferencedProduct"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeProductTypeSerializerState::IncludedReferencedProduct(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeProductTypeSerializerState::End__,
                        }
                    }
                    TradeProductTypeSerializerState::End__ => {
                        *self.state = TradeProductTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeProductTypeSerializerState::Done__ => return Ok(None),
                    TradeProductTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeProductTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeProductTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LineTradeAgreementTypeSerializer<'ser> {
        pub(super) value: &'ser super::LineTradeAgreementType,
        pub(super) state: Box<LineTradeAgreementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LineTradeAgreementTypeSerializerState<'ser> {
        Init__,
        SellerOrderReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        BuyerOrderReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        QuotationReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        ContractReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        AdditionalReferencedDocument(
            IterSerializer<
                'ser,
                &'ser [super::ReferencedDocumentType],
                super::ReferencedDocumentType,
            >,
        ),
        GrossPriceProductTradePrice(
            IterSerializer<'ser, Option<&'ser super::TradePriceType>, super::TradePriceType>,
        ),
        NetPriceProductTradePrice(<super::TradePriceType as WithSerializer>::Serializer<'ser>),
        UltimateCustomerOrderReferencedDocument(
            IterSerializer<
                'ser,
                &'ser [super::ReferencedDocumentType],
                super::ReferencedDocumentType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LineTradeAgreementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { LineTradeAgreementTypeSerializerState :: Init__ => { * self . state = LineTradeAgreementTypeSerializerState :: SellerOrderReferencedDocument (IterSerializer :: new (self . value . seller_order_referenced_document . as_ref () , Some ("ram:SellerOrderReferencedDocument") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } LineTradeAgreementTypeSerializerState :: SellerOrderReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeAgreementTypeSerializerState :: BuyerOrderReferencedDocument (IterSerializer :: new (self . value . buyer_order_referenced_document . as_ref () , Some ("ram:BuyerOrderReferencedDocument") , false)) , } LineTradeAgreementTypeSerializerState :: BuyerOrderReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeAgreementTypeSerializerState :: QuotationReferencedDocument (IterSerializer :: new (self . value . quotation_referenced_document . as_ref () , Some ("ram:QuotationReferencedDocument") , false)) , } LineTradeAgreementTypeSerializerState :: QuotationReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeAgreementTypeSerializerState :: ContractReferencedDocument (IterSerializer :: new (self . value . contract_referenced_document . as_ref () , Some ("ram:ContractReferencedDocument") , false)) , } LineTradeAgreementTypeSerializerState :: ContractReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeAgreementTypeSerializerState :: AdditionalReferencedDocument (IterSerializer :: new (& self . value . additional_referenced_document [..] , Some ("ram:AdditionalReferencedDocument") , false)) , } LineTradeAgreementTypeSerializerState :: AdditionalReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeAgreementTypeSerializerState :: GrossPriceProductTradePrice (IterSerializer :: new (self . value . gross_price_product_trade_price . as_ref () , Some ("ram:GrossPriceProductTradePrice") , false)) , } LineTradeAgreementTypeSerializerState :: GrossPriceProductTradePrice (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeAgreementTypeSerializerState :: NetPriceProductTradePrice (WithSerializer :: serializer (& self . value . net_price_product_trade_price , Some ("ram:NetPriceProductTradePrice") , false) ?) , } LineTradeAgreementTypeSerializerState :: NetPriceProductTradePrice (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeAgreementTypeSerializerState :: UltimateCustomerOrderReferencedDocument (IterSerializer :: new (& self . value . ultimate_customer_order_referenced_document [..] , Some ("ram:UltimateCustomerOrderReferencedDocument") , false)) , } LineTradeAgreementTypeSerializerState :: UltimateCustomerOrderReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeAgreementTypeSerializerState :: End__ , } LineTradeAgreementTypeSerializerState :: End__ => { * self . state = LineTradeAgreementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } LineTradeAgreementTypeSerializerState :: Done__ => return Ok (None) , LineTradeAgreementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for LineTradeAgreementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LineTradeAgreementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LineTradeDeliveryTypeSerializer<'ser> {
        pub(super) value: &'ser super::LineTradeDeliveryType,
        pub(super) state: Box<LineTradeDeliveryTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LineTradeDeliveryTypeSerializerState<'ser> {
        Init__,
        BilledQuantity(<super::QuantityType as WithSerializer>::Serializer<'ser>),
        ChargeFreeQuantity(
            IterSerializer<'ser, Option<&'ser super::QuantityType>, super::QuantityType>,
        ),
        PackageQuantity(
            IterSerializer<'ser, Option<&'ser super::QuantityType>, super::QuantityType>,
        ),
        ShipToTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        UltimateShipToTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        ActualDeliverySupplyChainEvent(
            IterSerializer<
                'ser,
                Option<&'ser super::SupplyChainEventType>,
                super::SupplyChainEventType,
            >,
        ),
        DespatchAdviceReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        ReceivingAdviceReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        DeliveryNoteReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LineTradeDeliveryTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { LineTradeDeliveryTypeSerializerState :: Init__ => { * self . state = LineTradeDeliveryTypeSerializerState :: BilledQuantity (WithSerializer :: serializer (& self . value . billed_quantity , Some ("ram:BilledQuantity") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } LineTradeDeliveryTypeSerializerState :: BilledQuantity (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: ChargeFreeQuantity (IterSerializer :: new (self . value . charge_free_quantity . as_ref () , Some ("ram:ChargeFreeQuantity") , false)) , } LineTradeDeliveryTypeSerializerState :: ChargeFreeQuantity (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: PackageQuantity (IterSerializer :: new (self . value . package_quantity . as_ref () , Some ("ram:PackageQuantity") , false)) , } LineTradeDeliveryTypeSerializerState :: PackageQuantity (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: ShipToTradeParty (IterSerializer :: new (self . value . ship_to_trade_party . as_ref () , Some ("ram:ShipToTradeParty") , false)) , } LineTradeDeliveryTypeSerializerState :: ShipToTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: UltimateShipToTradeParty (IterSerializer :: new (self . value . ultimate_ship_to_trade_party . as_ref () , Some ("ram:UltimateShipToTradeParty") , false)) , } LineTradeDeliveryTypeSerializerState :: UltimateShipToTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: ActualDeliverySupplyChainEvent (IterSerializer :: new (self . value . actual_delivery_supply_chain_event . as_ref () , Some ("ram:ActualDeliverySupplyChainEvent") , false)) , } LineTradeDeliveryTypeSerializerState :: ActualDeliverySupplyChainEvent (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: DespatchAdviceReferencedDocument (IterSerializer :: new (self . value . despatch_advice_referenced_document . as_ref () , Some ("ram:DespatchAdviceReferencedDocument") , false)) , } LineTradeDeliveryTypeSerializerState :: DespatchAdviceReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: ReceivingAdviceReferencedDocument (IterSerializer :: new (self . value . receiving_advice_referenced_document . as_ref () , Some ("ram:ReceivingAdviceReferencedDocument") , false)) , } LineTradeDeliveryTypeSerializerState :: ReceivingAdviceReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: DeliveryNoteReferencedDocument (IterSerializer :: new (self . value . delivery_note_referenced_document . as_ref () , Some ("ram:DeliveryNoteReferencedDocument") , false)) , } LineTradeDeliveryTypeSerializerState :: DeliveryNoteReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeDeliveryTypeSerializerState :: End__ , } LineTradeDeliveryTypeSerializerState :: End__ => { * self . state = LineTradeDeliveryTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } LineTradeDeliveryTypeSerializerState :: Done__ => return Ok (None) , LineTradeDeliveryTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for LineTradeDeliveryTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LineTradeDeliveryTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LineTradeSettlementTypeSerializer<'ser> {
        pub(super) value: &'ser super::LineTradeSettlementType,
        pub(super) state: Box<LineTradeSettlementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LineTradeSettlementTypeSerializerState<'ser> {
        Init__,
        ApplicableTradeTax(IterSerializer<'ser, &'ser [super::TradeTaxType], super::TradeTaxType>),
        BillingSpecifiedPeriod(
            IterSerializer<
                'ser,
                Option<&'ser super::SpecifiedPeriodType>,
                super::SpecifiedPeriodType,
            >,
        ),
        SpecifiedTradeAllowanceCharge(
            IterSerializer<
                'ser,
                &'ser [super::TradeAllowanceChargeType],
                super::TradeAllowanceChargeType,
            >,
        ),
        SpecifiedTradeSettlementLineMonetarySummation(
            <super::TradeSettlementLineMonetarySummationType as WithSerializer>::Serializer<'ser>,
        ),
        InvoiceReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        AdditionalReferencedDocument(
            IterSerializer<
                'ser,
                &'ser [super::ReferencedDocumentType],
                super::ReferencedDocumentType,
            >,
        ),
        ReceivableSpecifiedTradeAccountingAccount(
            IterSerializer<
                'ser,
                Option<&'ser super::TradeAccountingAccountType>,
                super::TradeAccountingAccountType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LineTradeSettlementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { LineTradeSettlementTypeSerializerState :: Init__ => { * self . state = LineTradeSettlementTypeSerializerState :: ApplicableTradeTax (IterSerializer :: new (& self . value . applicable_trade_tax [..] , Some ("ram:ApplicableTradeTax") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } LineTradeSettlementTypeSerializerState :: ApplicableTradeTax (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeSettlementTypeSerializerState :: BillingSpecifiedPeriod (IterSerializer :: new (self . value . billing_specified_period . as_ref () , Some ("ram:BillingSpecifiedPeriod") , false)) , } LineTradeSettlementTypeSerializerState :: BillingSpecifiedPeriod (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeSettlementTypeSerializerState :: SpecifiedTradeAllowanceCharge (IterSerializer :: new (& self . value . specified_trade_allowance_charge [..] , Some ("ram:SpecifiedTradeAllowanceCharge") , false)) , } LineTradeSettlementTypeSerializerState :: SpecifiedTradeAllowanceCharge (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeSettlementTypeSerializerState :: SpecifiedTradeSettlementLineMonetarySummation (WithSerializer :: serializer (& self . value . specified_trade_settlement_line_monetary_summation , Some ("ram:SpecifiedTradeSettlementLineMonetarySummation") , false) ?) , } LineTradeSettlementTypeSerializerState :: SpecifiedTradeSettlementLineMonetarySummation (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeSettlementTypeSerializerState :: InvoiceReferencedDocument (IterSerializer :: new (self . value . invoice_referenced_document . as_ref () , Some ("ram:InvoiceReferencedDocument") , false)) , } LineTradeSettlementTypeSerializerState :: InvoiceReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeSettlementTypeSerializerState :: AdditionalReferencedDocument (IterSerializer :: new (& self . value . additional_referenced_document [..] , Some ("ram:AdditionalReferencedDocument") , false)) , } LineTradeSettlementTypeSerializerState :: AdditionalReferencedDocument (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeSettlementTypeSerializerState :: ReceivableSpecifiedTradeAccountingAccount (IterSerializer :: new (self . value . receivable_specified_trade_accounting_account . as_ref () , Some ("ram:ReceivableSpecifiedTradeAccountingAccount") , false)) , } LineTradeSettlementTypeSerializerState :: ReceivableSpecifiedTradeAccountingAccount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = LineTradeSettlementTypeSerializerState :: End__ , } LineTradeSettlementTypeSerializerState :: End__ => { * self . state = LineTradeSettlementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } LineTradeSettlementTypeSerializerState :: Done__ => return Ok (None) , LineTradeSettlementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for LineTradeSettlementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LineTradeSettlementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradePartyTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradePartyType,
        pub(super) state: Box<TradePartyTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradePartyTypeSerializerState<'ser> {
        Init__,
        Id(IterSerializer<'ser, &'ser [super::IdType], super::IdType>),
        GlobalId(IterSerializer<'ser, &'ser [super::IdType], super::IdType>),
        Name(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        RoleCode(
            IterSerializer<'ser, Option<&'ser super::PartyRoleCodeType>, super::PartyRoleCodeType>,
        ),
        Description(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        SpecifiedLegalOrganization(
            IterSerializer<
                'ser,
                Option<&'ser super::LegalOrganizationType>,
                super::LegalOrganizationType,
            >,
        ),
        DefinedTradeContact(
            IterSerializer<'ser, &'ser [super::TradeContactType], super::TradeContactType>,
        ),
        PostalTradeAddress(
            IterSerializer<'ser, Option<&'ser super::TradeAddressType>, super::TradeAddressType>,
        ),
        UriUniversalCommunication(
            IterSerializer<
                'ser,
                Option<&'ser super::UniversalCommunicationType>,
                super::UniversalCommunicationType,
            >,
        ),
        SpecifiedTaxRegistration(
            IterSerializer<'ser, &'ser [super::TaxRegistrationType], super::TaxRegistrationType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradePartyTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradePartyTypeSerializerState::Init__ => {
                        *self.state = TradePartyTypeSerializerState::Id(IterSerializer::new(
                            &self.value.id[..],
                            Some("ram:ID"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradePartyTypeSerializerState::Id(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradePartyTypeSerializerState::GlobalId(IterSerializer::new(
                                    &self.value.global_id[..],
                                    Some("ram:GlobalID"),
                                    false,
                                ))
                        }
                    },
                    TradePartyTypeSerializerState::GlobalId(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = TradePartyTypeSerializerState::Name(IterSerializer::new(
                                self.value.name.as_ref(),
                                Some("ram:Name"),
                                false,
                            ))
                        }
                    },
                    TradePartyTypeSerializerState::Name(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradePartyTypeSerializerState::RoleCode(IterSerializer::new(
                                    self.value.role_code.as_ref(),
                                    Some("ram:RoleCode"),
                                    false,
                                ))
                        }
                    },
                    TradePartyTypeSerializerState::RoleCode(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradePartyTypeSerializerState::Description(IterSerializer::new(
                                    self.value.description.as_ref(),
                                    Some("ram:Description"),
                                    false,
                                ))
                        }
                    },
                    TradePartyTypeSerializerState::Description(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = TradePartyTypeSerializerState::SpecifiedLegalOrganization(
                                IterSerializer::new(
                                    self.value.specified_legal_organization.as_ref(),
                                    Some("ram:SpecifiedLegalOrganization"),
                                    false,
                                ),
                            )
                        }
                    },
                    TradePartyTypeSerializerState::SpecifiedLegalOrganization(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradePartyTypeSerializerState::DefinedTradeContact(
                                    IterSerializer::new(
                                        &self.value.defined_trade_contact[..],
                                        Some("ram:DefinedTradeContact"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradePartyTypeSerializerState::DefinedTradeContact(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradePartyTypeSerializerState::PostalTradeAddress(
                                    IterSerializer::new(
                                        self.value.postal_trade_address.as_ref(),
                                        Some("ram:PostalTradeAddress"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradePartyTypeSerializerState::PostalTradeAddress(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePartyTypeSerializerState::UriUniversalCommunication(
                                        IterSerializer::new(
                                            self.value.uri_universal_communication.as_ref(),
                                            Some("ram:URIUniversalCommunication"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePartyTypeSerializerState::UriUniversalCommunication(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePartyTypeSerializerState::SpecifiedTaxRegistration(
                                        IterSerializer::new(
                                            &self.value.specified_tax_registration[..],
                                            Some("ram:SpecifiedTaxRegistration"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePartyTypeSerializerState::SpecifiedTaxRegistration(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradePartyTypeSerializerState::End__,
                        }
                    }
                    TradePartyTypeSerializerState::End__ => {
                        *self.state = TradePartyTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradePartyTypeSerializerState::Done__ => return Ok(None),
                    TradePartyTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradePartyTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradePartyTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeDeliveryTermsTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeDeliveryTermsType,
        pub(super) state: Box<TradeDeliveryTermsTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeDeliveryTermsTypeSerializerState<'ser> {
        Init__,
        DeliveryTypeCode(<super::DeliveryTermsCodeType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeDeliveryTermsTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeDeliveryTermsTypeSerializerState::Init__ => {
                        *self.state = TradeDeliveryTermsTypeSerializerState::DeliveryTypeCode(
                            WithSerializer::serializer(
                                &self.value.delivery_type_code,
                                Some("ram:DeliveryTypeCode"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeDeliveryTermsTypeSerializerState::DeliveryTypeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeDeliveryTermsTypeSerializerState::End__,
                        }
                    }
                    TradeDeliveryTermsTypeSerializerState::End__ => {
                        *self.state = TradeDeliveryTermsTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeDeliveryTermsTypeSerializerState::Done__ => return Ok(None),
                    TradeDeliveryTermsTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeDeliveryTermsTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeDeliveryTermsTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ReferencedDocumentTypeSerializer<'ser> {
        pub(super) value: &'ser super::ReferencedDocumentType,
        pub(super) state: Box<ReferencedDocumentTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ReferencedDocumentTypeSerializerState<'ser> {
        Init__,
        IssuerAssignedId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        Uriid(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        LineId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        TypeCode(
            IterSerializer<'ser, Option<&'ser super::DocumentCodeType>, super::DocumentCodeType>,
        ),
        Name(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        AttachmentBinaryObject(
            IterSerializer<'ser, Option<&'ser super::BinaryObjectType>, super::BinaryObjectType>,
        ),
        ReferenceTypeCode(
            IterSerializer<'ser, Option<&'ser super::ReferenceCodeType>, super::ReferenceCodeType>,
        ),
        FormattedIssueDateTime(
            IterSerializer<
                'ser,
                Option<&'ser super::FormattedDateTimeType>,
                super::FormattedDateTimeType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ReferencedDocumentTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ReferencedDocumentTypeSerializerState::Init__ => {
                        *self.state = ReferencedDocumentTypeSerializerState::IssuerAssignedId(
                            IterSerializer::new(
                                self.value.issuer_assigned_id.as_ref(),
                                Some("ram:IssuerAssignedID"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ReferencedDocumentTypeSerializerState::IssuerAssignedId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ReferencedDocumentTypeSerializerState::Uriid(
                                    IterSerializer::new(
                                        self.value.uriid.as_ref(),
                                        Some("ram:URIID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ReferencedDocumentTypeSerializerState::Uriid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ReferencedDocumentTypeSerializerState::LineId(
                                    IterSerializer::new(
                                        self.value.line_id.as_ref(),
                                        Some("ram:LineID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ReferencedDocumentTypeSerializerState::LineId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ReferencedDocumentTypeSerializerState::TypeCode(
                                    IterSerializer::new(
                                        self.value.type_code.as_ref(),
                                        Some("ram:TypeCode"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ReferencedDocumentTypeSerializerState::TypeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ReferencedDocumentTypeSerializerState::Name(
                                    IterSerializer::new(
                                        self.value.name.as_ref(),
                                        Some("ram:Name"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ReferencedDocumentTypeSerializerState::Name(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                ReferencedDocumentTypeSerializerState::AttachmentBinaryObject(
                                    IterSerializer::new(
                                        self.value.attachment_binary_object.as_ref(),
                                        Some("ram:AttachmentBinaryObject"),
                                        false,
                                    ),
                                )
                        }
                    },
                    ReferencedDocumentTypeSerializerState::AttachmentBinaryObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ReferencedDocumentTypeSerializerState::ReferenceTypeCode(
                                        IterSerializer::new(
                                            self.value.reference_type_code.as_ref(),
                                            Some("ram:ReferenceTypeCode"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ReferencedDocumentTypeSerializerState::ReferenceTypeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ReferencedDocumentTypeSerializerState::FormattedIssueDateTime(
                                        IterSerializer::new(
                                            self.value.formatted_issue_date_time.as_ref(),
                                            Some("ram:FormattedIssueDateTime"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ReferencedDocumentTypeSerializerState::FormattedIssueDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ReferencedDocumentTypeSerializerState::End__,
                        }
                    }
                    ReferencedDocumentTypeSerializerState::End__ => {
                        *self.state = ReferencedDocumentTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ReferencedDocumentTypeSerializerState::Done__ => return Ok(None),
                    ReferencedDocumentTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ReferencedDocumentTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ReferencedDocumentTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProcuringProjectTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProcuringProjectType,
        pub(super) state: Box<ProcuringProjectTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProcuringProjectTypeSerializerState<'ser> {
        Init__,
        Id(<super::IdType as WithSerializer>::Serializer<'ser>),
        Name(<super::TextType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProcuringProjectTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProcuringProjectTypeSerializerState::Init__ => {
                        *self.state = ProcuringProjectTypeSerializerState::Id(
                            WithSerializer::serializer(&self.value.id, Some("ram:ID"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProcuringProjectTypeSerializerState::Id(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = ProcuringProjectTypeSerializerState::Name(
                                WithSerializer::serializer(
                                    &self.value.name,
                                    Some("ram:Name"),
                                    false,
                                )?,
                            )
                        }
                    },
                    ProcuringProjectTypeSerializerState::Name(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = ProcuringProjectTypeSerializerState::End__,
                    },
                    ProcuringProjectTypeSerializerState::End__ => {
                        *self.state = ProcuringProjectTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProcuringProjectTypeSerializerState::Done__ => return Ok(None),
                    ProcuringProjectTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProcuringProjectTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProcuringProjectTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplyChainConsignmentTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplyChainConsignmentType,
        pub(super) state: Box<SupplyChainConsignmentTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplyChainConsignmentTypeSerializerState<'ser> {
        Init__,
        SpecifiedLogisticsTransportMovement(
            IterSerializer<
                'ser,
                &'ser [super::LogisticsTransportMovementType],
                super::LogisticsTransportMovementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplyChainConsignmentTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { SupplyChainConsignmentTypeSerializerState :: Init__ => { * self . state = SupplyChainConsignmentTypeSerializerState :: SpecifiedLogisticsTransportMovement (IterSerializer :: new (& self . value . specified_logistics_transport_movement [..] , Some ("ram:SpecifiedLogisticsTransportMovement") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } SupplyChainConsignmentTypeSerializerState :: SpecifiedLogisticsTransportMovement (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SupplyChainConsignmentTypeSerializerState :: End__ , } SupplyChainConsignmentTypeSerializerState :: End__ => { * self . state = SupplyChainConsignmentTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } SupplyChainConsignmentTypeSerializerState :: Done__ => return Ok (None) , SupplyChainConsignmentTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for SupplyChainConsignmentTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplyChainConsignmentTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplyChainEventTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplyChainEventType,
        pub(super) state: Box<SupplyChainEventTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplyChainEventTypeSerializerState<'ser> {
        Init__,
        OccurrenceDateTime(<super::DateTimeType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplyChainEventTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SupplyChainEventTypeSerializerState::Init__ => {
                        *self.state = SupplyChainEventTypeSerializerState::OccurrenceDateTime(
                            WithSerializer::serializer(
                                &self.value.occurrence_date_time,
                                Some("ram:OccurrenceDateTime"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SupplyChainEventTypeSerializerState::OccurrenceDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SupplyChainEventTypeSerializerState::End__,
                        }
                    }
                    SupplyChainEventTypeSerializerState::End__ => {
                        *self.state = SupplyChainEventTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SupplyChainEventTypeSerializerState::Done__ => return Ok(None),
                    SupplyChainEventTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SupplyChainEventTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplyChainEventTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CurrencyCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::CurrencyCodeType,
        pub(super) state: Box<CurrencyCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CurrencyCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CurrencyCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CurrencyCodeTypeSerializerState::Init__ => {
                        *self.state = CurrencyCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CurrencyCodeTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CurrencyCodeTypeSerializerState::End__,
                    },
                    CurrencyCodeTypeSerializerState::End__ => {
                        *self.state = CurrencyCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CurrencyCodeTypeSerializerState::Done__ => return Ok(None),
                    CurrencyCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CurrencyCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CurrencyCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeCurrencyExchangeTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeCurrencyExchangeType,
        pub(super) state: Box<TradeCurrencyExchangeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeCurrencyExchangeTypeSerializerState<'ser> {
        Init__,
        SourceCurrencyCode(<super::CurrencyCodeType as WithSerializer>::Serializer<'ser>),
        TargetCurrencyCode(<super::CurrencyCodeType as WithSerializer>::Serializer<'ser>),
        ConversionRate(<super::RateType as WithSerializer>::Serializer<'ser>),
        ConversionRateDateTime(
            IterSerializer<'ser, Option<&'ser super::DateTimeType>, super::DateTimeType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeCurrencyExchangeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeCurrencyExchangeTypeSerializerState::Init__ => {
                        *self.state = TradeCurrencyExchangeTypeSerializerState::SourceCurrencyCode(
                            WithSerializer::serializer(
                                &self.value.source_currency_code,
                                Some("ram:SourceCurrencyCode"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeCurrencyExchangeTypeSerializerState::SourceCurrencyCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeCurrencyExchangeTypeSerializerState::TargetCurrencyCode(
                                        WithSerializer::serializer(
                                            &self.value.target_currency_code,
                                            Some("ram:TargetCurrencyCode"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    TradeCurrencyExchangeTypeSerializerState::TargetCurrencyCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeCurrencyExchangeTypeSerializerState::ConversionRate(
                                        WithSerializer::serializer(
                                            &self.value.conversion_rate,
                                            Some("ram:ConversionRate"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    TradeCurrencyExchangeTypeSerializerState::ConversionRate(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeCurrencyExchangeTypeSerializerState::ConversionRateDateTime(
                                        IterSerializer::new(
                                            self.value.conversion_rate_date_time.as_ref(),
                                            Some("ram:ConversionRateDateTime"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeCurrencyExchangeTypeSerializerState::ConversionRateDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeCurrencyExchangeTypeSerializerState::End__,
                        }
                    }
                    TradeCurrencyExchangeTypeSerializerState::End__ => {
                        *self.state = TradeCurrencyExchangeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeCurrencyExchangeTypeSerializerState::Done__ => return Ok(None),
                    TradeCurrencyExchangeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeCurrencyExchangeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeCurrencyExchangeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeSettlementPaymentMeansTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeSettlementPaymentMeansType,
        pub(super) state: Box<TradeSettlementPaymentMeansTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeSettlementPaymentMeansTypeSerializerState<'ser> {
        Init__,
        TypeCode(<super::PaymentMeansCodeType as WithSerializer>::Serializer<'ser>),
        Information(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        ApplicableTradeSettlementFinancialCard(
            IterSerializer<
                'ser,
                Option<&'ser super::TradeSettlementFinancialCardType>,
                super::TradeSettlementFinancialCardType,
            >,
        ),
        PayerPartyDebtorFinancialAccount(
            IterSerializer<
                'ser,
                Option<&'ser super::DebtorFinancialAccountType>,
                super::DebtorFinancialAccountType,
            >,
        ),
        PayeePartyCreditorFinancialAccount(
            IterSerializer<
                'ser,
                Option<&'ser super::CreditorFinancialAccountType>,
                super::CreditorFinancialAccountType,
            >,
        ),
        PayeeSpecifiedCreditorFinancialInstitution(
            IterSerializer<
                'ser,
                Option<&'ser super::CreditorFinancialInstitutionType>,
                super::CreditorFinancialInstitutionType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeSettlementPaymentMeansTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { TradeSettlementPaymentMeansTypeSerializerState :: Init__ => { * self . state = TradeSettlementPaymentMeansTypeSerializerState :: TypeCode (WithSerializer :: serializer (& self . value . type_code , Some ("ram:TypeCode") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } TradeSettlementPaymentMeansTypeSerializerState :: TypeCode (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementPaymentMeansTypeSerializerState :: Information (IterSerializer :: new (self . value . information . as_ref () , Some ("ram:Information") , false)) , } TradeSettlementPaymentMeansTypeSerializerState :: Information (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementPaymentMeansTypeSerializerState :: ApplicableTradeSettlementFinancialCard (IterSerializer :: new (self . value . applicable_trade_settlement_financial_card . as_ref () , Some ("ram:ApplicableTradeSettlementFinancialCard") , false)) , } TradeSettlementPaymentMeansTypeSerializerState :: ApplicableTradeSettlementFinancialCard (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementPaymentMeansTypeSerializerState :: PayerPartyDebtorFinancialAccount (IterSerializer :: new (self . value . payer_party_debtor_financial_account . as_ref () , Some ("ram:PayerPartyDebtorFinancialAccount") , false)) , } TradeSettlementPaymentMeansTypeSerializerState :: PayerPartyDebtorFinancialAccount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementPaymentMeansTypeSerializerState :: PayeePartyCreditorFinancialAccount (IterSerializer :: new (self . value . payee_party_creditor_financial_account . as_ref () , Some ("ram:PayeePartyCreditorFinancialAccount") , false)) , } TradeSettlementPaymentMeansTypeSerializerState :: PayeePartyCreditorFinancialAccount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementPaymentMeansTypeSerializerState :: PayeeSpecifiedCreditorFinancialInstitution (IterSerializer :: new (self . value . payee_specified_creditor_financial_institution . as_ref () , Some ("ram:PayeeSpecifiedCreditorFinancialInstitution") , false)) , } TradeSettlementPaymentMeansTypeSerializerState :: PayeeSpecifiedCreditorFinancialInstitution (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementPaymentMeansTypeSerializerState :: End__ , } TradeSettlementPaymentMeansTypeSerializerState :: End__ => { * self . state = TradeSettlementPaymentMeansTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } TradeSettlementPaymentMeansTypeSerializerState :: Done__ => return Ok (None) , TradeSettlementPaymentMeansTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for TradeSettlementPaymentMeansTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeSettlementPaymentMeansTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeTaxTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeTaxType,
        pub(super) state: Box<TradeTaxTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeTaxTypeSerializerState<'ser> {
        Init__,
        CalculatedAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        TypeCode(<super::TaxTypeCodeType as WithSerializer>::Serializer<'ser>),
        ExemptionReason(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        BasisAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        LineTotalBasisAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        AllowanceChargeBasisAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        CategoryCode(<super::TaxCategoryCodeType as WithSerializer>::Serializer<'ser>),
        ExemptionReasonCode(IterSerializer<'ser, Option<&'ser super::CodeType>, super::CodeType>),
        TaxPointDate(IterSerializer<'ser, Option<&'ser super::DateType>, super::DateType>),
        DueDateTypeCode(
            IterSerializer<
                'ser,
                Option<&'ser super::TimeReferenceCodeType>,
                super::TimeReferenceCodeType,
            >,
        ),
        RateApplicablePercent(
            IterSerializer<'ser, Option<&'ser super::PercentType>, super::PercentType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeTaxTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeTaxTypeSerializerState::Init__ => {
                        *self.state =
                            TradeTaxTypeSerializerState::CalculatedAmount(IterSerializer::new(
                                self.value.calculated_amount.as_ref(),
                                Some("ram:CalculatedAmount"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeTaxTypeSerializerState::CalculatedAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeTaxTypeSerializerState::TypeCode(
                                    WithSerializer::serializer(
                                        &self.value.type_code,
                                        Some("ram:TypeCode"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    TradeTaxTypeSerializerState::TypeCode(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeTaxTypeSerializerState::ExemptionReason(IterSerializer::new(
                                    self.value.exemption_reason.as_ref(),
                                    Some("ram:ExemptionReason"),
                                    false,
                                ))
                        }
                    },
                    TradeTaxTypeSerializerState::ExemptionReason(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeTaxTypeSerializerState::BasisAmount(IterSerializer::new(
                                        self.value.basis_amount.as_ref(),
                                        Some("ram:BasisAmount"),
                                        false,
                                    ))
                            }
                        }
                    }
                    TradeTaxTypeSerializerState::BasisAmount(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = TradeTaxTypeSerializerState::LineTotalBasisAmount(
                                IterSerializer::new(
                                    self.value.line_total_basis_amount.as_ref(),
                                    Some("ram:LineTotalBasisAmount"),
                                    false,
                                ),
                            )
                        }
                    },
                    TradeTaxTypeSerializerState::LineTotalBasisAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeTaxTypeSerializerState::AllowanceChargeBasisAmount(
                                        IterSerializer::new(
                                            self.value.allowance_charge_basis_amount.as_ref(),
                                            Some("ram:AllowanceChargeBasisAmount"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeTaxTypeSerializerState::AllowanceChargeBasisAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeTaxTypeSerializerState::CategoryCode(
                                    WithSerializer::serializer(
                                        &self.value.category_code,
                                        Some("ram:CategoryCode"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    TradeTaxTypeSerializerState::CategoryCode(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = TradeTaxTypeSerializerState::ExemptionReasonCode(
                                IterSerializer::new(
                                    self.value.exemption_reason_code.as_ref(),
                                    Some("ram:ExemptionReasonCode"),
                                    false,
                                ),
                            )
                        }
                    },
                    TradeTaxTypeSerializerState::ExemptionReasonCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeTaxTypeSerializerState::TaxPointDate(IterSerializer::new(
                                        self.value.tax_point_date.as_ref(),
                                        Some("ram:TaxPointDate"),
                                        false,
                                    ))
                            }
                        }
                    }
                    TradeTaxTypeSerializerState::TaxPointDate(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeTaxTypeSerializerState::DueDateTypeCode(IterSerializer::new(
                                    self.value.due_date_type_code.as_ref(),
                                    Some("ram:DueDateTypeCode"),
                                    false,
                                ))
                        }
                    },
                    TradeTaxTypeSerializerState::DueDateTypeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeTaxTypeSerializerState::RateApplicablePercent(
                                    IterSerializer::new(
                                        self.value.rate_applicable_percent.as_ref(),
                                        Some("ram:RateApplicablePercent"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeTaxTypeSerializerState::RateApplicablePercent(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeTaxTypeSerializerState::End__,
                        }
                    }
                    TradeTaxTypeSerializerState::End__ => {
                        *self.state = TradeTaxTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeTaxTypeSerializerState::Done__ => return Ok(None),
                    TradeTaxTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeTaxTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeTaxTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeAllowanceChargeTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeAllowanceChargeType,
        pub(super) state: Box<TradeAllowanceChargeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeAllowanceChargeTypeSerializerState<'ser> {
        Init__,
        ChargeIndicator(<super::IndicatorType as WithSerializer>::Serializer<'ser>),
        SequenceNumeric(IterSerializer<'ser, Option<&'ser super::NumericType>, super::NumericType>),
        CalculationPercent(
            IterSerializer<'ser, Option<&'ser super::PercentType>, super::PercentType>,
        ),
        BasisAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        BasisQuantity(IterSerializer<'ser, Option<&'ser super::QuantityType>, super::QuantityType>),
        ActualAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        ReasonCode(
            IterSerializer<
                'ser,
                Option<&'ser super::AllowanceChargeReasonCodeType>,
                super::AllowanceChargeReasonCodeType,
            >,
        ),
        Reason(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        CategoryTradeTax(
            IterSerializer<'ser, Option<&'ser super::TradeTaxType>, super::TradeTaxType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeAllowanceChargeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeAllowanceChargeTypeSerializerState::Init__ => {
                        *self.state = TradeAllowanceChargeTypeSerializerState::ChargeIndicator(
                            WithSerializer::serializer(
                                &self.value.charge_indicator,
                                Some("ram:ChargeIndicator"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeAllowanceChargeTypeSerializerState::ChargeIndicator(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeAllowanceChargeTypeSerializerState::SequenceNumeric(
                                        IterSerializer::new(
                                            self.value.sequence_numeric.as_ref(),
                                            Some("ram:SequenceNumeric"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::SequenceNumeric(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeAllowanceChargeTypeSerializerState::CalculationPercent(
                                        IterSerializer::new(
                                            self.value.calculation_percent.as_ref(),
                                            Some("ram:CalculationPercent"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::CalculationPercent(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeAllowanceChargeTypeSerializerState::BasisAmount(
                                    IterSerializer::new(
                                        self.value.basis_amount.as_ref(),
                                        Some("ram:BasisAmount"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::BasisAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeAllowanceChargeTypeSerializerState::BasisQuantity(
                                    IterSerializer::new(
                                        self.value.basis_quantity.as_ref(),
                                        Some("ram:BasisQuantity"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::BasisQuantity(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeAllowanceChargeTypeSerializerState::ActualAmount(
                                    WithSerializer::serializer(
                                        &self.value.actual_amount,
                                        Some("ram:ActualAmount"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::ActualAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeAllowanceChargeTypeSerializerState::ReasonCode(
                                    IterSerializer::new(
                                        self.value.reason_code.as_ref(),
                                        Some("ram:ReasonCode"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::ReasonCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeAllowanceChargeTypeSerializerState::Reason(
                                    IterSerializer::new(
                                        self.value.reason.as_ref(),
                                        Some("ram:Reason"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::Reason(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeAllowanceChargeTypeSerializerState::CategoryTradeTax(
                                        IterSerializer::new(
                                            self.value.category_trade_tax.as_ref(),
                                            Some("ram:CategoryTradeTax"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::CategoryTradeTax(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeAllowanceChargeTypeSerializerState::End__,
                        }
                    }
                    TradeAllowanceChargeTypeSerializerState::End__ => {
                        *self.state = TradeAllowanceChargeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeAllowanceChargeTypeSerializerState::Done__ => return Ok(None),
                    TradeAllowanceChargeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeAllowanceChargeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeAllowanceChargeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LogisticsServiceChargeTypeSerializer<'ser> {
        pub(super) value: &'ser super::LogisticsServiceChargeType,
        pub(super) state: Box<LogisticsServiceChargeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LogisticsServiceChargeTypeSerializerState<'ser> {
        Init__,
        Description(<super::TextType as WithSerializer>::Serializer<'ser>),
        AppliedAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        AppliedTradeTax(IterSerializer<'ser, &'ser [super::TradeTaxType], super::TradeTaxType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LogisticsServiceChargeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    LogisticsServiceChargeTypeSerializerState::Init__ => {
                        *self.state = LogisticsServiceChargeTypeSerializerState::Description(
                            WithSerializer::serializer(
                                &self.value.description,
                                Some("ram:Description"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    LogisticsServiceChargeTypeSerializerState::Description(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    LogisticsServiceChargeTypeSerializerState::AppliedAmount(
                                        WithSerializer::serializer(
                                            &self.value.applied_amount,
                                            Some("ram:AppliedAmount"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    LogisticsServiceChargeTypeSerializerState::AppliedAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    LogisticsServiceChargeTypeSerializerState::AppliedTradeTax(
                                        IterSerializer::new(
                                            &self.value.applied_trade_tax[..],
                                            Some("ram:AppliedTradeTax"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    LogisticsServiceChargeTypeSerializerState::AppliedTradeTax(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = LogisticsServiceChargeTypeSerializerState::End__,
                        }
                    }
                    LogisticsServiceChargeTypeSerializerState::End__ => {
                        *self.state = LogisticsServiceChargeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    LogisticsServiceChargeTypeSerializerState::Done__ => return Ok(None),
                    LogisticsServiceChargeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for LogisticsServiceChargeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LogisticsServiceChargeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradePaymentTermsTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradePaymentTermsType,
        pub(super) state: Box<TradePaymentTermsTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradePaymentTermsTypeSerializerState<'ser> {
        Init__,
        Description(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        DueDateDateTime(
            IterSerializer<'ser, Option<&'ser super::DateTimeType>, super::DateTimeType>,
        ),
        DirectDebitMandateId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        PartialPaymentAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        ApplicableTradePaymentPenaltyTerms(
            IterSerializer<
                'ser,
                Option<&'ser super::TradePaymentPenaltyTermsType>,
                super::TradePaymentPenaltyTermsType,
            >,
        ),
        ApplicableTradePaymentDiscountTerms(
            IterSerializer<
                'ser,
                Option<&'ser super::TradePaymentDiscountTermsType>,
                super::TradePaymentDiscountTermsType,
            >,
        ),
        PayeeTradeParty(
            IterSerializer<'ser, Option<&'ser super::TradePartyType>, super::TradePartyType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradePaymentTermsTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { TradePaymentTermsTypeSerializerState :: Init__ => { * self . state = TradePaymentTermsTypeSerializerState :: Description (IterSerializer :: new (self . value . description . as_ref () , Some ("ram:Description") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } TradePaymentTermsTypeSerializerState :: Description (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradePaymentTermsTypeSerializerState :: DueDateDateTime (IterSerializer :: new (self . value . due_date_date_time . as_ref () , Some ("ram:DueDateDateTime") , false)) , } TradePaymentTermsTypeSerializerState :: DueDateDateTime (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradePaymentTermsTypeSerializerState :: DirectDebitMandateId (IterSerializer :: new (self . value . direct_debit_mandate_id . as_ref () , Some ("ram:DirectDebitMandateID") , false)) , } TradePaymentTermsTypeSerializerState :: DirectDebitMandateId (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradePaymentTermsTypeSerializerState :: PartialPaymentAmount (IterSerializer :: new (self . value . partial_payment_amount . as_ref () , Some ("ram:PartialPaymentAmount") , false)) , } TradePaymentTermsTypeSerializerState :: PartialPaymentAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradePaymentTermsTypeSerializerState :: ApplicableTradePaymentPenaltyTerms (IterSerializer :: new (self . value . applicable_trade_payment_penalty_terms . as_ref () , Some ("ram:ApplicableTradePaymentPenaltyTerms") , false)) , } TradePaymentTermsTypeSerializerState :: ApplicableTradePaymentPenaltyTerms (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradePaymentTermsTypeSerializerState :: ApplicableTradePaymentDiscountTerms (IterSerializer :: new (self . value . applicable_trade_payment_discount_terms . as_ref () , Some ("ram:ApplicableTradePaymentDiscountTerms") , false)) , } TradePaymentTermsTypeSerializerState :: ApplicableTradePaymentDiscountTerms (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradePaymentTermsTypeSerializerState :: PayeeTradeParty (IterSerializer :: new (self . value . payee_trade_party . as_ref () , Some ("ram:PayeeTradeParty") , false)) , } TradePaymentTermsTypeSerializerState :: PayeeTradeParty (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradePaymentTermsTypeSerializerState :: End__ , } TradePaymentTermsTypeSerializerState :: End__ => { * self . state = TradePaymentTermsTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } TradePaymentTermsTypeSerializerState :: Done__ => return Ok (None) , TradePaymentTermsTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for TradePaymentTermsTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradePaymentTermsTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeSettlementHeaderMonetarySummationTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeSettlementHeaderMonetarySummationType,
        pub(super) state: Box<TradeSettlementHeaderMonetarySummationTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeSettlementHeaderMonetarySummationTypeSerializerState<'ser> {
        Init__,
        LineTotalAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        ChargeTotalAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        AllowanceTotalAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        TaxBasisTotalAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        TaxTotalAmount(IterSerializer<'ser, &'ser [super::AmountType], super::AmountType>),
        RoundingAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        GrandTotalAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        TotalPrepaidAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        DuePayableAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeSettlementHeaderMonetarySummationTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { TradeSettlementHeaderMonetarySummationTypeSerializerState :: Init__ => { * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: LineTotalAmount (WithSerializer :: serializer (& self . value . line_total_amount , Some ("ram:LineTotalAmount") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } TradeSettlementHeaderMonetarySummationTypeSerializerState :: LineTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: ChargeTotalAmount (IterSerializer :: new (self . value . charge_total_amount . as_ref () , Some ("ram:ChargeTotalAmount") , false)) , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: ChargeTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: AllowanceTotalAmount (IterSerializer :: new (self . value . allowance_total_amount . as_ref () , Some ("ram:AllowanceTotalAmount") , false)) , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: AllowanceTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: TaxBasisTotalAmount (WithSerializer :: serializer (& self . value . tax_basis_total_amount , Some ("ram:TaxBasisTotalAmount") , false) ?) , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: TaxBasisTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: TaxTotalAmount (IterSerializer :: new (& self . value . tax_total_amount [..] , Some ("ram:TaxTotalAmount") , false)) , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: TaxTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: RoundingAmount (IterSerializer :: new (self . value . rounding_amount . as_ref () , Some ("ram:RoundingAmount") , false)) , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: RoundingAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: GrandTotalAmount (WithSerializer :: serializer (& self . value . grand_total_amount , Some ("ram:GrandTotalAmount") , false) ?) , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: GrandTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: TotalPrepaidAmount (IterSerializer :: new (self . value . total_prepaid_amount . as_ref () , Some ("ram:TotalPrepaidAmount") , false)) , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: TotalPrepaidAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: DuePayableAmount (WithSerializer :: serializer (& self . value . due_payable_amount , Some ("ram:DuePayableAmount") , false) ?) , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: DuePayableAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: End__ , } TradeSettlementHeaderMonetarySummationTypeSerializerState :: End__ => { * self . state = TradeSettlementHeaderMonetarySummationTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } TradeSettlementHeaderMonetarySummationTypeSerializerState :: Done__ => return Ok (None) , TradeSettlementHeaderMonetarySummationTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for TradeSettlementHeaderMonetarySummationTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeSettlementHeaderMonetarySummationTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeAccountingAccountTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeAccountingAccountType,
        pub(super) state: Box<TradeAccountingAccountTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeAccountingAccountTypeSerializerState<'ser> {
        Init__,
        Id(<super::IdType as WithSerializer>::Serializer<'ser>),
        TypeCode(
            IterSerializer<
                'ser,
                Option<&'ser super::AccountingAccountTypeCodeType>,
                super::AccountingAccountTypeCodeType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeAccountingAccountTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeAccountingAccountTypeSerializerState::Init__ => {
                        *self.state = TradeAccountingAccountTypeSerializerState::Id(
                            WithSerializer::serializer(&self.value.id, Some("ram:ID"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeAccountingAccountTypeSerializerState::Id(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeAccountingAccountTypeSerializerState::TypeCode(
                                    IterSerializer::new(
                                        self.value.type_code.as_ref(),
                                        Some("ram:TypeCode"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradeAccountingAccountTypeSerializerState::TypeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeAccountingAccountTypeSerializerState::End__,
                        }
                    }
                    TradeAccountingAccountTypeSerializerState::End__ => {
                        *self.state = TradeAccountingAccountTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeAccountingAccountTypeSerializerState::Done__ => return Ok(None),
                    TradeAccountingAccountTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeAccountingAccountTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeAccountingAccountTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct AdvancePaymentTypeSerializer<'ser> {
        pub(super) value: &'ser super::AdvancePaymentType,
        pub(super) state: Box<AdvancePaymentTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum AdvancePaymentTypeSerializerState<'ser> {
        Init__,
        PaidAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        FormattedReceivedDateTime(
            IterSerializer<
                'ser,
                Option<&'ser super::FormattedDateTimeType>,
                super::FormattedDateTimeType,
            >,
        ),
        IncludedTradeTax(IterSerializer<'ser, &'ser [super::TradeTaxType], super::TradeTaxType>),
        InvoiceSpecifiedReferencedDocument(
            IterSerializer<
                'ser,
                Option<&'ser super::ReferencedDocumentType>,
                super::ReferencedDocumentType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> AdvancePaymentTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    AdvancePaymentTypeSerializerState::Init__ => {
                        *self.state = AdvancePaymentTypeSerializerState::PaidAmount(
                            WithSerializer::serializer(
                                &self.value.paid_amount,
                                Some("ram:PaidAmount"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    AdvancePaymentTypeSerializerState::PaidAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    AdvancePaymentTypeSerializerState::FormattedReceivedDateTime(
                                        IterSerializer::new(
                                            self.value.formatted_received_date_time.as_ref(),
                                            Some("ram:FormattedReceivedDateTime"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    AdvancePaymentTypeSerializerState::FormattedReceivedDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = AdvancePaymentTypeSerializerState::IncludedTradeTax(
                                    IterSerializer::new(
                                        &self.value.included_trade_tax[..],
                                        Some("ram:IncludedTradeTax"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    AdvancePaymentTypeSerializerState::IncludedTradeTax(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state =
                            AdvancePaymentTypeSerializerState::InvoiceSpecifiedReferencedDocument(
                                IterSerializer::new(
                                    self.value.invoice_specified_referenced_document.as_ref(),
                                    Some("ram:InvoiceSpecifiedReferencedDocument"),
                                    false,
                                ),
                            ),
                    },
                    AdvancePaymentTypeSerializerState::InvoiceSpecifiedReferencedDocument(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = AdvancePaymentTypeSerializerState::End__,
                        }
                    }
                    AdvancePaymentTypeSerializerState::End__ => {
                        *self.state = AdvancePaymentTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    AdvancePaymentTypeSerializerState::Done__ => return Ok(None),
                    AdvancePaymentTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for AdvancePaymentTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = AdvancePaymentTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LineStatusCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::LineStatusCodeType,
        pub(super) state: Box<LineStatusCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LineStatusCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LineStatusCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    LineStatusCodeTypeSerializerState::Init__ => {
                        *self.state = LineStatusCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    LineStatusCodeTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = LineStatusCodeTypeSerializerState::End__,
                        }
                    }
                    LineStatusCodeTypeSerializerState::End__ => {
                        *self.state = LineStatusCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    LineStatusCodeTypeSerializerState::Done__ => return Ok(None),
                    LineStatusCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for LineStatusCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LineStatusCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductCharacteristicTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductCharacteristicType,
        pub(super) state: Box<ProductCharacteristicTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductCharacteristicTypeSerializerState<'ser> {
        Init__,
        TypeCode(IterSerializer<'ser, Option<&'ser super::CodeType>, super::CodeType>),
        Description(<super::TextType as WithSerializer>::Serializer<'ser>),
        ValueMeasure(IterSerializer<'ser, Option<&'ser super::MeasureType>, super::MeasureType>),
        Value(<super::TextType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductCharacteristicTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductCharacteristicTypeSerializerState::Init__ => {
                        *self.state = ProductCharacteristicTypeSerializerState::TypeCode(
                            IterSerializer::new(
                                self.value.type_code.as_ref(),
                                Some("ram:TypeCode"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductCharacteristicTypeSerializerState::TypeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductCharacteristicTypeSerializerState::Description(
                                    WithSerializer::serializer(
                                        &self.value.description,
                                        Some("ram:Description"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    ProductCharacteristicTypeSerializerState::Description(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductCharacteristicTypeSerializerState::ValueMeasure(
                                    IterSerializer::new(
                                        self.value.value_measure.as_ref(),
                                        Some("ram:ValueMeasure"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductCharacteristicTypeSerializerState::ValueMeasure(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductCharacteristicTypeSerializerState::Value(
                                    WithSerializer::serializer(
                                        &self.value.value,
                                        Some("ram:Value"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    ProductCharacteristicTypeSerializerState::Value(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductCharacteristicTypeSerializerState::End__,
                        }
                    }
                    ProductCharacteristicTypeSerializerState::End__ => {
                        *self.state = ProductCharacteristicTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductCharacteristicTypeSerializerState::Done__ => return Ok(None),
                    ProductCharacteristicTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductCharacteristicTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductCharacteristicTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductClassificationTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductClassificationType,
        pub(super) state: Box<ProductClassificationTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductClassificationTypeSerializerState<'ser> {
        Init__,
        ClassCode(IterSerializer<'ser, Option<&'ser super::CodeType>, super::CodeType>),
        ClassName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductClassificationTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductClassificationTypeSerializerState::Init__ => {
                        *self.state = ProductClassificationTypeSerializerState::ClassCode(
                            IterSerializer::new(
                                self.value.class_code.as_ref(),
                                Some("ram:ClassCode"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductClassificationTypeSerializerState::ClassCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductClassificationTypeSerializerState::ClassName(
                                    IterSerializer::new(
                                        self.value.class_name.as_ref(),
                                        Some("ram:ClassName"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductClassificationTypeSerializerState::ClassName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductClassificationTypeSerializerState::End__,
                        }
                    }
                    ProductClassificationTypeSerializerState::End__ => {
                        *self.state = ProductClassificationTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductClassificationTypeSerializerState::Done__ => return Ok(None),
                    ProductClassificationTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductClassificationTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductClassificationTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeProductInstanceTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeProductInstanceType,
        pub(super) state: Box<TradeProductInstanceTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeProductInstanceTypeSerializerState<'ser> {
        Init__,
        BatchId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        SupplierAssignedSerialId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeProductInstanceTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeProductInstanceTypeSerializerState::Init__ => {
                        *self.state =
                            TradeProductInstanceTypeSerializerState::BatchId(IterSerializer::new(
                                self.value.batch_id.as_ref(),
                                Some("ram:BatchID"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeProductInstanceTypeSerializerState::BatchId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TradeProductInstanceTypeSerializerState::SupplierAssignedSerialId(
                                    IterSerializer::new(
                                        self.value.supplier_assigned_serial_id.as_ref(),
                                        Some("ram:SupplierAssignedSerialID"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    TradeProductInstanceTypeSerializerState::SupplierAssignedSerialId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeProductInstanceTypeSerializerState::End__,
                        }
                    }
                    TradeProductInstanceTypeSerializerState::End__ => {
                        *self.state = TradeProductInstanceTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeProductInstanceTypeSerializerState::Done__ => return Ok(None),
                    TradeProductInstanceTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeProductInstanceTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeProductInstanceTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeCountryTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeCountryType,
        pub(super) state: Box<TradeCountryTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeCountryTypeSerializerState<'ser> {
        Init__,
        Id(<super::CountryIdType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeCountryTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeCountryTypeSerializerState::Init__ => {
                        *self.state = TradeCountryTypeSerializerState::Id(
                            WithSerializer::serializer(&self.value.id, Some("ram:ID"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeCountryTypeSerializerState::Id(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = TradeCountryTypeSerializerState::End__,
                    },
                    TradeCountryTypeSerializerState::End__ => {
                        *self.state = TradeCountryTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeCountryTypeSerializerState::Done__ => return Ok(None),
                    TradeCountryTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeCountryTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeCountryTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ReferencedProductTypeSerializer<'ser> {
        pub(super) value: &'ser super::ReferencedProductType,
        pub(super) state: Box<ReferencedProductTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ReferencedProductTypeSerializerState<'ser> {
        Init__,
        Id(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        GlobalId(IterSerializer<'ser, &'ser [super::IdType], super::IdType>),
        SellerAssignedId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        BuyerAssignedId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        IndustryAssignedId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        Name(<super::TextType as WithSerializer>::Serializer<'ser>),
        Description(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        UnitQuantity(IterSerializer<'ser, Option<&'ser super::QuantityType>, super::QuantityType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ReferencedProductTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ReferencedProductTypeSerializerState::Init__ => {
                        *self.state = ReferencedProductTypeSerializerState::Id(
                            IterSerializer::new(self.value.id.as_ref(), Some("ram:ID"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ReferencedProductTypeSerializerState::Id(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                ReferencedProductTypeSerializerState::GlobalId(IterSerializer::new(
                                    &self.value.global_id[..],
                                    Some("ram:GlobalID"),
                                    false,
                                ))
                        }
                    },
                    ReferencedProductTypeSerializerState::GlobalId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ReferencedProductTypeSerializerState::SellerAssignedId(
                                    IterSerializer::new(
                                        self.value.seller_assigned_id.as_ref(),
                                        Some("ram:SellerAssignedID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ReferencedProductTypeSerializerState::SellerAssignedId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ReferencedProductTypeSerializerState::BuyerAssignedId(
                                    IterSerializer::new(
                                        self.value.buyer_assigned_id.as_ref(),
                                        Some("ram:BuyerAssignedID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ReferencedProductTypeSerializerState::BuyerAssignedId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ReferencedProductTypeSerializerState::IndustryAssignedId(
                                        IterSerializer::new(
                                            self.value.industry_assigned_id.as_ref(),
                                            Some("ram:IndustryAssignedID"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ReferencedProductTypeSerializerState::IndustryAssignedId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ReferencedProductTypeSerializerState::Name(
                                    WithSerializer::serializer(
                                        &self.value.name,
                                        Some("ram:Name"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    ReferencedProductTypeSerializerState::Name(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = ReferencedProductTypeSerializerState::Description(
                                IterSerializer::new(
                                    self.value.description.as_ref(),
                                    Some("ram:Description"),
                                    false,
                                ),
                            )
                        }
                    },
                    ReferencedProductTypeSerializerState::Description(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ReferencedProductTypeSerializerState::UnitQuantity(
                                    IterSerializer::new(
                                        self.value.unit_quantity.as_ref(),
                                        Some("ram:UnitQuantity"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ReferencedProductTypeSerializerState::UnitQuantity(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ReferencedProductTypeSerializerState::End__,
                        }
                    }
                    ReferencedProductTypeSerializerState::End__ => {
                        *self.state = ReferencedProductTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ReferencedProductTypeSerializerState::Done__ => return Ok(None),
                    ReferencedProductTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ReferencedProductTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ReferencedProductTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradePriceTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradePriceType,
        pub(super) state: Box<TradePriceTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradePriceTypeSerializerState<'ser> {
        Init__,
        ChargeAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        BasisQuantity(IterSerializer<'ser, Option<&'ser super::QuantityType>, super::QuantityType>),
        AppliedTradeAllowanceCharge(
            IterSerializer<
                'ser,
                &'ser [super::TradeAllowanceChargeType],
                super::TradeAllowanceChargeType,
            >,
        ),
        IncludedTradeTax(
            IterSerializer<'ser, Option<&'ser super::TradeTaxType>, super::TradeTaxType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradePriceTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradePriceTypeSerializerState::Init__ => {
                        *self.state = TradePriceTypeSerializerState::ChargeAmount(
                            WithSerializer::serializer(
                                &self.value.charge_amount,
                                Some("ram:ChargeAmount"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradePriceTypeSerializerState::ChargeAmount(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradePriceTypeSerializerState::BasisQuantity(IterSerializer::new(
                                    self.value.basis_quantity.as_ref(),
                                    Some("ram:BasisQuantity"),
                                    false,
                                ))
                        }
                    },
                    TradePriceTypeSerializerState::BasisQuantity(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePriceTypeSerializerState::AppliedTradeAllowanceCharge(
                                        IterSerializer::new(
                                            &self.value.applied_trade_allowance_charge[..],
                                            Some("ram:AppliedTradeAllowanceCharge"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePriceTypeSerializerState::AppliedTradeAllowanceCharge(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradePriceTypeSerializerState::IncludedTradeTax(
                                    IterSerializer::new(
                                        self.value.included_trade_tax.as_ref(),
                                        Some("ram:IncludedTradeTax"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TradePriceTypeSerializerState::IncludedTradeTax(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradePriceTypeSerializerState::End__,
                        }
                    }
                    TradePriceTypeSerializerState::End__ => {
                        *self.state = TradePriceTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradePriceTypeSerializerState::Done__ => return Ok(None),
                    TradePriceTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradePriceTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradePriceTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct QuantityTypeSerializer<'ser> {
        pub(super) value: &'ser super::QuantityType,
        pub(super) state: Box<QuantityTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum QuantityTypeSerializerState<'ser> {
        Init__,
        Content__(<f64 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> QuantityTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    QuantityTypeSerializerState::Init__ => {
                        *self.state = QuantityTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib_opt(&mut bytes, "udt:unitCode", &self.value.unit_code)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    QuantityTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = QuantityTypeSerializerState::End__,
                    },
                    QuantityTypeSerializerState::End__ => {
                        *self.state = QuantityTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    QuantityTypeSerializerState::Done__ => return Ok(None),
                    QuantityTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for QuantityTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = QuantityTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeSettlementLineMonetarySummationTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeSettlementLineMonetarySummationType,
        pub(super) state: Box<TradeSettlementLineMonetarySummationTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeSettlementLineMonetarySummationTypeSerializerState<'ser> {
        Init__,
        LineTotalAmount(<super::AmountType as WithSerializer>::Serializer<'ser>),
        ChargeTotalAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        AllowanceTotalAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        TaxTotalAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        GrandTotalAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        TotalAllowanceChargeAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeSettlementLineMonetarySummationTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { TradeSettlementLineMonetarySummationTypeSerializerState :: Init__ => { * self . state = TradeSettlementLineMonetarySummationTypeSerializerState :: LineTotalAmount (WithSerializer :: serializer (& self . value . line_total_amount , Some ("ram:LineTotalAmount") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns:rsm" [..] , & super :: NS_RSM [..])) ; bytes . push_attribute ((& b"xmlns:qdt" [..] , & super :: NS_QDT [..])) ; bytes . push_attribute ((& b"xmlns:ram" [..] , & super :: NS_RAM [..])) ; bytes . push_attribute ((& b"xmlns:udt" [..] , & super :: NS_UDT [..])) ; } return Ok (Some (Event :: Start (bytes))) } TradeSettlementLineMonetarySummationTypeSerializerState :: LineTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementLineMonetarySummationTypeSerializerState :: ChargeTotalAmount (IterSerializer :: new (self . value . charge_total_amount . as_ref () , Some ("ram:ChargeTotalAmount") , false)) , } TradeSettlementLineMonetarySummationTypeSerializerState :: ChargeTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementLineMonetarySummationTypeSerializerState :: AllowanceTotalAmount (IterSerializer :: new (self . value . allowance_total_amount . as_ref () , Some ("ram:AllowanceTotalAmount") , false)) , } TradeSettlementLineMonetarySummationTypeSerializerState :: AllowanceTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementLineMonetarySummationTypeSerializerState :: TaxTotalAmount (IterSerializer :: new (self . value . tax_total_amount . as_ref () , Some ("ram:TaxTotalAmount") , false)) , } TradeSettlementLineMonetarySummationTypeSerializerState :: TaxTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementLineMonetarySummationTypeSerializerState :: GrandTotalAmount (IterSerializer :: new (self . value . grand_total_amount . as_ref () , Some ("ram:GrandTotalAmount") , false)) , } TradeSettlementLineMonetarySummationTypeSerializerState :: GrandTotalAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementLineMonetarySummationTypeSerializerState :: TotalAllowanceChargeAmount (IterSerializer :: new (self . value . total_allowance_charge_amount . as_ref () , Some ("ram:TotalAllowanceChargeAmount") , false)) , } TradeSettlementLineMonetarySummationTypeSerializerState :: TotalAllowanceChargeAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TradeSettlementLineMonetarySummationTypeSerializerState :: End__ , } TradeSettlementLineMonetarySummationTypeSerializerState :: End__ => { * self . state = TradeSettlementLineMonetarySummationTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } TradeSettlementLineMonetarySummationTypeSerializerState :: Done__ => return Ok (None) , TradeSettlementLineMonetarySummationTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for TradeSettlementLineMonetarySummationTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeSettlementLineMonetarySummationTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PartyRoleCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::PartyRoleCodeType,
        pub(super) state: Box<PartyRoleCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PartyRoleCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PartyRoleCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PartyRoleCodeTypeSerializerState::Init__ => {
                        *self.state = PartyRoleCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PartyRoleCodeTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = PartyRoleCodeTypeSerializerState::End__,
                    },
                    PartyRoleCodeTypeSerializerState::End__ => {
                        *self.state = PartyRoleCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PartyRoleCodeTypeSerializerState::Done__ => return Ok(None),
                    PartyRoleCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PartyRoleCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PartyRoleCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LegalOrganizationTypeSerializer<'ser> {
        pub(super) value: &'ser super::LegalOrganizationType,
        pub(super) state: Box<LegalOrganizationTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LegalOrganizationTypeSerializerState<'ser> {
        Init__,
        Id(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        TradingBusinessName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        PostalTradeAddress(
            IterSerializer<'ser, Option<&'ser super::TradeAddressType>, super::TradeAddressType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LegalOrganizationTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    LegalOrganizationTypeSerializerState::Init__ => {
                        *self.state = LegalOrganizationTypeSerializerState::Id(
                            IterSerializer::new(self.value.id.as_ref(), Some("ram:ID"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    LegalOrganizationTypeSerializerState::Id(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = LegalOrganizationTypeSerializerState::TradingBusinessName(
                                IterSerializer::new(
                                    self.value.trading_business_name.as_ref(),
                                    Some("ram:TradingBusinessName"),
                                    false,
                                ),
                            )
                        }
                    },
                    LegalOrganizationTypeSerializerState::TradingBusinessName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    LegalOrganizationTypeSerializerState::PostalTradeAddress(
                                        IterSerializer::new(
                                            self.value.postal_trade_address.as_ref(),
                                            Some("ram:PostalTradeAddress"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    LegalOrganizationTypeSerializerState::PostalTradeAddress(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = LegalOrganizationTypeSerializerState::End__,
                        }
                    }
                    LegalOrganizationTypeSerializerState::End__ => {
                        *self.state = LegalOrganizationTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    LegalOrganizationTypeSerializerState::Done__ => return Ok(None),
                    LegalOrganizationTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for LegalOrganizationTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LegalOrganizationTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeContactTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeContactType,
        pub(super) state: Box<TradeContactTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeContactTypeSerializerState<'ser> {
        Init__,
        PersonName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        DepartmentName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        TypeCode(
            IterSerializer<
                'ser,
                Option<&'ser super::ContactTypeCodeType>,
                super::ContactTypeCodeType,
            >,
        ),
        TelephoneUniversalCommunication(
            IterSerializer<
                'ser,
                Option<&'ser super::UniversalCommunicationType>,
                super::UniversalCommunicationType,
            >,
        ),
        FaxUniversalCommunication(
            IterSerializer<
                'ser,
                Option<&'ser super::UniversalCommunicationType>,
                super::UniversalCommunicationType,
            >,
        ),
        EmailUriUniversalCommunication(
            IterSerializer<
                'ser,
                Option<&'ser super::UniversalCommunicationType>,
                super::UniversalCommunicationType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeContactTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeContactTypeSerializerState::Init__ => {
                        *self.state =
                            TradeContactTypeSerializerState::PersonName(IterSerializer::new(
                                self.value.person_name.as_ref(),
                                Some("ram:PersonName"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeContactTypeSerializerState::PersonName(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = TradeContactTypeSerializerState::DepartmentName(
                                IterSerializer::new(
                                    self.value.department_name.as_ref(),
                                    Some("ram:DepartmentName"),
                                    false,
                                ),
                            )
                        }
                    },
                    TradeContactTypeSerializerState::DepartmentName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeContactTypeSerializerState::TypeCode(IterSerializer::new(
                                        self.value.type_code.as_ref(),
                                        Some("ram:TypeCode"),
                                        false,
                                    ))
                            }
                        }
                    }
                    TradeContactTypeSerializerState::TypeCode(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeContactTypeSerializerState::TelephoneUniversalCommunication(
                                    IterSerializer::new(
                                        self.value.telephone_universal_communication.as_ref(),
                                        Some("ram:TelephoneUniversalCommunication"),
                                        false,
                                    ),
                                )
                        }
                    },
                    TradeContactTypeSerializerState::TelephoneUniversalCommunication(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeContactTypeSerializerState::FaxUniversalCommunication(
                                        IterSerializer::new(
                                            self.value.fax_universal_communication.as_ref(),
                                            Some("ram:FaxUniversalCommunication"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeContactTypeSerializerState::FaxUniversalCommunication(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeContactTypeSerializerState::EmailUriUniversalCommunication(
                                        IterSerializer::new(
                                            self.value.email_uri_universal_communication.as_ref(),
                                            Some("ram:EmailURIUniversalCommunication"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeContactTypeSerializerState::EmailUriUniversalCommunication(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeContactTypeSerializerState::End__,
                        }
                    }
                    TradeContactTypeSerializerState::End__ => {
                        *self.state = TradeContactTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeContactTypeSerializerState::Done__ => return Ok(None),
                    TradeContactTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeContactTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeContactTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeAddressTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeAddressType,
        pub(super) state: Box<TradeAddressTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeAddressTypeSerializerState<'ser> {
        Init__,
        PostcodeCode(IterSerializer<'ser, Option<&'ser super::CodeType>, super::CodeType>),
        LineOne(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        LineTwo(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        LineThree(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        CityName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        CountryId(<super::CountryIdType as WithSerializer>::Serializer<'ser>),
        CountrySubDivisionName(
            IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeAddressTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeAddressTypeSerializerState::Init__ => {
                        *self.state =
                            TradeAddressTypeSerializerState::PostcodeCode(IterSerializer::new(
                                self.value.postcode_code.as_ref(),
                                Some("ram:PostcodeCode"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeAddressTypeSerializerState::PostcodeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeAddressTypeSerializerState::LineOne(IterSerializer::new(
                                        self.value.line_one.as_ref(),
                                        Some("ram:LineOne"),
                                        false,
                                    ))
                            }
                        }
                    }
                    TradeAddressTypeSerializerState::LineOne(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeAddressTypeSerializerState::LineTwo(IterSerializer::new(
                                    self.value.line_two.as_ref(),
                                    Some("ram:LineTwo"),
                                    false,
                                ))
                        }
                    },
                    TradeAddressTypeSerializerState::LineTwo(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeAddressTypeSerializerState::LineThree(IterSerializer::new(
                                    self.value.line_three.as_ref(),
                                    Some("ram:LineThree"),
                                    false,
                                ))
                        }
                    },
                    TradeAddressTypeSerializerState::LineThree(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TradeAddressTypeSerializerState::CityName(IterSerializer::new(
                                    self.value.city_name.as_ref(),
                                    Some("ram:CityName"),
                                    false,
                                ))
                        }
                    },
                    TradeAddressTypeSerializerState::CityName(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = TradeAddressTypeSerializerState::CountryId(
                                WithSerializer::serializer(
                                    &self.value.country_id,
                                    Some("ram:CountryID"),
                                    false,
                                )?,
                            )
                        }
                    },
                    TradeAddressTypeSerializerState::CountryId(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = TradeAddressTypeSerializerState::CountrySubDivisionName(
                                IterSerializer::new(
                                    self.value.country_sub_division_name.as_ref(),
                                    Some("ram:CountrySubDivisionName"),
                                    false,
                                ),
                            )
                        }
                    },
                    TradeAddressTypeSerializerState::CountrySubDivisionName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TradeAddressTypeSerializerState::End__,
                        }
                    }
                    TradeAddressTypeSerializerState::End__ => {
                        *self.state = TradeAddressTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeAddressTypeSerializerState::Done__ => return Ok(None),
                    TradeAddressTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeAddressTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeAddressTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UniversalCommunicationTypeSerializer<'ser> {
        pub(super) value: &'ser super::UniversalCommunicationType,
        pub(super) state: Box<UniversalCommunicationTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UniversalCommunicationTypeSerializerState<'ser> {
        Init__,
        Uriid(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        CompleteNumber(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UniversalCommunicationTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UniversalCommunicationTypeSerializerState::Init__ => {
                        *self.state =
                            UniversalCommunicationTypeSerializerState::Uriid(IterSerializer::new(
                                self.value.uriid.as_ref(),
                                Some("ram:URIID"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UniversalCommunicationTypeSerializerState::Uriid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UniversalCommunicationTypeSerializerState::CompleteNumber(
                                        IterSerializer::new(
                                            self.value.complete_number.as_ref(),
                                            Some("ram:CompleteNumber"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UniversalCommunicationTypeSerializerState::CompleteNumber(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UniversalCommunicationTypeSerializerState::End__,
                        }
                    }
                    UniversalCommunicationTypeSerializerState::End__ => {
                        *self.state = UniversalCommunicationTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UniversalCommunicationTypeSerializerState::Done__ => return Ok(None),
                    UniversalCommunicationTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UniversalCommunicationTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UniversalCommunicationTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TaxRegistrationTypeSerializer<'ser> {
        pub(super) value: &'ser super::TaxRegistrationType,
        pub(super) state: Box<TaxRegistrationTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TaxRegistrationTypeSerializerState<'ser> {
        Init__,
        Id(<super::IdType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TaxRegistrationTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TaxRegistrationTypeSerializerState::Init__ => {
                        *self.state = TaxRegistrationTypeSerializerState::Id(
                            WithSerializer::serializer(&self.value.id, Some("ram:ID"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TaxRegistrationTypeSerializerState::Id(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = TaxRegistrationTypeSerializerState::End__,
                    },
                    TaxRegistrationTypeSerializerState::End__ => {
                        *self.state = TaxRegistrationTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TaxRegistrationTypeSerializerState::Done__ => return Ok(None),
                    TaxRegistrationTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TaxRegistrationTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TaxRegistrationTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DeliveryTermsCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::DeliveryTermsCodeType,
        pub(super) state: Box<DeliveryTermsCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DeliveryTermsCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DeliveryTermsCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DeliveryTermsCodeTypeSerializerState::Init__ => {
                        *self.state = DeliveryTermsCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DeliveryTermsCodeTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DeliveryTermsCodeTypeSerializerState::End__,
                        }
                    }
                    DeliveryTermsCodeTypeSerializerState::End__ => {
                        *self.state = DeliveryTermsCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DeliveryTermsCodeTypeSerializerState::Done__ => return Ok(None),
                    DeliveryTermsCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DeliveryTermsCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DeliveryTermsCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct BinaryObjectTypeSerializer<'ser> {
        pub(super) value: &'ser super::BinaryObjectType,
        pub(super) state: Box<BinaryObjectTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum BinaryObjectTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BinaryObjectTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BinaryObjectTypeSerializerState::Init__ => {
                        *self.state = BinaryObjectTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib(&mut bytes, "udt:mimeCode", &self.value.mime_code)?;
                        write_attrib(&mut bytes, "udt:filename", &self.value.filename)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    BinaryObjectTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = BinaryObjectTypeSerializerState::End__,
                    },
                    BinaryObjectTypeSerializerState::End__ => {
                        *self.state = BinaryObjectTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    BinaryObjectTypeSerializerState::Done__ => return Ok(None),
                    BinaryObjectTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BinaryObjectTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BinaryObjectTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ReferenceCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::ReferenceCodeType,
        pub(super) state: Box<ReferenceCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ReferenceCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ReferenceCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ReferenceCodeTypeSerializerState::Init__ => {
                        *self.state = ReferenceCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ReferenceCodeTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = ReferenceCodeTypeSerializerState::End__,
                    },
                    ReferenceCodeTypeSerializerState::End__ => {
                        *self.state = ReferenceCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ReferenceCodeTypeSerializerState::Done__ => return Ok(None),
                    ReferenceCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ReferenceCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ReferenceCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct FormattedDateTimeTypeSerializer<'ser> {
        pub(super) value: &'ser super::FormattedDateTimeType,
        pub(super) state: Box<FormattedDateTimeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum FormattedDateTimeTypeSerializerState<'ser> {
        Init__,
        DateTimeString(
            <super::FormattedDateTimeTypeDateTimeStringType as WithSerializer>::Serializer<'ser>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> FormattedDateTimeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    FormattedDateTimeTypeSerializerState::Init__ => {
                        *self.state = FormattedDateTimeTypeSerializerState::DateTimeString(
                            WithSerializer::serializer(
                                &self.value.date_time_string,
                                Some("qdt:DateTimeString"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    FormattedDateTimeTypeSerializerState::DateTimeString(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FormattedDateTimeTypeSerializerState::End__,
                        }
                    }
                    FormattedDateTimeTypeSerializerState::End__ => {
                        *self.state = FormattedDateTimeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    FormattedDateTimeTypeSerializerState::Done__ => return Ok(None),
                    FormattedDateTimeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for FormattedDateTimeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = FormattedDateTimeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LogisticsTransportMovementTypeSerializer<'ser> {
        pub(super) value: &'ser super::LogisticsTransportMovementType,
        pub(super) state: Box<LogisticsTransportMovementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LogisticsTransportMovementTypeSerializerState<'ser> {
        Init__,
        ModeCode(<super::TransportModeCodeType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LogisticsTransportMovementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    LogisticsTransportMovementTypeSerializerState::Init__ => {
                        *self.state = LogisticsTransportMovementTypeSerializerState::ModeCode(
                            WithSerializer::serializer(
                                &self.value.mode_code,
                                Some("ram:ModeCode"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    LogisticsTransportMovementTypeSerializerState::ModeCode(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = LogisticsTransportMovementTypeSerializerState::End__,
                    },
                    LogisticsTransportMovementTypeSerializerState::End__ => {
                        *self.state = LogisticsTransportMovementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    LogisticsTransportMovementTypeSerializerState::Done__ => return Ok(None),
                    LogisticsTransportMovementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for LogisticsTransportMovementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LogisticsTransportMovementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct RateTypeSerializer<'ser> {
        pub(super) value: &'ser super::RateType,
        pub(super) state: Box<RateTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum RateTypeSerializerState<'ser> {
        Init__,
        Content__(<f64 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> RateTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    RateTypeSerializerState::Init__ => {
                        *self.state = RateTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    RateTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = RateTypeSerializerState::End__,
                    },
                    RateTypeSerializerState::End__ => {
                        *self.state = RateTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    RateTypeSerializerState::Done__ => return Ok(None),
                    RateTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for RateTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = RateTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PaymentMeansCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::PaymentMeansCodeType,
        pub(super) state: Box<PaymentMeansCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PaymentMeansCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PaymentMeansCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PaymentMeansCodeTypeSerializerState::Init__ => {
                        *self.state = PaymentMeansCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PaymentMeansCodeTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = PaymentMeansCodeTypeSerializerState::End__,
                        }
                    }
                    PaymentMeansCodeTypeSerializerState::End__ => {
                        *self.state = PaymentMeansCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PaymentMeansCodeTypeSerializerState::Done__ => return Ok(None),
                    PaymentMeansCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PaymentMeansCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PaymentMeansCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradeSettlementFinancialCardTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradeSettlementFinancialCardType,
        pub(super) state: Box<TradeSettlementFinancialCardTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradeSettlementFinancialCardTypeSerializerState<'ser> {
        Init__,
        Id(<super::IdType as WithSerializer>::Serializer<'ser>),
        CardholderName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradeSettlementFinancialCardTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradeSettlementFinancialCardTypeSerializerState::Init__ => {
                        *self.state = TradeSettlementFinancialCardTypeSerializerState::Id(
                            WithSerializer::serializer(&self.value.id, Some("ram:ID"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradeSettlementFinancialCardTypeSerializerState::Id(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradeSettlementFinancialCardTypeSerializerState::CardholderName(
                                        IterSerializer::new(
                                            self.value.cardholder_name.as_ref(),
                                            Some("ram:CardholderName"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradeSettlementFinancialCardTypeSerializerState::CardholderName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradeSettlementFinancialCardTypeSerializerState::End__
                            }
                        }
                    }
                    TradeSettlementFinancialCardTypeSerializerState::End__ => {
                        *self.state = TradeSettlementFinancialCardTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradeSettlementFinancialCardTypeSerializerState::Done__ => return Ok(None),
                    TradeSettlementFinancialCardTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradeSettlementFinancialCardTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradeSettlementFinancialCardTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DebtorFinancialAccountTypeSerializer<'ser> {
        pub(super) value: &'ser super::DebtorFinancialAccountType,
        pub(super) state: Box<DebtorFinancialAccountTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DebtorFinancialAccountTypeSerializerState<'ser> {
        Init__,
        Ibanid(<super::IdType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DebtorFinancialAccountTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DebtorFinancialAccountTypeSerializerState::Init__ => {
                        *self.state = DebtorFinancialAccountTypeSerializerState::Ibanid(
                            WithSerializer::serializer(
                                &self.value.ibanid,
                                Some("ram:IBANID"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DebtorFinancialAccountTypeSerializerState::Ibanid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DebtorFinancialAccountTypeSerializerState::End__,
                        }
                    }
                    DebtorFinancialAccountTypeSerializerState::End__ => {
                        *self.state = DebtorFinancialAccountTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DebtorFinancialAccountTypeSerializerState::Done__ => return Ok(None),
                    DebtorFinancialAccountTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DebtorFinancialAccountTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DebtorFinancialAccountTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CreditorFinancialAccountTypeSerializer<'ser> {
        pub(super) value: &'ser super::CreditorFinancialAccountType,
        pub(super) state: Box<CreditorFinancialAccountTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CreditorFinancialAccountTypeSerializerState<'ser> {
        Init__,
        Ibanid(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        AccountName(IterSerializer<'ser, Option<&'ser super::TextType>, super::TextType>),
        ProprietaryId(IterSerializer<'ser, Option<&'ser super::IdType>, super::IdType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CreditorFinancialAccountTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CreditorFinancialAccountTypeSerializerState::Init__ => {
                        *self.state = CreditorFinancialAccountTypeSerializerState::Ibanid(
                            IterSerializer::new(
                                self.value.ibanid.as_ref(),
                                Some("ram:IBANID"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CreditorFinancialAccountTypeSerializerState::Ibanid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CreditorFinancialAccountTypeSerializerState::AccountName(
                                        IterSerializer::new(
                                            self.value.account_name.as_ref(),
                                            Some("ram:AccountName"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    CreditorFinancialAccountTypeSerializerState::AccountName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CreditorFinancialAccountTypeSerializerState::ProprietaryId(
                                        IterSerializer::new(
                                            self.value.proprietary_id.as_ref(),
                                            Some("ram:ProprietaryID"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    CreditorFinancialAccountTypeSerializerState::ProprietaryId(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CreditorFinancialAccountTypeSerializerState::End__,
                    },
                    CreditorFinancialAccountTypeSerializerState::End__ => {
                        *self.state = CreditorFinancialAccountTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CreditorFinancialAccountTypeSerializerState::Done__ => return Ok(None),
                    CreditorFinancialAccountTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CreditorFinancialAccountTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CreditorFinancialAccountTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CreditorFinancialInstitutionTypeSerializer<'ser> {
        pub(super) value: &'ser super::CreditorFinancialInstitutionType,
        pub(super) state: Box<CreditorFinancialInstitutionTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CreditorFinancialInstitutionTypeSerializerState<'ser> {
        Init__,
        Bicid(<super::IdType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CreditorFinancialInstitutionTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CreditorFinancialInstitutionTypeSerializerState::Init__ => {
                        *self.state = CreditorFinancialInstitutionTypeSerializerState::Bicid(
                            WithSerializer::serializer(
                                &self.value.bicid,
                                Some("ram:BICID"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CreditorFinancialInstitutionTypeSerializerState::Bicid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CreditorFinancialInstitutionTypeSerializerState::End__
                            }
                        }
                    }
                    CreditorFinancialInstitutionTypeSerializerState::End__ => {
                        *self.state = CreditorFinancialInstitutionTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CreditorFinancialInstitutionTypeSerializerState::Done__ => return Ok(None),
                    CreditorFinancialInstitutionTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CreditorFinancialInstitutionTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CreditorFinancialInstitutionTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct AmountTypeSerializer<'ser> {
        pub(super) value: &'ser super::AmountType,
        pub(super) state: Box<AmountTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum AmountTypeSerializerState<'ser> {
        Init__,
        Content__(<f64 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> AmountTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    AmountTypeSerializerState::Init__ => {
                        *self.state = AmountTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib_opt(&mut bytes, "udt:currencyID", &self.value.currency_id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    AmountTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = AmountTypeSerializerState::End__,
                    },
                    AmountTypeSerializerState::End__ => {
                        *self.state = AmountTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    AmountTypeSerializerState::Done__ => return Ok(None),
                    AmountTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for AmountTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = AmountTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TaxTypeCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::TaxTypeCodeType,
        pub(super) state: Box<TaxTypeCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TaxTypeCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TaxTypeCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TaxTypeCodeTypeSerializerState::Init__ => {
                        *self.state = TaxTypeCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TaxTypeCodeTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = TaxTypeCodeTypeSerializerState::End__,
                    },
                    TaxTypeCodeTypeSerializerState::End__ => {
                        *self.state = TaxTypeCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TaxTypeCodeTypeSerializerState::Done__ => return Ok(None),
                    TaxTypeCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TaxTypeCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TaxTypeCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TaxCategoryCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::TaxCategoryCodeType,
        pub(super) state: Box<TaxCategoryCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TaxCategoryCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TaxCategoryCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TaxCategoryCodeTypeSerializerState::Init__ => {
                        *self.state = TaxCategoryCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TaxCategoryCodeTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TaxCategoryCodeTypeSerializerState::End__,
                        }
                    }
                    TaxCategoryCodeTypeSerializerState::End__ => {
                        *self.state = TaxCategoryCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TaxCategoryCodeTypeSerializerState::Done__ => return Ok(None),
                    TaxCategoryCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TaxCategoryCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TaxCategoryCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DateTypeSerializer<'ser> {
        pub(super) value: &'ser super::DateType,
        pub(super) state: Box<DateTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DateTypeSerializerState<'ser> {
        Init__,
        Content__(<super::DateTypeContent as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DateTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DateTypeSerializerState::Init__ => {
                        *self.state = DateTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DateTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DateTypeSerializerState::End__,
                    },
                    DateTypeSerializerState::End__ => {
                        *self.state = DateTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DateTypeSerializerState::Done__ => return Ok(None),
                    DateTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DateTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DateTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DateTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::DateTypeContent,
        pub(super) state: Box<DateTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum DateTypeContentSerializerState<'ser> {
        Init__,
        DateString(<super::DateTypeDateStringType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DateTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DateTypeContentSerializerState::Init__ => match self.value {
                        super::DateTypeContent::DateString(x) => {
                            *self.state = DateTypeContentSerializerState::DateString(
                                WithSerializer::serializer(x, Some("udt:DateString"), false)?,
                            )
                        }
                    },
                    DateTypeContentSerializerState::DateString(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DateTypeContentSerializerState::Done__,
                    },
                    DateTypeContentSerializerState::Done__ => return Ok(None),
                    DateTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DateTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DateTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TimeReferenceCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::TimeReferenceCodeType,
        pub(super) state: Box<TimeReferenceCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TimeReferenceCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TimeReferenceCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TimeReferenceCodeTypeSerializerState::Init__ => {
                        *self.state = TimeReferenceCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TimeReferenceCodeTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TimeReferenceCodeTypeSerializerState::End__,
                        }
                    }
                    TimeReferenceCodeTypeSerializerState::End__ => {
                        *self.state = TimeReferenceCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TimeReferenceCodeTypeSerializerState::Done__ => return Ok(None),
                    TimeReferenceCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TimeReferenceCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TimeReferenceCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PercentTypeSerializer<'ser> {
        pub(super) value: &'ser super::PercentType,
        pub(super) state: Box<PercentTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PercentTypeSerializerState<'ser> {
        Init__,
        Content__(<f64 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PercentTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PercentTypeSerializerState::Init__ => {
                        *self.state = PercentTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PercentTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = PercentTypeSerializerState::End__,
                    },
                    PercentTypeSerializerState::End__ => {
                        *self.state = PercentTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PercentTypeSerializerState::Done__ => return Ok(None),
                    PercentTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PercentTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PercentTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct NumericTypeSerializer<'ser> {
        pub(super) value: &'ser super::NumericType,
        pub(super) state: Box<NumericTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum NumericTypeSerializerState<'ser> {
        Init__,
        Content__(<f64 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> NumericTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    NumericTypeSerializerState::Init__ => {
                        *self.state = NumericTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    NumericTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = NumericTypeSerializerState::End__,
                    },
                    NumericTypeSerializerState::End__ => {
                        *self.state = NumericTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    NumericTypeSerializerState::Done__ => return Ok(None),
                    NumericTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for NumericTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = NumericTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct AllowanceChargeReasonCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::AllowanceChargeReasonCodeType,
        pub(super) state: Box<AllowanceChargeReasonCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum AllowanceChargeReasonCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> AllowanceChargeReasonCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    AllowanceChargeReasonCodeTypeSerializerState::Init__ => {
                        *self.state = AllowanceChargeReasonCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    AllowanceChargeReasonCodeTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = AllowanceChargeReasonCodeTypeSerializerState::End__,
                    },
                    AllowanceChargeReasonCodeTypeSerializerState::End__ => {
                        *self.state = AllowanceChargeReasonCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    AllowanceChargeReasonCodeTypeSerializerState::Done__ => return Ok(None),
                    AllowanceChargeReasonCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for AllowanceChargeReasonCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = AllowanceChargeReasonCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradePaymentPenaltyTermsTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradePaymentPenaltyTermsType,
        pub(super) state: Box<TradePaymentPenaltyTermsTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradePaymentPenaltyTermsTypeSerializerState<'ser> {
        Init__,
        BasisDateTime(IterSerializer<'ser, Option<&'ser super::DateTimeType>, super::DateTimeType>),
        BasisPeriodMeasure(
            IterSerializer<'ser, Option<&'ser super::MeasureType>, super::MeasureType>,
        ),
        BasisAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        CalculationPercent(
            IterSerializer<'ser, Option<&'ser super::PercentType>, super::PercentType>,
        ),
        ActualPenaltyAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradePaymentPenaltyTermsTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradePaymentPenaltyTermsTypeSerializerState::Init__ => {
                        *self.state = TradePaymentPenaltyTermsTypeSerializerState::BasisDateTime(
                            IterSerializer::new(
                                self.value.basis_date_time.as_ref(),
                                Some("ram:BasisDateTime"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradePaymentPenaltyTermsTypeSerializerState::BasisDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePaymentPenaltyTermsTypeSerializerState::BasisPeriodMeasure(
                                        IterSerializer::new(
                                            self.value.basis_period_measure.as_ref(),
                                            Some("ram:BasisPeriodMeasure"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePaymentPenaltyTermsTypeSerializerState::BasisPeriodMeasure(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePaymentPenaltyTermsTypeSerializerState::BasisAmount(
                                        IterSerializer::new(
                                            self.value.basis_amount.as_ref(),
                                            Some("ram:BasisAmount"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePaymentPenaltyTermsTypeSerializerState::BasisAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePaymentPenaltyTermsTypeSerializerState::CalculationPercent(
                                        IterSerializer::new(
                                            self.value.calculation_percent.as_ref(),
                                            Some("ram:CalculationPercent"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePaymentPenaltyTermsTypeSerializerState::CalculationPercent(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePaymentPenaltyTermsTypeSerializerState::ActualPenaltyAmount(
                                        IterSerializer::new(
                                            self.value.actual_penalty_amount.as_ref(),
                                            Some("ram:ActualPenaltyAmount"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePaymentPenaltyTermsTypeSerializerState::ActualPenaltyAmount(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = TradePaymentPenaltyTermsTypeSerializerState::End__,
                    },
                    TradePaymentPenaltyTermsTypeSerializerState::End__ => {
                        *self.state = TradePaymentPenaltyTermsTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradePaymentPenaltyTermsTypeSerializerState::Done__ => return Ok(None),
                    TradePaymentPenaltyTermsTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradePaymentPenaltyTermsTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradePaymentPenaltyTermsTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TradePaymentDiscountTermsTypeSerializer<'ser> {
        pub(super) value: &'ser super::TradePaymentDiscountTermsType,
        pub(super) state: Box<TradePaymentDiscountTermsTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TradePaymentDiscountTermsTypeSerializerState<'ser> {
        Init__,
        BasisDateTime(IterSerializer<'ser, Option<&'ser super::DateTimeType>, super::DateTimeType>),
        BasisPeriodMeasure(
            IterSerializer<'ser, Option<&'ser super::MeasureType>, super::MeasureType>,
        ),
        BasisAmount(IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>),
        CalculationPercent(
            IterSerializer<'ser, Option<&'ser super::PercentType>, super::PercentType>,
        ),
        ActualDiscountAmount(
            IterSerializer<'ser, Option<&'ser super::AmountType>, super::AmountType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TradePaymentDiscountTermsTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TradePaymentDiscountTermsTypeSerializerState::Init__ => {
                        *self.state = TradePaymentDiscountTermsTypeSerializerState::BasisDateTime(
                            IterSerializer::new(
                                self.value.basis_date_time.as_ref(),
                                Some("ram:BasisDateTime"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TradePaymentDiscountTermsTypeSerializerState::BasisDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePaymentDiscountTermsTypeSerializerState::BasisPeriodMeasure(
                                        IterSerializer::new(
                                            self.value.basis_period_measure.as_ref(),
                                            Some("ram:BasisPeriodMeasure"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePaymentDiscountTermsTypeSerializerState::BasisPeriodMeasure(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePaymentDiscountTermsTypeSerializerState::BasisAmount(
                                        IterSerializer::new(
                                            self.value.basis_amount.as_ref(),
                                            Some("ram:BasisAmount"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePaymentDiscountTermsTypeSerializerState::BasisAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TradePaymentDiscountTermsTypeSerializerState::CalculationPercent(
                                        IterSerializer::new(
                                            self.value.calculation_percent.as_ref(),
                                            Some("ram:CalculationPercent"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TradePaymentDiscountTermsTypeSerializerState::CalculationPercent(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TradePaymentDiscountTermsTypeSerializerState::ActualDiscountAmount(
                                    IterSerializer::new(
                                        self.value.actual_discount_amount.as_ref(),
                                        Some("ram:ActualDiscountAmount"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    TradePaymentDiscountTermsTypeSerializerState::ActualDiscountAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TradePaymentDiscountTermsTypeSerializerState::End__
                            }
                        }
                    }
                    TradePaymentDiscountTermsTypeSerializerState::End__ => {
                        *self.state = TradePaymentDiscountTermsTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TradePaymentDiscountTermsTypeSerializerState::Done__ => return Ok(None),
                    TradePaymentDiscountTermsTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TradePaymentDiscountTermsTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TradePaymentDiscountTermsTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct AccountingAccountTypeCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::AccountingAccountTypeCodeType,
        pub(super) state: Box<AccountingAccountTypeCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum AccountingAccountTypeCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> AccountingAccountTypeCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    AccountingAccountTypeCodeTypeSerializerState::Init__ => {
                        *self.state = AccountingAccountTypeCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    AccountingAccountTypeCodeTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = AccountingAccountTypeCodeTypeSerializerState::End__,
                    },
                    AccountingAccountTypeCodeTypeSerializerState::End__ => {
                        *self.state = AccountingAccountTypeCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    AccountingAccountTypeCodeTypeSerializerState::Done__ => return Ok(None),
                    AccountingAccountTypeCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for AccountingAccountTypeCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = AccountingAccountTypeCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct MeasureTypeSerializer<'ser> {
        pub(super) value: &'ser super::MeasureType,
        pub(super) state: Box<MeasureTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum MeasureTypeSerializerState<'ser> {
        Init__,
        Content__(<f64 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> MeasureTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    MeasureTypeSerializerState::Init__ => {
                        *self.state = MeasureTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib_opt(&mut bytes, "udt:unitCode", &self.value.unit_code)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    MeasureTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = MeasureTypeSerializerState::End__,
                    },
                    MeasureTypeSerializerState::End__ => {
                        *self.state = MeasureTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    MeasureTypeSerializerState::Done__ => return Ok(None),
                    MeasureTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for MeasureTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = MeasureTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CountryIdTypeSerializer<'ser> {
        pub(super) value: &'ser super::CountryIdType,
        pub(super) state: Box<CountryIdTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CountryIdTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CountryIdTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CountryIdTypeSerializerState::Init__ => {
                        *self.state = CountryIdTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CountryIdTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CountryIdTypeSerializerState::End__,
                    },
                    CountryIdTypeSerializerState::End__ => {
                        *self.state = CountryIdTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CountryIdTypeSerializerState::Done__ => return Ok(None),
                    CountryIdTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CountryIdTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CountryIdTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ContactTypeCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::ContactTypeCodeType,
        pub(super) state: Box<ContactTypeCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ContactTypeCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ContactTypeCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ContactTypeCodeTypeSerializerState::Init__ => {
                        *self.state = ContactTypeCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ContactTypeCodeTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ContactTypeCodeTypeSerializerState::End__,
                        }
                    }
                    ContactTypeCodeTypeSerializerState::End__ => {
                        *self.state = ContactTypeCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ContactTypeCodeTypeSerializerState::Done__ => return Ok(None),
                    ContactTypeCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ContactTypeCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ContactTypeCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct FormattedDateTimeTypeDateTimeStringTypeSerializer<'ser> {
        pub(super) value: &'ser super::FormattedDateTimeTypeDateTimeStringType,
        pub(super) state: Box<FormattedDateTimeTypeDateTimeStringTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum FormattedDateTimeTypeDateTimeStringTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> FormattedDateTimeTypeDateTimeStringTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    FormattedDateTimeTypeDateTimeStringTypeSerializerState::Init__ => {
                        *self.state =
                            FormattedDateTimeTypeDateTimeStringTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib(&mut bytes, "qdt:format", &self.value.format)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    FormattedDateTimeTypeDateTimeStringTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    FormattedDateTimeTypeDateTimeStringTypeSerializerState::End__
                            }
                        }
                    }
                    FormattedDateTimeTypeDateTimeStringTypeSerializerState::End__ => {
                        *self.state =
                            FormattedDateTimeTypeDateTimeStringTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    FormattedDateTimeTypeDateTimeStringTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    FormattedDateTimeTypeDateTimeStringTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for FormattedDateTimeTypeDateTimeStringTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = FormattedDateTimeTypeDateTimeStringTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TransportModeCodeTypeSerializer<'ser> {
        pub(super) value: &'ser super::TransportModeCodeType,
        pub(super) state: Box<TransportModeCodeTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TransportModeCodeTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TransportModeCodeTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TransportModeCodeTypeSerializerState::Init__ => {
                        *self.state = TransportModeCodeTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TransportModeCodeTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TransportModeCodeTypeSerializerState::End__,
                        }
                    }
                    TransportModeCodeTypeSerializerState::End__ => {
                        *self.state = TransportModeCodeTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TransportModeCodeTypeSerializerState::Done__ => return Ok(None),
                    TransportModeCodeTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TransportModeCodeTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TransportModeCodeTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DateTypeDateStringTypeSerializer<'ser> {
        pub(super) value: &'ser super::DateTypeDateStringType,
        pub(super) state: Box<DateTypeDateStringTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DateTypeDateStringTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DateTypeDateStringTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DateTypeDateStringTypeSerializerState::Init__ => {
                        *self.state = DateTypeDateStringTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns:rsm"[..], &super::NS_RSM[..]));
                            bytes.push_attribute((&b"xmlns:qdt"[..], &super::NS_QDT[..]));
                            bytes.push_attribute((&b"xmlns:ram"[..], &super::NS_RAM[..]));
                            bytes.push_attribute((&b"xmlns:udt"[..], &super::NS_UDT[..]));
                        }
                        write_attrib(&mut bytes, "udt:format", &self.value.format)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DateTypeDateStringTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DateTypeDateStringTypeSerializerState::End__,
                        }
                    }
                    DateTypeDateStringTypeSerializerState::End__ => {
                        *self.state = DateTypeDateStringTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DateTypeDateStringTypeSerializerState::Done__ => return Ok(None),
                    DateTypeDateStringTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DateTypeDateStringTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DateTypeDateStringTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
}
