use std::borrow::Cow;
use xsd_parser::{
    models::schema::Namespace,
    quick_xml::{
        DeserializeBytes, DeserializeReader, Error, ErrorKind, RawByteStr, SerializeBytes,
        WithDeserializer, WithSerializer,
    },
};
pub const NS_XS: Namespace = Namespace::new_const(b"http://www.w3.org/2001/XMLSchema");
pub const NS_XML: Namespace = Namespace::new_const(b"http://www.w3.org/XML/1998/namespace");
pub const NS_DEFAULT: Namespace = Namespace::new_const(b"http://www.ofdspec.org/2016");
pub type Annotations = AnnotationsXElementType;
#[derive(Debug)]
pub struct AnnotationsXElementType {
    pub page: Vec<AnnotationsPageXElementType>,
}
impl WithSerializer for AnnotationsXElementType {
    type Serializer<'x> = quick_xml_serialize::AnnotationsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::AnnotationsXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::AnnotationsXElementTypeSerializerState::Init__),
            name: name.unwrap_or("Annotations"),
            is_root,
        })
    }
}
impl WithDeserializer for AnnotationsXElementType {
    type Deserializer = quick_xml_deserialize::AnnotationsXElementTypeDeserializer;
}
pub type Attachments = AttachmentsXElementType;
#[derive(Debug)]
pub struct AttachmentsXElementType {
    pub attachment: Vec<CtAttachmentXType>,
}
impl WithSerializer for AttachmentsXElementType {
    type Serializer<'x> = quick_xml_serialize::AttachmentsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::AttachmentsXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::AttachmentsXElementTypeSerializerState::Init__),
            name: name.unwrap_or("Attachments"),
            is_root,
        })
    }
}
impl WithDeserializer for AttachmentsXElementType {
    type Deserializer = quick_xml_deserialize::AttachmentsXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtActionXType {
    pub event: CtActionEventXType,
    pub content: Vec<CtActionXTypeContent>,
}
#[derive(Debug)]
pub enum CtActionXTypeContent {
    Region(CtRegionXType),
    Goto(CtActionGotoXElementType),
    Uri(CtActionUriXElementType),
    GotoA(CtActionGotoAxElementType),
    Sound(CtActionSoundXElementType),
    Movie(CtActionMovieXElementType),
}
impl WithSerializer for CtActionXType {
    type Serializer<'x> = quick_xml_serialize::CtActionXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtActionXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtActionXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Action"),
            is_root,
        })
    }
}
impl WithSerializer for CtActionXTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtActionXTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::CtActionXTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtActionXTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for CtActionXType {
    type Deserializer = quick_xml_deserialize::CtActionXTypeDeserializer;
}
impl WithDeserializer for CtActionXTypeContent {
    type Deserializer = quick_xml_deserialize::CtActionXTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtAttachmentXType {
    pub id: String,
    pub name: String,
    pub format: Option<String>,
    pub creation_date: Option<String>,
    pub mod_date: Option<String>,
    pub size: Option<f64>,
    pub visible: bool,
    pub usage: String,
    pub file_loc: String,
}
impl CtAttachmentXType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_usage() -> String {
        String::from("none")
    }
}
impl WithSerializer for CtAttachmentXType {
    type Serializer<'x> = quick_xml_serialize::CtAttachmentXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtAttachmentXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtAttachmentXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Attachment"),
            is_root,
        })
    }
}
impl WithDeserializer for CtAttachmentXType {
    type Deserializer = quick_xml_deserialize::CtAttachmentXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtAxialShdXType {
    pub map_type: CtAxialShdMapTypeXType,
    pub map_unit: Option<f64>,
    pub extend: CtAxialShdExtendXType,
    pub start_point: String,
    pub end_point: String,
    pub segment: Vec<CtAxialShdSegmentXElementType>,
}
impl CtAxialShdXType {
    #[must_use]
    pub fn default_map_type() -> CtAxialShdMapTypeXType {
        CtAxialShdMapTypeXType::Direct
    }
    #[must_use]
    pub fn default_extend() -> CtAxialShdExtendXType {
        CtAxialShdExtendXType::_0
    }
}
impl WithSerializer for CtAxialShdXType {
    type Serializer<'x> = quick_xml_serialize::CtAxialShdXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtAxialShdXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtAxialShdXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_AxialShd"),
            is_root,
        })
    }
}
impl WithDeserializer for CtAxialShdXType {
    type Deserializer = quick_xml_deserialize::CtAxialShdXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtBookmarkXType {
    pub name: String,
    pub dest: CtDestXType,
}
impl WithSerializer for CtBookmarkXType {
    type Serializer<'x> = quick_xml_serialize::CtBookmarkXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtBookmarkXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtBookmarkXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Bookmark"),
            is_root,
        })
    }
}
impl WithDeserializer for CtBookmarkXType {
    type Deserializer = quick_xml_deserialize::CtBookmarkXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtCgTransformXType {
    pub code_position: i32,
    pub code_count: i32,
    pub glyph_count: i32,
    pub glyphs: Option<String>,
}
impl CtCgTransformXType {
    #[must_use]
    pub fn default_code_count() -> i32 {
        1i32
    }
    #[must_use]
    pub fn default_glyph_count() -> i32 {
        1i32
    }
}
impl WithSerializer for CtCgTransformXType {
    type Serializer<'x> = quick_xml_serialize::CtCgTransformXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtCgTransformXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtCgTransformXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_CGTransform"),
            is_root,
        })
    }
}
impl WithDeserializer for CtCgTransformXType {
    type Deserializer = quick_xml_deserialize::CtCgTransformXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtClipXType {
    pub area: Vec<CtClipAreaXElementType>,
}
impl WithSerializer for CtClipXType {
    type Serializer<'x> = quick_xml_serialize::CtClipXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtClipXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtClipXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Clip"),
            is_root,
        })
    }
}
impl WithDeserializer for CtClipXType {
    type Deserializer = quick_xml_deserialize::CtClipXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtColorXType {
    pub value: Option<String>,
    pub index: Option<i32>,
    pub color_space: Option<u32>,
    pub alpha: i32,
    pub content: Option<CtColorXTypeContent>,
}
#[derive(Debug)]
pub enum CtColorXTypeContent {
    Pattern(CtPatternXType),
    AxialShd(CtAxialShdXType),
    RadialShd(CtRadialShdXType),
    GouraudShd(Box<CtGouraudShdXType>),
    LaGourandShd(Box<CtLaGouraudShdXType>),
}
impl CtColorXType {
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
}
impl WithSerializer for CtColorXType {
    type Serializer<'x> = quick_xml_serialize::CtColorXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtColorXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtColorXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Color"),
            is_root,
        })
    }
}
impl WithSerializer for CtColorXTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtColorXTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::CtColorXTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtColorXTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for CtColorXType {
    type Deserializer = quick_xml_deserialize::CtColorXTypeDeserializer;
}
impl WithDeserializer for CtColorXTypeContent {
    type Deserializer = quick_xml_deserialize::CtColorXTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtColorSpaceXType {
    pub type_: CtColorSpaceTypeXType,
    pub bits_per_component: i32,
    pub profile: Option<String>,
    pub palette: Option<CtColorSpacePaletteXElementType>,
}
impl CtColorSpaceXType {
    #[must_use]
    pub fn default_bits_per_component() -> i32 {
        8i32
    }
}
impl WithSerializer for CtColorSpaceXType {
    type Serializer<'x> = quick_xml_serialize::CtColorSpaceXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtColorSpaceXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtColorSpaceXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_ColorSpace"),
            is_root,
        })
    }
}
impl WithDeserializer for CtColorSpaceXType {
    type Deserializer = quick_xml_deserialize::CtColorSpaceXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtCompositeXType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub resource_id: u32,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub clips: Option<CtGraphicUnitClipsXElementType>,
}
impl CtCompositeXType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
}
impl WithSerializer for CtCompositeXType {
    type Serializer<'x> = quick_xml_serialize::CtCompositeXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtCompositeXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtCompositeXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Composite"),
            is_root,
        })
    }
}
impl WithDeserializer for CtCompositeXType {
    type Deserializer = quick_xml_deserialize::CtCompositeXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtDestXType {
    pub type_: CtDestTypeXType,
    pub page_id: u32,
    pub left: Option<f64>,
    pub top: Option<f64>,
    pub right: Option<f64>,
    pub bottom: Option<f64>,
    pub zoom: Option<f64>,
}
impl WithSerializer for CtDestXType {
    type Serializer<'x> = quick_xml_serialize::CtDestXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtDestXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtDestXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Dest"),
            is_root,
        })
    }
}
impl WithDeserializer for CtDestXType {
    type Deserializer = quick_xml_deserialize::CtDestXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtDocInfoXType {
    pub doc_id: String,
    pub title: Option<String>,
    pub author: Option<String>,
    pub subject: Option<String>,
    pub abstract_: Option<String>,
    pub creation_date: Option<String>,
    pub mod_date: Option<String>,
    pub doc_usage: Option<String>,
    pub cover: Option<String>,
    pub keywords: Option<CtDocInfoKeywordsXElementType>,
    pub creator: Option<String>,
    pub creator_version: Option<String>,
    pub custom_datas: Option<CtDocInfoCustomDatasXElementType>,
}
impl WithSerializer for CtDocInfoXType {
    type Serializer<'x> = quick_xml_serialize::CtDocInfoXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtDocInfoXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtDocInfoXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_DocInfo"),
            is_root,
        })
    }
}
impl WithDeserializer for CtDocInfoXType {
    type Deserializer = quick_xml_deserialize::CtDocInfoXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtDrawParamXType {
    pub relative: Option<u32>,
    pub line_width: f64,
    pub join: String,
    pub cap: String,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub miter_limit: f64,
    pub fill_color: Option<CtColorXType>,
    pub stroke_color: Option<CtColorXType>,
}
impl CtDrawParamXType {
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_join() -> String {
        String::from("Miter")
    }
    #[must_use]
    pub fn default_cap() -> String {
        String::from("Butt")
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
}
impl WithSerializer for CtDrawParamXType {
    type Serializer<'x> = quick_xml_serialize::CtDrawParamXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtDrawParamXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtDrawParamXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_DrawParam"),
            is_root,
        })
    }
}
impl WithDeserializer for CtDrawParamXType {
    type Deserializer = quick_xml_deserialize::CtDrawParamXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtExtensionXType {
    pub app_name: String,
    pub company: Option<String>,
    pub app_version: Option<String>,
    pub date: Option<String>,
    pub ref_id: u32,
    pub content: Vec<CtExtensionXTypeContent>,
}
#[derive(Debug)]
pub enum CtExtensionXTypeContent {
    Property(CtExtensionPropertyXElementType),
    Data(xs::AnyTypeXType),
    ExtendData(String),
}
impl WithSerializer for CtExtensionXType {
    type Serializer<'x> = quick_xml_serialize::CtExtensionXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtExtensionXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtExtensionXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Extension"),
            is_root,
        })
    }
}
impl WithSerializer for CtExtensionXTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtExtensionXTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::CtExtensionXTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtExtensionXTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for CtExtensionXType {
    type Deserializer = quick_xml_deserialize::CtExtensionXTypeDeserializer;
}
impl WithDeserializer for CtExtensionXTypeContent {
    type Deserializer = quick_xml_deserialize::CtExtensionXTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtFontXType {
    pub font_name: String,
    pub family_name: Option<String>,
    pub charset: CtFontCharsetXType,
    pub italic: bool,
    pub bold: bool,
    pub serif: bool,
    pub fixed_width: bool,
    pub font_file: Option<String>,
}
impl CtFontXType {
    #[must_use]
    pub fn default_charset() -> CtFontCharsetXType {
        CtFontCharsetXType::Unicode
    }
    #[must_use]
    pub fn default_italic() -> bool {
        false
    }
    #[must_use]
    pub fn default_bold() -> bool {
        false
    }
    #[must_use]
    pub fn default_serif() -> bool {
        false
    }
    #[must_use]
    pub fn default_fixed_width() -> bool {
        false
    }
}
impl WithSerializer for CtFontXType {
    type Serializer<'x> = quick_xml_serialize::CtFontXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtFontXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtFontXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Font"),
            is_root,
        })
    }
}
impl WithDeserializer for CtFontXType {
    type Deserializer = quick_xml_deserialize::CtFontXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtGouraudShdXType {
    pub extend: Option<i32>,
    pub point: Vec<CtGouraudShdPointXElementType>,
    pub back_color: Option<Box<CtColorXType>>,
}
impl WithSerializer for CtGouraudShdXType {
    type Serializer<'x> = quick_xml_serialize::CtGouraudShdXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtGouraudShdXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtGouraudShdXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_GouraudShd"),
            is_root,
        })
    }
}
impl WithDeserializer for CtGouraudShdXType {
    type Deserializer = quick_xml_deserialize::CtGouraudShdXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtGraphicUnitXType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub clips: Option<CtGraphicUnitClipsXElementType>,
}
impl CtGraphicUnitXType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
}
impl WithSerializer for CtGraphicUnitXType {
    type Serializer<'x> = quick_xml_serialize::CtGraphicUnitXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtGraphicUnitXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtGraphicUnitXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_GraphicUnit"),
            is_root,
        })
    }
}
impl WithDeserializer for CtGraphicUnitXType {
    type Deserializer = quick_xml_deserialize::CtGraphicUnitXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtImageXType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub resource_id: u32,
    pub substitution: Option<u32>,
    pub image_mask: Option<u32>,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub clips: Option<CtGraphicUnitClipsXElementType>,
    pub border: Option<CtImageBorderXElementType>,
}
impl CtImageXType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
}
impl WithSerializer for CtImageXType {
    type Serializer<'x> = quick_xml_serialize::CtImageXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtImageXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtImageXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Image"),
            is_root,
        })
    }
}
impl WithDeserializer for CtImageXType {
    type Deserializer = quick_xml_deserialize::CtImageXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtLaGouraudShdXType {
    pub vertices_per_row: i32,
    pub extend: Option<i32>,
    pub point: Vec<CtLaGouraudShdPointXElementType>,
    pub back_color: Option<Box<CtColorXType>>,
}
impl WithSerializer for CtLaGouraudShdXType {
    type Serializer<'x> = quick_xml_serialize::CtLaGouraudShdXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtLaGouraudShdXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtLaGouraudShdXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_LaGouraudShd"),
            is_root,
        })
    }
}
impl WithDeserializer for CtLaGouraudShdXType {
    type Deserializer = quick_xml_deserialize::CtLaGouraudShdXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtLayerXType {
    pub type_: CtLayerTypeXType,
    pub draw_param: Option<u32>,
    pub content: Vec<CtLayerXTypeContent>,
}
#[derive(Debug)]
pub enum CtLayerXTypeContent {
    TextObject(CtPageBlockTextObjectXElementType),
    PathObject(CtPageBlockPathObjectXElementType),
    ImageObject(CtPageBlockImageObjectXElementType),
    CompositeObject(CtPageBlockCompositeObjectXElementType),
    PageBlock(CtPageBlockPageBlockXElementType),
}
impl CtLayerXType {
    #[must_use]
    pub fn default_type_() -> CtLayerTypeXType {
        CtLayerTypeXType::Body
    }
}
impl WithSerializer for CtLayerXType {
    type Serializer<'x> = quick_xml_serialize::CtLayerXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtLayerXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtLayerXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Layer"),
            is_root,
        })
    }
}
impl WithSerializer for CtLayerXTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtLayerXTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::CtLayerXTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtLayerXTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for CtLayerXType {
    type Deserializer = quick_xml_deserialize::CtLayerXTypeDeserializer;
}
impl WithDeserializer for CtLayerXTypeContent {
    type Deserializer = quick_xml_deserialize::CtLayerXTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtMultiMediaXType {
    pub type_: CtMultiMediaTypeXType,
    pub format: Option<String>,
    pub media_file: String,
}
impl WithSerializer for CtMultiMediaXType {
    type Serializer<'x> = quick_xml_serialize::CtMultiMediaXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtMultiMediaXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtMultiMediaXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_MultiMedia"),
            is_root,
        })
    }
}
impl WithDeserializer for CtMultiMediaXType {
    type Deserializer = quick_xml_deserialize::CtMultiMediaXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtOutlineElemXType {
    pub title: String,
    pub count: Option<i32>,
    pub expanded: bool,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub outline_elem: Vec<CtOutlineElemXType>,
}
impl CtOutlineElemXType {
    #[must_use]
    pub fn default_expanded() -> bool {
        true
    }
}
impl WithSerializer for CtOutlineElemXType {
    type Serializer<'x> = quick_xml_serialize::CtOutlineElemXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtOutlineElemXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtOutlineElemXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_OutlineElem"),
            is_root,
        })
    }
}
impl WithDeserializer for CtOutlineElemXType {
    type Deserializer = quick_xml_deserialize::CtOutlineElemXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtPageAreaXType {
    pub physical_box: String,
    pub application_box: Option<String>,
    pub content_box: Option<String>,
    pub bleed_box: Option<String>,
}
impl WithSerializer for CtPageAreaXType {
    type Serializer<'x> = quick_xml_serialize::CtPageAreaXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtPageAreaXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtPageAreaXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_PageArea"),
            is_root,
        })
    }
}
impl WithDeserializer for CtPageAreaXType {
    type Deserializer = quick_xml_deserialize::CtPageAreaXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtPageBlockXType {
    pub content: Vec<CtPageBlockXTypeContent>,
}
#[derive(Debug)]
pub enum CtPageBlockXTypeContent {
    TextObject(CtPageBlockTextObjectXElementType),
    PathObject(CtPageBlockPathObjectXElementType),
    ImageObject(CtPageBlockImageObjectXElementType),
    CompositeObject(CtPageBlockCompositeObjectXElementType),
    PageBlock(CtPageBlockPageBlockXElementType),
}
impl WithSerializer for CtPageBlockXType {
    type Serializer<'x> = quick_xml_serialize::CtPageBlockXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtPageBlockXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtPageBlockXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_PageBlock"),
            is_root,
        })
    }
}
impl WithSerializer for CtPageBlockXTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtPageBlockXTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::CtPageBlockXTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtPageBlockXTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for CtPageBlockXType {
    type Deserializer = quick_xml_deserialize::CtPageBlockXTypeDeserializer;
}
impl WithDeserializer for CtPageBlockXTypeContent {
    type Deserializer = quick_xml_deserialize::CtPageBlockXTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtPathXType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub stroke: bool,
    pub fill: bool,
    pub rule: CtPathRuleXType,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub clips: Option<CtGraphicUnitClipsXElementType>,
    pub stroke_color: Option<CtColorXType>,
    pub fill_color: Option<CtColorXType>,
    pub abbreviated_data: String,
}
impl CtPathXType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
    #[must_use]
    pub fn default_stroke() -> bool {
        true
    }
    #[must_use]
    pub fn default_fill() -> bool {
        false
    }
    #[must_use]
    pub fn default_rule() -> CtPathRuleXType {
        CtPathRuleXType::NonZero
    }
}
impl WithSerializer for CtPathXType {
    type Serializer<'x> = quick_xml_serialize::CtPathXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtPathXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtPathXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Path"),
            is_root,
        })
    }
}
impl WithDeserializer for CtPathXType {
    type Deserializer = quick_xml_deserialize::CtPathXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtPatternXType {
    pub width: f64,
    pub height: f64,
    pub x_step: Option<f64>,
    pub y_step: Option<f64>,
    pub reflect_method: CtPatternReflectMethodXType,
    pub relative_to: CtPatternRelativeToXType,
    pub ctm: Option<String>,
    pub cell_content: CtPatternCellContentXElementType,
}
impl CtPatternXType {
    #[must_use]
    pub fn default_reflect_method() -> CtPatternReflectMethodXType {
        CtPatternReflectMethodXType::Normal
    }
    #[must_use]
    pub fn default_relative_to() -> CtPatternRelativeToXType {
        CtPatternRelativeToXType::Object
    }
}
impl WithSerializer for CtPatternXType {
    type Serializer<'x> = quick_xml_serialize::CtPatternXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtPatternXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtPatternXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Pattern"),
            is_root,
        })
    }
}
impl WithDeserializer for CtPatternXType {
    type Deserializer = quick_xml_deserialize::CtPatternXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtPermissionXType {
    pub edit: Option<bool>,
    pub annot: Option<bool>,
    pub export: Option<bool>,
    pub signature: Option<bool>,
    pub watermark: Option<bool>,
    pub print_screen: Option<bool>,
    pub print: Option<CtPermissionPrintXElementType>,
    pub valid_period: Option<CtPermissionValidPeriodXElementType>,
}
impl WithSerializer for CtPermissionXType {
    type Serializer<'x> = quick_xml_serialize::CtPermissionXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtPermissionXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtPermissionXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Permission"),
            is_root,
        })
    }
}
impl WithDeserializer for CtPermissionXType {
    type Deserializer = quick_xml_deserialize::CtPermissionXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtRadialShdXType {
    pub map_type: CtAxialShdMapTypeXType,
    pub map_unit: Option<f64>,
    pub eccentricity: f64,
    pub angle: f64,
    pub start_point: String,
    pub start_radius: f64,
    pub end_point: String,
    pub end_radius: f64,
    pub extend: i32,
    pub seqment: Vec<CtAxialShdSegmentXElementType>,
}
impl CtRadialShdXType {
    #[must_use]
    pub fn default_map_type() -> CtAxialShdMapTypeXType {
        CtAxialShdMapTypeXType::Direct
    }
    #[must_use]
    pub fn default_eccentricity() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_angle() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_start_radius() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_extend() -> i32 {
        0i32
    }
}
impl WithSerializer for CtRadialShdXType {
    type Serializer<'x> = quick_xml_serialize::CtRadialShdXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtRadialShdXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtRadialShdXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_RadialShd"),
            is_root,
        })
    }
}
impl WithDeserializer for CtRadialShdXType {
    type Deserializer = quick_xml_deserialize::CtRadialShdXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtRegionXType {
    pub area: Vec<CtRegionAreaXElementType>,
}
impl WithSerializer for CtRegionXType {
    type Serializer<'x> = quick_xml_serialize::CtRegionXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtRegionXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtRegionXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Region"),
            is_root,
        })
    }
}
impl WithDeserializer for CtRegionXType {
    type Deserializer = quick_xml_deserialize::CtRegionXTypeDeserializer;
}
#[derive(Debug)]
pub struct CtTextXType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub font: u32,
    pub size: f64,
    pub stroke: bool,
    pub fill: bool,
    pub h_scale: f64,
    pub read_direction: i32,
    pub char_direction: i32,
    pub weight: CtTextWeightXType,
    pub italic: bool,
    pub content: Vec<CtTextXTypeContent>,
}
#[derive(Debug)]
pub enum CtTextXTypeContent {
    Actions(CtGraphicUnitActionsXElementType),
    Clips(CtGraphicUnitClipsXElementType),
    FillColor(CtColorXType),
    StrokeColor(CtColorXType),
    CgTransform(CtCgTransformXType),
    TextCode(CtTextTextCodeXElementType),
}
impl CtTextXType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
    #[must_use]
    pub fn default_stroke() -> bool {
        false
    }
    #[must_use]
    pub fn default_fill() -> bool {
        true
    }
    #[must_use]
    pub fn default_h_scale() -> f64 {
        1f64
    }
    #[must_use]
    pub fn default_read_direction() -> i32 {
        0i32
    }
    #[must_use]
    pub fn default_char_direction() -> i32 {
        0i32
    }
    #[must_use]
    pub fn default_weight() -> CtTextWeightXType {
        CtTextWeightXType::_400
    }
    #[must_use]
    pub fn default_italic() -> bool {
        false
    }
}
impl WithSerializer for CtTextXType {
    type Serializer<'x> = quick_xml_serialize::CtTextXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtTextXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtTextXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_Text"),
            is_root,
        })
    }
}
impl WithSerializer for CtTextXTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtTextXTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::CtTextXTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtTextXTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for CtTextXType {
    type Deserializer = quick_xml_deserialize::CtTextXTypeDeserializer;
}
impl WithDeserializer for CtTextXTypeContent {
    type Deserializer = quick_xml_deserialize::CtTextXTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtVPreferencesXType {
    pub content: Vec<CtVPreferencesXTypeContent>,
}
#[derive(Debug)]
pub enum CtVPreferencesXTypeContent {
    PageMode(CtVPreferencesPageModeXElementType),
    PageLayout(CtVPreferencesPageLayoutXElementType),
    TabDisplay(CtVPreferencesTabDisplayXElementType),
    HideToolbar(bool),
    HideMenubar(bool),
    HideWindowUi(bool),
    ZoomMode(CtVPreferencesZoomModeXElementType),
    Zoom(f64),
}
impl WithSerializer for CtVPreferencesXType {
    type Serializer<'x> = quick_xml_serialize::CtVPreferencesXTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtVPreferencesXTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtVPreferencesXTypeSerializerState::Init__),
            name: name.unwrap_or("CT_VPreferences"),
            is_root,
        })
    }
}
impl WithSerializer for CtVPreferencesXTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtVPreferencesXTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::CtVPreferencesXTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtVPreferencesXTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for CtVPreferencesXType {
    type Deserializer = quick_xml_deserialize::CtVPreferencesXTypeDeserializer;
}
impl WithDeserializer for CtVPreferencesXTypeContent {
    type Deserializer = quick_xml_deserialize::CtVPreferencesXTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtVectorGxType {
    pub width: f64,
    pub height: f64,
    pub thumbnail: Option<u32>,
    pub substitution: Option<u32>,
    pub content: CtPageBlockXType,
}
impl WithSerializer for CtVectorGxType {
    type Serializer<'x> = quick_xml_serialize::CtVectorGxTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtVectorGxTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtVectorGxTypeSerializerState::Init__),
            name: name.unwrap_or("CT_VectorG"),
            is_root,
        })
    }
}
impl WithDeserializer for CtVectorGxType {
    type Deserializer = quick_xml_deserialize::CtVectorGxTypeDeserializer;
}
pub type CustomTags = CustomTagsXElementType;
#[derive(Debug)]
pub struct CustomTagsXElementType {
    pub custom_tag: Vec<CustomTagsCustomTagXElementType>,
}
impl WithSerializer for CustomTagsXElementType {
    type Serializer<'x> = quick_xml_serialize::CustomTagsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CustomTagsXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CustomTagsXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CustomTags"),
            is_root,
        })
    }
}
impl WithDeserializer for CustomTagsXElementType {
    type Deserializer = quick_xml_deserialize::CustomTagsXElementTypeDeserializer;
}
pub type DocVersion = DocVersionXElementType;
#[derive(Debug)]
pub struct DocVersionXElementType {
    pub id: String,
    pub version: Option<String>,
    pub name: Option<String>,
    pub creation_date: Option<String>,
    pub file_list: DocVersionFileListXElementType,
    pub doc_root: String,
}
impl WithSerializer for DocVersionXElementType {
    type Serializer<'x> = quick_xml_serialize::DocVersionXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DocVersionXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DocVersionXElementTypeSerializerState::Init__),
            name: name.unwrap_or("DocVersion"),
            is_root,
        })
    }
}
impl WithDeserializer for DocVersionXElementType {
    type Deserializer = quick_xml_deserialize::DocVersionXElementTypeDeserializer;
}
pub type Document = DocumentXElementType;
#[derive(Debug)]
pub struct DocumentXElementType {
    pub common_data: DocumentCommonDataXElementType,
    pub pages: DocumentPagesXElementType,
    pub outlines: Option<DocumentOutlinesXElementType>,
    pub permissions: Option<CtPermissionXType>,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub v_preferences: Option<CtVPreferencesXType>,
    pub bookmarks: Option<DocumentBookmarksXElementType>,
    pub annotations: Option<String>,
    pub custom_tags: Option<String>,
    pub attachments: Option<String>,
    pub extensions: Option<String>,
}
impl WithSerializer for DocumentXElementType {
    type Serializer<'x> = quick_xml_serialize::DocumentXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DocumentXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DocumentXElementTypeSerializerState::Init__),
            name: name.unwrap_or("Document"),
            is_root,
        })
    }
}
impl WithDeserializer for DocumentXElementType {
    type Deserializer = quick_xml_deserialize::DocumentXElementTypeDeserializer;
}
pub type Extensions = ExtensionsXElementType;
#[derive(Debug)]
pub struct ExtensionsXElementType {
    pub extension: Vec<CtExtensionXType>,
}
impl WithSerializer for ExtensionsXElementType {
    type Serializer<'x> = quick_xml_serialize::ExtensionsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ExtensionsXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ExtensionsXElementTypeSerializerState::Init__),
            name: name.unwrap_or("Extensions"),
            is_root,
        })
    }
}
impl WithDeserializer for ExtensionsXElementType {
    type Deserializer = quick_xml_deserialize::ExtensionsXElementTypeDeserializer;
}
pub type Ofd = OfdXElementType;
#[derive(Debug)]
pub struct OfdXElementType {
    pub version: String,
    pub doc_type: OfdDocTypeXType,
    pub doc_body: Vec<OfdDocBodyXElementType>,
}
impl WithSerializer for OfdXElementType {
    type Serializer<'x> = quick_xml_serialize::OfdXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::OfdXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::OfdXElementTypeSerializerState::Init__),
            name: name.unwrap_or("OFD"),
            is_root,
        })
    }
}
impl WithDeserializer for OfdXElementType {
    type Deserializer = quick_xml_deserialize::OfdXElementTypeDeserializer;
}
pub type Page = PageXElementType;
#[derive(Debug)]
pub struct PageXElementType {
    pub template: Vec<PageTemplateXElementType>,
    pub page_res: Vec<String>,
    pub area: Option<CtPageAreaXType>,
    pub content: Option<PageContentXElementType>,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
}
impl WithSerializer for PageXElementType {
    type Serializer<'x> = quick_xml_serialize::PageXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PageXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PageXElementTypeSerializerState::Init__),
            name: name.unwrap_or("Page"),
            is_root,
        })
    }
}
impl WithDeserializer for PageXElementType {
    type Deserializer = quick_xml_deserialize::PageXElementTypeDeserializer;
}
pub type PageAnnot = PageAnnotXElementType;
#[derive(Debug)]
pub struct PageAnnotXElementType {
    pub annot: Vec<PageAnnotAnnotXElementType>,
}
impl WithSerializer for PageAnnotXElementType {
    type Serializer<'x> = quick_xml_serialize::PageAnnotXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PageAnnotXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PageAnnotXElementTypeSerializerState::Init__),
            name: name.unwrap_or("PageAnnot"),
            is_root,
        })
    }
}
impl WithDeserializer for PageAnnotXElementType {
    type Deserializer = quick_xml_deserialize::PageAnnotXElementTypeDeserializer;
}
pub type Res = ResXElementType;
#[derive(Debug)]
pub struct ResXElementType {
    pub base_loc: String,
    pub content: Vec<ResXElementTypeContent>,
}
#[derive(Debug)]
pub enum ResXElementTypeContent {
    ColorSpaces(ResColorSpacesXElementType),
    DrawParams(ResDrawParamsXElementType),
    Fonts(ResFontsXElementType),
    MultiMedias(ResMultiMediasXElementType),
    CompositeGraphicUnits(ResCompositeGraphicUnitsXElementType),
}
impl WithSerializer for ResXElementType {
    type Serializer<'x> = quick_xml_serialize::ResXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ResXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ResXElementTypeSerializerState::Init__),
            name: name.unwrap_or("Res"),
            is_root,
        })
    }
}
impl WithSerializer for ResXElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::ResXElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::ResXElementTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ResXElementTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for ResXElementType {
    type Deserializer = quick_xml_deserialize::ResXElementTypeDeserializer;
}
impl WithDeserializer for ResXElementTypeContent {
    type Deserializer = quick_xml_deserialize::ResXElementTypeContentDeserializer;
}
pub type StArrayXType = String;
pub type StBoxXType = String;
pub type StIdXType = u32;
pub type StLocXType = String;
pub type StPosXType = String;
pub type StRefIdXType = u32;
pub type Sianature = SianatureXElementType;
#[derive(Debug)]
pub struct SianatureXElementType {
    pub siqned_info: SianatureSiqnedInfoXElementType,
    pub signed_value: String,
}
impl WithSerializer for SianatureXElementType {
    type Serializer<'x> = quick_xml_serialize::SianatureXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SianatureXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SianatureXElementTypeSerializerState::Init__),
            name: name.unwrap_or("Sianature"),
            is_root,
        })
    }
}
impl WithDeserializer for SianatureXElementType {
    type Deserializer = quick_xml_deserialize::SianatureXElementTypeDeserializer;
}
pub type Siqnatures = SiqnaturesXElementType;
#[derive(Debug)]
pub struct SiqnaturesXElementType {
    pub max_sign_id: Option<String>,
    pub signature: Vec<SiqnaturesSignatureXElementType>,
}
impl WithSerializer for SiqnaturesXElementType {
    type Serializer<'x> = quick_xml_serialize::SiqnaturesXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SiqnaturesXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SiqnaturesXElementTypeSerializerState::Init__),
            name: name.unwrap_or("Siqnatures"),
            is_root,
        })
    }
}
impl WithDeserializer for SiqnaturesXElementType {
    type Deserializer = quick_xml_deserialize::SiqnaturesXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct AnnotationsPageXElementType {
    pub page_id: u32,
    pub file_loc: String,
}
impl WithSerializer for AnnotationsPageXElementType {
    type Serializer<'x> = quick_xml_serialize::AnnotationsPageXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::AnnotationsPageXElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::AnnotationsPageXElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("AnnotationsPage"),
            is_root,
        })
    }
}
impl WithDeserializer for AnnotationsPageXElementType {
    type Deserializer = quick_xml_deserialize::AnnotationsPageXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtActionEventXType {
    Do,
    Po,
    Click,
}
impl SerializeBytes for CtActionEventXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Do => Ok(Some(Cow::Borrowed("DO"))),
            Self::Po => Ok(Some(Cow::Borrowed("PO"))),
            Self::Click => Ok(Some(Cow::Borrowed("CLICK"))),
        }
    }
}
impl DeserializeBytes for CtActionEventXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"DO" => Ok(Self::Do),
            b"PO" => Ok(Self::Po),
            b"CLICK" => Ok(Self::Click),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtActionGotoXElementType {
    Dest(CtDestXType),
    Bookmark(CtActionGotoBookmarkXElementType),
}
impl WithSerializer for CtActionGotoXElementType {
    type Serializer<'x> = quick_xml_serialize::CtActionGotoXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtActionGotoXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtActionGotoXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtActionGoto"),
            is_root,
        })
    }
}
impl WithDeserializer for CtActionGotoXElementType {
    type Deserializer = quick_xml_deserialize::CtActionGotoXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtActionUriXElementType {
    pub uri: String,
    pub base: Option<String>,
    pub target: Option<String>,
}
impl WithSerializer for CtActionUriXElementType {
    type Serializer<'x> = quick_xml_serialize::CtActionUriXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtActionUriXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtActionUriXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtActionUri"),
            is_root,
        })
    }
}
impl WithDeserializer for CtActionUriXElementType {
    type Deserializer = quick_xml_deserialize::CtActionUriXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtActionGotoAxElementType {
    pub attach_id: String,
    pub new_window: bool,
}
impl CtActionGotoAxElementType {
    #[must_use]
    pub fn default_new_window() -> bool {
        true
    }
}
impl WithSerializer for CtActionGotoAxElementType {
    type Serializer<'x> = quick_xml_serialize::CtActionGotoAxElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtActionGotoAxElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtActionGotoAxElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtActionGotoA"),
            is_root,
        })
    }
}
impl WithDeserializer for CtActionGotoAxElementType {
    type Deserializer = quick_xml_deserialize::CtActionGotoAxElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtActionSoundXElementType {
    pub resource_id: u32,
    pub volume: Option<i32>,
    pub repeat: Option<bool>,
    pub synchronous: Option<bool>,
}
impl WithSerializer for CtActionSoundXElementType {
    type Serializer<'x> = quick_xml_serialize::CtActionSoundXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtActionSoundXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtActionSoundXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtActionSound"),
            is_root,
        })
    }
}
impl WithDeserializer for CtActionSoundXElementType {
    type Deserializer = quick_xml_deserialize::CtActionSoundXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtActionMovieXElementType {
    pub resource_id: u32,
    pub operator: CtActionMovieOperatorXType,
}
impl CtActionMovieXElementType {
    #[must_use]
    pub fn default_operator() -> CtActionMovieOperatorXType {
        CtActionMovieOperatorXType::Play
    }
}
impl WithSerializer for CtActionMovieXElementType {
    type Serializer<'x> = quick_xml_serialize::CtActionMovieXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtActionMovieXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtActionMovieXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtActionMovie"),
            is_root,
        })
    }
}
impl WithDeserializer for CtActionMovieXElementType {
    type Deserializer = quick_xml_deserialize::CtActionMovieXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtAxialShdMapTypeXType {
    Direct,
    Repeat,
    Reflect,
}
impl SerializeBytes for CtAxialShdMapTypeXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Direct => Ok(Some(Cow::Borrowed("Direct"))),
            Self::Repeat => Ok(Some(Cow::Borrowed("Repeat"))),
            Self::Reflect => Ok(Some(Cow::Borrowed("Reflect"))),
        }
    }
}
impl DeserializeBytes for CtAxialShdMapTypeXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Direct" => Ok(Self::Direct),
            b"Repeat" => Ok(Self::Repeat),
            b"Reflect" => Ok(Self::Reflect),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtAxialShdExtendXType {
    _0,
    _1,
    _2,
    _3,
}
impl SerializeBytes for CtAxialShdExtendXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_0 => Ok(Some(Cow::Borrowed("0"))),
            Self::_1 => Ok(Some(Cow::Borrowed("1"))),
            Self::_2 => Ok(Some(Cow::Borrowed("2"))),
            Self::_3 => Ok(Some(Cow::Borrowed("3"))),
        }
    }
}
impl DeserializeBytes for CtAxialShdExtendXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"0" => Ok(Self::_0),
            b"1" => Ok(Self::_1),
            b"2" => Ok(Self::_2),
            b"3" => Ok(Self::_3),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtAxialShdSegmentXElementType {
    pub position: Option<f64>,
    pub color: CtColorXType,
}
impl WithSerializer for CtAxialShdSegmentXElementType {
    type Serializer<'x> = quick_xml_serialize::CtAxialShdSegmentXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtAxialShdSegmentXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtAxialShdSegmentXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtAxialShdSegment"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtAxialShdSegmentXElementType {
    type Deserializer = quick_xml_deserialize::CtAxialShdSegmentXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtClipAreaXElementType {
    pub draw_param: Option<u32>,
    pub ctm: Option<String>,
    pub content: CtClipAreaXElementTypeContent,
}
#[derive(Debug)]
pub enum CtClipAreaXElementTypeContent {
    Path(CtPathXType),
    Text(CtTextXType),
}
impl WithSerializer for CtClipAreaXElementType {
    type Serializer<'x> = quick_xml_serialize::CtClipAreaXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtClipAreaXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtClipAreaXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtClipArea"),
            is_root,
        })
    }
}
impl WithSerializer for CtClipAreaXElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtClipAreaXElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(
            quick_xml_serialize::CtClipAreaXElementTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtClipAreaXElementTypeContentSerializerState::Init__,
                ),
            },
        )
    }
}
impl WithDeserializer for CtClipAreaXElementType {
    type Deserializer = quick_xml_deserialize::CtClipAreaXElementTypeDeserializer;
}
impl WithDeserializer for CtClipAreaXElementTypeContent {
    type Deserializer = quick_xml_deserialize::CtClipAreaXElementTypeContentDeserializer;
}
#[derive(Debug)]
pub enum CtColorSpaceTypeXType {
    Gray,
    Rgb,
    Cmyk,
}
impl SerializeBytes for CtColorSpaceTypeXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Gray => Ok(Some(Cow::Borrowed("GRAY"))),
            Self::Rgb => Ok(Some(Cow::Borrowed("RGB"))),
            Self::Cmyk => Ok(Some(Cow::Borrowed("CMYK"))),
        }
    }
}
impl DeserializeBytes for CtColorSpaceTypeXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"GRAY" => Ok(Self::Gray),
            b"RGB" => Ok(Self::Rgb),
            b"CMYK" => Ok(Self::Cmyk),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtColorSpacePaletteXElementType {
    pub cv: Vec<String>,
}
impl WithSerializer for CtColorSpacePaletteXElementType {
    type Serializer<'x> = quick_xml_serialize::CtColorSpacePaletteXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtColorSpacePaletteXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtColorSpacePaletteXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtColorSpacePalette"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtColorSpacePaletteXElementType {
    type Deserializer = quick_xml_deserialize::CtColorSpacePaletteXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtGraphicUnitCapXType {
    Butt,
    Round,
    Square,
}
impl SerializeBytes for CtGraphicUnitCapXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Butt => Ok(Some(Cow::Borrowed("Butt"))),
            Self::Round => Ok(Some(Cow::Borrowed("Round"))),
            Self::Square => Ok(Some(Cow::Borrowed("Square"))),
        }
    }
}
impl DeserializeBytes for CtGraphicUnitCapXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Butt" => Ok(Self::Butt),
            b"Round" => Ok(Self::Round),
            b"Square" => Ok(Self::Square),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtGraphicUnitJoinXType {
    Miter,
    Round,
    Bevel,
}
impl SerializeBytes for CtGraphicUnitJoinXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Miter => Ok(Some(Cow::Borrowed("Miter"))),
            Self::Round => Ok(Some(Cow::Borrowed("Round"))),
            Self::Bevel => Ok(Some(Cow::Borrowed("Bevel"))),
        }
    }
}
impl DeserializeBytes for CtGraphicUnitJoinXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Miter" => Ok(Self::Miter),
            b"Round" => Ok(Self::Round),
            b"Bevel" => Ok(Self::Bevel),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtGraphicUnitActionsXElementType {
    pub action: Vec<CtActionXType>,
}
impl WithSerializer for CtGraphicUnitActionsXElementType {
    type Serializer<'x> = quick_xml_serialize::CtGraphicUnitActionsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtGraphicUnitActionsXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtGraphicUnitActionsXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtGraphicUnitActions"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtGraphicUnitActionsXElementType {
    type Deserializer = quick_xml_deserialize::CtGraphicUnitActionsXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtGraphicUnitClipsXElementType {
    pub clip: Vec<CtClipXType>,
}
impl WithSerializer for CtGraphicUnitClipsXElementType {
    type Serializer<'x> = quick_xml_serialize::CtGraphicUnitClipsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtGraphicUnitClipsXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtGraphicUnitClipsXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtGraphicUnitClips"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtGraphicUnitClipsXElementType {
    type Deserializer = quick_xml_deserialize::CtGraphicUnitClipsXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtDestTypeXType {
    Xyz,
    Fit,
    FitH,
    FitV,
    FitR,
}
impl SerializeBytes for CtDestTypeXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Xyz => Ok(Some(Cow::Borrowed("XYZ"))),
            Self::Fit => Ok(Some(Cow::Borrowed("Fit"))),
            Self::FitH => Ok(Some(Cow::Borrowed("FitH"))),
            Self::FitV => Ok(Some(Cow::Borrowed("FitV"))),
            Self::FitR => Ok(Some(Cow::Borrowed("FitR"))),
        }
    }
}
impl DeserializeBytes for CtDestTypeXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"XYZ" => Ok(Self::Xyz),
            b"Fit" => Ok(Self::Fit),
            b"FitH" => Ok(Self::FitH),
            b"FitV" => Ok(Self::FitV),
            b"FitR" => Ok(Self::FitR),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtDocInfoKeywordsXElementType {
    pub keyword: Vec<String>,
}
impl WithSerializer for CtDocInfoKeywordsXElementType {
    type Serializer<'x> = quick_xml_serialize::CtDocInfoKeywordsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtDocInfoKeywordsXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtDocInfoKeywordsXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtDocInfoKeywords"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtDocInfoKeywordsXElementType {
    type Deserializer = quick_xml_deserialize::CtDocInfoKeywordsXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtDocInfoCustomDatasXElementType {
    pub custom_data: Vec<CtDocInfoCustomDatasCustomDataXElementType>,
}
impl WithSerializer for CtDocInfoCustomDatasXElementType {
    type Serializer<'x> = quick_xml_serialize::CtDocInfoCustomDatasXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtDocInfoCustomDatasXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtDocInfoCustomDatasXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtDocInfoCustomDatas"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtDocInfoCustomDatasXElementType {
    type Deserializer = quick_xml_deserialize::CtDocInfoCustomDatasXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtExtensionPropertyXElementType {
    pub name: String,
    pub type_: Option<String>,
    pub content: String,
}
impl WithSerializer for CtExtensionPropertyXElementType {
    type Serializer<'x> = quick_xml_serialize::CtExtensionPropertyXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtExtensionPropertyXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtExtensionPropertyXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtExtensionProperty"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtExtensionPropertyXElementType {
    type Deserializer = quick_xml_deserialize::CtExtensionPropertyXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtFontCharsetXType {
    Symbol,
    Prc,
    Big5,
    ShiftIis,
    Wansung,
    Johab,
    Unicode,
}
impl SerializeBytes for CtFontCharsetXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Symbol => Ok(Some(Cow::Borrowed("symbol"))),
            Self::Prc => Ok(Some(Cow::Borrowed("prc"))),
            Self::Big5 => Ok(Some(Cow::Borrowed("big5"))),
            Self::ShiftIis => Ok(Some(Cow::Borrowed("shift-iis"))),
            Self::Wansung => Ok(Some(Cow::Borrowed("wansung"))),
            Self::Johab => Ok(Some(Cow::Borrowed("johab"))),
            Self::Unicode => Ok(Some(Cow::Borrowed("unicode"))),
        }
    }
}
impl DeserializeBytes for CtFontCharsetXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"symbol" => Ok(Self::Symbol),
            b"prc" => Ok(Self::Prc),
            b"big5" => Ok(Self::Big5),
            b"shift-iis" => Ok(Self::ShiftIis),
            b"wansung" => Ok(Self::Wansung),
            b"johab" => Ok(Self::Johab),
            b"unicode" => Ok(Self::Unicode),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtGouraudShdPointXElementType {
    pub x: f64,
    pub y: f64,
    pub edge_flag: Option<CtGouraudShdPointEdgeFlagXType>,
    pub color: CtColorXType,
}
impl WithSerializer for CtGouraudShdPointXElementType {
    type Serializer<'x> = quick_xml_serialize::CtGouraudShdPointXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtGouraudShdPointXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtGouraudShdPointXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtGouraudShdPoint"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtGouraudShdPointXElementType {
    type Deserializer = quick_xml_deserialize::CtGouraudShdPointXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtImageBorderXElementType {
    pub line_width: f64,
    pub horizonal_corner_radius: f64,
    pub vertical_corner_radius: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub border_color: Option<CtColorXType>,
}
impl CtImageBorderXElementType {
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_horizonal_corner_radius() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_vertical_corner_radius() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
}
impl WithSerializer for CtImageBorderXElementType {
    type Serializer<'x> = quick_xml_serialize::CtImageBorderXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtImageBorderXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtImageBorderXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtImageBorder"),
            is_root,
        })
    }
}
impl WithDeserializer for CtImageBorderXElementType {
    type Deserializer = quick_xml_deserialize::CtImageBorderXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtLaGouraudShdPointXElementType {
    pub x: Option<f64>,
    pub y: Option<f64>,
    pub color: CtColorXType,
}
impl WithSerializer for CtLaGouraudShdPointXElementType {
    type Serializer<'x> = quick_xml_serialize::CtLaGouraudShdPointXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtLaGouraudShdPointXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtLaGouraudShdPointXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtLaGouraudShdPoint"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtLaGouraudShdPointXElementType {
    type Deserializer = quick_xml_deserialize::CtLaGouraudShdPointXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtLayerTypeXType {
    Body,
    Background,
    Foreground,
    Custom,
}
impl SerializeBytes for CtLayerTypeXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Body => Ok(Some(Cow::Borrowed("Body"))),
            Self::Background => Ok(Some(Cow::Borrowed("Background"))),
            Self::Foreground => Ok(Some(Cow::Borrowed("Foreground"))),
            Self::Custom => Ok(Some(Cow::Borrowed("Custom"))),
        }
    }
}
impl DeserializeBytes for CtLayerTypeXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Body" => Ok(Self::Body),
            b"Background" => Ok(Self::Background),
            b"Foreground" => Ok(Self::Foreground),
            b"Custom" => Ok(Self::Custom),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtPageBlockTextObjectXElementType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub font: u32,
    pub size: f64,
    pub stroke: bool,
    pub fill: bool,
    pub h_scale: f64,
    pub read_direction: i32,
    pub char_direction: i32,
    pub weight: CtTextWeightXType,
    pub italic: bool,
    pub id: u32,
    pub content: Vec<CtPageBlockTextObjectXElementTypeContent>,
}
#[derive(Debug)]
pub enum CtPageBlockTextObjectXElementTypeContent {
    Actions(CtGraphicUnitActionsXElementType),
    Clips(CtGraphicUnitClipsXElementType),
    FillColor(CtColorXType),
    StrokeColor(CtColorXType),
    CgTransform(CtCgTransformXType),
    TextCode(CtTextTextCodeXElementType),
}
impl CtPageBlockTextObjectXElementType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
    #[must_use]
    pub fn default_stroke() -> bool {
        false
    }
    #[must_use]
    pub fn default_fill() -> bool {
        true
    }
    #[must_use]
    pub fn default_h_scale() -> f64 {
        1f64
    }
    #[must_use]
    pub fn default_read_direction() -> i32 {
        0i32
    }
    #[must_use]
    pub fn default_char_direction() -> i32 {
        0i32
    }
    #[must_use]
    pub fn default_weight() -> CtTextWeightXType {
        CtTextWeightXType::_400
    }
    #[must_use]
    pub fn default_italic() -> bool {
        false
    }
}
impl WithSerializer for CtPageBlockTextObjectXElementType {
    type Serializer<'x> = quick_xml_serialize::CtPageBlockTextObjectXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtPageBlockTextObjectXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtPageBlockTextObjectXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtPageBlockTextObject"),
                is_root,
            },
        )
    }
}
impl WithSerializer for CtPageBlockTextObjectXElementTypeContent {
    type Serializer<'x> =
        quick_xml_serialize::CtPageBlockTextObjectXElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok (quick_xml_serialize :: CtPageBlockTextObjectXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockTextObjectXElementTypeContentSerializerState :: Init__) , })
    }
}
impl WithDeserializer for CtPageBlockTextObjectXElementType {
    type Deserializer = quick_xml_deserialize::CtPageBlockTextObjectXElementTypeDeserializer;
}
impl WithDeserializer for CtPageBlockTextObjectXElementTypeContent {
    type Deserializer = quick_xml_deserialize::CtPageBlockTextObjectXElementTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtPageBlockPathObjectXElementType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub stroke: bool,
    pub fill: bool,
    pub rule: CtPathRuleXType,
    pub id: u32,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub clips: Option<CtGraphicUnitClipsXElementType>,
    pub stroke_color: Option<CtColorXType>,
    pub fill_color: Option<CtColorXType>,
    pub abbreviated_data: String,
}
impl CtPageBlockPathObjectXElementType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
    #[must_use]
    pub fn default_stroke() -> bool {
        true
    }
    #[must_use]
    pub fn default_fill() -> bool {
        false
    }
    #[must_use]
    pub fn default_rule() -> CtPathRuleXType {
        CtPathRuleXType::NonZero
    }
}
impl WithSerializer for CtPageBlockPathObjectXElementType {
    type Serializer<'x> = quick_xml_serialize::CtPageBlockPathObjectXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtPageBlockPathObjectXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtPageBlockPathObjectXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtPageBlockPathObject"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtPageBlockPathObjectXElementType {
    type Deserializer = quick_xml_deserialize::CtPageBlockPathObjectXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtPageBlockImageObjectXElementType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub resource_id: u32,
    pub substitution: Option<u32>,
    pub image_mask: Option<u32>,
    pub id: u32,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub clips: Option<CtGraphicUnitClipsXElementType>,
    pub border: Option<CtImageBorderXElementType>,
}
impl CtPageBlockImageObjectXElementType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
}
impl WithSerializer for CtPageBlockImageObjectXElementType {
    type Serializer<'x> = quick_xml_serialize::CtPageBlockImageObjectXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtPageBlockImageObjectXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtPageBlockImageObjectXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtPageBlockImageObject"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtPageBlockImageObjectXElementType {
    type Deserializer = quick_xml_deserialize::CtPageBlockImageObjectXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtPageBlockCompositeObjectXElementType {
    pub boundary: String,
    pub name: Option<String>,
    pub visible: bool,
    pub ctm: Option<String>,
    pub draw_param: Option<u32>,
    pub line_width: f64,
    pub cap: CtGraphicUnitCapXType,
    pub join: CtGraphicUnitJoinXType,
    pub miter_limit: f64,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub alpha: i32,
    pub resource_id: u32,
    pub id: u32,
    pub actions: Option<CtGraphicUnitActionsXElementType>,
    pub clips: Option<CtGraphicUnitClipsXElementType>,
}
impl CtPageBlockCompositeObjectXElementType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_cap() -> CtGraphicUnitCapXType {
        CtGraphicUnitCapXType::Butt
    }
    #[must_use]
    pub fn default_join() -> CtGraphicUnitJoinXType {
        CtGraphicUnitJoinXType::Miter
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_alpha() -> i32 {
        255i32
    }
}
impl WithSerializer for CtPageBlockCompositeObjectXElementType {
    type Serializer<'x> = quick_xml_serialize::CtPageBlockCompositeObjectXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: CtPageBlockCompositeObjectXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockCompositeObjectXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtPageBlockCompositeObject") , is_root , })
    }
}
impl WithDeserializer for CtPageBlockCompositeObjectXElementType {
    type Deserializer = quick_xml_deserialize::CtPageBlockCompositeObjectXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtPageBlockPageBlockXElementType {
    pub id: u32,
    pub content: Vec<CtPageBlockPageBlockXElementTypeContent>,
}
#[derive(Debug)]
pub enum CtPageBlockPageBlockXElementTypeContent {
    TextObject(CtPageBlockTextObjectXElementType),
    PathObject(CtPageBlockPathObjectXElementType),
    ImageObject(CtPageBlockImageObjectXElementType),
    CompositeObject(CtPageBlockCompositeObjectXElementType),
    PageBlock(CtPageBlockPageBlockXElementType),
}
impl WithSerializer for CtPageBlockPageBlockXElementType {
    type Serializer<'x> = quick_xml_serialize::CtPageBlockPageBlockXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtPageBlockPageBlockXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtPageBlockPageBlockXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtPageBlockPageBlock"),
                is_root,
            },
        )
    }
}
impl WithSerializer for CtPageBlockPageBlockXElementTypeContent {
    type Serializer<'x> =
        quick_xml_serialize::CtPageBlockPageBlockXElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok (quick_xml_serialize :: CtPageBlockPageBlockXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockPageBlockXElementTypeContentSerializerState :: Init__) , })
    }
}
impl WithDeserializer for CtPageBlockPageBlockXElementType {
    type Deserializer = quick_xml_deserialize::CtPageBlockPageBlockXElementTypeDeserializer;
}
impl WithDeserializer for CtPageBlockPageBlockXElementTypeContent {
    type Deserializer = quick_xml_deserialize::CtPageBlockPageBlockXElementTypeContentDeserializer;
}
#[derive(Debug)]
pub enum CtMultiMediaTypeXType {
    Image,
    Audio,
    Video,
}
impl SerializeBytes for CtMultiMediaTypeXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Image => Ok(Some(Cow::Borrowed("Image"))),
            Self::Audio => Ok(Some(Cow::Borrowed("Audio"))),
            Self::Video => Ok(Some(Cow::Borrowed("Video"))),
        }
    }
}
impl DeserializeBytes for CtMultiMediaTypeXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Image" => Ok(Self::Image),
            b"Audio" => Ok(Self::Audio),
            b"Video" => Ok(Self::Video),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtPathRuleXType {
    NonZero,
    EvenOdd,
}
impl SerializeBytes for CtPathRuleXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::NonZero => Ok(Some(Cow::Borrowed("NonZero"))),
            Self::EvenOdd => Ok(Some(Cow::Borrowed("Even-Odd"))),
        }
    }
}
impl DeserializeBytes for CtPathRuleXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"NonZero" => Ok(Self::NonZero),
            b"Even-Odd" => Ok(Self::EvenOdd),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtPatternReflectMethodXType {
    Normal,
    Row,
    Column,
    RowAndColumn,
}
impl SerializeBytes for CtPatternReflectMethodXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Normal => Ok(Some(Cow::Borrowed("Normal"))),
            Self::Row => Ok(Some(Cow::Borrowed("Row"))),
            Self::Column => Ok(Some(Cow::Borrowed("Column"))),
            Self::RowAndColumn => Ok(Some(Cow::Borrowed("RowAndColumn"))),
        }
    }
}
impl DeserializeBytes for CtPatternReflectMethodXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Normal" => Ok(Self::Normal),
            b"Row" => Ok(Self::Row),
            b"Column" => Ok(Self::Column),
            b"RowAndColumn" => Ok(Self::RowAndColumn),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtPatternRelativeToXType {
    Page,
    Object,
}
impl SerializeBytes for CtPatternRelativeToXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Page => Ok(Some(Cow::Borrowed("Page"))),
            Self::Object => Ok(Some(Cow::Borrowed("Object"))),
        }
    }
}
impl DeserializeBytes for CtPatternRelativeToXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Page" => Ok(Self::Page),
            b"Object" => Ok(Self::Object),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtPatternCellContentXElementType {
    pub thumbnail: Option<u32>,
    pub content: Vec<CtPatternCellContentXElementTypeContent>,
}
#[derive(Debug)]
pub enum CtPatternCellContentXElementTypeContent {
    TextObject(CtPageBlockTextObjectXElementType),
    PathObject(CtPageBlockPathObjectXElementType),
    ImageObject(CtPageBlockImageObjectXElementType),
    CompositeObject(CtPageBlockCompositeObjectXElementType),
    PageBlock(CtPageBlockPageBlockXElementType),
}
impl WithSerializer for CtPatternCellContentXElementType {
    type Serializer<'x> = quick_xml_serialize::CtPatternCellContentXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtPatternCellContentXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtPatternCellContentXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtPatternCellContent"),
                is_root,
            },
        )
    }
}
impl WithSerializer for CtPatternCellContentXElementTypeContent {
    type Serializer<'x> =
        quick_xml_serialize::CtPatternCellContentXElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok (quick_xml_serialize :: CtPatternCellContentXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPatternCellContentXElementTypeContentSerializerState :: Init__) , })
    }
}
impl WithDeserializer for CtPatternCellContentXElementType {
    type Deserializer = quick_xml_deserialize::CtPatternCellContentXElementTypeDeserializer;
}
impl WithDeserializer for CtPatternCellContentXElementTypeContent {
    type Deserializer = quick_xml_deserialize::CtPatternCellContentXElementTypeContentDeserializer;
}
#[derive(Debug)]
pub struct CtPermissionPrintXElementType {
    pub printable: bool,
    pub copies: i32,
}
impl CtPermissionPrintXElementType {
    #[must_use]
    pub fn default_copies() -> i32 {
        -1i32
    }
}
impl WithSerializer for CtPermissionPrintXElementType {
    type Serializer<'x> = quick_xml_serialize::CtPermissionPrintXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtPermissionPrintXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtPermissionPrintXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtPermissionPrint"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtPermissionPrintXElementType {
    type Deserializer = quick_xml_deserialize::CtPermissionPrintXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtPermissionValidPeriodXElementType {
    pub start_date: Option<String>,
    pub end_date: Option<String>,
}
impl WithSerializer for CtPermissionValidPeriodXElementType {
    type Serializer<'x> = quick_xml_serialize::CtPermissionValidPeriodXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtPermissionValidPeriodXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtPermissionValidPeriodXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtPermissionValidPeriod"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtPermissionValidPeriodXElementType {
    type Deserializer = quick_xml_deserialize::CtPermissionValidPeriodXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtRegionAreaXElementType {
    pub start: String,
    pub content: Vec<CtRegionAreaXElementTypeContent>,
}
#[derive(Debug)]
pub enum CtRegionAreaXElementTypeContent {
    Move(CtRegionAreaLineXElementType),
    Line(CtRegionAreaLineXElementType),
    OuadraticBezier(CtRegionAreaOuadraticBezierXElementType),
    CubicBezier(CtRegionAreaCubicBezierXElementType),
    Arc(CtRegionAreaArcXElementType),
    Close(xs::AnyTypeXType),
}
impl WithSerializer for CtRegionAreaXElementType {
    type Serializer<'x> = quick_xml_serialize::CtRegionAreaXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtRegionAreaXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtRegionAreaXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtRegionArea"),
            is_root,
        })
    }
}
impl WithSerializer for CtRegionAreaXElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::CtRegionAreaXElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(
            quick_xml_serialize::CtRegionAreaXElementTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtRegionAreaXElementTypeContentSerializerState::Init__,
                ),
            },
        )
    }
}
impl WithDeserializer for CtRegionAreaXElementType {
    type Deserializer = quick_xml_deserialize::CtRegionAreaXElementTypeDeserializer;
}
impl WithDeserializer for CtRegionAreaXElementTypeContent {
    type Deserializer = quick_xml_deserialize::CtRegionAreaXElementTypeContentDeserializer;
}
#[derive(Debug)]
pub enum CtTextWeightXType {
    _0,
    _100,
    _200,
    _300,
    _400,
    _500,
    _600,
    _700,
    _800,
    _900,
    _1000,
}
impl SerializeBytes for CtTextWeightXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_0 => Ok(Some(Cow::Borrowed("0"))),
            Self::_100 => Ok(Some(Cow::Borrowed("100"))),
            Self::_200 => Ok(Some(Cow::Borrowed("200"))),
            Self::_300 => Ok(Some(Cow::Borrowed("300"))),
            Self::_400 => Ok(Some(Cow::Borrowed("400"))),
            Self::_500 => Ok(Some(Cow::Borrowed("500"))),
            Self::_600 => Ok(Some(Cow::Borrowed("600"))),
            Self::_700 => Ok(Some(Cow::Borrowed("700"))),
            Self::_800 => Ok(Some(Cow::Borrowed("800"))),
            Self::_900 => Ok(Some(Cow::Borrowed("900"))),
            Self::_1000 => Ok(Some(Cow::Borrowed("1000"))),
        }
    }
}
impl DeserializeBytes for CtTextWeightXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"0" => Ok(Self::_0),
            b"100" => Ok(Self::_100),
            b"200" => Ok(Self::_200),
            b"300" => Ok(Self::_300),
            b"400" => Ok(Self::_400),
            b"500" => Ok(Self::_500),
            b"600" => Ok(Self::_600),
            b"700" => Ok(Self::_700),
            b"800" => Ok(Self::_800),
            b"900" => Ok(Self::_900),
            b"1000" => Ok(Self::_1000),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtTextTextCodeXElementType {
    pub x: Option<f64>,
    pub y: Option<f64>,
    pub delta_x: Option<String>,
    pub deltay: Option<String>,
    pub content: String,
}
impl WithSerializer for CtTextTextCodeXElementType {
    type Serializer<'x> = quick_xml_serialize::CtTextTextCodeXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtTextTextCodeXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CtTextTextCodeXElementTypeSerializerState::Init__),
            name: name.unwrap_or("CtTextTextCode"),
            is_root,
        })
    }
}
impl WithDeserializer for CtTextTextCodeXElementType {
    type Deserializer = quick_xml_deserialize::CtTextTextCodeXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtVPreferencesPageModeXElementType {
    None,
    FullScreen,
    UseOutlines,
    UseThumbs,
    UseCustomTags,
    UseLayers,
    UseAttatchs,
    UseBookmarks,
}
impl SerializeBytes for CtVPreferencesPageModeXElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::None => Ok(Some(Cow::Borrowed("None"))),
            Self::FullScreen => Ok(Some(Cow::Borrowed("FullScreen"))),
            Self::UseOutlines => Ok(Some(Cow::Borrowed("UseOutlines"))),
            Self::UseThumbs => Ok(Some(Cow::Borrowed("UseThumbs"))),
            Self::UseCustomTags => Ok(Some(Cow::Borrowed("UseCustomTags"))),
            Self::UseLayers => Ok(Some(Cow::Borrowed("UseLayers"))),
            Self::UseAttatchs => Ok(Some(Cow::Borrowed("UseAttatchs"))),
            Self::UseBookmarks => Ok(Some(Cow::Borrowed("UseBookmarks"))),
        }
    }
}
impl DeserializeBytes for CtVPreferencesPageModeXElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"None" => Ok(Self::None),
            b"FullScreen" => Ok(Self::FullScreen),
            b"UseOutlines" => Ok(Self::UseOutlines),
            b"UseThumbs" => Ok(Self::UseThumbs),
            b"UseCustomTags" => Ok(Self::UseCustomTags),
            b"UseLayers" => Ok(Self::UseLayers),
            b"UseAttatchs" => Ok(Self::UseAttatchs),
            b"UseBookmarks" => Ok(Self::UseBookmarks),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtVPreferencesPageLayoutXElementType {
    OnePage,
    OneColumn,
    TwoPageL,
    TwoColumnL,
    TwoPageR,
    TwoColumnR,
}
impl SerializeBytes for CtVPreferencesPageLayoutXElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::OnePage => Ok(Some(Cow::Borrowed("OnePage"))),
            Self::OneColumn => Ok(Some(Cow::Borrowed("OneColumn"))),
            Self::TwoPageL => Ok(Some(Cow::Borrowed("TwoPageL"))),
            Self::TwoColumnL => Ok(Some(Cow::Borrowed("TwoColumnL"))),
            Self::TwoPageR => Ok(Some(Cow::Borrowed("TwoPageR"))),
            Self::TwoColumnR => Ok(Some(Cow::Borrowed("TwoColumnR"))),
        }
    }
}
impl DeserializeBytes for CtVPreferencesPageLayoutXElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"OnePage" => Ok(Self::OnePage),
            b"OneColumn" => Ok(Self::OneColumn),
            b"TwoPageL" => Ok(Self::TwoPageL),
            b"TwoColumnL" => Ok(Self::TwoColumnL),
            b"TwoPageR" => Ok(Self::TwoPageR),
            b"TwoColumnR" => Ok(Self::TwoColumnR),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtVPreferencesTabDisplayXElementType {
    DocTitle,
    FileName,
}
impl SerializeBytes for CtVPreferencesTabDisplayXElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::DocTitle => Ok(Some(Cow::Borrowed("DocTitle"))),
            Self::FileName => Ok(Some(Cow::Borrowed("FileName"))),
        }
    }
}
impl DeserializeBytes for CtVPreferencesTabDisplayXElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"DocTitle" => Ok(Self::DocTitle),
            b"FileName" => Ok(Self::FileName),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CtVPreferencesZoomModeXElementType {
    Default,
    FitHeight,
    FitWidth,
    FitRect,
}
impl SerializeBytes for CtVPreferencesZoomModeXElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Default => Ok(Some(Cow::Borrowed("Default"))),
            Self::FitHeight => Ok(Some(Cow::Borrowed("FitHeight"))),
            Self::FitWidth => Ok(Some(Cow::Borrowed("FitWidth"))),
            Self::FitRect => Ok(Some(Cow::Borrowed("FitRect"))),
        }
    }
}
impl DeserializeBytes for CtVPreferencesZoomModeXElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Default" => Ok(Self::Default),
            b"FitHeight" => Ok(Self::FitHeight),
            b"FitWidth" => Ok(Self::FitWidth),
            b"FitRect" => Ok(Self::FitRect),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CustomTagsCustomTagXElementType {
    pub name_space: String,
    pub schema_loc: Option<String>,
    pub file_loc: String,
}
impl WithSerializer for CustomTagsCustomTagXElementType {
    type Serializer<'x> = quick_xml_serialize::CustomTagsCustomTagXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CustomTagsCustomTagXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CustomTagsCustomTagXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CustomTagsCustomTag"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CustomTagsCustomTagXElementType {
    type Deserializer = quick_xml_deserialize::CustomTagsCustomTagXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DocVersionFileListXElementType {
    pub file: Vec<DocVersionFileListFileXElementType>,
}
impl WithSerializer for DocVersionFileListXElementType {
    type Serializer<'x> = quick_xml_serialize::DocVersionFileListXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::DocVersionFileListXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DocVersionFileListXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("DocVersionFileList"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for DocVersionFileListXElementType {
    type Deserializer = quick_xml_deserialize::DocVersionFileListXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DocumentCommonDataXElementType {
    pub max_unit_id: u32,
    pub page_area: CtPageAreaXType,
    pub public_res: Vec<String>,
    pub document_res: Vec<String>,
    pub template_page: Vec<DocumentCommonDataTemplatePageXElementType>,
    pub default_cs: Option<u32>,
}
impl WithSerializer for DocumentCommonDataXElementType {
    type Serializer<'x> = quick_xml_serialize::DocumentCommonDataXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::DocumentCommonDataXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DocumentCommonDataXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("DocumentCommonData"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for DocumentCommonDataXElementType {
    type Deserializer = quick_xml_deserialize::DocumentCommonDataXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DocumentPagesXElementType {
    pub page: Vec<DocumentPagesPageXElementType>,
}
impl WithSerializer for DocumentPagesXElementType {
    type Serializer<'x> = quick_xml_serialize::DocumentPagesXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DocumentPagesXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DocumentPagesXElementTypeSerializerState::Init__),
            name: name.unwrap_or("DocumentPages"),
            is_root,
        })
    }
}
impl WithDeserializer for DocumentPagesXElementType {
    type Deserializer = quick_xml_deserialize::DocumentPagesXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DocumentOutlinesXElementType {
    pub outline_elem: Vec<CtOutlineElemXType>,
}
impl WithSerializer for DocumentOutlinesXElementType {
    type Serializer<'x> = quick_xml_serialize::DocumentOutlinesXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::DocumentOutlinesXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DocumentOutlinesXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("DocumentOutlines"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for DocumentOutlinesXElementType {
    type Deserializer = quick_xml_deserialize::DocumentOutlinesXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DocumentBookmarksXElementType {
    pub bookmark: Vec<CtBookmarkXType>,
}
impl WithSerializer for DocumentBookmarksXElementType {
    type Serializer<'x> = quick_xml_serialize::DocumentBookmarksXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::DocumentBookmarksXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DocumentBookmarksXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("DocumentBookmarks"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for DocumentBookmarksXElementType {
    type Deserializer = quick_xml_deserialize::DocumentBookmarksXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum OfdDocTypeXType {
    Ofd,
}
impl SerializeBytes for OfdDocTypeXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Ofd => Ok(Some(Cow::Borrowed("OFD"))),
        }
    }
}
impl DeserializeBytes for OfdDocTypeXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"OFD" => Ok(Self::Ofd),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct OfdDocBodyXElementType {
    pub doc_info: CtDocInfoXType,
    pub doc_root: String,
    pub versions: Option<OfdDocBodyVersionsXElementType>,
    pub signatures: Option<String>,
}
impl WithSerializer for OfdDocBodyXElementType {
    type Serializer<'x> = quick_xml_serialize::OfdDocBodyXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::OfdDocBodyXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::OfdDocBodyXElementTypeSerializerState::Init__),
            name: name.unwrap_or("OfdDocBody"),
            is_root,
        })
    }
}
impl WithDeserializer for OfdDocBodyXElementType {
    type Deserializer = quick_xml_deserialize::OfdDocBodyXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct PageTemplateXElementType {
    pub template_id: u32,
    pub z_order: PageTemplateZOrderXType,
}
impl PageTemplateXElementType {
    #[must_use]
    pub fn default_z_order() -> PageTemplateZOrderXType {
        PageTemplateZOrderXType::Backqround
    }
}
impl WithSerializer for PageTemplateXElementType {
    type Serializer<'x> = quick_xml_serialize::PageTemplateXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PageTemplateXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PageTemplateXElementTypeSerializerState::Init__),
            name: name.unwrap_or("PageTemplate"),
            is_root,
        })
    }
}
impl WithDeserializer for PageTemplateXElementType {
    type Deserializer = quick_xml_deserialize::PageTemplateXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct PageContentXElementType {
    pub layer: Vec<PageContentLayerXElementType>,
}
impl WithSerializer for PageContentXElementType {
    type Serializer<'x> = quick_xml_serialize::PageContentXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PageContentXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PageContentXElementTypeSerializerState::Init__),
            name: name.unwrap_or("PageContent"),
            is_root,
        })
    }
}
impl WithDeserializer for PageContentXElementType {
    type Deserializer = quick_xml_deserialize::PageContentXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct PageAnnotAnnotXElementType {
    pub id: u32,
    pub type_: PageAnnotAnnotTypeXType,
    pub creator: String,
    pub last_mod_date: String,
    pub visible: bool,
    pub subtype: Option<String>,
    pub print: bool,
    pub no_zoom: bool,
    pub no_rotate: bool,
    pub read_only: bool,
    pub remark: Option<String>,
    pub parameters: Option<PageAnnotAnnotParametersXElementType>,
    pub appearance: PageAnnotAnnotAppearanceXElementType,
}
impl PageAnnotAnnotXElementType {
    #[must_use]
    pub fn default_visible() -> bool {
        true
    }
    #[must_use]
    pub fn default_print() -> bool {
        true
    }
    #[must_use]
    pub fn default_no_zoom() -> bool {
        false
    }
    #[must_use]
    pub fn default_no_rotate() -> bool {
        false
    }
    #[must_use]
    pub fn default_read_only() -> bool {
        true
    }
}
impl WithSerializer for PageAnnotAnnotXElementType {
    type Serializer<'x> = quick_xml_serialize::PageAnnotAnnotXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PageAnnotAnnotXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PageAnnotAnnotXElementTypeSerializerState::Init__),
            name: name.unwrap_or("PageAnnotAnnot"),
            is_root,
        })
    }
}
impl WithDeserializer for PageAnnotAnnotXElementType {
    type Deserializer = quick_xml_deserialize::PageAnnotAnnotXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResColorSpacesXElementType {
    pub color_space: Vec<ResColorSpacesColorSpaceXElementType>,
}
impl WithSerializer for ResColorSpacesXElementType {
    type Serializer<'x> = quick_xml_serialize::ResColorSpacesXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ResColorSpacesXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ResColorSpacesXElementTypeSerializerState::Init__),
            name: name.unwrap_or("ResColorSpaces"),
            is_root,
        })
    }
}
impl WithDeserializer for ResColorSpacesXElementType {
    type Deserializer = quick_xml_deserialize::ResColorSpacesXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResDrawParamsXElementType {
    pub draw_param: Vec<ResDrawParamsDrawParamXElementType>,
}
impl WithSerializer for ResDrawParamsXElementType {
    type Serializer<'x> = quick_xml_serialize::ResDrawParamsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ResDrawParamsXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ResDrawParamsXElementTypeSerializerState::Init__),
            name: name.unwrap_or("ResDrawParams"),
            is_root,
        })
    }
}
impl WithDeserializer for ResDrawParamsXElementType {
    type Deserializer = quick_xml_deserialize::ResDrawParamsXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResFontsXElementType {
    pub font: Vec<ResFontsFontXElementType>,
}
impl WithSerializer for ResFontsXElementType {
    type Serializer<'x> = quick_xml_serialize::ResFontsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ResFontsXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ResFontsXElementTypeSerializerState::Init__),
            name: name.unwrap_or("ResFonts"),
            is_root,
        })
    }
}
impl WithDeserializer for ResFontsXElementType {
    type Deserializer = quick_xml_deserialize::ResFontsXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResMultiMediasXElementType {
    pub multi_media: Vec<ResMultiMediasMultiMediaXElementType>,
}
impl WithSerializer for ResMultiMediasXElementType {
    type Serializer<'x> = quick_xml_serialize::ResMultiMediasXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ResMultiMediasXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ResMultiMediasXElementTypeSerializerState::Init__),
            name: name.unwrap_or("ResMultiMedias"),
            is_root,
        })
    }
}
impl WithDeserializer for ResMultiMediasXElementType {
    type Deserializer = quick_xml_deserialize::ResMultiMediasXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResCompositeGraphicUnitsXElementType {
    pub composite_graphic_unit: Vec<ResCompositeGraphicUnitsCompositeGraphicUnitXElementType>,
}
impl WithSerializer for ResCompositeGraphicUnitsXElementType {
    type Serializer<'x> = quick_xml_serialize::ResCompositeGraphicUnitsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: ResCompositeGraphicUnitsXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResCompositeGraphicUnitsXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResCompositeGraphicUnits") , is_root , })
    }
}
impl WithDeserializer for ResCompositeGraphicUnitsXElementType {
    type Deserializer = quick_xml_deserialize::ResCompositeGraphicUnitsXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SianatureSiqnedInfoXElementType {
    pub provider: SianatureSiqnedInfoProviderXElementType,
    pub signature_method: Option<String>,
    pub sianature_date_time: Option<String>,
    pub references: SianatureSiqnedInfoReferencesXElementType,
    pub stamp_annot: Vec<SianatureSiqnedInfoStampAnnotXElementType>,
    pub seal: Option<SianatureSiqnedInfoSealXElementType>,
}
impl WithSerializer for SianatureSiqnedInfoXElementType {
    type Serializer<'x> = quick_xml_serialize::SianatureSiqnedInfoXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::SianatureSiqnedInfoXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::SianatureSiqnedInfoXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("SianatureSiqnedInfo"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for SianatureSiqnedInfoXElementType {
    type Deserializer = quick_xml_deserialize::SianatureSiqnedInfoXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SiqnaturesSignatureXElementType {
    pub id: String,
    pub type_: SiqnaturesSignatureTypeXType,
    pub base_loc: String,
}
impl SiqnaturesSignatureXElementType {
    #[must_use]
    pub fn default_type_() -> SiqnaturesSignatureTypeXType {
        SiqnaturesSignatureTypeXType::Seal
    }
}
impl WithSerializer for SiqnaturesSignatureXElementType {
    type Serializer<'x> = quick_xml_serialize::SiqnaturesSignatureXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::SiqnaturesSignatureXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::SiqnaturesSignatureXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("SiqnaturesSignature"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for SiqnaturesSignatureXElementType {
    type Deserializer = quick_xml_deserialize::SiqnaturesSignatureXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtActionGotoBookmarkXElementType {
    pub name: String,
}
impl WithSerializer for CtActionGotoBookmarkXElementType {
    type Serializer<'x> = quick_xml_serialize::CtActionGotoBookmarkXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtActionGotoBookmarkXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtActionGotoBookmarkXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtActionGotoBookmark"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtActionGotoBookmarkXElementType {
    type Deserializer = quick_xml_deserialize::CtActionGotoBookmarkXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtActionMovieOperatorXType {
    Play,
    Stop,
    Pause,
    Resume,
}
impl SerializeBytes for CtActionMovieOperatorXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Play => Ok(Some(Cow::Borrowed("Play"))),
            Self::Stop => Ok(Some(Cow::Borrowed("Stop"))),
            Self::Pause => Ok(Some(Cow::Borrowed("Pause"))),
            Self::Resume => Ok(Some(Cow::Borrowed("Resume"))),
        }
    }
}
impl DeserializeBytes for CtActionMovieOperatorXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Play" => Ok(Self::Play),
            b"Stop" => Ok(Self::Stop),
            b"Pause" => Ok(Self::Pause),
            b"Resume" => Ok(Self::Resume),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtDocInfoCustomDatasCustomDataXElementType {
    pub name: String,
    pub content: String,
}
impl WithSerializer for CtDocInfoCustomDatasCustomDataXElementType {
    type Serializer<'x> =
        quick_xml_serialize::CtDocInfoCustomDatasCustomDataXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: CtDocInfoCustomDatasCustomDataXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtDocInfoCustomDatasCustomData") , is_root , })
    }
}
impl WithDeserializer for CtDocInfoCustomDatasCustomDataXElementType {
    type Deserializer =
        quick_xml_deserialize::CtDocInfoCustomDatasCustomDataXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum CtGouraudShdPointEdgeFlagXType {
    _0,
    _1,
    _2,
}
impl SerializeBytes for CtGouraudShdPointEdgeFlagXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_0 => Ok(Some(Cow::Borrowed("0"))),
            Self::_1 => Ok(Some(Cow::Borrowed("1"))),
            Self::_2 => Ok(Some(Cow::Borrowed("2"))),
        }
    }
}
impl DeserializeBytes for CtGouraudShdPointEdgeFlagXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"0" => Ok(Self::_0),
            b"1" => Ok(Self::_1),
            b"2" => Ok(Self::_2),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CtRegionAreaLineXElementType {
    pub point_1: String,
}
impl WithSerializer for CtRegionAreaLineXElementType {
    type Serializer<'x> = quick_xml_serialize::CtRegionAreaLineXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtRegionAreaLineXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtRegionAreaLineXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtRegionAreaLine"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtRegionAreaLineXElementType {
    type Deserializer = quick_xml_deserialize::CtRegionAreaLineXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtRegionAreaOuadraticBezierXElementType {
    pub pointl: String,
    pub point_2: String,
}
impl WithSerializer for CtRegionAreaOuadraticBezierXElementType {
    type Serializer<'x> =
        quick_xml_serialize::CtRegionAreaOuadraticBezierXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: CtRegionAreaOuadraticBezierXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtRegionAreaOuadraticBezierXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtRegionAreaOuadraticBezier") , is_root , })
    }
}
impl WithDeserializer for CtRegionAreaOuadraticBezierXElementType {
    type Deserializer = quick_xml_deserialize::CtRegionAreaOuadraticBezierXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtRegionAreaCubicBezierXElementType {
    pub point_1: Option<String>,
    pub point_2: Option<String>,
    pub point_3: String,
}
impl WithSerializer for CtRegionAreaCubicBezierXElementType {
    type Serializer<'x> = quick_xml_serialize::CtRegionAreaCubicBezierXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CtRegionAreaCubicBezierXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtRegionAreaCubicBezierXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtRegionAreaCubicBezier"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CtRegionAreaCubicBezierXElementType {
    type Deserializer = quick_xml_deserialize::CtRegionAreaCubicBezierXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CtRegionAreaArcXElementType {
    pub sweep_direction: bool,
    pub large_arc: bool,
    pub rotation_anglet: f64,
    pub ellipse_size: String,
    pub end_point: String,
}
impl WithSerializer for CtRegionAreaArcXElementType {
    type Serializer<'x> = quick_xml_serialize::CtRegionAreaArcXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CtRegionAreaArcXElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::CtRegionAreaArcXElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("CtRegionAreaArc"),
            is_root,
        })
    }
}
impl WithDeserializer for CtRegionAreaArcXElementType {
    type Deserializer = quick_xml_deserialize::CtRegionAreaArcXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DocVersionFileListFileXElementType {
    pub id: String,
    pub content: String,
}
impl WithSerializer for DocVersionFileListFileXElementType {
    type Serializer<'x> = quick_xml_serialize::DocVersionFileListFileXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::DocVersionFileListFileXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DocVersionFileListFileXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("DocVersionFileListFile"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for DocVersionFileListFileXElementType {
    type Deserializer = quick_xml_deserialize::DocVersionFileListFileXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DocumentCommonDataTemplatePageXElementType {
    pub id: String,
    pub name: Option<String>,
    pub z_order: Option<DocumentCommonDataTemplatePageZOrderXType>,
    pub base_loc: String,
}
impl WithSerializer for DocumentCommonDataTemplatePageXElementType {
    type Serializer<'x> =
        quick_xml_serialize::DocumentCommonDataTemplatePageXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: DocumentCommonDataTemplatePageXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: DocumentCommonDataTemplatePageXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("DocumentCommonDataTemplatePage") , is_root , })
    }
}
impl WithDeserializer for DocumentCommonDataTemplatePageXElementType {
    type Deserializer =
        quick_xml_deserialize::DocumentCommonDataTemplatePageXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DocumentPagesPageXElementType {
    pub id: u32,
    pub base_loc: String,
}
impl WithSerializer for DocumentPagesPageXElementType {
    type Serializer<'x> = quick_xml_serialize::DocumentPagesPageXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::DocumentPagesPageXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DocumentPagesPageXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("DocumentPagesPage"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for DocumentPagesPageXElementType {
    type Deserializer = quick_xml_deserialize::DocumentPagesPageXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct OfdDocBodyVersionsXElementType {
    pub version: Vec<OfdDocBodyVersionsVersionXElementType>,
}
impl WithSerializer for OfdDocBodyVersionsXElementType {
    type Serializer<'x> = quick_xml_serialize::OfdDocBodyVersionsXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::OfdDocBodyVersionsXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::OfdDocBodyVersionsXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("OfdDocBodyVersions"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for OfdDocBodyVersionsXElementType {
    type Deserializer = quick_xml_deserialize::OfdDocBodyVersionsXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum PageTemplateZOrderXType {
    Backqround,
    Foreground,
}
impl SerializeBytes for PageTemplateZOrderXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Backqround => Ok(Some(Cow::Borrowed("Backqround"))),
            Self::Foreground => Ok(Some(Cow::Borrowed("Foreground"))),
        }
    }
}
impl DeserializeBytes for PageTemplateZOrderXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Backqround" => Ok(Self::Backqround),
            b"Foreground" => Ok(Self::Foreground),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct PageContentLayerXElementType {
    pub type_: CtLayerTypeXType,
    pub draw_param: Option<u32>,
    pub id: u32,
    pub content: Vec<PageContentLayerXElementTypeContent>,
}
#[derive(Debug)]
pub enum PageContentLayerXElementTypeContent {
    TextObject(CtPageBlockTextObjectXElementType),
    PathObject(CtPageBlockPathObjectXElementType),
    ImageObject(CtPageBlockImageObjectXElementType),
    CompositeObject(CtPageBlockCompositeObjectXElementType),
    PageBlock(CtPageBlockPageBlockXElementType),
}
impl PageContentLayerXElementType {
    #[must_use]
    pub fn default_type_() -> CtLayerTypeXType {
        CtLayerTypeXType::Body
    }
}
impl WithSerializer for PageContentLayerXElementType {
    type Serializer<'x> = quick_xml_serialize::PageContentLayerXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::PageContentLayerXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::PageContentLayerXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PageContentLayer"),
                is_root,
            },
        )
    }
}
impl WithSerializer for PageContentLayerXElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::PageContentLayerXElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(
            quick_xml_serialize::PageContentLayerXElementTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::PageContentLayerXElementTypeContentSerializerState::Init__,
                ),
            },
        )
    }
}
impl WithDeserializer for PageContentLayerXElementType {
    type Deserializer = quick_xml_deserialize::PageContentLayerXElementTypeDeserializer;
}
impl WithDeserializer for PageContentLayerXElementTypeContent {
    type Deserializer = quick_xml_deserialize::PageContentLayerXElementTypeContentDeserializer;
}
#[derive(Debug)]
pub enum PageAnnotAnnotTypeXType {
    Link,
    Path,
    Highlight,
    Stamp,
    Watermark,
}
impl SerializeBytes for PageAnnotAnnotTypeXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Link => Ok(Some(Cow::Borrowed("Link"))),
            Self::Path => Ok(Some(Cow::Borrowed("Path"))),
            Self::Highlight => Ok(Some(Cow::Borrowed("Highlight"))),
            Self::Stamp => Ok(Some(Cow::Borrowed("Stamp"))),
            Self::Watermark => Ok(Some(Cow::Borrowed("Watermark"))),
        }
    }
}
impl DeserializeBytes for PageAnnotAnnotTypeXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Link" => Ok(Self::Link),
            b"Path" => Ok(Self::Path),
            b"Highlight" => Ok(Self::Highlight),
            b"Stamp" => Ok(Self::Stamp),
            b"Watermark" => Ok(Self::Watermark),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct PageAnnotAnnotParametersXElementType {
    pub parameter: Vec<CtDocInfoCustomDatasCustomDataXElementType>,
}
impl WithSerializer for PageAnnotAnnotParametersXElementType {
    type Serializer<'x> = quick_xml_serialize::PageAnnotAnnotParametersXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: PageAnnotAnnotParametersXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: PageAnnotAnnotParametersXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("PageAnnotAnnotParameters") , is_root , })
    }
}
impl WithDeserializer for PageAnnotAnnotParametersXElementType {
    type Deserializer = quick_xml_deserialize::PageAnnotAnnotParametersXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct PageAnnotAnnotAppearanceXElementType {
    pub boundary: Option<String>,
    pub content: Vec<PageAnnotAnnotAppearanceXElementTypeContent>,
}
#[derive(Debug)]
pub enum PageAnnotAnnotAppearanceXElementTypeContent {
    TextObject(CtPageBlockTextObjectXElementType),
    PathObject(CtPageBlockPathObjectXElementType),
    ImageObject(CtPageBlockImageObjectXElementType),
    CompositeObject(CtPageBlockCompositeObjectXElementType),
    PageBlock(CtPageBlockPageBlockXElementType),
}
impl WithSerializer for PageAnnotAnnotAppearanceXElementType {
    type Serializer<'x> = quick_xml_serialize::PageAnnotAnnotAppearanceXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: PageAnnotAnnotAppearanceXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: PageAnnotAnnotAppearanceXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("PageAnnotAnnotAppearance") , is_root , })
    }
}
impl WithSerializer for PageAnnotAnnotAppearanceXElementTypeContent {
    type Serializer<'x> =
        quick_xml_serialize::PageAnnotAnnotAppearanceXElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok (quick_xml_serialize :: PageAnnotAnnotAppearanceXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Init__) , })
    }
}
impl WithDeserializer for PageAnnotAnnotAppearanceXElementType {
    type Deserializer = quick_xml_deserialize::PageAnnotAnnotAppearanceXElementTypeDeserializer;
}
impl WithDeserializer for PageAnnotAnnotAppearanceXElementTypeContent {
    type Deserializer =
        quick_xml_deserialize::PageAnnotAnnotAppearanceXElementTypeContentDeserializer;
}
#[derive(Debug)]
pub struct ResColorSpacesColorSpaceXElementType {
    pub type_: CtColorSpaceTypeXType,
    pub bits_per_component: i32,
    pub profile: Option<String>,
    pub id: u32,
    pub palette: Option<CtColorSpacePaletteXElementType>,
}
impl ResColorSpacesColorSpaceXElementType {
    #[must_use]
    pub fn default_bits_per_component() -> i32 {
        8i32
    }
}
impl WithSerializer for ResColorSpacesColorSpaceXElementType {
    type Serializer<'x> = quick_xml_serialize::ResColorSpacesColorSpaceXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: ResColorSpacesColorSpaceXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResColorSpacesColorSpaceXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResColorSpacesColorSpace") , is_root , })
    }
}
impl WithDeserializer for ResColorSpacesColorSpaceXElementType {
    type Deserializer = quick_xml_deserialize::ResColorSpacesColorSpaceXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResDrawParamsDrawParamXElementType {
    pub relative: Option<u32>,
    pub line_width: f64,
    pub join: String,
    pub cap: String,
    pub dash_offset: f64,
    pub dash_pattern: Option<String>,
    pub miter_limit: f64,
    pub id: u32,
    pub fill_color: Option<CtColorXType>,
    pub stroke_color: Option<CtColorXType>,
}
impl ResDrawParamsDrawParamXElementType {
    #[must_use]
    pub fn default_line_width() -> f64 {
        0.353f64
    }
    #[must_use]
    pub fn default_join() -> String {
        String::from("Miter")
    }
    #[must_use]
    pub fn default_cap() -> String {
        String::from("Butt")
    }
    #[must_use]
    pub fn default_dash_offset() -> f64 {
        0f64
    }
    #[must_use]
    pub fn default_miter_limit() -> f64 {
        4.234f64
    }
}
impl WithSerializer for ResDrawParamsDrawParamXElementType {
    type Serializer<'x> = quick_xml_serialize::ResDrawParamsDrawParamXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::ResDrawParamsDrawParamXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ResDrawParamsDrawParamXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ResDrawParamsDrawParam"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for ResDrawParamsDrawParamXElementType {
    type Deserializer = quick_xml_deserialize::ResDrawParamsDrawParamXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResFontsFontXElementType {
    pub font_name: String,
    pub family_name: Option<String>,
    pub charset: CtFontCharsetXType,
    pub italic: bool,
    pub bold: bool,
    pub serif: bool,
    pub fixed_width: bool,
    pub id: u32,
    pub font_file: Option<String>,
}
impl ResFontsFontXElementType {
    #[must_use]
    pub fn default_charset() -> CtFontCharsetXType {
        CtFontCharsetXType::Unicode
    }
    #[must_use]
    pub fn default_italic() -> bool {
        false
    }
    #[must_use]
    pub fn default_bold() -> bool {
        false
    }
    #[must_use]
    pub fn default_serif() -> bool {
        false
    }
    #[must_use]
    pub fn default_fixed_width() -> bool {
        false
    }
}
impl WithSerializer for ResFontsFontXElementType {
    type Serializer<'x> = quick_xml_serialize::ResFontsFontXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ResFontsFontXElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ResFontsFontXElementTypeSerializerState::Init__),
            name: name.unwrap_or("ResFontsFont"),
            is_root,
        })
    }
}
impl WithDeserializer for ResFontsFontXElementType {
    type Deserializer = quick_xml_deserialize::ResFontsFontXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResMultiMediasMultiMediaXElementType {
    pub type_: CtMultiMediaTypeXType,
    pub format: Option<String>,
    pub id: u32,
    pub media_file: String,
}
impl WithSerializer for ResMultiMediasMultiMediaXElementType {
    type Serializer<'x> = quick_xml_serialize::ResMultiMediasMultiMediaXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: ResMultiMediasMultiMediaXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResMultiMediasMultiMediaXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResMultiMediasMultiMedia") , is_root , })
    }
}
impl WithDeserializer for ResMultiMediasMultiMediaXElementType {
    type Deserializer = quick_xml_deserialize::ResMultiMediasMultiMediaXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ResCompositeGraphicUnitsCompositeGraphicUnitXElementType {
    pub width: f64,
    pub height: f64,
    pub id: u32,
    pub thumbnail: Option<u32>,
    pub substitution: Option<u32>,
    pub content: CtPageBlockXType,
}
impl WithSerializer for ResCompositeGraphicUnitsCompositeGraphicUnitXElementType {
    type Serializer<'x> =
        quick_xml_serialize::ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResCompositeGraphicUnitsCompositeGraphicUnit") , is_root , })
    }
}
impl WithDeserializer for ResCompositeGraphicUnitsCompositeGraphicUnitXElementType {
    type Deserializer =
        quick_xml_deserialize::ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SianatureSiqnedInfoProviderXElementType {
    pub provider_name: String,
    pub version: Option<String>,
    pub company: Option<String>,
}
impl WithSerializer for SianatureSiqnedInfoProviderXElementType {
    type Serializer<'x> =
        quick_xml_serialize::SianatureSiqnedInfoProviderXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: SianatureSiqnedInfoProviderXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoProviderXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoProvider") , is_root , })
    }
}
impl WithDeserializer for SianatureSiqnedInfoProviderXElementType {
    type Deserializer = quick_xml_deserialize::SianatureSiqnedInfoProviderXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SianatureSiqnedInfoReferencesXElementType {
    pub check_method: SianatureSiqnedInfoReferencesCheckMethodXType,
    pub reference: Vec<SianatureSiqnedInfoReferencesReferenceXElementType>,
}
impl SianatureSiqnedInfoReferencesXElementType {
    #[must_use]
    pub fn default_check_method() -> SianatureSiqnedInfoReferencesCheckMethodXType {
        SianatureSiqnedInfoReferencesCheckMethodXType::Md5
    }
}
impl WithSerializer for SianatureSiqnedInfoReferencesXElementType {
    type Serializer<'x> =
        quick_xml_serialize::SianatureSiqnedInfoReferencesXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: SianatureSiqnedInfoReferencesXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoReferencesXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoReferences") , is_root , })
    }
}
impl WithDeserializer for SianatureSiqnedInfoReferencesXElementType {
    type Deserializer =
        quick_xml_deserialize::SianatureSiqnedInfoReferencesXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SianatureSiqnedInfoStampAnnotXElementType {
    pub id: String,
    pub page_ref: u32,
    pub boundary: String,
    pub clip: Option<String>,
}
impl WithSerializer for SianatureSiqnedInfoStampAnnotXElementType {
    type Serializer<'x> =
        quick_xml_serialize::SianatureSiqnedInfoStampAnnotXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: SianatureSiqnedInfoStampAnnotXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoStampAnnotXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoStampAnnot") , is_root , })
    }
}
impl WithDeserializer for SianatureSiqnedInfoStampAnnotXElementType {
    type Deserializer =
        quick_xml_deserialize::SianatureSiqnedInfoStampAnnotXElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SianatureSiqnedInfoSealXElementType {
    pub base_loc: String,
}
impl WithSerializer for SianatureSiqnedInfoSealXElementType {
    type Serializer<'x> = quick_xml_serialize::SianatureSiqnedInfoSealXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::SianatureSiqnedInfoSealXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::SianatureSiqnedInfoSealXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("SianatureSiqnedInfoSeal"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for SianatureSiqnedInfoSealXElementType {
    type Deserializer = quick_xml_deserialize::SianatureSiqnedInfoSealXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum SiqnaturesSignatureTypeXType {
    Seal,
    Siqn,
}
impl SerializeBytes for SiqnaturesSignatureTypeXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Seal => Ok(Some(Cow::Borrowed("Seal"))),
            Self::Siqn => Ok(Some(Cow::Borrowed("Siqn"))),
        }
    }
}
impl DeserializeBytes for SiqnaturesSignatureTypeXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Seal" => Ok(Self::Seal),
            b"Siqn" => Ok(Self::Siqn),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum DocumentCommonDataTemplatePageZOrderXType {
    Background,
    Foreground,
}
impl SerializeBytes for DocumentCommonDataTemplatePageZOrderXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Background => Ok(Some(Cow::Borrowed("Background"))),
            Self::Foreground => Ok(Some(Cow::Borrowed("Foreground"))),
        }
    }
}
impl DeserializeBytes for DocumentCommonDataTemplatePageZOrderXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"Background" => Ok(Self::Background),
            b"Foreground" => Ok(Self::Foreground),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct OfdDocBodyVersionsVersionXElementType {
    pub id: String,
    pub index: i32,
    pub current: bool,
    pub base_loc: String,
}
impl OfdDocBodyVersionsVersionXElementType {
    #[must_use]
    pub fn default_current() -> bool {
        false
    }
}
impl WithSerializer for OfdDocBodyVersionsVersionXElementType {
    type Serializer<'x> = quick_xml_serialize::OfdDocBodyVersionsVersionXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: OfdDocBodyVersionsVersionXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: OfdDocBodyVersionsVersionXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("OfdDocBodyVersionsVersion") , is_root , })
    }
}
impl WithDeserializer for OfdDocBodyVersionsVersionXElementType {
    type Deserializer = quick_xml_deserialize::OfdDocBodyVersionsVersionXElementTypeDeserializer;
}
#[derive(Debug)]
pub enum SianatureSiqnedInfoReferencesCheckMethodXType {
    Md5,
    Sha1,
}
impl SerializeBytes for SianatureSiqnedInfoReferencesCheckMethodXType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Md5 => Ok(Some(Cow::Borrowed("MD5"))),
            Self::Sha1 => Ok(Some(Cow::Borrowed("SHA1"))),
        }
    }
}
impl DeserializeBytes for SianatureSiqnedInfoReferencesCheckMethodXType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"MD5" => Ok(Self::Md5),
            b"SHA1" => Ok(Self::Sha1),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct SianatureSiqnedInfoReferencesReferenceXElementType {
    pub file_ref: String,
    pub check_value: String,
}
impl WithSerializer for SianatureSiqnedInfoReferencesReferenceXElementType {
    type Serializer<'x> =
        quick_xml_serialize::SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoReferencesReference") , is_root , })
    }
}
impl WithDeserializer for SianatureSiqnedInfoReferencesReferenceXElementType {
    type Deserializer =
        quick_xml_deserialize::SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializer;
}
pub mod quick_xml_deserialize {
    use core::mem::replace;
    use xsd_parser::quick_xml::{
        filter_xmlns_attributes, BytesStart, ContentDeserializer, DeserializeReader, Deserializer,
        DeserializerArtifact, DeserializerEvent, DeserializerOutput, DeserializerResult,
        ElementHandlerOutput, Error, ErrorKind, Event, RawByteStr, WithDeserializer,
    };
    #[derive(Debug)]
    pub struct AnnotationsXElementTypeDeserializer {
        page: Vec<super::AnnotationsPageXElementType>,
        state: Box<AnnotationsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum AnnotationsXElementTypeDeserializerState {
        Init__,
        Page(Option<<super::AnnotationsPageXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl AnnotationsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                page: Vec::new(),
                state: Box::new(AnnotationsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: AnnotationsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use AnnotationsXElementTypeDeserializerState as S;
            match state {
                S::Page(Some(deserializer)) => self.store_page(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_page(&mut self, value: super::AnnotationsPageXElementType) -> Result<(), Error> {
            self.page.push(value);
            Ok(())
        }
        fn handle_page<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::AnnotationsPageXElementType>,
            fallback: &mut Option<AnnotationsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(AnnotationsXElementTypeDeserializerState::Page(None));
                *self.state = AnnotationsXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_page(data)?;
                    *self.state = AnnotationsXElementTypeDeserializerState::Page(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(AnnotationsXElementTypeDeserializerState::Page(
                                Some(deserializer),
                            ));
                            *self.state = AnnotationsXElementTypeDeserializerState::Page(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                AnnotationsXElementTypeDeserializerState::Page(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::AnnotationsXElementType>
        for AnnotationsXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AnnotationsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AnnotationsXElementType>
        where
            R: DeserializeReader,
        {
            use AnnotationsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Page(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = AnnotationsXElementTypeDeserializerState::Page(None);
                        event
                    }
                    (S::Page(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Page",
                            false,
                        )?;
                        match self.handle_page(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::AnnotationsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                AnnotationsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::AnnotationsXElementType { page: self.page })
        }
    }
    #[derive(Debug)]
    pub struct AttachmentsXElementTypeDeserializer {
        attachment: Vec<super::CtAttachmentXType>,
        state: Box<AttachmentsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum AttachmentsXElementTypeDeserializerState {
        Init__,
        Attachment(Option<<super::CtAttachmentXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl AttachmentsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                attachment: Vec::new(),
                state: Box::new(AttachmentsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: AttachmentsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use AttachmentsXElementTypeDeserializerState as S;
            match state {
                S::Attachment(Some(deserializer)) => {
                    self.store_attachment(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_attachment(&mut self, value: super::CtAttachmentXType) -> Result<(), Error> {
            self.attachment.push(value);
            Ok(())
        }
        fn handle_attachment<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtAttachmentXType>,
            fallback: &mut Option<AttachmentsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(AttachmentsXElementTypeDeserializerState::Attachment(None));
                *self.state = AttachmentsXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_attachment(data)?;
                    *self.state = AttachmentsXElementTypeDeserializerState::Attachment(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                AttachmentsXElementTypeDeserializerState::Attachment(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                AttachmentsXElementTypeDeserializerState::Attachment(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = AttachmentsXElementTypeDeserializerState::Attachment(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::AttachmentsXElementType>
        for AttachmentsXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AttachmentsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AttachmentsXElementType>
        where
            R: DeserializeReader,
        {
            use AttachmentsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Attachment(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_attachment(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = AttachmentsXElementTypeDeserializerState::Attachment(None);
                        event
                    }
                    (S::Attachment(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Attachment",
                            false,
                        )?;
                        match self.handle_attachment(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::AttachmentsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                AttachmentsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::AttachmentsXElementType {
                attachment: self.attachment,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtActionXTypeDeserializer {
        event: super::CtActionEventXType,
        content: Vec<super::CtActionXTypeContent>,
        state: Box<CtActionXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtActionXTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtActionXTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtActionXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut event: Option<super::CtActionEventXType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Event")
                ) {
                    reader.read_attrib(&mut event, b"Event", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                event: event
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Event".into())))?,
                content: Vec::new(),
                state: Box::new(CtActionXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtActionXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtActionXTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::CtActionXTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtActionXTypeContent>,
            fallback: &mut Option<CtActionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtActionXTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtActionXTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let can_have_more = self.content.len().saturating_add(1) < 2usize;
                    let ret = if can_have_more {
                        ElementHandlerOutput::from_event(event, allow_any)
                    } else {
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    };
                    match (can_have_more, &ret) {
                        (true, ElementHandlerOutput::Continue { .. }) => {
                            fallback.get_or_insert(CtActionXTypeDeserializerState::Content__(
                                deserializer,
                            ));
                            *self.state = CtActionXTypeDeserializerState::Next__;
                        }
                        (false, _) | (_, ElementHandlerOutput::Break { .. }) => {
                            *self.state = CtActionXTypeDeserializerState::Content__(deserializer);
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtActionXType> for CtActionXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtActionXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionXType>
        where
            R: DeserializeReader,
        {
            use CtActionXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output =
                            <super::CtActionXTypeContent as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtActionXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtActionXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtActionXType {
                event: self.event,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtActionXTypeContentDeserializer {
        state: Box<CtActionXTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtActionXTypeContentDeserializerState {
        Init__,
        Region(
            Option<super::CtRegionXType>,
            Option<<super::CtRegionXType as WithDeserializer>::Deserializer>,
        ),
        Goto(
            Option<super::CtActionGotoXElementType>,
            Option<<super::CtActionGotoXElementType as WithDeserializer>::Deserializer>,
        ),
        Uri(
            Option<super::CtActionUriXElementType>,
            Option<<super::CtActionUriXElementType as WithDeserializer>::Deserializer>,
        ),
        GotoA(
            Option<super::CtActionGotoAxElementType>,
            Option<<super::CtActionGotoAxElementType as WithDeserializer>::Deserializer>,
        ),
        Sound(
            Option<super::CtActionSoundXElementType>,
            Option<<super::CtActionSoundXElementType as WithDeserializer>::Deserializer>,
        ),
        Movie(
            Option<super::CtActionMovieXElementType>,
            Option<<super::CtActionMovieXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtActionXTypeContent),
        Unknown__,
    }
    impl CtActionXTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtActionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Region")
                ) {
                    let output = <super::CtRegionXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_region(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Goto")
                ) {
                    let output =
                        <super::CtActionGotoXElementType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_goto(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"URI")
                ) {
                    let output =
                        <super::CtActionUriXElementType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_uri(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"GotoA")
                ) {
                    let output =
                        <super::CtActionGotoAxElementType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_goto_a(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Sound")
                ) {
                    let output =
                        <super::CtActionSoundXElementType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_sound(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Movie")
                ) {
                    let output =
                        <super::CtActionMovieXElementType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_movie(reader, Default::default(), output, &mut *fallback);
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtActionXTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtActionXTypeContentDeserializerState,
        ) -> Result<super::CtActionXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtActionXTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Region(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_region(&mut values, value)?;
                    }
                    Ok(super::CtActionXTypeContent::Region(values.ok_or_else(
                        || ErrorKind::MissingElement("Region".into()),
                    )?))
                }
                S::Goto(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_goto(&mut values, value)?;
                    }
                    Ok(super::CtActionXTypeContent::Goto(
                        values.ok_or_else(|| ErrorKind::MissingElement("Goto".into()))?,
                    ))
                }
                S::Uri(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_uri(&mut values, value)?;
                    }
                    Ok(super::CtActionXTypeContent::Uri(
                        values.ok_or_else(|| ErrorKind::MissingElement("URI".into()))?,
                    ))
                }
                S::GotoA(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_goto_a(&mut values, value)?;
                    }
                    Ok(super::CtActionXTypeContent::GotoA(values.ok_or_else(
                        || ErrorKind::MissingElement("GotoA".into()),
                    )?))
                }
                S::Sound(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_sound(&mut values, value)?;
                    }
                    Ok(super::CtActionXTypeContent::Sound(values.ok_or_else(
                        || ErrorKind::MissingElement("Sound".into()),
                    )?))
                }
                S::Movie(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_movie(&mut values, value)?;
                    }
                    Ok(super::CtActionXTypeContent::Movie(values.ok_or_else(
                        || ErrorKind::MissingElement("Movie".into()),
                    )?))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_region(
            values: &mut Option<super::CtRegionXType>,
            value: super::CtRegionXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Region",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_goto(
            values: &mut Option<super::CtActionGotoXElementType>,
            value: super::CtActionGotoXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Goto")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_uri(
            values: &mut Option<super::CtActionUriXElementType>,
            value: super::CtActionUriXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"URI")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_goto_a(
            values: &mut Option<super::CtActionGotoAxElementType>,
            value: super::CtActionGotoAxElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GotoA",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_sound(
            values: &mut Option<super::CtActionSoundXElementType>,
            value: super::CtActionSoundXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Sound",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_movie(
            values: &mut Option<super::CtActionMovieXElementType>,
            value: super::CtActionMovieXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Movie",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_region<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtRegionXType>,
            output: DeserializerOutput<'de, super::CtRegionXType>,
            fallback: &mut Option<CtActionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtActionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtActionXTypeContentDeserializerState::Region(values, None),
                    Some(CtActionXTypeContentDeserializerState::Region(_, Some(deserializer))) => {
                        CtActionXTypeContentDeserializerState::Region(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtActionXTypeContentDeserializerState::Region(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_region(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_region(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtActionXTypeContentDeserializerState::Region(values, None),
                    )?;
                    *self.state = CtActionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtActionXTypeContentDeserializerState::Region(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_goto<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtActionGotoXElementType>,
            output: DeserializerOutput<'de, super::CtActionGotoXElementType>,
            fallback: &mut Option<CtActionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtActionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtActionXTypeContentDeserializerState::Goto(values, None),
                    Some(CtActionXTypeContentDeserializerState::Goto(_, Some(deserializer))) => {
                        CtActionXTypeContentDeserializerState::Goto(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtActionXTypeContentDeserializerState::Goto(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_goto(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_goto(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtActionXTypeContentDeserializerState::Goto(values, None),
                    )?;
                    *self.state = CtActionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtActionXTypeContentDeserializerState::Goto(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_uri<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtActionUriXElementType>,
            output: DeserializerOutput<'de, super::CtActionUriXElementType>,
            fallback: &mut Option<CtActionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtActionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtActionXTypeContentDeserializerState::Uri(values, None),
                    Some(CtActionXTypeContentDeserializerState::Uri(_, Some(deserializer))) => {
                        CtActionXTypeContentDeserializerState::Uri(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtActionXTypeContentDeserializerState::Uri(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_uri(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_uri(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtActionXTypeContentDeserializerState::Uri(values, None),
                    )?;
                    *self.state = CtActionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtActionXTypeContentDeserializerState::Uri(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_goto_a<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtActionGotoAxElementType>,
            output: DeserializerOutput<'de, super::CtActionGotoAxElementType>,
            fallback: &mut Option<CtActionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtActionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtActionXTypeContentDeserializerState::GotoA(values, None),
                    Some(CtActionXTypeContentDeserializerState::GotoA(_, Some(deserializer))) => {
                        CtActionXTypeContentDeserializerState::GotoA(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtActionXTypeContentDeserializerState::GotoA(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_goto_a(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_goto_a(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtActionXTypeContentDeserializerState::GotoA(values, None),
                    )?;
                    *self.state = CtActionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtActionXTypeContentDeserializerState::GotoA(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_sound<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtActionSoundXElementType>,
            output: DeserializerOutput<'de, super::CtActionSoundXElementType>,
            fallback: &mut Option<CtActionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtActionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtActionXTypeContentDeserializerState::Sound(values, None),
                    Some(CtActionXTypeContentDeserializerState::Sound(_, Some(deserializer))) => {
                        CtActionXTypeContentDeserializerState::Sound(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtActionXTypeContentDeserializerState::Sound(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_sound(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_sound(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtActionXTypeContentDeserializerState::Sound(values, None),
                    )?;
                    *self.state = CtActionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtActionXTypeContentDeserializerState::Sound(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_movie<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtActionMovieXElementType>,
            output: DeserializerOutput<'de, super::CtActionMovieXElementType>,
            fallback: &mut Option<CtActionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtActionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtActionXTypeContentDeserializerState::Movie(values, None),
                    Some(CtActionXTypeContentDeserializerState::Movie(_, Some(deserializer))) => {
                        CtActionXTypeContentDeserializerState::Movie(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtActionXTypeContentDeserializerState::Movie(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_movie(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_movie(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtActionXTypeContentDeserializerState::Movie(values, None),
                    )?;
                    *self.state = CtActionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtActionXTypeContentDeserializerState::Movie(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtActionXTypeContent> for CtActionXTypeContentDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionXTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtActionXTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, CtActionXTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionXTypeContent>
        where
            R: DeserializeReader,
        {
            use CtActionXTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Region(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_region(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Goto(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_goto(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Uri(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_uri(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::GotoA(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_goto_a(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Sound(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_sound(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Movie(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_movie(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Region(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Region",
                            true,
                        )?;
                        match self.handle_region(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Goto(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Goto",
                            false,
                        )?;
                        match self.handle_goto(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Uri(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"URI",
                            false,
                        )?;
                        match self.handle_uri(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::GotoA(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"GotoA",
                            false,
                        )?;
                        match self.handle_goto_a(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Sound(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Sound",
                            false,
                        )?;
                        match self.handle_sound(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Movie(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Movie",
                            false,
                        )?;
                        match self.handle_movie(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtActionXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtAttachmentXTypeDeserializer {
        id: String,
        name: String,
        format: Option<String>,
        creation_date: Option<String>,
        mod_date: Option<String>,
        size: Option<f64>,
        visible: bool,
        usage: String,
        file_loc: Option<String>,
        state: Box<CtAttachmentXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtAttachmentXTypeDeserializerState {
        Init__,
        FileLoc(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtAttachmentXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<String> = None;
            let mut name: Option<String> = None;
            let mut format: Option<String> = None;
            let mut creation_date: Option<String> = None;
            let mut mod_date: Option<String> = None;
            let mut size: Option<f64> = None;
            let mut visible: Option<bool> = None;
            let mut usage: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Format")
                ) {
                    reader.read_attrib(&mut format, b"Format", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CreationDate")
                ) {
                    reader.read_attrib(&mut creation_date, b"CreationDate", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ModDate")
                ) {
                    reader.read_attrib(&mut mod_date, b"ModDate", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Size")
                ) {
                    reader.read_attrib(&mut size, b"Size", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Usage")
                ) {
                    reader.read_attrib(&mut usage, b"Usage", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                name: name
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Name".into())))?,
                format: format,
                creation_date: creation_date,
                mod_date: mod_date,
                size: size,
                visible: visible.unwrap_or_else(super::CtAttachmentXType::default_visible),
                usage: usage.unwrap_or_else(super::CtAttachmentXType::default_usage),
                file_loc: None,
                state: Box::new(CtAttachmentXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtAttachmentXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtAttachmentXTypeDeserializerState as S;
            match state {
                S::FileLoc(Some(deserializer)) => {
                    self.store_file_loc(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_file_loc(&mut self, value: String) -> Result<(), Error> {
            if self.file_loc.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FileLoc",
                )))?;
            }
            self.file_loc = Some(value);
            Ok(())
        }
        fn handle_file_loc<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtAttachmentXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.file_loc.is_some() {
                    fallback.get_or_insert(CtAttachmentXTypeDeserializerState::FileLoc(None));
                    *self.state = CtAttachmentXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtAttachmentXTypeDeserializerState::FileLoc(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_file_loc(data)?;
                    *self.state = CtAttachmentXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtAttachmentXTypeDeserializerState::FileLoc(
                                Some(deserializer),
                            ));
                            *self.state = CtAttachmentXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtAttachmentXTypeDeserializerState::FileLoc(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtAttachmentXType> for CtAttachmentXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtAttachmentXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtAttachmentXType>
        where
            R: DeserializeReader,
        {
            use CtAttachmentXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::FileLoc(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_file_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtAttachmentXTypeDeserializerState::FileLoc(None);
                        event
                    }
                    (S::FileLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FileLoc",
                            false,
                        )?;
                        match self.handle_file_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtAttachmentXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtAttachmentXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtAttachmentXType {
                id: self.id,
                name: self.name,
                format: self.format,
                creation_date: self.creation_date,
                mod_date: self.mod_date,
                size: self.size,
                visible: self.visible,
                usage: self.usage,
                file_loc: self
                    .file_loc
                    .ok_or_else(|| ErrorKind::MissingElement("FileLoc".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtAxialShdXTypeDeserializer {
        map_type: super::CtAxialShdMapTypeXType,
        map_unit: Option<f64>,
        extend: super::CtAxialShdExtendXType,
        start_point: String,
        end_point: String,
        segment: Vec<super::CtAxialShdSegmentXElementType>,
        state: Box<CtAxialShdXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtAxialShdXTypeDeserializerState {
        Init__,
        Segment(Option<<super::CtAxialShdSegmentXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtAxialShdXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut map_type: Option<super::CtAxialShdMapTypeXType> = None;
            let mut map_unit: Option<f64> = None;
            let mut extend: Option<super::CtAxialShdExtendXType> = None;
            let mut start_point: Option<String> = None;
            let mut end_point: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MapType")
                ) {
                    reader.read_attrib(&mut map_type, b"MapType", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MapUnit")
                ) {
                    reader.read_attrib(&mut map_unit, b"MapUnit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Extend")
                ) {
                    reader.read_attrib(&mut extend, b"Extend", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"StartPoint")
                ) {
                    reader.read_attrib(&mut start_point, b"StartPoint", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"EndPoint")
                ) {
                    reader.read_attrib(&mut end_point, b"EndPoint", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                map_type: map_type.unwrap_or_else(super::CtAxialShdXType::default_map_type),
                map_unit: map_unit,
                extend: extend.unwrap_or_else(super::CtAxialShdXType::default_extend),
                start_point: start_point.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("StartPoint".into()))
                })?,
                end_point: end_point.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("EndPoint".into()))
                })?,
                segment: Vec::new(),
                state: Box::new(CtAxialShdXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtAxialShdXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtAxialShdXTypeDeserializerState as S;
            match state {
                S::Segment(Some(deserializer)) => {
                    self.store_segment(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_segment(
            &mut self,
            value: super::CtAxialShdSegmentXElementType,
        ) -> Result<(), Error> {
            self.segment.push(value);
            Ok(())
        }
        fn handle_segment<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtAxialShdSegmentXElementType>,
            fallback: &mut Option<CtAxialShdXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.segment.len() < 2usize {
                    *self.state = CtAxialShdXTypeDeserializerState::Segment(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CtAxialShdXTypeDeserializerState::Segment(None));
                    *self.state = CtAxialShdXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_segment(data)?;
                    *self.state = CtAxialShdXTypeDeserializerState::Segment(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtAxialShdXTypeDeserializerState::Segment(
                                Some(deserializer),
                            ));
                            if self.segment.len().saturating_add(1) < 2usize {
                                *self.state = CtAxialShdXTypeDeserializerState::Segment(None);
                            } else {
                                *self.state = CtAxialShdXTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtAxialShdXTypeDeserializerState::Segment(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtAxialShdXType> for CtAxialShdXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtAxialShdXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtAxialShdXType>
        where
            R: DeserializeReader,
        {
            use CtAxialShdXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Segment(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_segment(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtAxialShdXTypeDeserializerState::Segment(None);
                        event
                    }
                    (S::Segment(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Segment",
                            true,
                        )?;
                        match self.handle_segment(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtAxialShdXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtAxialShdXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtAxialShdXType {
                map_type: self.map_type,
                map_unit: self.map_unit,
                extend: self.extend,
                start_point: self.start_point,
                end_point: self.end_point,
                segment: self.segment,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtBookmarkXTypeDeserializer {
        name: String,
        dest: Option<super::CtDestXType>,
        state: Box<CtBookmarkXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtBookmarkXTypeDeserializerState {
        Init__,
        Dest(Option<<super::CtDestXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtBookmarkXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut name: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                name: name
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Name".into())))?,
                dest: None,
                state: Box::new(CtBookmarkXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtBookmarkXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtBookmarkXTypeDeserializerState as S;
            match state {
                S::Dest(Some(deserializer)) => self.store_dest(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_dest(&mut self, value: super::CtDestXType) -> Result<(), Error> {
            if self.dest.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Dest")))?;
            }
            self.dest = Some(value);
            Ok(())
        }
        fn handle_dest<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtDestXType>,
            fallback: &mut Option<CtBookmarkXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.dest.is_some() {
                    fallback.get_or_insert(CtBookmarkXTypeDeserializerState::Dest(None));
                    *self.state = CtBookmarkXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtBookmarkXTypeDeserializerState::Dest(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_dest(data)?;
                    *self.state = CtBookmarkXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtBookmarkXTypeDeserializerState::Dest(Some(
                                deserializer,
                            )));
                            *self.state = CtBookmarkXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtBookmarkXTypeDeserializerState::Dest(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtBookmarkXType> for CtBookmarkXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtBookmarkXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtBookmarkXType>
        where
            R: DeserializeReader,
        {
            use CtBookmarkXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Dest(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_dest(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtBookmarkXTypeDeserializerState::Dest(None);
                        event
                    }
                    (S::Dest(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Dest",
                            false,
                        )?;
                        match self.handle_dest(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtBookmarkXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtBookmarkXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtBookmarkXType {
                name: self.name,
                dest: self
                    .dest
                    .ok_or_else(|| ErrorKind::MissingElement("Dest".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtCgTransformXTypeDeserializer {
        code_position: i32,
        code_count: i32,
        glyph_count: i32,
        glyphs: Option<String>,
        state: Box<CtCgTransformXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtCgTransformXTypeDeserializerState {
        Init__,
        Glyphs(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtCgTransformXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut code_position: Option<i32> = None;
            let mut code_count: Option<i32> = None;
            let mut glyph_count: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CodePosition")
                ) {
                    reader.read_attrib(&mut code_position, b"CodePosition", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CodeCount")
                ) {
                    reader.read_attrib(&mut code_count, b"CodeCount", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"GlyphCount")
                ) {
                    reader.read_attrib(&mut glyph_count, b"GlyphCount", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                code_position: code_position.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("CodePosition".into()))
                })?,
                code_count: code_count
                    .unwrap_or_else(super::CtCgTransformXType::default_code_count),
                glyph_count: glyph_count
                    .unwrap_or_else(super::CtCgTransformXType::default_glyph_count),
                glyphs: None,
                state: Box::new(CtCgTransformXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtCgTransformXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtCgTransformXTypeDeserializerState as S;
            match state {
                S::Glyphs(Some(deserializer)) => self.store_glyphs(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_glyphs(&mut self, value: String) -> Result<(), Error> {
            if self.glyphs.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Glyphs",
                )))?;
            }
            self.glyphs = Some(value);
            Ok(())
        }
        fn handle_glyphs<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtCgTransformXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtCgTransformXTypeDeserializerState::Glyphs(None));
                *self.state = CtCgTransformXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_glyphs(data)?;
                    *self.state = CtCgTransformXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtCgTransformXTypeDeserializerState::Glyphs(
                                Some(deserializer),
                            ));
                            *self.state = CtCgTransformXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtCgTransformXTypeDeserializerState::Glyphs(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtCgTransformXType> for CtCgTransformXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtCgTransformXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtCgTransformXType>
        where
            R: DeserializeReader,
        {
            use CtCgTransformXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Glyphs(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_glyphs(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtCgTransformXTypeDeserializerState::Glyphs(None);
                        event
                    }
                    (S::Glyphs(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Glyphs",
                            false,
                        )?;
                        match self.handle_glyphs(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtCgTransformXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtCgTransformXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtCgTransformXType {
                code_position: self.code_position,
                code_count: self.code_count,
                glyph_count: self.glyph_count,
                glyphs: self.glyphs,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtClipXTypeDeserializer {
        area: Vec<super::CtClipAreaXElementType>,
        state: Box<CtClipXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtClipXTypeDeserializerState {
        Init__,
        Area(Option<<super::CtClipAreaXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtClipXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                area: Vec::new(),
                state: Box::new(CtClipXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtClipXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtClipXTypeDeserializerState as S;
            match state {
                S::Area(Some(deserializer)) => self.store_area(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_area(&mut self, value: super::CtClipAreaXElementType) -> Result<(), Error> {
            self.area.push(value);
            Ok(())
        }
        fn handle_area<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtClipAreaXElementType>,
            fallback: &mut Option<CtClipXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.area.len() < 1usize {
                    *self.state = CtClipXTypeDeserializerState::Area(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CtClipXTypeDeserializerState::Area(None));
                    *self.state = CtClipXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_area(data)?;
                    *self.state = CtClipXTypeDeserializerState::Area(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtClipXTypeDeserializerState::Area(Some(
                                deserializer,
                            )));
                            if self.area.len().saturating_add(1) < 1usize {
                                *self.state = CtClipXTypeDeserializerState::Area(None);
                            } else {
                                *self.state = CtClipXTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtClipXTypeDeserializerState::Area(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtClipXType> for CtClipXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtClipXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtClipXType>
        where
            R: DeserializeReader,
        {
            use CtClipXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Area(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_area(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtClipXTypeDeserializerState::Area(None);
                        event
                    }
                    (S::Area(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Area",
                            true,
                        )?;
                        match self.handle_area(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtClipXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtClipXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtClipXType { area: self.area })
        }
    }
    #[derive(Debug)]
    pub struct CtColorXTypeDeserializer {
        value: Option<String>,
        index: Option<i32>,
        color_space: Option<u32>,
        alpha: i32,
        content: Option<super::CtColorXTypeContent>,
        state: Box<CtColorXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtColorXTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtColorXTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtColorXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut value: Option<String> = None;
            let mut index: Option<i32> = None;
            let mut color_space: Option<u32> = None;
            let mut alpha: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Value")
                ) {
                    reader.read_attrib(&mut value, b"Value", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Index")
                ) {
                    reader.read_attrib(&mut index, b"Index", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ColorSpace")
                ) {
                    reader.read_attrib(&mut color_space, b"ColorSpace", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                value: value,
                index: index,
                color_space: color_space,
                alpha: alpha.unwrap_or_else(super::CtColorXType::default_alpha),
                content: None,
                state: Box::new(CtColorXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtColorXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtColorXTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::CtColorXTypeContent) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXTypeContent>,
            fallback: &mut Option<CtColorXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtColorXTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtColorXTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtColorXTypeDeserializerState::Content__(deserializer);
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtColorXType> for CtColorXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtColorXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtColorXType>
        where
            R: DeserializeReader,
        {
            use CtColorXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output =
                            <super::CtColorXTypeContent as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtColorXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtColorXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtColorXType {
                value: self.value,
                index: self.index,
                color_space: self.color_space,
                alpha: self.alpha,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtColorXTypeContentDeserializer {
        state: Box<CtColorXTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtColorXTypeContentDeserializerState {
        Init__,
        Pattern(
            Option<super::CtPatternXType>,
            Option<<super::CtPatternXType as WithDeserializer>::Deserializer>,
        ),
        AxialShd(
            Option<super::CtAxialShdXType>,
            Option<<super::CtAxialShdXType as WithDeserializer>::Deserializer>,
        ),
        RadialShd(
            Option<super::CtRadialShdXType>,
            Option<<super::CtRadialShdXType as WithDeserializer>::Deserializer>,
        ),
        GouraudShd(
            Option<super::CtGouraudShdXType>,
            Option<<super::CtGouraudShdXType as WithDeserializer>::Deserializer>,
        ),
        LaGourandShd(
            Option<super::CtLaGouraudShdXType>,
            Option<<super::CtLaGouraudShdXType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtColorXTypeContent),
        Unknown__,
    }
    impl CtColorXTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtColorXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Pattern")
                ) {
                    let output = <super::CtPatternXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_pattern(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"AxialShd")
                ) {
                    let output = <super::CtAxialShdXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_axial_shd(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"RadialShd")
                ) {
                    let output = <super::CtRadialShdXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_radial_shd(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"GouraudShd")
                ) {
                    let output =
                        <super::CtGouraudShdXType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_gouraud_shd(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"LaGourandShd")
                ) {
                    let output =
                        <super::CtLaGouraudShdXType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_la_gourand_shd(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtColorXTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtColorXTypeContentDeserializerState,
        ) -> Result<super::CtColorXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtColorXTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Pattern(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_pattern(&mut values, value)?;
                    }
                    Ok(super::CtColorXTypeContent::Pattern(values.ok_or_else(
                        || ErrorKind::MissingElement("Pattern".into()),
                    )?))
                }
                S::AxialShd(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_axial_shd(&mut values, value)?;
                    }
                    Ok(super::CtColorXTypeContent::AxialShd(values.ok_or_else(
                        || ErrorKind::MissingElement("AxialShd".into()),
                    )?))
                }
                S::RadialShd(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_radial_shd(&mut values, value)?;
                    }
                    Ok(super::CtColorXTypeContent::RadialShd(values.ok_or_else(
                        || ErrorKind::MissingElement("RadialShd".into()),
                    )?))
                }
                S::GouraudShd(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_gouraud_shd(&mut values, value)?;
                    }
                    Ok(super::CtColorXTypeContent::GouraudShd(Box::new(
                        values.ok_or_else(|| ErrorKind::MissingElement("GouraudShd".into()))?,
                    )))
                }
                S::LaGourandShd(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_la_gourand_shd(&mut values, value)?;
                    }
                    Ok(super::CtColorXTypeContent::LaGourandShd(Box::new(
                        values.ok_or_else(|| ErrorKind::MissingElement("LaGourandShd".into()))?,
                    )))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_pattern(
            values: &mut Option<super::CtPatternXType>,
            value: super::CtPatternXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Pattern",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_axial_shd(
            values: &mut Option<super::CtAxialShdXType>,
            value: super::CtAxialShdXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AxialShd",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_radial_shd(
            values: &mut Option<super::CtRadialShdXType>,
            value: super::CtRadialShdXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"RadialShd",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_gouraud_shd(
            values: &mut Option<super::CtGouraudShdXType>,
            value: super::CtGouraudShdXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GouraudShd",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_la_gourand_shd(
            values: &mut Option<super::CtLaGouraudShdXType>,
            value: super::CtLaGouraudShdXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LaGourandShd",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_pattern<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPatternXType>,
            output: DeserializerOutput<'de, super::CtPatternXType>,
            fallback: &mut Option<CtColorXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtColorXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtColorXTypeContentDeserializerState::Pattern(values, None),
                    Some(CtColorXTypeContentDeserializerState::Pattern(_, Some(deserializer))) => {
                        CtColorXTypeContentDeserializerState::Pattern(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtColorXTypeContentDeserializerState::Pattern(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_pattern(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_pattern(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtColorXTypeContentDeserializerState::Pattern(values, None),
                    )?;
                    *self.state = CtColorXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtColorXTypeContentDeserializerState::Pattern(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_axial_shd<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtAxialShdXType>,
            output: DeserializerOutput<'de, super::CtAxialShdXType>,
            fallback: &mut Option<CtColorXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtColorXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtColorXTypeContentDeserializerState::AxialShd(values, None),
                    Some(CtColorXTypeContentDeserializerState::AxialShd(_, Some(deserializer))) => {
                        CtColorXTypeContentDeserializerState::AxialShd(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtColorXTypeContentDeserializerState::AxialShd(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_axial_shd(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_axial_shd(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtColorXTypeContentDeserializerState::AxialShd(values, None),
                    )?;
                    *self.state = CtColorXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtColorXTypeContentDeserializerState::AxialShd(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_radial_shd<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtRadialShdXType>,
            output: DeserializerOutput<'de, super::CtRadialShdXType>,
            fallback: &mut Option<CtColorXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtColorXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtColorXTypeContentDeserializerState::RadialShd(values, None),
                    Some(CtColorXTypeContentDeserializerState::RadialShd(
                        _,
                        Some(deserializer),
                    )) => {
                        CtColorXTypeContentDeserializerState::RadialShd(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtColorXTypeContentDeserializerState::RadialShd(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_radial_shd(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_radial_shd(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtColorXTypeContentDeserializerState::RadialShd(values, None),
                    )?;
                    *self.state = CtColorXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtColorXTypeContentDeserializerState::RadialShd(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_gouraud_shd<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtGouraudShdXType>,
            output: DeserializerOutput<'de, super::CtGouraudShdXType>,
            fallback: &mut Option<CtColorXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtColorXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtColorXTypeContentDeserializerState::GouraudShd(values, None),
                    Some(CtColorXTypeContentDeserializerState::GouraudShd(
                        _,
                        Some(deserializer),
                    )) => {
                        CtColorXTypeContentDeserializerState::GouraudShd(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtColorXTypeContentDeserializerState::GouraudShd(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_gouraud_shd(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_gouraud_shd(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtColorXTypeContentDeserializerState::GouraudShd(values, None),
                    )?;
                    *self.state = CtColorXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtColorXTypeContentDeserializerState::GouraudShd(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_la_gourand_shd<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtLaGouraudShdXType>,
            output: DeserializerOutput<'de, super::CtLaGouraudShdXType>,
            fallback: &mut Option<CtColorXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtColorXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtColorXTypeContentDeserializerState::LaGourandShd(values, None),
                    Some(CtColorXTypeContentDeserializerState::LaGourandShd(
                        _,
                        Some(deserializer),
                    )) => CtColorXTypeContentDeserializerState::LaGourandShd(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtColorXTypeContentDeserializerState::LaGourandShd(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_la_gourand_shd(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_la_gourand_shd(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtColorXTypeContentDeserializerState::LaGourandShd(values, None),
                    )?;
                    *self.state = CtColorXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtColorXTypeContentDeserializerState::LaGourandShd(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtColorXTypeContent> for CtColorXTypeContentDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtColorXTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtColorXTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, CtColorXTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtColorXTypeContent>
        where
            R: DeserializeReader,
        {
            use CtColorXTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Pattern(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_pattern(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::AxialShd(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_axial_shd(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::RadialShd(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_radial_shd(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::GouraudShd(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_gouraud_shd(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::LaGourandShd(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_la_gourand_shd(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Pattern(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Pattern",
                            true,
                        )?;
                        match self.handle_pattern(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::AxialShd(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"AxialShd",
                            true,
                        )?;
                        match self.handle_axial_shd(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::RadialShd(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"RadialShd",
                            true,
                        )?;
                        match self.handle_radial_shd(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::GouraudShd(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"GouraudShd",
                            true,
                        )?;
                        match self.handle_gouraud_shd(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::LaGourandShd(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"LaGourandShd",
                            true,
                        )?;
                        match self.handle_la_gourand_shd(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtColorXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtColorSpaceXTypeDeserializer {
        type_: super::CtColorSpaceTypeXType,
        bits_per_component: i32,
        profile: Option<String>,
        palette: Option<super::CtColorSpacePaletteXElementType>,
        state: Box<CtColorSpaceXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtColorSpaceXTypeDeserializerState {
        Init__,
        Palette(Option<<super::CtColorSpacePaletteXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtColorSpaceXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CtColorSpaceTypeXType> = None;
            let mut bits_per_component: Option<i32> = None;
            let mut profile: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"BitsPerComponent")
                ) {
                    reader.read_attrib(
                        &mut bits_per_component,
                        b"BitsPerComponent",
                        &attrib.value,
                    )?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Profile")
                ) {
                    reader.read_attrib(&mut profile, b"Profile", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Type".into())))?,
                bits_per_component: bits_per_component
                    .unwrap_or_else(super::CtColorSpaceXType::default_bits_per_component),
                profile: profile,
                palette: None,
                state: Box::new(CtColorSpaceXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtColorSpaceXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtColorSpaceXTypeDeserializerState as S;
            match state {
                S::Palette(Some(deserializer)) => {
                    self.store_palette(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_palette(
            &mut self,
            value: super::CtColorSpacePaletteXElementType,
        ) -> Result<(), Error> {
            if self.palette.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Palette",
                )))?;
            }
            self.palette = Some(value);
            Ok(())
        }
        fn handle_palette<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorSpacePaletteXElementType>,
            fallback: &mut Option<CtColorSpaceXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtColorSpaceXTypeDeserializerState::Palette(None));
                *self.state = CtColorSpaceXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_palette(data)?;
                    *self.state = CtColorSpaceXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtColorSpaceXTypeDeserializerState::Palette(
                                Some(deserializer),
                            ));
                            *self.state = CtColorSpaceXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtColorSpaceXTypeDeserializerState::Palette(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtColorSpaceXType> for CtColorSpaceXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtColorSpaceXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtColorSpaceXType>
        where
            R: DeserializeReader,
        {
            use CtColorSpaceXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Palette(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_palette(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtColorSpaceXTypeDeserializerState::Palette(None);
                        event
                    }
                    (S::Palette(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Palette",
                            false,
                        )?;
                        match self.handle_palette(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtColorSpaceXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtColorSpaceXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtColorSpaceXType {
                type_: self.type_,
                bits_per_component: self.bits_per_component,
                profile: self.profile,
                palette: self.palette,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtCompositeXTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        resource_id: u32,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        clips: Option<super::CtGraphicUnitClipsXElementType>,
        state: Box<CtCompositeXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtCompositeXTypeDeserializerState {
        Init__,
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtCompositeXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            let mut resource_id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ResourceID")
                ) {
                    reader.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible.unwrap_or_else(super::CtCompositeXType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width.unwrap_or_else(super::CtCompositeXType::default_line_width),
                cap: cap.unwrap_or_else(super::CtCompositeXType::default_cap),
                join: join.unwrap_or_else(super::CtCompositeXType::default_join),
                miter_limit: miter_limit
                    .unwrap_or_else(super::CtCompositeXType::default_miter_limit),
                dash_offset: dash_offset
                    .unwrap_or_else(super::CtCompositeXType::default_dash_offset),
                dash_pattern: dash_pattern,
                alpha: alpha.unwrap_or_else(super::CtCompositeXType::default_alpha),
                resource_id: resource_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("ResourceID".into()))
                })?,
                actions: None,
                clips: None,
                state: Box::new(CtCompositeXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtCompositeXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtCompositeXTypeDeserializerState as S;
            match state {
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::Clips(Some(deserializer)) => self.store_clips(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_clips(
            &mut self,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if self.clips.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            self.clips = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtCompositeXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtCompositeXTypeDeserializerState::Actions(None));
                *self.state = CtCompositeXTypeDeserializerState::Clips(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = CtCompositeXTypeDeserializerState::Clips(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtCompositeXTypeDeserializerState::Actions(
                                Some(deserializer),
                            ));
                            *self.state = CtCompositeXTypeDeserializerState::Clips(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtCompositeXTypeDeserializerState::Actions(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtCompositeXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtCompositeXTypeDeserializerState::Clips(None));
                *self.state = CtCompositeXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_clips(data)?;
                    *self.state = CtCompositeXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtCompositeXTypeDeserializerState::Clips(Some(
                                deserializer,
                            )));
                            *self.state = CtCompositeXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtCompositeXTypeDeserializerState::Clips(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtCompositeXType> for CtCompositeXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtCompositeXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtCompositeXType>
        where
            R: DeserializeReader,
        {
            use CtCompositeXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtCompositeXTypeDeserializerState::Actions(None);
                        event
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtCompositeXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtCompositeXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtCompositeXType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                resource_id: self.resource_id,
                actions: self.actions,
                clips: self.clips,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtDestXTypeDeserializer {
        type_: super::CtDestTypeXType,
        page_id: u32,
        left: Option<f64>,
        top: Option<f64>,
        right: Option<f64>,
        bottom: Option<f64>,
        zoom: Option<f64>,
        state: Box<CtDestXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtDestXTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtDestXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CtDestTypeXType> = None;
            let mut page_id: Option<u32> = None;
            let mut left: Option<f64> = None;
            let mut top: Option<f64> = None;
            let mut right: Option<f64> = None;
            let mut bottom: Option<f64> = None;
            let mut zoom: Option<f64> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"PageID")
                ) {
                    reader.read_attrib(&mut page_id, b"PageID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Left")
                ) {
                    reader.read_attrib(&mut left, b"Left", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Top")
                ) {
                    reader.read_attrib(&mut top, b"Top", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Right")
                ) {
                    reader.read_attrib(&mut right, b"Right", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Bottom")
                ) {
                    reader.read_attrib(&mut bottom, b"Bottom", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Zoom")
                ) {
                    reader.read_attrib(&mut zoom, b"Zoom", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Type".into())))?,
                page_id: page_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("PageID".into()))
                })?,
                left: left,
                top: top,
                right: right,
                bottom: bottom,
                zoom: zoom,
                state: Box::new(CtDestXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtDestXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtDestXType> for CtDestXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtDestXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDestXType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtDestXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtDestXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtDestXType {
                type_: self.type_,
                page_id: self.page_id,
                left: self.left,
                top: self.top,
                right: self.right,
                bottom: self.bottom,
                zoom: self.zoom,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtDocInfoXTypeDeserializer {
        doc_id: Option<String>,
        title: Option<String>,
        author: Option<String>,
        subject: Option<String>,
        abstract_: Option<String>,
        creation_date: Option<String>,
        mod_date: Option<String>,
        doc_usage: Option<String>,
        cover: Option<String>,
        keywords: Option<super::CtDocInfoKeywordsXElementType>,
        creator: Option<String>,
        creator_version: Option<String>,
        custom_datas: Option<super::CtDocInfoCustomDatasXElementType>,
        state: Box<CtDocInfoXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtDocInfoXTypeDeserializerState {
        Init__,
        DocId(Option<<String as WithDeserializer>::Deserializer>),
        Title(Option<<String as WithDeserializer>::Deserializer>),
        Author(Option<<String as WithDeserializer>::Deserializer>),
        Subject(Option<<String as WithDeserializer>::Deserializer>),
        Abstract(Option<<String as WithDeserializer>::Deserializer>),
        CreationDate(Option<<String as WithDeserializer>::Deserializer>),
        ModDate(Option<<String as WithDeserializer>::Deserializer>),
        DocUsage(Option<<String as WithDeserializer>::Deserializer>),
        Cover(Option<<String as WithDeserializer>::Deserializer>),
        Keywords(Option<<super::CtDocInfoKeywordsXElementType as WithDeserializer>::Deserializer>),
        Creator(Option<<String as WithDeserializer>::Deserializer>),
        CreatorVersion(Option<<String as WithDeserializer>::Deserializer>),
        CustomDatas(
            Option<<super::CtDocInfoCustomDatasXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl CtDocInfoXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                doc_id: None,
                title: None,
                author: None,
                subject: None,
                abstract_: None,
                creation_date: None,
                mod_date: None,
                doc_usage: None,
                cover: None,
                keywords: None,
                creator: None,
                creator_version: None,
                custom_datas: None,
                state: Box::new(CtDocInfoXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtDocInfoXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtDocInfoXTypeDeserializerState as S;
            match state {
                S::DocId(Some(deserializer)) => self.store_doc_id(deserializer.finish(reader)?)?,
                S::Title(Some(deserializer)) => self.store_title(deserializer.finish(reader)?)?,
                S::Author(Some(deserializer)) => self.store_author(deserializer.finish(reader)?)?,
                S::Subject(Some(deserializer)) => {
                    self.store_subject(deserializer.finish(reader)?)?
                }
                S::Abstract(Some(deserializer)) => {
                    self.store_abstract_(deserializer.finish(reader)?)?
                }
                S::CreationDate(Some(deserializer)) => {
                    self.store_creation_date(deserializer.finish(reader)?)?
                }
                S::ModDate(Some(deserializer)) => {
                    self.store_mod_date(deserializer.finish(reader)?)?
                }
                S::DocUsage(Some(deserializer)) => {
                    self.store_doc_usage(deserializer.finish(reader)?)?
                }
                S::Cover(Some(deserializer)) => self.store_cover(deserializer.finish(reader)?)?,
                S::Keywords(Some(deserializer)) => {
                    self.store_keywords(deserializer.finish(reader)?)?
                }
                S::Creator(Some(deserializer)) => {
                    self.store_creator(deserializer.finish(reader)?)?
                }
                S::CreatorVersion(Some(deserializer)) => {
                    self.store_creator_version(deserializer.finish(reader)?)?
                }
                S::CustomDatas(Some(deserializer)) => {
                    self.store_custom_datas(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_doc_id(&mut self, value: String) -> Result<(), Error> {
            if self.doc_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DocID",
                )))?;
            }
            self.doc_id = Some(value);
            Ok(())
        }
        fn store_title(&mut self, value: String) -> Result<(), Error> {
            if self.title.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Title",
                )))?;
            }
            self.title = Some(value);
            Ok(())
        }
        fn store_author(&mut self, value: String) -> Result<(), Error> {
            if self.author.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Author",
                )))?;
            }
            self.author = Some(value);
            Ok(())
        }
        fn store_subject(&mut self, value: String) -> Result<(), Error> {
            if self.subject.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Subject",
                )))?;
            }
            self.subject = Some(value);
            Ok(())
        }
        fn store_abstract_(&mut self, value: String) -> Result<(), Error> {
            if self.abstract_.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Abstract",
                )))?;
            }
            self.abstract_ = Some(value);
            Ok(())
        }
        fn store_creation_date(&mut self, value: String) -> Result<(), Error> {
            if self.creation_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CreationDate",
                )))?;
            }
            self.creation_date = Some(value);
            Ok(())
        }
        fn store_mod_date(&mut self, value: String) -> Result<(), Error> {
            if self.mod_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ModDate",
                )))?;
            }
            self.mod_date = Some(value);
            Ok(())
        }
        fn store_doc_usage(&mut self, value: String) -> Result<(), Error> {
            if self.doc_usage.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DocUsage",
                )))?;
            }
            self.doc_usage = Some(value);
            Ok(())
        }
        fn store_cover(&mut self, value: String) -> Result<(), Error> {
            if self.cover.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Cover",
                )))?;
            }
            self.cover = Some(value);
            Ok(())
        }
        fn store_keywords(
            &mut self,
            value: super::CtDocInfoKeywordsXElementType,
        ) -> Result<(), Error> {
            if self.keywords.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Keywords",
                )))?;
            }
            self.keywords = Some(value);
            Ok(())
        }
        fn store_creator(&mut self, value: String) -> Result<(), Error> {
            if self.creator.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Creator",
                )))?;
            }
            self.creator = Some(value);
            Ok(())
        }
        fn store_creator_version(&mut self, value: String) -> Result<(), Error> {
            if self.creator_version.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CreatorVersion",
                )))?;
            }
            self.creator_version = Some(value);
            Ok(())
        }
        fn store_custom_datas(
            &mut self,
            value: super::CtDocInfoCustomDatasXElementType,
        ) -> Result<(), Error> {
            if self.custom_datas.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CustomDatas",
                )))?;
            }
            self.custom_datas = Some(value);
            Ok(())
        }
        fn handle_doc_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.doc_id.is_some() {
                    fallback.get_or_insert(CtDocInfoXTypeDeserializerState::DocId(None));
                    *self.state = CtDocInfoXTypeDeserializerState::Title(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtDocInfoXTypeDeserializerState::DocId(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_doc_id(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::Title(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::DocId(Some(
                                deserializer,
                            )));
                            *self.state = CtDocInfoXTypeDeserializerState::Title(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::DocId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_title<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Title(None));
                *self.state = CtDocInfoXTypeDeserializerState::Author(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_title(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::Author(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Title(Some(
                                deserializer,
                            )));
                            *self.state = CtDocInfoXTypeDeserializerState::Author(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::Title(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_author<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Author(None));
                *self.state = CtDocInfoXTypeDeserializerState::Subject(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_author(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::Subject(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Author(Some(
                                deserializer,
                            )));
                            *self.state = CtDocInfoXTypeDeserializerState::Subject(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::Author(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_subject<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Subject(None));
                *self.state = CtDocInfoXTypeDeserializerState::Abstract(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_subject(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::Abstract(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Subject(Some(
                                deserializer,
                            )));
                            *self.state = CtDocInfoXTypeDeserializerState::Abstract(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::Subject(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_abstract_<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Abstract(None));
                *self.state = CtDocInfoXTypeDeserializerState::CreationDate(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_abstract_(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::CreationDate(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Abstract(
                                Some(deserializer),
                            ));
                            *self.state = CtDocInfoXTypeDeserializerState::CreationDate(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::Abstract(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_creation_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::CreationDate(None));
                *self.state = CtDocInfoXTypeDeserializerState::ModDate(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_creation_date(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::ModDate(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::CreationDate(
                                Some(deserializer),
                            ));
                            *self.state = CtDocInfoXTypeDeserializerState::ModDate(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::CreationDate(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mod_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::ModDate(None));
                *self.state = CtDocInfoXTypeDeserializerState::DocUsage(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mod_date(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::DocUsage(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::ModDate(Some(
                                deserializer,
                            )));
                            *self.state = CtDocInfoXTypeDeserializerState::DocUsage(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::ModDate(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_doc_usage<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::DocUsage(None));
                *self.state = CtDocInfoXTypeDeserializerState::Cover(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_doc_usage(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::Cover(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::DocUsage(
                                Some(deserializer),
                            ));
                            *self.state = CtDocInfoXTypeDeserializerState::Cover(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::DocUsage(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_cover<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Cover(None));
                *self.state = CtDocInfoXTypeDeserializerState::Keywords(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_cover(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::Keywords(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Cover(Some(
                                deserializer,
                            )));
                            *self.state = CtDocInfoXTypeDeserializerState::Keywords(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::Cover(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_keywords<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtDocInfoKeywordsXElementType>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Keywords(None));
                *self.state = CtDocInfoXTypeDeserializerState::Creator(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_keywords(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::Creator(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Keywords(
                                Some(deserializer),
                            ));
                            *self.state = CtDocInfoXTypeDeserializerState::Creator(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::Keywords(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_creator<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Creator(None));
                *self.state = CtDocInfoXTypeDeserializerState::CreatorVersion(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_creator(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::CreatorVersion(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::Creator(Some(
                                deserializer,
                            )));
                            *self.state = CtDocInfoXTypeDeserializerState::CreatorVersion(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::Creator(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_creator_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::CreatorVersion(None));
                *self.state = CtDocInfoXTypeDeserializerState::CustomDatas(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_creator_version(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::CustomDatas(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtDocInfoXTypeDeserializerState::CreatorVersion(Some(deserializer)),
                            );
                            *self.state = CtDocInfoXTypeDeserializerState::CustomDatas(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::CreatorVersion(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_custom_datas<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtDocInfoCustomDatasXElementType>,
            fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDocInfoXTypeDeserializerState::CustomDatas(None));
                *self.state = CtDocInfoXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_custom_datas(data)?;
                    *self.state = CtDocInfoXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDocInfoXTypeDeserializerState::CustomDatas(
                                Some(deserializer),
                            ));
                            *self.state = CtDocInfoXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoXTypeDeserializerState::CustomDatas(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtDocInfoXType> for CtDocInfoXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtDocInfoXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDocInfoXType>
        where
            R: DeserializeReader,
        {
            use CtDocInfoXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DocId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_doc_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Title(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_title(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Author(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_author(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Subject(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_subject(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Abstract(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_abstract_(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CreationDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_creation_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ModDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mod_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DocUsage(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_doc_usage(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Cover(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_cover(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Keywords(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_keywords(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Creator(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_creator(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CreatorVersion(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_creator_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CustomDatas(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_custom_datas(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtDocInfoXTypeDeserializerState::DocId(None);
                        event
                    }
                    (S::DocId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DocID",
                            false,
                        )?;
                        match self.handle_doc_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Title(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Title",
                            false,
                        )?;
                        match self.handle_title(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Author(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Author",
                            false,
                        )?;
                        match self.handle_author(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Subject(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Subject",
                            false,
                        )?;
                        match self.handle_subject(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Abstract(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Abstract",
                            false,
                        )?;
                        match self.handle_abstract_(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CreationDate(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CreationDate",
                            false,
                        )?;
                        match self.handle_creation_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ModDate(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ModDate",
                            false,
                        )?;
                        match self.handle_mod_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DocUsage(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DocUsage",
                            false,
                        )?;
                        match self.handle_doc_usage(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Cover(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Cover",
                            false,
                        )?;
                        match self.handle_cover(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Keywords(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Keywords",
                            false,
                        )?;
                        match self.handle_keywords(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Creator(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Creator",
                            false,
                        )?;
                        match self.handle_creator(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CreatorVersion(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CreatorVersion",
                            false,
                        )?;
                        match self.handle_creator_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CustomDatas(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CustomDatas",
                            false,
                        )?;
                        match self.handle_custom_datas(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtDocInfoXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtDocInfoXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtDocInfoXType {
                doc_id: self
                    .doc_id
                    .ok_or_else(|| ErrorKind::MissingElement("DocID".into()))?,
                title: self.title,
                author: self.author,
                subject: self.subject,
                abstract_: self.abstract_,
                creation_date: self.creation_date,
                mod_date: self.mod_date,
                doc_usage: self.doc_usage,
                cover: self.cover,
                keywords: self.keywords,
                creator: self.creator,
                creator_version: self.creator_version,
                custom_datas: self.custom_datas,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtDrawParamXTypeDeserializer {
        relative: Option<u32>,
        line_width: f64,
        join: String,
        cap: String,
        dash_offset: f64,
        dash_pattern: Option<String>,
        miter_limit: f64,
        fill_color: Option<super::CtColorXType>,
        stroke_color: Option<super::CtColorXType>,
        state: Box<CtDrawParamXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtDrawParamXTypeDeserializerState {
        Init__,
        FillColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        StrokeColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtDrawParamXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut relative: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut join: Option<String> = None;
            let mut cap: Option<String> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut miter_limit: Option<f64> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Relative")
                ) {
                    reader.read_attrib(&mut relative, b"Relative", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                relative: relative,
                line_width: line_width.unwrap_or_else(super::CtDrawParamXType::default_line_width),
                join: join.unwrap_or_else(super::CtDrawParamXType::default_join),
                cap: cap.unwrap_or_else(super::CtDrawParamXType::default_cap),
                dash_offset: dash_offset
                    .unwrap_or_else(super::CtDrawParamXType::default_dash_offset),
                dash_pattern: dash_pattern,
                miter_limit: miter_limit
                    .unwrap_or_else(super::CtDrawParamXType::default_miter_limit),
                fill_color: None,
                stroke_color: None,
                state: Box::new(CtDrawParamXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtDrawParamXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtDrawParamXTypeDeserializerState as S;
            match state {
                S::FillColor(Some(deserializer)) => {
                    self.store_fill_color(deserializer.finish(reader)?)?
                }
                S::StrokeColor(Some(deserializer)) => {
                    self.store_stroke_color(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_fill_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.fill_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FillColor",
                )))?;
            }
            self.fill_color = Some(value);
            Ok(())
        }
        fn store_stroke_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.stroke_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"StrokeColor",
                )))?;
            }
            self.stroke_color = Some(value);
            Ok(())
        }
        fn handle_fill_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtDrawParamXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDrawParamXTypeDeserializerState::FillColor(None));
                *self.state = CtDrawParamXTypeDeserializerState::StrokeColor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fill_color(data)?;
                    *self.state = CtDrawParamXTypeDeserializerState::StrokeColor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDrawParamXTypeDeserializerState::FillColor(
                                Some(deserializer),
                            ));
                            *self.state = CtDrawParamXTypeDeserializerState::StrokeColor(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDrawParamXTypeDeserializerState::FillColor(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_stroke_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtDrawParamXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtDrawParamXTypeDeserializerState::StrokeColor(None));
                *self.state = CtDrawParamXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_stroke_color(data)?;
                    *self.state = CtDrawParamXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtDrawParamXTypeDeserializerState::StrokeColor(
                                Some(deserializer),
                            ));
                            *self.state = CtDrawParamXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDrawParamXTypeDeserializerState::StrokeColor(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtDrawParamXType> for CtDrawParamXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDrawParamXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDrawParamXType>
        where
            R: DeserializeReader,
        {
            use CtDrawParamXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::FillColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fill_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StrokeColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_stroke_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtDrawParamXTypeDeserializerState::FillColor(None);
                        event
                    }
                    (S::FillColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FillColor",
                            true,
                        )?;
                        match self.handle_fill_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StrokeColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"StrokeColor",
                            true,
                        )?;
                        match self.handle_stroke_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtDrawParamXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtDrawParamXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtDrawParamXType {
                relative: self.relative,
                line_width: self.line_width,
                join: self.join,
                cap: self.cap,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                miter_limit: self.miter_limit,
                fill_color: self.fill_color,
                stroke_color: self.stroke_color,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtExtensionXTypeDeserializer {
        app_name: String,
        company: Option<String>,
        app_version: Option<String>,
        date: Option<String>,
        ref_id: u32,
        content: Vec<super::CtExtensionXTypeContent>,
        state: Box<CtExtensionXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtExtensionXTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtExtensionXTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtExtensionXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut app_name: Option<String> = None;
            let mut company: Option<String> = None;
            let mut app_version: Option<String> = None;
            let mut date: Option<String> = None;
            let mut ref_id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"AppName")
                ) {
                    reader.read_attrib(&mut app_name, b"AppName", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Company")
                ) {
                    reader.read_attrib(&mut company, b"Company", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"AppVersion")
                ) {
                    reader.read_attrib(&mut app_version, b"AppVersion", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Date")
                ) {
                    reader.read_attrib(&mut date, b"Date", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"RefId")
                ) {
                    reader.read_attrib(&mut ref_id, b"RefId", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                app_name: app_name.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("AppName".into()))
                })?,
                company: company,
                app_version: app_version,
                date: date,
                ref_id: ref_id
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("RefId".into())))?,
                content: Vec::new(),
                state: Box::new(CtExtensionXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtExtensionXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtExtensionXTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::CtExtensionXTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtExtensionXTypeContent>,
            fallback: &mut Option<CtExtensionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtExtensionXTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtExtensionXTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtExtensionXTypeDeserializerState::Content__(deserializer);
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtExtensionXTypeDeserializerState::Content__(
                                deserializer,
                            ));
                            *self.state = CtExtensionXTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtExtensionXType> for CtExtensionXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtExtensionXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtExtensionXType>
        where
            R: DeserializeReader,
        {
            use CtExtensionXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: CtExtensionXTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtExtensionXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtExtensionXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtExtensionXType {
                app_name: self.app_name,
                company: self.company,
                app_version: self.app_version,
                date: self.date,
                ref_id: self.ref_id,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtExtensionXTypeContentDeserializer {
        state: Box<CtExtensionXTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtExtensionXTypeContentDeserializerState {
        Init__,
        Property(
            Option<super::CtExtensionPropertyXElementType>,
            Option<<super::CtExtensionPropertyXElementType as WithDeserializer>::Deserializer>,
        ),
        Data(
            Option<super::xs::AnyTypeXType>,
            Option<<super::xs::AnyTypeXType as WithDeserializer>::Deserializer>,
        ),
        ExtendData(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtExtensionXTypeContent),
        Unknown__,
    }
    impl CtExtensionXTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtExtensionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Property")
                ) {
                    let output = < super :: CtExtensionPropertyXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_property(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Data")
                ) {
                    let output = <super::xs::AnyTypeXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_data(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ExtendData")
                ) {
                    let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                    return self.handle_extend_data(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtExtensionXTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtExtensionXTypeContentDeserializerState,
        ) -> Result<super::CtExtensionXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtExtensionXTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Property(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_property(&mut values, value)?;
                    }
                    Ok(super::CtExtensionXTypeContent::Property(
                        values.ok_or_else(|| ErrorKind::MissingElement("Property".into()))?,
                    ))
                }
                S::Data(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_data(&mut values, value)?;
                    }
                    Ok(super::CtExtensionXTypeContent::Data(
                        values.ok_or_else(|| ErrorKind::MissingElement("Data".into()))?,
                    ))
                }
                S::ExtendData(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_extend_data(&mut values, value)?;
                    }
                    Ok(super::CtExtensionXTypeContent::ExtendData(
                        values.ok_or_else(|| ErrorKind::MissingElement("ExtendData".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_property(
            values: &mut Option<super::CtExtensionPropertyXElementType>,
            value: super::CtExtensionPropertyXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Property",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_data(
            values: &mut Option<super::xs::AnyTypeXType>,
            value: super::xs::AnyTypeXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Data")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_extend_data(values: &mut Option<String>, value: String) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ExtendData",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_property<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtExtensionPropertyXElementType>,
            output: DeserializerOutput<'de, super::CtExtensionPropertyXElementType>,
            fallback: &mut Option<CtExtensionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtExtensionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtExtensionXTypeContentDeserializerState::Property(values, None),
                    Some(CtExtensionXTypeContentDeserializerState::Property(
                        _,
                        Some(deserializer),
                    )) => CtExtensionXTypeContentDeserializerState::Property(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtExtensionXTypeContentDeserializerState::Property(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_property(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_property(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtExtensionXTypeContentDeserializerState::Property(values, None),
                    )?;
                    *self.state = CtExtensionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtExtensionXTypeContentDeserializerState::Property(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_data<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::xs::AnyTypeXType>,
            output: DeserializerOutput<'de, super::xs::AnyTypeXType>,
            fallback: &mut Option<CtExtensionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtExtensionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtExtensionXTypeContentDeserializerState::Data(values, None),
                    Some(CtExtensionXTypeContentDeserializerState::Data(_, Some(deserializer))) => {
                        CtExtensionXTypeContentDeserializerState::Data(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtExtensionXTypeContentDeserializerState::Data(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_data(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_data(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtExtensionXTypeContentDeserializerState::Data(values, None),
                    )?;
                    *self.state = CtExtensionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtExtensionXTypeContentDeserializerState::Data(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_extend_data<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtExtensionXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtExtensionXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtExtensionXTypeContentDeserializerState::ExtendData(values, None),
                    Some(CtExtensionXTypeContentDeserializerState::ExtendData(
                        _,
                        Some(deserializer),
                    )) => CtExtensionXTypeContentDeserializerState::ExtendData(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtExtensionXTypeContentDeserializerState::ExtendData(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_extend_data(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_extend_data(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtExtensionXTypeContentDeserializerState::ExtendData(values, None),
                    )?;
                    *self.state = CtExtensionXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtExtensionXTypeContentDeserializerState::ExtendData(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtExtensionXTypeContent>
        for CtExtensionXTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtExtensionXTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtExtensionXTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, CtExtensionXTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtExtensionXTypeContent>
        where
            R: DeserializeReader,
        {
            use CtExtensionXTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Property(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_property(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Data(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_data(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ExtendData(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_extend_data(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Property(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Property",
                            false,
                        )?;
                        match self.handle_property(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Data(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Data",
                            true,
                        )?;
                        match self.handle_data(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ExtendData(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ExtendData",
                            false,
                        )?;
                        match self.handle_extend_data(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtExtensionXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtFontXTypeDeserializer {
        font_name: String,
        family_name: Option<String>,
        charset: super::CtFontCharsetXType,
        italic: bool,
        bold: bool,
        serif: bool,
        fixed_width: bool,
        font_file: Option<String>,
        state: Box<CtFontXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtFontXTypeDeserializerState {
        Init__,
        FontFile(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtFontXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut font_name: Option<String> = None;
            let mut family_name: Option<String> = None;
            let mut charset: Option<super::CtFontCharsetXType> = None;
            let mut italic: Option<bool> = None;
            let mut bold: Option<bool> = None;
            let mut serif: Option<bool> = None;
            let mut fixed_width: Option<bool> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"FontName")
                ) {
                    reader.read_attrib(&mut font_name, b"FontName", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"FamilyName")
                ) {
                    reader.read_attrib(&mut family_name, b"FamilyName", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Charset")
                ) {
                    reader.read_attrib(&mut charset, b"Charset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Italic")
                ) {
                    reader.read_attrib(&mut italic, b"Italic", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Bold")
                ) {
                    reader.read_attrib(&mut bold, b"Bold", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Serif")
                ) {
                    reader.read_attrib(&mut serif, b"Serif", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"FixedWidth")
                ) {
                    reader.read_attrib(&mut fixed_width, b"FixedWidth", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                font_name: font_name.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("FontName".into()))
                })?,
                family_name: family_name,
                charset: charset.unwrap_or_else(super::CtFontXType::default_charset),
                italic: italic.unwrap_or_else(super::CtFontXType::default_italic),
                bold: bold.unwrap_or_else(super::CtFontXType::default_bold),
                serif: serif.unwrap_or_else(super::CtFontXType::default_serif),
                fixed_width: fixed_width.unwrap_or_else(super::CtFontXType::default_fixed_width),
                font_file: None,
                state: Box::new(CtFontXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtFontXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtFontXTypeDeserializerState as S;
            match state {
                S::FontFile(Some(deserializer)) => {
                    self.store_font_file(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_font_file(&mut self, value: String) -> Result<(), Error> {
            if self.font_file.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FontFile",
                )))?;
            }
            self.font_file = Some(value);
            Ok(())
        }
        fn handle_font_file<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtFontXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtFontXTypeDeserializerState::FontFile(None));
                *self.state = CtFontXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_font_file(data)?;
                    *self.state = CtFontXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtFontXTypeDeserializerState::FontFile(Some(
                                deserializer,
                            )));
                            *self.state = CtFontXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtFontXTypeDeserializerState::FontFile(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtFontXType> for CtFontXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtFontXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtFontXType>
        where
            R: DeserializeReader,
        {
            use CtFontXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::FontFile(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_font_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtFontXTypeDeserializerState::FontFile(None);
                        event
                    }
                    (S::FontFile(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FontFile",
                            false,
                        )?;
                        match self.handle_font_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtFontXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtFontXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtFontXType {
                font_name: self.font_name,
                family_name: self.family_name,
                charset: self.charset,
                italic: self.italic,
                bold: self.bold,
                serif: self.serif,
                fixed_width: self.fixed_width,
                font_file: self.font_file,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtGouraudShdXTypeDeserializer {
        extend: Option<i32>,
        point: Vec<super::CtGouraudShdPointXElementType>,
        back_color: Option<super::CtColorXType>,
        state: Box<CtGouraudShdXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtGouraudShdXTypeDeserializerState {
        Init__,
        Point(Option<<super::CtGouraudShdPointXElementType as WithDeserializer>::Deserializer>),
        BackColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtGouraudShdXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut extend: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Extend")
                ) {
                    reader.read_attrib(&mut extend, b"Extend", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                extend: extend,
                point: Vec::new(),
                back_color: None,
                state: Box::new(CtGouraudShdXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtGouraudShdXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtGouraudShdXTypeDeserializerState as S;
            match state {
                S::Point(Some(deserializer)) => self.store_point(deserializer.finish(reader)?)?,
                S::BackColor(Some(deserializer)) => {
                    self.store_back_color(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_point(
            &mut self,
            value: super::CtGouraudShdPointXElementType,
        ) -> Result<(), Error> {
            self.point.push(value);
            Ok(())
        }
        fn store_back_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.back_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BackColor",
                )))?;
            }
            self.back_color = Some(value);
            Ok(())
        }
        fn handle_point<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGouraudShdPointXElementType>,
            fallback: &mut Option<CtGouraudShdXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.point.len() < 3usize {
                    *self.state = CtGouraudShdXTypeDeserializerState::Point(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CtGouraudShdXTypeDeserializerState::Point(None));
                    *self.state = CtGouraudShdXTypeDeserializerState::BackColor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_point(data)?;
                    *self.state = CtGouraudShdXTypeDeserializerState::Point(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtGouraudShdXTypeDeserializerState::Point(
                                Some(deserializer),
                            ));
                            if self.point.len().saturating_add(1) < 3usize {
                                *self.state = CtGouraudShdXTypeDeserializerState::Point(None);
                            } else {
                                *self.state = CtGouraudShdXTypeDeserializerState::BackColor(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtGouraudShdXTypeDeserializerState::Point(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_back_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtGouraudShdXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtGouraudShdXTypeDeserializerState::BackColor(None));
                *self.state = CtGouraudShdXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_back_color(data)?;
                    *self.state = CtGouraudShdXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtGouraudShdXTypeDeserializerState::BackColor(
                                Some(deserializer),
                            ));
                            *self.state = CtGouraudShdXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtGouraudShdXTypeDeserializerState::BackColor(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtGouraudShdXType> for CtGouraudShdXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGouraudShdXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGouraudShdXType>
        where
            R: DeserializeReader,
        {
            use CtGouraudShdXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Point(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_point(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BackColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_back_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtGouraudShdXTypeDeserializerState::Point(None);
                        event
                    }
                    (S::Point(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Point",
                            true,
                        )?;
                        match self.handle_point(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BackColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"BackColor",
                            true,
                        )?;
                        match self.handle_back_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtGouraudShdXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtGouraudShdXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtGouraudShdXType {
                extend: self.extend,
                point: self.point,
                back_color: self.back_color.map(Box::new),
            })
        }
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitXTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        clips: Option<super::CtGraphicUnitClipsXElementType>,
        state: Box<CtGraphicUnitXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtGraphicUnitXTypeDeserializerState {
        Init__,
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtGraphicUnitXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible.unwrap_or_else(super::CtGraphicUnitXType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width
                    .unwrap_or_else(super::CtGraphicUnitXType::default_line_width),
                cap: cap.unwrap_or_else(super::CtGraphicUnitXType::default_cap),
                join: join.unwrap_or_else(super::CtGraphicUnitXType::default_join),
                miter_limit: miter_limit
                    .unwrap_or_else(super::CtGraphicUnitXType::default_miter_limit),
                dash_offset: dash_offset
                    .unwrap_or_else(super::CtGraphicUnitXType::default_dash_offset),
                dash_pattern: dash_pattern,
                alpha: alpha.unwrap_or_else(super::CtGraphicUnitXType::default_alpha),
                actions: None,
                clips: None,
                state: Box::new(CtGraphicUnitXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtGraphicUnitXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtGraphicUnitXTypeDeserializerState as S;
            match state {
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::Clips(Some(deserializer)) => self.store_clips(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_clips(
            &mut self,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if self.clips.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            self.clips = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtGraphicUnitXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtGraphicUnitXTypeDeserializerState::Actions(None));
                *self.state = CtGraphicUnitXTypeDeserializerState::Clips(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = CtGraphicUnitXTypeDeserializerState::Clips(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtGraphicUnitXTypeDeserializerState::Actions(
                                Some(deserializer),
                            ));
                            *self.state = CtGraphicUnitXTypeDeserializerState::Clips(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtGraphicUnitXTypeDeserializerState::Actions(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtGraphicUnitXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtGraphicUnitXTypeDeserializerState::Clips(None));
                *self.state = CtGraphicUnitXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_clips(data)?;
                    *self.state = CtGraphicUnitXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtGraphicUnitXTypeDeserializerState::Clips(
                                Some(deserializer),
                            ));
                            *self.state = CtGraphicUnitXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtGraphicUnitXTypeDeserializerState::Clips(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtGraphicUnitXType> for CtGraphicUnitXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGraphicUnitXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGraphicUnitXType>
        where
            R: DeserializeReader,
        {
            use CtGraphicUnitXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtGraphicUnitXTypeDeserializerState::Actions(None);
                        event
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtGraphicUnitXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtGraphicUnitXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtGraphicUnitXType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                actions: self.actions,
                clips: self.clips,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtImageXTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        resource_id: u32,
        substitution: Option<u32>,
        image_mask: Option<u32>,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        clips: Option<super::CtGraphicUnitClipsXElementType>,
        border: Option<super::CtImageBorderXElementType>,
        state: Box<CtImageXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtImageXTypeDeserializerState {
        Init__,
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>),
        Border(Option<<super::CtImageBorderXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtImageXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            let mut resource_id: Option<u32> = None;
            let mut substitution: Option<u32> = None;
            let mut image_mask: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ResourceID")
                ) {
                    reader.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Substitution")
                ) {
                    reader.read_attrib(&mut substitution, b"Substitution", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ImageMask")
                ) {
                    reader.read_attrib(&mut image_mask, b"ImageMask", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible.unwrap_or_else(super::CtImageXType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width.unwrap_or_else(super::CtImageXType::default_line_width),
                cap: cap.unwrap_or_else(super::CtImageXType::default_cap),
                join: join.unwrap_or_else(super::CtImageXType::default_join),
                miter_limit: miter_limit.unwrap_or_else(super::CtImageXType::default_miter_limit),
                dash_offset: dash_offset.unwrap_or_else(super::CtImageXType::default_dash_offset),
                dash_pattern: dash_pattern,
                alpha: alpha.unwrap_or_else(super::CtImageXType::default_alpha),
                resource_id: resource_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("ResourceID".into()))
                })?,
                substitution: substitution,
                image_mask: image_mask,
                actions: None,
                clips: None,
                border: None,
                state: Box::new(CtImageXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtImageXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtImageXTypeDeserializerState as S;
            match state {
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::Clips(Some(deserializer)) => self.store_clips(deserializer.finish(reader)?)?,
                S::Border(Some(deserializer)) => self.store_border(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_clips(
            &mut self,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if self.clips.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            self.clips = Some(value);
            Ok(())
        }
        fn store_border(&mut self, value: super::CtImageBorderXElementType) -> Result<(), Error> {
            if self.border.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Border",
                )))?;
            }
            self.border = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtImageXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtImageXTypeDeserializerState::Actions(None));
                *self.state = CtImageXTypeDeserializerState::Clips(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = CtImageXTypeDeserializerState::Clips(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtImageXTypeDeserializerState::Actions(Some(
                                deserializer,
                            )));
                            *self.state = CtImageXTypeDeserializerState::Clips(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtImageXTypeDeserializerState::Actions(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtImageXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtImageXTypeDeserializerState::Clips(None));
                *self.state = CtImageXTypeDeserializerState::Border(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_clips(data)?;
                    *self.state = CtImageXTypeDeserializerState::Border(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtImageXTypeDeserializerState::Clips(Some(
                                deserializer,
                            )));
                            *self.state = CtImageXTypeDeserializerState::Border(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtImageXTypeDeserializerState::Clips(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_border<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtImageBorderXElementType>,
            fallback: &mut Option<CtImageXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtImageXTypeDeserializerState::Border(None));
                *self.state = CtImageXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_border(data)?;
                    *self.state = CtImageXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtImageXTypeDeserializerState::Border(Some(
                                deserializer,
                            )));
                            *self.state = CtImageXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtImageXTypeDeserializerState::Border(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtImageXType> for CtImageXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtImageXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtImageXType>
        where
            R: DeserializeReader,
        {
            use CtImageXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Border(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_border(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtImageXTypeDeserializerState::Actions(None);
                        event
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Border(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Border",
                            true,
                        )?;
                        match self.handle_border(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtImageXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtImageXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtImageXType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                resource_id: self.resource_id,
                substitution: self.substitution,
                image_mask: self.image_mask,
                actions: self.actions,
                clips: self.clips,
                border: self.border,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtLaGouraudShdXTypeDeserializer {
        vertices_per_row: i32,
        extend: Option<i32>,
        point: Vec<super::CtLaGouraudShdPointXElementType>,
        back_color: Option<super::CtColorXType>,
        state: Box<CtLaGouraudShdXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtLaGouraudShdXTypeDeserializerState {
        Init__,
        Point(Option<<super::CtLaGouraudShdPointXElementType as WithDeserializer>::Deserializer>),
        BackColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtLaGouraudShdXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut vertices_per_row: Option<i32> = None;
            let mut extend: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"VerticesPerRow")
                ) {
                    reader.read_attrib(&mut vertices_per_row, b"VerticesPerRow", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Extend")
                ) {
                    reader.read_attrib(&mut extend, b"Extend", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                vertices_per_row: vertices_per_row.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("VerticesPerRow".into()))
                })?,
                extend: extend,
                point: Vec::new(),
                back_color: None,
                state: Box::new(CtLaGouraudShdXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtLaGouraudShdXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtLaGouraudShdXTypeDeserializerState as S;
            match state {
                S::Point(Some(deserializer)) => self.store_point(deserializer.finish(reader)?)?,
                S::BackColor(Some(deserializer)) => {
                    self.store_back_color(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_point(
            &mut self,
            value: super::CtLaGouraudShdPointXElementType,
        ) -> Result<(), Error> {
            self.point.push(value);
            Ok(())
        }
        fn store_back_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.back_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BackColor",
                )))?;
            }
            self.back_color = Some(value);
            Ok(())
        }
        fn handle_point<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtLaGouraudShdPointXElementType>,
            fallback: &mut Option<CtLaGouraudShdXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.point.len() < 4usize {
                    *self.state = CtLaGouraudShdXTypeDeserializerState::Point(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CtLaGouraudShdXTypeDeserializerState::Point(None));
                    *self.state = CtLaGouraudShdXTypeDeserializerState::BackColor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_point(data)?;
                    *self.state = CtLaGouraudShdXTypeDeserializerState::Point(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtLaGouraudShdXTypeDeserializerState::Point(
                                Some(deserializer),
                            ));
                            if self.point.len().saturating_add(1) < 4usize {
                                *self.state = CtLaGouraudShdXTypeDeserializerState::Point(None);
                            } else {
                                *self.state = CtLaGouraudShdXTypeDeserializerState::BackColor(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtLaGouraudShdXTypeDeserializerState::Point(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_back_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtLaGouraudShdXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtLaGouraudShdXTypeDeserializerState::BackColor(None));
                *self.state = CtLaGouraudShdXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_back_color(data)?;
                    *self.state = CtLaGouraudShdXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtLaGouraudShdXTypeDeserializerState::BackColor(Some(deserializer)),
                            );
                            *self.state = CtLaGouraudShdXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtLaGouraudShdXTypeDeserializerState::BackColor(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtLaGouraudShdXType> for CtLaGouraudShdXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtLaGouraudShdXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtLaGouraudShdXType>
        where
            R: DeserializeReader,
        {
            use CtLaGouraudShdXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Point(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_point(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BackColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_back_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtLaGouraudShdXTypeDeserializerState::Point(None);
                        event
                    }
                    (S::Point(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Point",
                            true,
                        )?;
                        match self.handle_point(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BackColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"BackColor",
                            true,
                        )?;
                        match self.handle_back_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtLaGouraudShdXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtLaGouraudShdXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtLaGouraudShdXType {
                vertices_per_row: self.vertices_per_row,
                extend: self.extend,
                point: self.point,
                back_color: self.back_color.map(Box::new),
            })
        }
    }
    #[derive(Debug)]
    pub struct CtLayerXTypeDeserializer {
        type_: super::CtLayerTypeXType,
        draw_param: Option<u32>,
        content: Vec<super::CtLayerXTypeContent>,
        state: Box<CtLayerXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtLayerXTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtLayerXTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtLayerXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CtLayerTypeXType> = None;
            let mut draw_param: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_.unwrap_or_else(super::CtLayerXType::default_type_),
                draw_param: draw_param,
                content: Vec::new(),
                state: Box::new(CtLayerXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtLayerXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtLayerXTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::CtLayerXTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtLayerXTypeContent>,
            fallback: &mut Option<CtLayerXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtLayerXTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtLayerXTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtLayerXTypeDeserializerState::Content__(deserializer);
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtLayerXTypeDeserializerState::Content__(
                                deserializer,
                            ));
                            *self.state = CtLayerXTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtLayerXType> for CtLayerXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtLayerXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtLayerXType>
        where
            R: DeserializeReader,
        {
            use CtLayerXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output =
                            <super::CtLayerXTypeContent as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtLayerXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtLayerXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtLayerXType {
                type_: self.type_,
                draw_param: self.draw_param,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtLayerXTypeContentDeserializer {
        state: Box<CtLayerXTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtLayerXTypeContentDeserializerState {
        Init__,
        TextObject(
            Option<super::CtPageBlockTextObjectXElementType>,
            Option<<super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        PathObject(
            Option<super::CtPageBlockPathObjectXElementType>,
            Option<<super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        ImageObject(
            Option<super::CtPageBlockImageObjectXElementType>,
            Option<<super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        CompositeObject(
            Option<super::CtPageBlockCompositeObjectXElementType>,
            Option<
                <super::CtPageBlockCompositeObjectXElementType as WithDeserializer>::Deserializer,
            >,
        ),
        PageBlock(
            Option<super::CtPageBlockPageBlockXElementType>,
            Option<<super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtLayerXTypeContent),
        Unknown__,
    }
    impl CtLayerXTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtLayerXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TextObject")
                ) {
                    let output = < super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_text_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PathObject")
                ) {
                    let output = < super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_path_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ImageObject")
                ) {
                    let output = < super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_image_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CompositeObject")
                ) {
                    let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_composite_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PageBlock")
                ) {
                    let output = < super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_page_block(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtLayerXTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtLayerXTypeContentDeserializerState,
        ) -> Result<super::CtLayerXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtLayerXTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::TextObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text_object(&mut values, value)?;
                    }
                    Ok(super::CtLayerXTypeContent::TextObject(values.ok_or_else(
                        || ErrorKind::MissingElement("TextObject".into()),
                    )?))
                }
                S::PathObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_path_object(&mut values, value)?;
                    }
                    Ok(super::CtLayerXTypeContent::PathObject(values.ok_or_else(
                        || ErrorKind::MissingElement("PathObject".into()),
                    )?))
                }
                S::ImageObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_image_object(&mut values, value)?;
                    }
                    Ok(super::CtLayerXTypeContent::ImageObject(values.ok_or_else(
                        || ErrorKind::MissingElement("ImageObject".into()),
                    )?))
                }
                S::CompositeObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_composite_object(&mut values, value)?;
                    }
                    Ok(super::CtLayerXTypeContent::CompositeObject(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("CompositeObject".into()))?,
                    ))
                }
                S::PageBlock(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_page_block(&mut values, value)?;
                    }
                    Ok(super::CtLayerXTypeContent::PageBlock(values.ok_or_else(
                        || ErrorKind::MissingElement("PageBlock".into()),
                    )?))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_text_object(
            values: &mut Option<super::CtPageBlockTextObjectXElementType>,
            value: super::CtPageBlockTextObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TextObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_path_object(
            values: &mut Option<super::CtPageBlockPathObjectXElementType>,
            value: super::CtPageBlockPathObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PathObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_image_object(
            values: &mut Option<super::CtPageBlockImageObjectXElementType>,
            value: super::CtPageBlockImageObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ImageObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_composite_object(
            values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
            value: super::CtPageBlockCompositeObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompositeObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_page_block(
            values: &mut Option<super::CtPageBlockPageBlockXElementType>,
            value: super::CtPageBlockPageBlockXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageBlock",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_text_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockTextObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            fallback: &mut Option<CtLayerXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtLayerXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtLayerXTypeContentDeserializerState::TextObject(values, None),
                    Some(CtLayerXTypeContentDeserializerState::TextObject(
                        _,
                        Some(deserializer),
                    )) => {
                        CtLayerXTypeContentDeserializerState::TextObject(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtLayerXTypeContentDeserializerState::TextObject(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtLayerXTypeContentDeserializerState::TextObject(values, None),
                    )?;
                    *self.state = CtLayerXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtLayerXTypeContentDeserializerState::TextObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_path_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPathObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            fallback: &mut Option<CtLayerXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtLayerXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtLayerXTypeContentDeserializerState::PathObject(values, None),
                    Some(CtLayerXTypeContentDeserializerState::PathObject(
                        _,
                        Some(deserializer),
                    )) => {
                        CtLayerXTypeContentDeserializerState::PathObject(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtLayerXTypeContentDeserializerState::PathObject(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_path_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_path_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtLayerXTypeContentDeserializerState::PathObject(values, None),
                    )?;
                    *self.state = CtLayerXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtLayerXTypeContentDeserializerState::PathObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_image_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockImageObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            fallback: &mut Option<CtLayerXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtLayerXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtLayerXTypeContentDeserializerState::ImageObject(values, None),
                    Some(CtLayerXTypeContentDeserializerState::ImageObject(
                        _,
                        Some(deserializer),
                    )) => CtLayerXTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtLayerXTypeContentDeserializerState::ImageObject(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_image_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_image_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtLayerXTypeContentDeserializerState::ImageObject(values, None),
                    )?;
                    *self.state = CtLayerXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtLayerXTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_composite_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            fallback: &mut Option<CtLayerXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtLayerXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtLayerXTypeContentDeserializerState::CompositeObject(values, None),
                    Some(CtLayerXTypeContentDeserializerState::CompositeObject(
                        _,
                        Some(deserializer),
                    )) => CtLayerXTypeContentDeserializerState::CompositeObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtLayerXTypeContentDeserializerState::CompositeObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_composite_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtLayerXTypeContentDeserializerState::CompositeObject(values, None),
                    )?;
                    *self.state = CtLayerXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtLayerXTypeContentDeserializerState::CompositeObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_page_block<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPageBlockXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            fallback: &mut Option<CtLayerXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtLayerXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtLayerXTypeContentDeserializerState::PageBlock(values, None),
                    Some(CtLayerXTypeContentDeserializerState::PageBlock(
                        _,
                        Some(deserializer),
                    )) => {
                        CtLayerXTypeContentDeserializerState::PageBlock(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtLayerXTypeContentDeserializerState::PageBlock(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_page_block(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_page_block(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtLayerXTypeContentDeserializerState::PageBlock(values, None),
                    )?;
                    *self.state = CtLayerXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtLayerXTypeContentDeserializerState::PageBlock(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtLayerXTypeContent> for CtLayerXTypeContentDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtLayerXTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtLayerXTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, CtLayerXTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtLayerXTypeContent>
        where
            R: DeserializeReader,
        {
            use CtLayerXTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TextObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::TextObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TextObject",
                            true,
                        )?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PathObject",
                            true,
                        )?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ImageObject",
                            true,
                        )?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CompositeObject",
                            true,
                        )?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageBlock",
                            true,
                        )?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtLayerXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtMultiMediaXTypeDeserializer {
        type_: super::CtMultiMediaTypeXType,
        format: Option<String>,
        media_file: Option<String>,
        state: Box<CtMultiMediaXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtMultiMediaXTypeDeserializerState {
        Init__,
        MediaFile(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtMultiMediaXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CtMultiMediaTypeXType> = None;
            let mut format: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Format")
                ) {
                    reader.read_attrib(&mut format, b"Format", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Type".into())))?,
                format: format,
                media_file: None,
                state: Box::new(CtMultiMediaXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtMultiMediaXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtMultiMediaXTypeDeserializerState as S;
            match state {
                S::MediaFile(Some(deserializer)) => {
                    self.store_media_file(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_media_file(&mut self, value: String) -> Result<(), Error> {
            if self.media_file.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MediaFile",
                )))?;
            }
            self.media_file = Some(value);
            Ok(())
        }
        fn handle_media_file<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtMultiMediaXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.media_file.is_some() {
                    fallback.get_or_insert(CtMultiMediaXTypeDeserializerState::MediaFile(None));
                    *self.state = CtMultiMediaXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtMultiMediaXTypeDeserializerState::MediaFile(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_media_file(data)?;
                    *self.state = CtMultiMediaXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtMultiMediaXTypeDeserializerState::MediaFile(
                                Some(deserializer),
                            ));
                            *self.state = CtMultiMediaXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtMultiMediaXTypeDeserializerState::MediaFile(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtMultiMediaXType> for CtMultiMediaXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtMultiMediaXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtMultiMediaXType>
        where
            R: DeserializeReader,
        {
            use CtMultiMediaXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::MediaFile(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_media_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtMultiMediaXTypeDeserializerState::MediaFile(None);
                        event
                    }
                    (S::MediaFile(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"MediaFile",
                            false,
                        )?;
                        match self.handle_media_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtMultiMediaXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtMultiMediaXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtMultiMediaXType {
                type_: self.type_,
                format: self.format,
                media_file: self
                    .media_file
                    .ok_or_else(|| ErrorKind::MissingElement("MediaFile".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtOutlineElemXTypeDeserializer {
        title: String,
        count: Option<i32>,
        expanded: bool,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        outline_elem: Vec<super::CtOutlineElemXType>,
        state: Box<CtOutlineElemXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtOutlineElemXTypeDeserializerState {
        Init__,
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        OutlineElem(Option<<super::CtOutlineElemXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtOutlineElemXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut title: Option<String> = None;
            let mut count: Option<i32> = None;
            let mut expanded: Option<bool> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Title")
                ) {
                    reader.read_attrib(&mut title, b"Title", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Count")
                ) {
                    reader.read_attrib(&mut count, b"Count", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Expanded")
                ) {
                    reader.read_attrib(&mut expanded, b"Expanded", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                title: title
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Title".into())))?,
                count: count,
                expanded: expanded.unwrap_or_else(super::CtOutlineElemXType::default_expanded),
                actions: None,
                outline_elem: Vec::new(),
                state: Box::new(CtOutlineElemXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtOutlineElemXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtOutlineElemXTypeDeserializerState as S;
            match state {
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::OutlineElem(Some(deserializer)) => {
                    self.store_outline_elem(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_outline_elem(&mut self, value: super::CtOutlineElemXType) -> Result<(), Error> {
            self.outline_elem.push(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtOutlineElemXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtOutlineElemXTypeDeserializerState::Actions(None));
                *self.state = CtOutlineElemXTypeDeserializerState::OutlineElem(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = CtOutlineElemXTypeDeserializerState::OutlineElem(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtOutlineElemXTypeDeserializerState::Actions(
                                Some(deserializer),
                            ));
                            *self.state = CtOutlineElemXTypeDeserializerState::OutlineElem(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtOutlineElemXTypeDeserializerState::Actions(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_outline_elem<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtOutlineElemXType>,
            fallback: &mut Option<CtOutlineElemXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtOutlineElemXTypeDeserializerState::OutlineElem(None));
                *self.state = CtOutlineElemXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_outline_elem(data)?;
                    *self.state = CtOutlineElemXTypeDeserializerState::OutlineElem(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtOutlineElemXTypeDeserializerState::OutlineElem(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CtOutlineElemXTypeDeserializerState::OutlineElem(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtOutlineElemXTypeDeserializerState::OutlineElem(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtOutlineElemXType> for CtOutlineElemXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtOutlineElemXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtOutlineElemXType>
        where
            R: DeserializeReader,
        {
            use CtOutlineElemXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::OutlineElem(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_outline_elem(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtOutlineElemXTypeDeserializerState::Actions(None);
                        event
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::OutlineElem(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"OutlineElem",
                            true,
                        )?;
                        match self.handle_outline_elem(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtOutlineElemXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtOutlineElemXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtOutlineElemXType {
                title: self.title,
                count: self.count,
                expanded: self.expanded,
                actions: self.actions,
                outline_elem: self.outline_elem,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageAreaXTypeDeserializer {
        physical_box: Option<String>,
        application_box: Option<String>,
        content_box: Option<String>,
        bleed_box: Option<String>,
        state: Box<CtPageAreaXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPageAreaXTypeDeserializerState {
        Init__,
        PhysicalBox(Option<<String as WithDeserializer>::Deserializer>),
        ApplicationBox(Option<<String as WithDeserializer>::Deserializer>),
        ContentBox(Option<<String as WithDeserializer>::Deserializer>),
        BleedBox(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtPageAreaXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                physical_box: None,
                application_box: None,
                content_box: None,
                bleed_box: None,
                state: Box::new(CtPageAreaXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPageAreaXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtPageAreaXTypeDeserializerState as S;
            match state {
                S::PhysicalBox(Some(deserializer)) => {
                    self.store_physical_box(deserializer.finish(reader)?)?
                }
                S::ApplicationBox(Some(deserializer)) => {
                    self.store_application_box(deserializer.finish(reader)?)?
                }
                S::ContentBox(Some(deserializer)) => {
                    self.store_content_box(deserializer.finish(reader)?)?
                }
                S::BleedBox(Some(deserializer)) => {
                    self.store_bleed_box(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_physical_box(&mut self, value: String) -> Result<(), Error> {
            if self.physical_box.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PhysicalBox",
                )))?;
            }
            self.physical_box = Some(value);
            Ok(())
        }
        fn store_application_box(&mut self, value: String) -> Result<(), Error> {
            if self.application_box.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ApplicationBox",
                )))?;
            }
            self.application_box = Some(value);
            Ok(())
        }
        fn store_content_box(&mut self, value: String) -> Result<(), Error> {
            if self.content_box.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ContentBox",
                )))?;
            }
            self.content_box = Some(value);
            Ok(())
        }
        fn store_bleed_box(&mut self, value: String) -> Result<(), Error> {
            if self.bleed_box.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BleedBox",
                )))?;
            }
            self.bleed_box = Some(value);
            Ok(())
        }
        fn handle_physical_box<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtPageAreaXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.physical_box.is_some() {
                    fallback.get_or_insert(CtPageAreaXTypeDeserializerState::PhysicalBox(None));
                    *self.state = CtPageAreaXTypeDeserializerState::ApplicationBox(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtPageAreaXTypeDeserializerState::PhysicalBox(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_physical_box(data)?;
                    *self.state = CtPageAreaXTypeDeserializerState::ApplicationBox(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPageAreaXTypeDeserializerState::PhysicalBox(
                                Some(deserializer),
                            ));
                            *self.state = CtPageAreaXTypeDeserializerState::ApplicationBox(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageAreaXTypeDeserializerState::PhysicalBox(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_application_box<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtPageAreaXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPageAreaXTypeDeserializerState::ApplicationBox(None));
                *self.state = CtPageAreaXTypeDeserializerState::ContentBox(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_application_box(data)?;
                    *self.state = CtPageAreaXTypeDeserializerState::ContentBox(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageAreaXTypeDeserializerState::ApplicationBox(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CtPageAreaXTypeDeserializerState::ContentBox(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtPageAreaXTypeDeserializerState::ApplicationBox(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_content_box<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtPageAreaXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPageAreaXTypeDeserializerState::ContentBox(None));
                *self.state = CtPageAreaXTypeDeserializerState::BleedBox(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content_box(data)?;
                    *self.state = CtPageAreaXTypeDeserializerState::BleedBox(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPageAreaXTypeDeserializerState::ContentBox(
                                Some(deserializer),
                            ));
                            *self.state = CtPageAreaXTypeDeserializerState::BleedBox(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageAreaXTypeDeserializerState::ContentBox(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_bleed_box<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtPageAreaXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPageAreaXTypeDeserializerState::BleedBox(None));
                *self.state = CtPageAreaXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_bleed_box(data)?;
                    *self.state = CtPageAreaXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPageAreaXTypeDeserializerState::BleedBox(
                                Some(deserializer),
                            ));
                            *self.state = CtPageAreaXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageAreaXTypeDeserializerState::BleedBox(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageAreaXType> for CtPageAreaXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtPageAreaXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageAreaXType>
        where
            R: DeserializeReader,
        {
            use CtPageAreaXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::PhysicalBox(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_physical_box(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicationBox(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_application_box(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ContentBox(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content_box(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BleedBox(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_bleed_box(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtPageAreaXTypeDeserializerState::PhysicalBox(None);
                        event
                    }
                    (S::PhysicalBox(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PhysicalBox",
                            false,
                        )?;
                        match self.handle_physical_box(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ApplicationBox(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ApplicationBox",
                            false,
                        )?;
                        match self.handle_application_box(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ContentBox(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ContentBox",
                            false,
                        )?;
                        match self.handle_content_box(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BleedBox(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"BleedBox",
                            false,
                        )?;
                        match self.handle_bleed_box(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtPageAreaXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPageAreaXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPageAreaXType {
                physical_box: self
                    .physical_box
                    .ok_or_else(|| ErrorKind::MissingElement("PhysicalBox".into()))?,
                application_box: self.application_box,
                content_box: self.content_box,
                bleed_box: self.bleed_box,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockXTypeDeserializer {
        content: Vec<super::CtPageBlockXTypeContent>,
        state: Box<CtPageBlockXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPageBlockXTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtPageBlockXTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtPageBlockXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: Vec::new(),
                state: Box::new(CtPageBlockXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPageBlockXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtPageBlockXTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::CtPageBlockXTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPageBlockXTypeContent>,
            fallback: &mut Option<CtPageBlockXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtPageBlockXTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtPageBlockXTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockXTypeDeserializerState::Content__(deserializer);
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPageBlockXTypeDeserializerState::Content__(
                                deserializer,
                            ));
                            *self.state = CtPageBlockXTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockXType> for CtPageBlockXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockXType>
        where
            R: DeserializeReader,
        {
            use CtPageBlockXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: CtPageBlockXTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtPageBlockXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPageBlockXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPageBlockXType {
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockXTypeContentDeserializer {
        state: Box<CtPageBlockXTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtPageBlockXTypeContentDeserializerState {
        Init__,
        TextObject(
            Option<super::CtPageBlockTextObjectXElementType>,
            Option<<super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        PathObject(
            Option<super::CtPageBlockPathObjectXElementType>,
            Option<<super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        ImageObject(
            Option<super::CtPageBlockImageObjectXElementType>,
            Option<<super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        CompositeObject(
            Option<super::CtPageBlockCompositeObjectXElementType>,
            Option<
                <super::CtPageBlockCompositeObjectXElementType as WithDeserializer>::Deserializer,
            >,
        ),
        PageBlock(
            Option<super::CtPageBlockPageBlockXElementType>,
            Option<<super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtPageBlockXTypeContent),
        Unknown__,
    }
    impl CtPageBlockXTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtPageBlockXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TextObject")
                ) {
                    let output = < super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_text_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PathObject")
                ) {
                    let output = < super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_path_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ImageObject")
                ) {
                    let output = < super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_image_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CompositeObject")
                ) {
                    let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_composite_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PageBlock")
                ) {
                    let output = < super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_page_block(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtPageBlockXTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtPageBlockXTypeContentDeserializerState,
        ) -> Result<super::CtPageBlockXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtPageBlockXTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::TextObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text_object(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockXTypeContent::TextObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("TextObject".into()))?,
                    ))
                }
                S::PathObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_path_object(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockXTypeContent::PathObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("PathObject".into()))?,
                    ))
                }
                S::ImageObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_image_object(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockXTypeContent::ImageObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("ImageObject".into()))?,
                    ))
                }
                S::CompositeObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_composite_object(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockXTypeContent::CompositeObject(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("CompositeObject".into()))?,
                    ))
                }
                S::PageBlock(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_page_block(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockXTypeContent::PageBlock(
                        values.ok_or_else(|| ErrorKind::MissingElement("PageBlock".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_text_object(
            values: &mut Option<super::CtPageBlockTextObjectXElementType>,
            value: super::CtPageBlockTextObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TextObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_path_object(
            values: &mut Option<super::CtPageBlockPathObjectXElementType>,
            value: super::CtPageBlockPathObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PathObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_image_object(
            values: &mut Option<super::CtPageBlockImageObjectXElementType>,
            value: super::CtPageBlockImageObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ImageObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_composite_object(
            values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
            value: super::CtPageBlockCompositeObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompositeObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_page_block(
            values: &mut Option<super::CtPageBlockPageBlockXElementType>,
            value: super::CtPageBlockPageBlockXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageBlock",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_text_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockTextObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            fallback: &mut Option<CtPageBlockXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtPageBlockXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockXTypeContentDeserializerState::TextObject(values, None),
                    Some(CtPageBlockXTypeContentDeserializerState::TextObject(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockXTypeContentDeserializerState::TextObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockXTypeContentDeserializerState::TextObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockXTypeContentDeserializerState::TextObject(values, None),
                    )?;
                    *self.state = CtPageBlockXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtPageBlockXTypeContentDeserializerState::TextObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_path_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPathObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            fallback: &mut Option<CtPageBlockXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtPageBlockXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockXTypeContentDeserializerState::PathObject(values, None),
                    Some(CtPageBlockXTypeContentDeserializerState::PathObject(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockXTypeContentDeserializerState::PathObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockXTypeContentDeserializerState::PathObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_path_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_path_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockXTypeContentDeserializerState::PathObject(values, None),
                    )?;
                    *self.state = CtPageBlockXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtPageBlockXTypeContentDeserializerState::PathObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_image_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockImageObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            fallback: &mut Option<CtPageBlockXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtPageBlockXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockXTypeContentDeserializerState::ImageObject(values, None),
                    Some(CtPageBlockXTypeContentDeserializerState::ImageObject(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockXTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockXTypeContentDeserializerState::ImageObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_image_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_image_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockXTypeContentDeserializerState::ImageObject(values, None),
                    )?;
                    *self.state = CtPageBlockXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtPageBlockXTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_composite_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            fallback: &mut Option<CtPageBlockXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtPageBlockXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockXTypeContentDeserializerState::CompositeObject(values, None),
                    Some(CtPageBlockXTypeContentDeserializerState::CompositeObject(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockXTypeContentDeserializerState::CompositeObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockXTypeContentDeserializerState::CompositeObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_composite_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockXTypeContentDeserializerState::CompositeObject(values, None),
                    )?;
                    *self.state = CtPageBlockXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtPageBlockXTypeContentDeserializerState::CompositeObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_page_block<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPageBlockXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            fallback: &mut Option<CtPageBlockXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtPageBlockXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockXTypeContentDeserializerState::PageBlock(values, None),
                    Some(CtPageBlockXTypeContentDeserializerState::PageBlock(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockXTypeContentDeserializerState::PageBlock(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockXTypeContentDeserializerState::PageBlock(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_page_block(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_page_block(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockXTypeContentDeserializerState::PageBlock(values, None),
                    )?;
                    *self.state = CtPageBlockXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtPageBlockXTypeContentDeserializerState::PageBlock(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockXTypeContent>
        for CtPageBlockXTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockXTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtPageBlockXTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, CtPageBlockXTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockXTypeContent>
        where
            R: DeserializeReader,
        {
            use CtPageBlockXTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TextObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::TextObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TextObject",
                            true,
                        )?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PathObject",
                            true,
                        )?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ImageObject",
                            true,
                        )?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CompositeObject",
                            true,
                        )?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageBlock",
                            true,
                        )?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtPageBlockXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtPathXTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        stroke: bool,
        fill: bool,
        rule: super::CtPathRuleXType,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        clips: Option<super::CtGraphicUnitClipsXElementType>,
        stroke_color: Option<super::CtColorXType>,
        fill_color: Option<super::CtColorXType>,
        abbreviated_data: Option<String>,
        state: Box<CtPathXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPathXTypeDeserializerState {
        Init__,
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>),
        StrokeColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        FillColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        AbbreviatedData(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtPathXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            let mut stroke: Option<bool> = None;
            let mut fill: Option<bool> = None;
            let mut rule: Option<super::CtPathRuleXType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Stroke")
                ) {
                    reader.read_attrib(&mut stroke, b"Stroke", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Fill")
                ) {
                    reader.read_attrib(&mut fill, b"Fill", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Rule")
                ) {
                    reader.read_attrib(&mut rule, b"Rule", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible.unwrap_or_else(super::CtPathXType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width.unwrap_or_else(super::CtPathXType::default_line_width),
                cap: cap.unwrap_or_else(super::CtPathXType::default_cap),
                join: join.unwrap_or_else(super::CtPathXType::default_join),
                miter_limit: miter_limit.unwrap_or_else(super::CtPathXType::default_miter_limit),
                dash_offset: dash_offset.unwrap_or_else(super::CtPathXType::default_dash_offset),
                dash_pattern: dash_pattern,
                alpha: alpha.unwrap_or_else(super::CtPathXType::default_alpha),
                stroke: stroke.unwrap_or_else(super::CtPathXType::default_stroke),
                fill: fill.unwrap_or_else(super::CtPathXType::default_fill),
                rule: rule.unwrap_or_else(super::CtPathXType::default_rule),
                actions: None,
                clips: None,
                stroke_color: None,
                fill_color: None,
                abbreviated_data: None,
                state: Box::new(CtPathXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPathXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtPathXTypeDeserializerState as S;
            match state {
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::Clips(Some(deserializer)) => self.store_clips(deserializer.finish(reader)?)?,
                S::StrokeColor(Some(deserializer)) => {
                    self.store_stroke_color(deserializer.finish(reader)?)?
                }
                S::FillColor(Some(deserializer)) => {
                    self.store_fill_color(deserializer.finish(reader)?)?
                }
                S::AbbreviatedData(Some(deserializer)) => {
                    self.store_abbreviated_data(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_clips(
            &mut self,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if self.clips.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            self.clips = Some(value);
            Ok(())
        }
        fn store_stroke_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.stroke_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"StrokeColor",
                )))?;
            }
            self.stroke_color = Some(value);
            Ok(())
        }
        fn store_fill_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.fill_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FillColor",
                )))?;
            }
            self.fill_color = Some(value);
            Ok(())
        }
        fn store_abbreviated_data(&mut self, value: String) -> Result<(), Error> {
            if self.abbreviated_data.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AbbreviatedData",
                )))?;
            }
            self.abbreviated_data = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtPathXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPathXTypeDeserializerState::Actions(None));
                *self.state = CtPathXTypeDeserializerState::Clips(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = CtPathXTypeDeserializerState::Clips(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPathXTypeDeserializerState::Actions(Some(
                                deserializer,
                            )));
                            *self.state = CtPathXTypeDeserializerState::Clips(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtPathXTypeDeserializerState::Actions(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtPathXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPathXTypeDeserializerState::Clips(None));
                *self.state = CtPathXTypeDeserializerState::StrokeColor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_clips(data)?;
                    *self.state = CtPathXTypeDeserializerState::StrokeColor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPathXTypeDeserializerState::Clips(Some(
                                deserializer,
                            )));
                            *self.state = CtPathXTypeDeserializerState::StrokeColor(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtPathXTypeDeserializerState::Clips(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_stroke_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtPathXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPathXTypeDeserializerState::StrokeColor(None));
                *self.state = CtPathXTypeDeserializerState::FillColor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_stroke_color(data)?;
                    *self.state = CtPathXTypeDeserializerState::FillColor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPathXTypeDeserializerState::StrokeColor(
                                Some(deserializer),
                            ));
                            *self.state = CtPathXTypeDeserializerState::FillColor(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPathXTypeDeserializerState::StrokeColor(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_fill_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtPathXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPathXTypeDeserializerState::FillColor(None));
                *self.state = CtPathXTypeDeserializerState::AbbreviatedData(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fill_color(data)?;
                    *self.state = CtPathXTypeDeserializerState::AbbreviatedData(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPathXTypeDeserializerState::FillColor(Some(
                                deserializer,
                            )));
                            *self.state = CtPathXTypeDeserializerState::AbbreviatedData(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPathXTypeDeserializerState::FillColor(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_abbreviated_data<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtPathXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.abbreviated_data.is_some() {
                    fallback.get_or_insert(CtPathXTypeDeserializerState::AbbreviatedData(None));
                    *self.state = CtPathXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtPathXTypeDeserializerState::AbbreviatedData(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_abbreviated_data(data)?;
                    *self.state = CtPathXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPathXTypeDeserializerState::AbbreviatedData(
                                Some(deserializer),
                            ));
                            *self.state = CtPathXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPathXTypeDeserializerState::AbbreviatedData(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPathXType> for CtPathXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtPathXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPathXType>
        where
            R: DeserializeReader,
        {
            use CtPathXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StrokeColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_stroke_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FillColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fill_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AbbreviatedData(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_abbreviated_data(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtPathXTypeDeserializerState::Actions(None);
                        event
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StrokeColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"StrokeColor",
                            true,
                        )?;
                        match self.handle_stroke_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FillColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FillColor",
                            true,
                        )?;
                        match self.handle_fill_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AbbreviatedData(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"AbbreviatedData",
                            false,
                        )?;
                        match self.handle_abbreviated_data(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtPathXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtPathXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtPathXType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                stroke: self.stroke,
                fill: self.fill,
                rule: self.rule,
                actions: self.actions,
                clips: self.clips,
                stroke_color: self.stroke_color,
                fill_color: self.fill_color,
                abbreviated_data: self
                    .abbreviated_data
                    .ok_or_else(|| ErrorKind::MissingElement("AbbreviatedData".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPatternXTypeDeserializer {
        width: f64,
        height: f64,
        x_step: Option<f64>,
        y_step: Option<f64>,
        reflect_method: super::CtPatternReflectMethodXType,
        relative_to: super::CtPatternRelativeToXType,
        ctm: Option<String>,
        cell_content: Option<super::CtPatternCellContentXElementType>,
        state: Box<CtPatternXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPatternXTypeDeserializerState {
        Init__,
        CellContent(
            Option<<super::CtPatternCellContentXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl CtPatternXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut width: Option<f64> = None;
            let mut height: Option<f64> = None;
            let mut x_step: Option<f64> = None;
            let mut y_step: Option<f64> = None;
            let mut reflect_method: Option<super::CtPatternReflectMethodXType> = None;
            let mut relative_to: Option<super::CtPatternRelativeToXType> = None;
            let mut ctm: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Width")
                ) {
                    reader.read_attrib(&mut width, b"Width", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Height")
                ) {
                    reader.read_attrib(&mut height, b"Height", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"XStep")
                ) {
                    reader.read_attrib(&mut x_step, b"XStep", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"YStep")
                ) {
                    reader.read_attrib(&mut y_step, b"YStep", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ReflectMethod")
                ) {
                    reader.read_attrib(&mut reflect_method, b"ReflectMethod", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"RelativeTo")
                ) {
                    reader.read_attrib(&mut relative_to, b"RelativeTo", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                width: width
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Width".into())))?,
                height: height.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Height".into()))
                })?,
                x_step: x_step,
                y_step: y_step,
                reflect_method: reflect_method
                    .unwrap_or_else(super::CtPatternXType::default_reflect_method),
                relative_to: relative_to.unwrap_or_else(super::CtPatternXType::default_relative_to),
                ctm: ctm,
                cell_content: None,
                state: Box::new(CtPatternXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPatternXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtPatternXTypeDeserializerState as S;
            match state {
                S::CellContent(Some(deserializer)) => {
                    self.store_cell_content(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_cell_content(
            &mut self,
            value: super::CtPatternCellContentXElementType,
        ) -> Result<(), Error> {
            if self.cell_content.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CellContent",
                )))?;
            }
            self.cell_content = Some(value);
            Ok(())
        }
        fn handle_cell_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPatternCellContentXElementType>,
            fallback: &mut Option<CtPatternXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.cell_content.is_some() {
                    fallback.get_or_insert(CtPatternXTypeDeserializerState::CellContent(None));
                    *self.state = CtPatternXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtPatternXTypeDeserializerState::CellContent(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_cell_content(data)?;
                    *self.state = CtPatternXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPatternXTypeDeserializerState::CellContent(
                                Some(deserializer),
                            ));
                            *self.state = CtPatternXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPatternXTypeDeserializerState::CellContent(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPatternXType> for CtPatternXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtPatternXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPatternXType>
        where
            R: DeserializeReader,
        {
            use CtPatternXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CellContent(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_cell_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtPatternXTypeDeserializerState::CellContent(None);
                        event
                    }
                    (S::CellContent(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CellContent",
                            true,
                        )?;
                        match self.handle_cell_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtPatternXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtPatternXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtPatternXType {
                width: self.width,
                height: self.height,
                x_step: self.x_step,
                y_step: self.y_step,
                reflect_method: self.reflect_method,
                relative_to: self.relative_to,
                ctm: self.ctm,
                cell_content: self
                    .cell_content
                    .ok_or_else(|| ErrorKind::MissingElement("CellContent".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPermissionXTypeDeserializer {
        edit: Option<bool>,
        annot: Option<bool>,
        export: Option<bool>,
        signature: Option<bool>,
        watermark: Option<bool>,
        print_screen: Option<bool>,
        print: Option<super::CtPermissionPrintXElementType>,
        valid_period: Option<super::CtPermissionValidPeriodXElementType>,
        state: Box<CtPermissionXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPermissionXTypeDeserializerState {
        Init__,
        Edit(Option<<bool as WithDeserializer>::Deserializer>),
        Annot(Option<<bool as WithDeserializer>::Deserializer>),
        Export(Option<<bool as WithDeserializer>::Deserializer>),
        Signature(Option<<bool as WithDeserializer>::Deserializer>),
        Watermark(Option<<bool as WithDeserializer>::Deserializer>),
        PrintScreen(Option<<bool as WithDeserializer>::Deserializer>),
        Print(Option<<super::CtPermissionPrintXElementType as WithDeserializer>::Deserializer>),
        ValidPeriod(
            Option<<super::CtPermissionValidPeriodXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl CtPermissionXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                edit: None,
                annot: None,
                export: None,
                signature: None,
                watermark: None,
                print_screen: None,
                print: None,
                valid_period: None,
                state: Box::new(CtPermissionXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPermissionXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtPermissionXTypeDeserializerState as S;
            match state {
                S::Edit(Some(deserializer)) => self.store_edit(deserializer.finish(reader)?)?,
                S::Annot(Some(deserializer)) => self.store_annot(deserializer.finish(reader)?)?,
                S::Export(Some(deserializer)) => self.store_export(deserializer.finish(reader)?)?,
                S::Signature(Some(deserializer)) => {
                    self.store_signature(deserializer.finish(reader)?)?
                }
                S::Watermark(Some(deserializer)) => {
                    self.store_watermark(deserializer.finish(reader)?)?
                }
                S::PrintScreen(Some(deserializer)) => {
                    self.store_print_screen(deserializer.finish(reader)?)?
                }
                S::Print(Some(deserializer)) => self.store_print(deserializer.finish(reader)?)?,
                S::ValidPeriod(Some(deserializer)) => {
                    self.store_valid_period(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_edit(&mut self, value: bool) -> Result<(), Error> {
            if self.edit.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Edit")))?;
            }
            self.edit = Some(value);
            Ok(())
        }
        fn store_annot(&mut self, value: bool) -> Result<(), Error> {
            if self.annot.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Annot",
                )))?;
            }
            self.annot = Some(value);
            Ok(())
        }
        fn store_export(&mut self, value: bool) -> Result<(), Error> {
            if self.export.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Export",
                )))?;
            }
            self.export = Some(value);
            Ok(())
        }
        fn store_signature(&mut self, value: bool) -> Result<(), Error> {
            if self.signature.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Signature",
                )))?;
            }
            self.signature = Some(value);
            Ok(())
        }
        fn store_watermark(&mut self, value: bool) -> Result<(), Error> {
            if self.watermark.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Watermark",
                )))?;
            }
            self.watermark = Some(value);
            Ok(())
        }
        fn store_print_screen(&mut self, value: bool) -> Result<(), Error> {
            if self.print_screen.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PrintScreen",
                )))?;
            }
            self.print_screen = Some(value);
            Ok(())
        }
        fn store_print(
            &mut self,
            value: super::CtPermissionPrintXElementType,
        ) -> Result<(), Error> {
            if self.print.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Print",
                )))?;
            }
            self.print = Some(value);
            Ok(())
        }
        fn store_valid_period(
            &mut self,
            value: super::CtPermissionValidPeriodXElementType,
        ) -> Result<(), Error> {
            if self.valid_period.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ValidPeriod",
                )))?;
            }
            self.valid_period = Some(value);
            Ok(())
        }
        fn handle_edit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtPermissionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPermissionXTypeDeserializerState::Edit(None));
                *self.state = CtPermissionXTypeDeserializerState::Annot(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_edit(data)?;
                    *self.state = CtPermissionXTypeDeserializerState::Annot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPermissionXTypeDeserializerState::Edit(Some(
                                deserializer,
                            )));
                            *self.state = CtPermissionXTypeDeserializerState::Annot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPermissionXTypeDeserializerState::Edit(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_annot<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtPermissionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPermissionXTypeDeserializerState::Annot(None));
                *self.state = CtPermissionXTypeDeserializerState::Export(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_annot(data)?;
                    *self.state = CtPermissionXTypeDeserializerState::Export(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPermissionXTypeDeserializerState::Annot(
                                Some(deserializer),
                            ));
                            *self.state = CtPermissionXTypeDeserializerState::Export(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPermissionXTypeDeserializerState::Annot(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_export<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtPermissionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPermissionXTypeDeserializerState::Export(None));
                *self.state = CtPermissionXTypeDeserializerState::Signature(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_export(data)?;
                    *self.state = CtPermissionXTypeDeserializerState::Signature(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPermissionXTypeDeserializerState::Export(
                                Some(deserializer),
                            ));
                            *self.state = CtPermissionXTypeDeserializerState::Signature(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPermissionXTypeDeserializerState::Export(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_signature<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtPermissionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPermissionXTypeDeserializerState::Signature(None));
                *self.state = CtPermissionXTypeDeserializerState::Watermark(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_signature(data)?;
                    *self.state = CtPermissionXTypeDeserializerState::Watermark(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPermissionXTypeDeserializerState::Signature(
                                Some(deserializer),
                            ));
                            *self.state = CtPermissionXTypeDeserializerState::Watermark(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPermissionXTypeDeserializerState::Signature(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_watermark<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtPermissionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPermissionXTypeDeserializerState::Watermark(None));
                *self.state = CtPermissionXTypeDeserializerState::PrintScreen(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_watermark(data)?;
                    *self.state = CtPermissionXTypeDeserializerState::PrintScreen(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPermissionXTypeDeserializerState::Watermark(
                                Some(deserializer),
                            ));
                            *self.state = CtPermissionXTypeDeserializerState::PrintScreen(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPermissionXTypeDeserializerState::Watermark(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_print_screen<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtPermissionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPermissionXTypeDeserializerState::PrintScreen(None));
                *self.state = CtPermissionXTypeDeserializerState::Print(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_print_screen(data)?;
                    *self.state = CtPermissionXTypeDeserializerState::Print(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPermissionXTypeDeserializerState::PrintScreen(Some(deserializer)),
                            );
                            *self.state = CtPermissionXTypeDeserializerState::Print(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPermissionXTypeDeserializerState::PrintScreen(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_print<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPermissionPrintXElementType>,
            fallback: &mut Option<CtPermissionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPermissionXTypeDeserializerState::Print(None));
                *self.state = CtPermissionXTypeDeserializerState::ValidPeriod(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_print(data)?;
                    *self.state = CtPermissionXTypeDeserializerState::ValidPeriod(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtPermissionXTypeDeserializerState::Print(
                                Some(deserializer),
                            ));
                            *self.state = CtPermissionXTypeDeserializerState::ValidPeriod(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPermissionXTypeDeserializerState::Print(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_valid_period<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPermissionValidPeriodXElementType>,
            fallback: &mut Option<CtPermissionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPermissionXTypeDeserializerState::ValidPeriod(None));
                *self.state = CtPermissionXTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_valid_period(data)?;
                    *self.state = CtPermissionXTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPermissionXTypeDeserializerState::ValidPeriod(Some(deserializer)),
                            );
                            *self.state = CtPermissionXTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPermissionXTypeDeserializerState::ValidPeriod(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPermissionXType> for CtPermissionXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPermissionXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPermissionXType>
        where
            R: DeserializeReader,
        {
            use CtPermissionXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Edit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_edit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Annot(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_annot(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Export(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_export(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Signature(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_signature(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Watermark(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_watermark(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PrintScreen(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_print_screen(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Print(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_print(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ValidPeriod(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_valid_period(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtPermissionXTypeDeserializerState::Edit(None);
                        event
                    }
                    (S::Edit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Edit",
                            false,
                        )?;
                        match self.handle_edit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Annot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Annot",
                            false,
                        )?;
                        match self.handle_annot(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Export(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Export",
                            false,
                        )?;
                        match self.handle_export(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Signature(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Signature",
                            false,
                        )?;
                        match self.handle_signature(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Watermark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Watermark",
                            false,
                        )?;
                        match self.handle_watermark(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PrintScreen(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PrintScreen",
                            false,
                        )?;
                        match self.handle_print_screen(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Print(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Print",
                            false,
                        )?;
                        match self.handle_print(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ValidPeriod(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ValidPeriod",
                            false,
                        )?;
                        match self.handle_valid_period(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtPermissionXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPermissionXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPermissionXType {
                edit: self.edit,
                annot: self.annot,
                export: self.export,
                signature: self.signature,
                watermark: self.watermark,
                print_screen: self.print_screen,
                print: self.print,
                valid_period: self.valid_period,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtRadialShdXTypeDeserializer {
        map_type: super::CtAxialShdMapTypeXType,
        map_unit: Option<f64>,
        eccentricity: f64,
        angle: f64,
        start_point: String,
        start_radius: f64,
        end_point: String,
        end_radius: f64,
        extend: i32,
        seqment: Vec<super::CtAxialShdSegmentXElementType>,
        state: Box<CtRadialShdXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtRadialShdXTypeDeserializerState {
        Init__,
        Seqment(Option<<super::CtAxialShdSegmentXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtRadialShdXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut map_type: Option<super::CtAxialShdMapTypeXType> = None;
            let mut map_unit: Option<f64> = None;
            let mut eccentricity: Option<f64> = None;
            let mut angle: Option<f64> = None;
            let mut start_point: Option<String> = None;
            let mut start_radius: Option<f64> = None;
            let mut end_point: Option<String> = None;
            let mut end_radius: Option<f64> = None;
            let mut extend: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MapType")
                ) {
                    reader.read_attrib(&mut map_type, b"MapType", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MapUnit")
                ) {
                    reader.read_attrib(&mut map_unit, b"MapUnit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Eccentricity")
                ) {
                    reader.read_attrib(&mut eccentricity, b"Eccentricity", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Angle")
                ) {
                    reader.read_attrib(&mut angle, b"Angle", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"StartPoint")
                ) {
                    reader.read_attrib(&mut start_point, b"StartPoint", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"StartRadius")
                ) {
                    reader.read_attrib(&mut start_radius, b"StartRadius", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"EndPoint")
                ) {
                    reader.read_attrib(&mut end_point, b"EndPoint", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"EndRadius")
                ) {
                    reader.read_attrib(&mut end_radius, b"EndRadius", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Extend")
                ) {
                    reader.read_attrib(&mut extend, b"Extend", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                map_type: map_type.unwrap_or_else(super::CtRadialShdXType::default_map_type),
                map_unit: map_unit,
                eccentricity: eccentricity
                    .unwrap_or_else(super::CtRadialShdXType::default_eccentricity),
                angle: angle.unwrap_or_else(super::CtRadialShdXType::default_angle),
                start_point: start_point.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("StartPoint".into()))
                })?,
                start_radius: start_radius
                    .unwrap_or_else(super::CtRadialShdXType::default_start_radius),
                end_point: end_point.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("EndPoint".into()))
                })?,
                end_radius: end_radius.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("EndRadius".into()))
                })?,
                extend: extend.unwrap_or_else(super::CtRadialShdXType::default_extend),
                seqment: Vec::new(),
                state: Box::new(CtRadialShdXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtRadialShdXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtRadialShdXTypeDeserializerState as S;
            match state {
                S::Seqment(Some(deserializer)) => {
                    self.store_seqment(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_seqment(
            &mut self,
            value: super::CtAxialShdSegmentXElementType,
        ) -> Result<(), Error> {
            self.seqment.push(value);
            Ok(())
        }
        fn handle_seqment<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtAxialShdSegmentXElementType>,
            fallback: &mut Option<CtRadialShdXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.seqment.len() < 2usize {
                    *self.state = CtRadialShdXTypeDeserializerState::Seqment(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CtRadialShdXTypeDeserializerState::Seqment(None));
                    *self.state = CtRadialShdXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_seqment(data)?;
                    *self.state = CtRadialShdXTypeDeserializerState::Seqment(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtRadialShdXTypeDeserializerState::Seqment(
                                Some(deserializer),
                            ));
                            if self.seqment.len().saturating_add(1) < 2usize {
                                *self.state = CtRadialShdXTypeDeserializerState::Seqment(None);
                            } else {
                                *self.state = CtRadialShdXTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtRadialShdXTypeDeserializerState::Seqment(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtRadialShdXType> for CtRadialShdXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRadialShdXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRadialShdXType>
        where
            R: DeserializeReader,
        {
            use CtRadialShdXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Seqment(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_seqment(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtRadialShdXTypeDeserializerState::Seqment(None);
                        event
                    }
                    (S::Seqment(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Seqment",
                            true,
                        )?;
                        match self.handle_seqment(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtRadialShdXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtRadialShdXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtRadialShdXType {
                map_type: self.map_type,
                map_unit: self.map_unit,
                eccentricity: self.eccentricity,
                angle: self.angle,
                start_point: self.start_point,
                start_radius: self.start_radius,
                end_point: self.end_point,
                end_radius: self.end_radius,
                extend: self.extend,
                seqment: self.seqment,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtRegionXTypeDeserializer {
        area: Vec<super::CtRegionAreaXElementType>,
        state: Box<CtRegionXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtRegionXTypeDeserializerState {
        Init__,
        Area(Option<<super::CtRegionAreaXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtRegionXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                area: Vec::new(),
                state: Box::new(CtRegionXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtRegionXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtRegionXTypeDeserializerState as S;
            match state {
                S::Area(Some(deserializer)) => self.store_area(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_area(&mut self, value: super::CtRegionAreaXElementType) -> Result<(), Error> {
            self.area.push(value);
            Ok(())
        }
        fn handle_area<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtRegionAreaXElementType>,
            fallback: &mut Option<CtRegionXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.area.len() < 1usize {
                    *self.state = CtRegionXTypeDeserializerState::Area(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CtRegionXTypeDeserializerState::Area(None));
                    *self.state = CtRegionXTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_area(data)?;
                    *self.state = CtRegionXTypeDeserializerState::Area(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtRegionXTypeDeserializerState::Area(Some(
                                deserializer,
                            )));
                            if self.area.len().saturating_add(1) < 1usize {
                                *self.state = CtRegionXTypeDeserializerState::Area(None);
                            } else {
                                *self.state = CtRegionXTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtRegionXTypeDeserializerState::Area(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtRegionXType> for CtRegionXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtRegionXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionXType>
        where
            R: DeserializeReader,
        {
            use CtRegionXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Area(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_area(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtRegionXTypeDeserializerState::Area(None);
                        event
                    }
                    (S::Area(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Area",
                            true,
                        )?;
                        match self.handle_area(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtRegionXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtRegionXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtRegionXType { area: self.area })
        }
    }
    #[derive(Debug)]
    pub struct CtTextXTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        font: u32,
        size: f64,
        stroke: bool,
        fill: bool,
        h_scale: f64,
        read_direction: i32,
        char_direction: i32,
        weight: super::CtTextWeightXType,
        italic: bool,
        content: Vec<super::CtTextXTypeContent>,
        state: Box<CtTextXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtTextXTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtTextXTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtTextXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            let mut font: Option<u32> = None;
            let mut size: Option<f64> = None;
            let mut stroke: Option<bool> = None;
            let mut fill: Option<bool> = None;
            let mut h_scale: Option<f64> = None;
            let mut read_direction: Option<i32> = None;
            let mut char_direction: Option<i32> = None;
            let mut weight: Option<super::CtTextWeightXType> = None;
            let mut italic: Option<bool> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Font")
                ) {
                    reader.read_attrib(&mut font, b"Font", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Size")
                ) {
                    reader.read_attrib(&mut size, b"Size", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Stroke")
                ) {
                    reader.read_attrib(&mut stroke, b"Stroke", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Fill")
                ) {
                    reader.read_attrib(&mut fill, b"Fill", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"HScale")
                ) {
                    reader.read_attrib(&mut h_scale, b"HScale", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ReadDirection")
                ) {
                    reader.read_attrib(&mut read_direction, b"ReadDirection", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CharDirection")
                ) {
                    reader.read_attrib(&mut char_direction, b"CharDirection", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Weight")
                ) {
                    reader.read_attrib(&mut weight, b"Weight", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Italic")
                ) {
                    reader.read_attrib(&mut italic, b"Italic", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible.unwrap_or_else(super::CtTextXType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width.unwrap_or_else(super::CtTextXType::default_line_width),
                cap: cap.unwrap_or_else(super::CtTextXType::default_cap),
                join: join.unwrap_or_else(super::CtTextXType::default_join),
                miter_limit: miter_limit.unwrap_or_else(super::CtTextXType::default_miter_limit),
                dash_offset: dash_offset.unwrap_or_else(super::CtTextXType::default_dash_offset),
                dash_pattern: dash_pattern,
                alpha: alpha.unwrap_or_else(super::CtTextXType::default_alpha),
                font: font
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Font".into())))?,
                size: size
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Size".into())))?,
                stroke: stroke.unwrap_or_else(super::CtTextXType::default_stroke),
                fill: fill.unwrap_or_else(super::CtTextXType::default_fill),
                h_scale: h_scale.unwrap_or_else(super::CtTextXType::default_h_scale),
                read_direction: read_direction
                    .unwrap_or_else(super::CtTextXType::default_read_direction),
                char_direction: char_direction
                    .unwrap_or_else(super::CtTextXType::default_char_direction),
                weight: weight.unwrap_or_else(super::CtTextXType::default_weight),
                italic: italic.unwrap_or_else(super::CtTextXType::default_italic),
                content: Vec::new(),
                state: Box::new(CtTextXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtTextXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtTextXTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::CtTextXTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtTextXTypeContent>,
            fallback: &mut Option<CtTextXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtTextXTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtTextXTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtTextXTypeDeserializerState::Content__(deserializer);
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtTextXTypeDeserializerState::Content__(
                                deserializer,
                            ));
                            *self.state = CtTextXTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtTextXType> for CtTextXTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtTextXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtTextXType>
        where
            R: DeserializeReader,
        {
            use CtTextXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output =
                            <super::CtTextXTypeContent as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtTextXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtTextXTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtTextXType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                font: self.font,
                size: self.size,
                stroke: self.stroke,
                fill: self.fill,
                h_scale: self.h_scale,
                read_direction: self.read_direction,
                char_direction: self.char_direction,
                weight: self.weight,
                italic: self.italic,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtTextXTypeContentDeserializer {
        state: Box<CtTextXTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtTextXTypeContentDeserializerState {
        Init__,
        Actions(
            Option<super::CtGraphicUnitActionsXElementType>,
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(
            Option<super::CtGraphicUnitClipsXElementType>,
            Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
        ),
        FillColor(
            Option<super::CtColorXType>,
            Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
        ),
        StrokeColor(
            Option<super::CtColorXType>,
            Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
        ),
        CgTransform(
            Option<super::CtCgTransformXType>,
            Option<<super::CtCgTransformXType as WithDeserializer>::Deserializer>,
        ),
        TextCode(
            Option<super::CtTextTextCodeXElementType>,
            Option<<super::CtTextTextCodeXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtTextXTypeContent),
        Unknown__,
    }
    impl CtTextXTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtTextXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Actions")
                ) {
                    let output = < super :: CtGraphicUnitActionsXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_actions(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Clips")
                ) {
                    let output = < super :: CtGraphicUnitClipsXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_clips(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"FillColor")
                ) {
                    let output = <super::CtColorXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_fill_color(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"StrokeColor")
                ) {
                    let output = <super::CtColorXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_stroke_color(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CGTransform")
                ) {
                    let output =
                        <super::CtCgTransformXType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_cg_transform(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TextCode")
                ) {
                    let output = < super :: CtTextTextCodeXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_text_code(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtTextXTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtTextXTypeContentDeserializerState,
        ) -> Result<super::CtTextXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtTextXTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Actions(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_actions(&mut values, value)?;
                    }
                    Ok(super::CtTextXTypeContent::Actions(values.ok_or_else(
                        || ErrorKind::MissingElement("Actions".into()),
                    )?))
                }
                S::Clips(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_clips(&mut values, value)?;
                    }
                    Ok(super::CtTextXTypeContent::Clips(values.ok_or_else(
                        || ErrorKind::MissingElement("Clips".into()),
                    )?))
                }
                S::FillColor(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_fill_color(&mut values, value)?;
                    }
                    Ok(super::CtTextXTypeContent::FillColor(values.ok_or_else(
                        || ErrorKind::MissingElement("FillColor".into()),
                    )?))
                }
                S::StrokeColor(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_stroke_color(&mut values, value)?;
                    }
                    Ok(super::CtTextXTypeContent::StrokeColor(values.ok_or_else(
                        || ErrorKind::MissingElement("StrokeColor".into()),
                    )?))
                }
                S::CgTransform(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_cg_transform(&mut values, value)?;
                    }
                    Ok(super::CtTextXTypeContent::CgTransform(values.ok_or_else(
                        || ErrorKind::MissingElement("CGTransform".into()),
                    )?))
                }
                S::TextCode(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text_code(&mut values, value)?;
                    }
                    Ok(super::CtTextXTypeContent::TextCode(values.ok_or_else(
                        || ErrorKind::MissingElement("TextCode".into()),
                    )?))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_actions(
            values: &mut Option<super::CtGraphicUnitActionsXElementType>,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_clips(
            values: &mut Option<super::CtGraphicUnitClipsXElementType>,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_fill_color(
            values: &mut Option<super::CtColorXType>,
            value: super::CtColorXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FillColor",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_stroke_color(
            values: &mut Option<super::CtColorXType>,
            value: super::CtColorXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"StrokeColor",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_cg_transform(
            values: &mut Option<super::CtCgTransformXType>,
            value: super::CtCgTransformXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CGTransform",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_text_code(
            values: &mut Option<super::CtTextTextCodeXElementType>,
            value: super::CtTextTextCodeXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TextCode",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtGraphicUnitActionsXElementType>,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtTextXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtTextXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtTextXTypeContentDeserializerState::Actions(values, None),
                    Some(CtTextXTypeContentDeserializerState::Actions(_, Some(deserializer))) => {
                        CtTextXTypeContentDeserializerState::Actions(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtTextXTypeContentDeserializerState::Actions(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_actions(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_actions(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtTextXTypeContentDeserializerState::Actions(values, None),
                    )?;
                    *self.state = CtTextXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtTextXTypeContentDeserializerState::Actions(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtGraphicUnitClipsXElementType>,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtTextXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtTextXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtTextXTypeContentDeserializerState::Clips(values, None),
                    Some(CtTextXTypeContentDeserializerState::Clips(_, Some(deserializer))) => {
                        CtTextXTypeContentDeserializerState::Clips(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtTextXTypeContentDeserializerState::Clips(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_clips(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_clips(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtTextXTypeContentDeserializerState::Clips(values, None),
                    )?;
                    *self.state = CtTextXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtTextXTypeContentDeserializerState::Clips(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_fill_color<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtColorXType>,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtTextXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtTextXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtTextXTypeContentDeserializerState::FillColor(values, None),
                    Some(CtTextXTypeContentDeserializerState::FillColor(_, Some(deserializer))) => {
                        CtTextXTypeContentDeserializerState::FillColor(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtTextXTypeContentDeserializerState::FillColor(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_fill_color(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_fill_color(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtTextXTypeContentDeserializerState::FillColor(values, None),
                    )?;
                    *self.state = CtTextXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtTextXTypeContentDeserializerState::FillColor(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_stroke_color<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtColorXType>,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtTextXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtTextXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtTextXTypeContentDeserializerState::StrokeColor(values, None),
                    Some(CtTextXTypeContentDeserializerState::StrokeColor(
                        _,
                        Some(deserializer),
                    )) => {
                        CtTextXTypeContentDeserializerState::StrokeColor(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtTextXTypeContentDeserializerState::StrokeColor(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_stroke_color(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_stroke_color(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtTextXTypeContentDeserializerState::StrokeColor(values, None),
                    )?;
                    *self.state = CtTextXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtTextXTypeContentDeserializerState::StrokeColor(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_cg_transform<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtCgTransformXType>,
            output: DeserializerOutput<'de, super::CtCgTransformXType>,
            fallback: &mut Option<CtTextXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtTextXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtTextXTypeContentDeserializerState::CgTransform(values, None),
                    Some(CtTextXTypeContentDeserializerState::CgTransform(
                        _,
                        Some(deserializer),
                    )) => {
                        CtTextXTypeContentDeserializerState::CgTransform(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtTextXTypeContentDeserializerState::CgTransform(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_cg_transform(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_cg_transform(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtTextXTypeContentDeserializerState::CgTransform(values, None),
                    )?;
                    *self.state = CtTextXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtTextXTypeContentDeserializerState::CgTransform(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_text_code<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtTextTextCodeXElementType>,
            output: DeserializerOutput<'de, super::CtTextTextCodeXElementType>,
            fallback: &mut Option<CtTextXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtTextXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtTextXTypeContentDeserializerState::TextCode(values, None),
                    Some(CtTextXTypeContentDeserializerState::TextCode(_, Some(deserializer))) => {
                        CtTextXTypeContentDeserializerState::TextCode(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtTextXTypeContentDeserializerState::TextCode(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text_code(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text_code(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtTextXTypeContentDeserializerState::TextCode(values, None),
                    )?;
                    *self.state = CtTextXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtTextXTypeContentDeserializerState::TextCode(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtTextXTypeContent> for CtTextXTypeContentDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtTextXTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtTextXTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, CtTextXTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtTextXTypeContent>
        where
            R: DeserializeReader,
        {
            use CtTextXTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Clips(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::FillColor(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fill_color(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::StrokeColor(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_stroke_color(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CgTransform(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_cg_transform(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TextCode(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text_code(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Actions(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Clips(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::FillColor(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FillColor",
                            true,
                        )?;
                        match self.handle_fill_color(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::StrokeColor(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"StrokeColor",
                            true,
                        )?;
                        match self.handle_stroke_color(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CgTransform(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CGTransform",
                            false,
                        )?;
                        match self.handle_cg_transform(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TextCode(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TextCode",
                            false,
                        )?;
                        match self.handle_text_code(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtTextXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtVPreferencesXTypeDeserializer {
        content: Vec<super::CtVPreferencesXTypeContent>,
        state: Box<CtVPreferencesXTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtVPreferencesXTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtVPreferencesXTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtVPreferencesXTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: Vec::new(),
                state: Box::new(CtVPreferencesXTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtVPreferencesXTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtVPreferencesXTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::CtVPreferencesXTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtVPreferencesXTypeContent>,
            fallback: &mut Option<CtVPreferencesXTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtVPreferencesXTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtVPreferencesXTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let can_have_more = self.content.len().saturating_add(1) < 7usize;
                    let ret = if can_have_more {
                        ElementHandlerOutput::from_event(event, allow_any)
                    } else {
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    };
                    match (can_have_more, &ret) {
                        (true, ElementHandlerOutput::Continue { .. }) => {
                            fallback.get_or_insert(
                                CtVPreferencesXTypeDeserializerState::Content__(deserializer),
                            );
                            *self.state = CtVPreferencesXTypeDeserializerState::Next__;
                        }
                        (false, _) | (_, ElementHandlerOutput::Break { .. }) => {
                            *self.state =
                                CtVPreferencesXTypeDeserializerState::Content__(deserializer);
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtVPreferencesXType> for CtVPreferencesXTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtVPreferencesXType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtVPreferencesXType>
        where
            R: DeserializeReader,
        {
            use CtVPreferencesXTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: CtVPreferencesXTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtVPreferencesXType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtVPreferencesXTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtVPreferencesXType {
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtVPreferencesXTypeContentDeserializer {
        state: Box<CtVPreferencesXTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtVPreferencesXTypeContentDeserializerState {
        Init__,
        PageMode(
            Option<super::CtVPreferencesPageModeXElementType>,
            Option<<super::CtVPreferencesPageModeXElementType as WithDeserializer>::Deserializer>,
        ),
        PageLayout(
            Option<super::CtVPreferencesPageLayoutXElementType>,
            Option<<super::CtVPreferencesPageLayoutXElementType as WithDeserializer>::Deserializer>,
        ),
        TabDisplay(
            Option<super::CtVPreferencesTabDisplayXElementType>,
            Option<<super::CtVPreferencesTabDisplayXElementType as WithDeserializer>::Deserializer>,
        ),
        HideToolbar(
            Option<bool>,
            Option<<bool as WithDeserializer>::Deserializer>,
        ),
        HideMenubar(
            Option<bool>,
            Option<<bool as WithDeserializer>::Deserializer>,
        ),
        HideWindowUi(
            Option<bool>,
            Option<<bool as WithDeserializer>::Deserializer>,
        ),
        ZoomMode(
            Option<super::CtVPreferencesZoomModeXElementType>,
            Option<<super::CtVPreferencesZoomModeXElementType as WithDeserializer>::Deserializer>,
        ),
        Zoom(Option<f64>, Option<<f64 as WithDeserializer>::Deserializer>),
        Done__(super::CtVPreferencesXTypeContent),
        Unknown__,
    }
    impl CtVPreferencesXTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PageMode")
                ) {
                    let output = < super :: CtVPreferencesPageModeXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_page_mode(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PageLayout")
                ) {
                    let output = < super :: CtVPreferencesPageLayoutXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_page_layout(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TabDisplay")
                ) {
                    let output = < super :: CtVPreferencesTabDisplayXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_tab_display(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"HideToolbar")
                ) {
                    let output = <bool as WithDeserializer>::Deserializer::init(reader, event)?;
                    return self.handle_hide_toolbar(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"HideMenubar")
                ) {
                    let output = <bool as WithDeserializer>::Deserializer::init(reader, event)?;
                    return self.handle_hide_menubar(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"HideWindowUI")
                ) {
                    let output = <bool as WithDeserializer>::Deserializer::init(reader, event)?;
                    return self.handle_hide_window_ui(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ZoomMode")
                ) {
                    let output = < super :: CtVPreferencesZoomModeXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_zoom_mode(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Zoom")
                ) {
                    let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                    return self.handle_zoom(reader, Default::default(), output, &mut *fallback);
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtVPreferencesXTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtVPreferencesXTypeContentDeserializerState,
        ) -> Result<super::CtVPreferencesXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtVPreferencesXTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::PageMode(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_page_mode(&mut values, value)?;
                    }
                    Ok(super::CtVPreferencesXTypeContent::PageMode(
                        values.ok_or_else(|| ErrorKind::MissingElement("PageMode".into()))?,
                    ))
                }
                S::PageLayout(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_page_layout(&mut values, value)?;
                    }
                    Ok(super::CtVPreferencesXTypeContent::PageLayout(
                        values.ok_or_else(|| ErrorKind::MissingElement("PageLayout".into()))?,
                    ))
                }
                S::TabDisplay(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_tab_display(&mut values, value)?;
                    }
                    Ok(super::CtVPreferencesXTypeContent::TabDisplay(
                        values.ok_or_else(|| ErrorKind::MissingElement("TabDisplay".into()))?,
                    ))
                }
                S::HideToolbar(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_hide_toolbar(&mut values, value)?;
                    }
                    Ok(super::CtVPreferencesXTypeContent::HideToolbar(
                        values.ok_or_else(|| ErrorKind::MissingElement("HideToolbar".into()))?,
                    ))
                }
                S::HideMenubar(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_hide_menubar(&mut values, value)?;
                    }
                    Ok(super::CtVPreferencesXTypeContent::HideMenubar(
                        values.ok_or_else(|| ErrorKind::MissingElement("HideMenubar".into()))?,
                    ))
                }
                S::HideWindowUi(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_hide_window_ui(&mut values, value)?;
                    }
                    Ok(super::CtVPreferencesXTypeContent::HideWindowUi(
                        values.ok_or_else(|| ErrorKind::MissingElement("HideWindowUI".into()))?,
                    ))
                }
                S::ZoomMode(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_zoom_mode(&mut values, value)?;
                    }
                    Ok(super::CtVPreferencesXTypeContent::ZoomMode(
                        values.ok_or_else(|| ErrorKind::MissingElement("ZoomMode".into()))?,
                    ))
                }
                S::Zoom(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_zoom(&mut values, value)?;
                    }
                    Ok(super::CtVPreferencesXTypeContent::Zoom(
                        values.ok_or_else(|| ErrorKind::MissingElement("Zoom".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_page_mode(
            values: &mut Option<super::CtVPreferencesPageModeXElementType>,
            value: super::CtVPreferencesPageModeXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageMode",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_page_layout(
            values: &mut Option<super::CtVPreferencesPageLayoutXElementType>,
            value: super::CtVPreferencesPageLayoutXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageLayout",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_tab_display(
            values: &mut Option<super::CtVPreferencesTabDisplayXElementType>,
            value: super::CtVPreferencesTabDisplayXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TabDisplay",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_hide_toolbar(values: &mut Option<bool>, value: bool) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"HideToolbar",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_hide_menubar(values: &mut Option<bool>, value: bool) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"HideMenubar",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_hide_window_ui(values: &mut Option<bool>, value: bool) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"HideWindowUI",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_zoom_mode(
            values: &mut Option<super::CtVPreferencesZoomModeXElementType>,
            value: super::CtVPreferencesZoomModeXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ZoomMode",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_zoom(values: &mut Option<f64>, value: f64) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Zoom")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_page_mode<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtVPreferencesPageModeXElementType>,
            output: DeserializerOutput<'de, super::CtVPreferencesPageModeXElementType>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtVPreferencesXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtVPreferencesXTypeContentDeserializerState::PageMode(values, None),
                    Some(CtVPreferencesXTypeContentDeserializerState::PageMode(
                        _,
                        Some(deserializer),
                    )) => CtVPreferencesXTypeContentDeserializerState::PageMode(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtVPreferencesXTypeContentDeserializerState::PageMode(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_page_mode(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_page_mode(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtVPreferencesXTypeContentDeserializerState::PageMode(values, None),
                    )?;
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtVPreferencesXTypeContentDeserializerState::PageMode(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_page_layout<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtVPreferencesPageLayoutXElementType>,
            output: DeserializerOutput<'de, super::CtVPreferencesPageLayoutXElementType>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtVPreferencesXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtVPreferencesXTypeContentDeserializerState::PageLayout(values, None),
                    Some(CtVPreferencesXTypeContentDeserializerState::PageLayout(
                        _,
                        Some(deserializer),
                    )) => CtVPreferencesXTypeContentDeserializerState::PageLayout(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtVPreferencesXTypeContentDeserializerState::PageLayout(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_page_layout(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_page_layout(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtVPreferencesXTypeContentDeserializerState::PageLayout(values, None),
                    )?;
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtVPreferencesXTypeContentDeserializerState::PageLayout(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_tab_display<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtVPreferencesTabDisplayXElementType>,
            output: DeserializerOutput<'de, super::CtVPreferencesTabDisplayXElementType>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtVPreferencesXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtVPreferencesXTypeContentDeserializerState::TabDisplay(values, None),
                    Some(CtVPreferencesXTypeContentDeserializerState::TabDisplay(
                        _,
                        Some(deserializer),
                    )) => CtVPreferencesXTypeContentDeserializerState::TabDisplay(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtVPreferencesXTypeContentDeserializerState::TabDisplay(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_tab_display(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_tab_display(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtVPreferencesXTypeContentDeserializerState::TabDisplay(values, None),
                    )?;
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtVPreferencesXTypeContentDeserializerState::TabDisplay(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_hide_toolbar<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<bool>,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtVPreferencesXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtVPreferencesXTypeContentDeserializerState::HideToolbar(values, None),
                    Some(CtVPreferencesXTypeContentDeserializerState::HideToolbar(
                        _,
                        Some(deserializer),
                    )) => CtVPreferencesXTypeContentDeserializerState::HideToolbar(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtVPreferencesXTypeContentDeserializerState::HideToolbar(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_hide_toolbar(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_hide_toolbar(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtVPreferencesXTypeContentDeserializerState::HideToolbar(values, None),
                    )?;
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtVPreferencesXTypeContentDeserializerState::HideToolbar(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_hide_menubar<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<bool>,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtVPreferencesXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtVPreferencesXTypeContentDeserializerState::HideMenubar(values, None),
                    Some(CtVPreferencesXTypeContentDeserializerState::HideMenubar(
                        _,
                        Some(deserializer),
                    )) => CtVPreferencesXTypeContentDeserializerState::HideMenubar(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtVPreferencesXTypeContentDeserializerState::HideMenubar(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_hide_menubar(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_hide_menubar(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtVPreferencesXTypeContentDeserializerState::HideMenubar(values, None),
                    )?;
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtVPreferencesXTypeContentDeserializerState::HideMenubar(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_hide_window_ui<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<bool>,
            output: DeserializerOutput<'de, bool>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtVPreferencesXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtVPreferencesXTypeContentDeserializerState::HideWindowUi(values, None),
                    Some(CtVPreferencesXTypeContentDeserializerState::HideWindowUi(
                        _,
                        Some(deserializer),
                    )) => CtVPreferencesXTypeContentDeserializerState::HideWindowUi(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtVPreferencesXTypeContentDeserializerState::HideWindowUi(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_hide_window_ui(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_hide_window_ui(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtVPreferencesXTypeContentDeserializerState::HideWindowUi(values, None),
                    )?;
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtVPreferencesXTypeContentDeserializerState::HideWindowUi(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_zoom_mode<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtVPreferencesZoomModeXElementType>,
            output: DeserializerOutput<'de, super::CtVPreferencesZoomModeXElementType>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtVPreferencesXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtVPreferencesXTypeContentDeserializerState::ZoomMode(values, None),
                    Some(CtVPreferencesXTypeContentDeserializerState::ZoomMode(
                        _,
                        Some(deserializer),
                    )) => CtVPreferencesXTypeContentDeserializerState::ZoomMode(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtVPreferencesXTypeContentDeserializerState::ZoomMode(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_zoom_mode(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_zoom_mode(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtVPreferencesXTypeContentDeserializerState::ZoomMode(values, None),
                    )?;
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtVPreferencesXTypeContentDeserializerState::ZoomMode(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_zoom<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<CtVPreferencesXTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtVPreferencesXTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtVPreferencesXTypeContentDeserializerState::Zoom(values, None),
                    Some(CtVPreferencesXTypeContentDeserializerState::Zoom(
                        _,
                        Some(deserializer),
                    )) => CtVPreferencesXTypeContentDeserializerState::Zoom(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtVPreferencesXTypeContentDeserializerState::Zoom(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_zoom(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_zoom(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtVPreferencesXTypeContentDeserializerState::Zoom(values, None),
                    )?;
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtVPreferencesXTypeContentDeserializerState::Zoom(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtVPreferencesXTypeContent>
        for CtVPreferencesXTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtVPreferencesXTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtVPreferencesXTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        CtVPreferencesXTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtVPreferencesXTypeContent>
        where
            R: DeserializeReader,
        {
            use CtVPreferencesXTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::PageMode(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_mode(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageLayout(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_layout(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TabDisplay(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tab_display(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::HideToolbar(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_hide_toolbar(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::HideMenubar(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_hide_menubar(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::HideWindowUi(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_hide_window_ui(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ZoomMode(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_zoom_mode(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Zoom(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_zoom(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::PageMode(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageMode",
                            false,
                        )?;
                        match self.handle_page_mode(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageLayout(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageLayout",
                            false,
                        )?;
                        match self.handle_page_layout(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TabDisplay(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TabDisplay",
                            false,
                        )?;
                        match self.handle_tab_display(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::HideToolbar(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"HideToolbar",
                            false,
                        )?;
                        match self.handle_hide_toolbar(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::HideMenubar(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"HideMenubar",
                            false,
                        )?;
                        match self.handle_hide_menubar(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::HideWindowUi(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"HideWindowUI",
                            false,
                        )?;
                        match self.handle_hide_window_ui(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ZoomMode(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ZoomMode",
                            false,
                        )?;
                        match self.handle_zoom_mode(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Zoom(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Zoom",
                            false,
                        )?;
                        match self.handle_zoom(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtVPreferencesXTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtVectorGxTypeDeserializer {
        width: f64,
        height: f64,
        thumbnail: Option<u32>,
        substitution: Option<u32>,
        content: Option<super::CtPageBlockXType>,
        state: Box<CtVectorGxTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtVectorGxTypeDeserializerState {
        Init__,
        Thumbnail(Option<<u32 as WithDeserializer>::Deserializer>),
        Substitution(Option<<u32 as WithDeserializer>::Deserializer>),
        Content(Option<<super::CtPageBlockXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtVectorGxTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut width: Option<f64> = None;
            let mut height: Option<f64> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Width")
                ) {
                    reader.read_attrib(&mut width, b"Width", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Height")
                ) {
                    reader.read_attrib(&mut height, b"Height", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                width: width
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Width".into())))?,
                height: height.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Height".into()))
                })?,
                thumbnail: None,
                substitution: None,
                content: None,
                state: Box::new(CtVectorGxTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtVectorGxTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtVectorGxTypeDeserializerState as S;
            match state {
                S::Thumbnail(Some(deserializer)) => {
                    self.store_thumbnail(deserializer.finish(reader)?)?
                }
                S::Substitution(Some(deserializer)) => {
                    self.store_substitution(deserializer.finish(reader)?)?
                }
                S::Content(Some(deserializer)) => {
                    self.store_content(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_thumbnail(&mut self, value: u32) -> Result<(), Error> {
            if self.thumbnail.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Thumbnail",
                )))?;
            }
            self.thumbnail = Some(value);
            Ok(())
        }
        fn store_substitution(&mut self, value: u32) -> Result<(), Error> {
            if self.substitution.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Substitution",
                )))?;
            }
            self.substitution = Some(value);
            Ok(())
        }
        fn store_content(&mut self, value: super::CtPageBlockXType) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Content",
                )))?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_thumbnail<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, u32>,
            fallback: &mut Option<CtVectorGxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtVectorGxTypeDeserializerState::Thumbnail(None));
                *self.state = CtVectorGxTypeDeserializerState::Substitution(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_thumbnail(data)?;
                    *self.state = CtVectorGxTypeDeserializerState::Substitution(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtVectorGxTypeDeserializerState::Thumbnail(
                                Some(deserializer),
                            ));
                            *self.state = CtVectorGxTypeDeserializerState::Substitution(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtVectorGxTypeDeserializerState::Thumbnail(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_substitution<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, u32>,
            fallback: &mut Option<CtVectorGxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtVectorGxTypeDeserializerState::Substitution(None));
                *self.state = CtVectorGxTypeDeserializerState::Content(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_substitution(data)?;
                    *self.state = CtVectorGxTypeDeserializerState::Content(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtVectorGxTypeDeserializerState::Substitution(
                                Some(deserializer),
                            ));
                            *self.state = CtVectorGxTypeDeserializerState::Content(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtVectorGxTypeDeserializerState::Substitution(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPageBlockXType>,
            fallback: &mut Option<CtVectorGxTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.content.is_some() {
                    fallback.get_or_insert(CtVectorGxTypeDeserializerState::Content(None));
                    *self.state = CtVectorGxTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtVectorGxTypeDeserializerState::Content(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtVectorGxTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CtVectorGxTypeDeserializerState::Content(Some(
                                deserializer,
                            )));
                            *self.state = CtVectorGxTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtVectorGxTypeDeserializerState::Content(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtVectorGxType> for CtVectorGxTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CtVectorGxType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtVectorGxType>
        where
            R: DeserializeReader,
        {
            use CtVectorGxTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Thumbnail(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_thumbnail(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Substitution(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_substitution(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Content(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtVectorGxTypeDeserializerState::Thumbnail(None);
                        event
                    }
                    (S::Thumbnail(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Thumbnail",
                            false,
                        )?;
                        match self.handle_thumbnail(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Substitution(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Substitution",
                            false,
                        )?;
                        match self.handle_substitution(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Content(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Content",
                            true,
                        )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtVectorGxType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, CtVectorGxTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::CtVectorGxType {
                width: self.width,
                height: self.height,
                thumbnail: self.thumbnail,
                substitution: self.substitution,
                content: self
                    .content
                    .ok_or_else(|| ErrorKind::MissingElement("Content".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CustomTagsXElementTypeDeserializer {
        custom_tag: Vec<super::CustomTagsCustomTagXElementType>,
        state: Box<CustomTagsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CustomTagsXElementTypeDeserializerState {
        Init__,
        CustomTag(
            Option<<super::CustomTagsCustomTagXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl CustomTagsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                custom_tag: Vec::new(),
                state: Box::new(CustomTagsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CustomTagsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CustomTagsXElementTypeDeserializerState as S;
            match state {
                S::CustomTag(Some(deserializer)) => {
                    self.store_custom_tag(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_custom_tag(
            &mut self,
            value: super::CustomTagsCustomTagXElementType,
        ) -> Result<(), Error> {
            self.custom_tag.push(value);
            Ok(())
        }
        fn handle_custom_tag<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CustomTagsCustomTagXElementType>,
            fallback: &mut Option<CustomTagsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CustomTagsXElementTypeDeserializerState::CustomTag(None));
                *self.state = CustomTagsXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_custom_tag(data)?;
                    *self.state = CustomTagsXElementTypeDeserializerState::CustomTag(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CustomTagsXElementTypeDeserializerState::CustomTag(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CustomTagsXElementTypeDeserializerState::CustomTag(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CustomTagsXElementTypeDeserializerState::CustomTag(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CustomTagsXElementType> for CustomTagsXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CustomTagsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CustomTagsXElementType>
        where
            R: DeserializeReader,
        {
            use CustomTagsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CustomTag(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_custom_tag(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CustomTagsXElementTypeDeserializerState::CustomTag(None);
                        event
                    }
                    (S::CustomTag(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CustomTag",
                            false,
                        )?;
                        match self.handle_custom_tag(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CustomTagsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CustomTagsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CustomTagsXElementType {
                custom_tag: self.custom_tag,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocVersionXElementTypeDeserializer {
        id: String,
        version: Option<String>,
        name: Option<String>,
        creation_date: Option<String>,
        file_list: Option<super::DocVersionFileListXElementType>,
        doc_root: Option<String>,
        state: Box<DocVersionXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocVersionXElementTypeDeserializerState {
        Init__,
        FileList(Option<<super::DocVersionFileListXElementType as WithDeserializer>::Deserializer>),
        DocRoot(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DocVersionXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<String> = None;
            let mut version: Option<String> = None;
            let mut name: Option<String> = None;
            let mut creation_date: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Version")
                ) {
                    reader.read_attrib(&mut version, b"Version", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CreationDate")
                ) {
                    reader.read_attrib(&mut creation_date, b"CreationDate", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                version: version,
                name: name,
                creation_date: creation_date,
                file_list: None,
                doc_root: None,
                state: Box::new(DocVersionXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocVersionXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocVersionXElementTypeDeserializerState as S;
            match state {
                S::FileList(Some(deserializer)) => {
                    self.store_file_list(deserializer.finish(reader)?)?
                }
                S::DocRoot(Some(deserializer)) => {
                    self.store_doc_root(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_file_list(
            &mut self,
            value: super::DocVersionFileListXElementType,
        ) -> Result<(), Error> {
            if self.file_list.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FileList",
                )))?;
            }
            self.file_list = Some(value);
            Ok(())
        }
        fn store_doc_root(&mut self, value: String) -> Result<(), Error> {
            if self.doc_root.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DocRoot",
                )))?;
            }
            self.doc_root = Some(value);
            Ok(())
        }
        fn handle_file_list<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocVersionFileListXElementType>,
            fallback: &mut Option<DocVersionXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.file_list.is_some() {
                    fallback.get_or_insert(DocVersionXElementTypeDeserializerState::FileList(None));
                    *self.state = DocVersionXElementTypeDeserializerState::DocRoot(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DocVersionXElementTypeDeserializerState::FileList(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_file_list(data)?;
                    *self.state = DocVersionXElementTypeDeserializerState::DocRoot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocVersionXElementTypeDeserializerState::FileList(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocVersionXElementTypeDeserializerState::DocRoot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocVersionXElementTypeDeserializerState::FileList(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_doc_root<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<DocVersionXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.doc_root.is_some() {
                    fallback.get_or_insert(DocVersionXElementTypeDeserializerState::DocRoot(None));
                    *self.state = DocVersionXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DocVersionXElementTypeDeserializerState::DocRoot(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_doc_root(data)?;
                    *self.state = DocVersionXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocVersionXElementTypeDeserializerState::DocRoot(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocVersionXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocVersionXElementTypeDeserializerState::DocRoot(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocVersionXElementType> for DocVersionXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocVersionXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocVersionXElementType>
        where
            R: DeserializeReader,
        {
            use DocVersionXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::FileList(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_file_list(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DocRoot(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_doc_root(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = DocVersionXElementTypeDeserializerState::FileList(None);
                        event
                    }
                    (S::FileList(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FileList",
                            false,
                        )?;
                        match self.handle_file_list(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DocRoot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DocRoot",
                            false,
                        )?;
                        match self.handle_doc_root(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocVersionXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocVersionXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocVersionXElementType {
                id: self.id,
                version: self.version,
                name: self.name,
                creation_date: self.creation_date,
                file_list: self
                    .file_list
                    .ok_or_else(|| ErrorKind::MissingElement("FileList".into()))?,
                doc_root: self
                    .doc_root
                    .ok_or_else(|| ErrorKind::MissingElement("DocRoot".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocumentXElementTypeDeserializer {
        common_data: Option<super::DocumentCommonDataXElementType>,
        pages: Option<super::DocumentPagesXElementType>,
        outlines: Option<super::DocumentOutlinesXElementType>,
        permissions: Option<super::CtPermissionXType>,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        v_preferences: Option<super::CtVPreferencesXType>,
        bookmarks: Option<super::DocumentBookmarksXElementType>,
        annotations: Option<String>,
        custom_tags: Option<String>,
        attachments: Option<String>,
        extensions: Option<String>,
        state: Box<DocumentXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentXElementTypeDeserializerState {
        Init__,
        CommonData(
            Option<<super::DocumentCommonDataXElementType as WithDeserializer>::Deserializer>,
        ),
        Pages(Option<<super::DocumentPagesXElementType as WithDeserializer>::Deserializer>),
        Outlines(Option<<super::DocumentOutlinesXElementType as WithDeserializer>::Deserializer>),
        Permissions(Option<<super::CtPermissionXType as WithDeserializer>::Deserializer>),
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        VPreferences(Option<<super::CtVPreferencesXType as WithDeserializer>::Deserializer>),
        Bookmarks(Option<<super::DocumentBookmarksXElementType as WithDeserializer>::Deserializer>),
        Annotations(Option<<String as WithDeserializer>::Deserializer>),
        CustomTags(Option<<String as WithDeserializer>::Deserializer>),
        Attachments(Option<<String as WithDeserializer>::Deserializer>),
        Extensions(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DocumentXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                common_data: None,
                pages: None,
                outlines: None,
                permissions: None,
                actions: None,
                v_preferences: None,
                bookmarks: None,
                annotations: None,
                custom_tags: None,
                attachments: None,
                extensions: None,
                state: Box::new(DocumentXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocumentXElementTypeDeserializerState as S;
            match state {
                S::CommonData(Some(deserializer)) => {
                    self.store_common_data(deserializer.finish(reader)?)?
                }
                S::Pages(Some(deserializer)) => self.store_pages(deserializer.finish(reader)?)?,
                S::Outlines(Some(deserializer)) => {
                    self.store_outlines(deserializer.finish(reader)?)?
                }
                S::Permissions(Some(deserializer)) => {
                    self.store_permissions(deserializer.finish(reader)?)?
                }
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::VPreferences(Some(deserializer)) => {
                    self.store_v_preferences(deserializer.finish(reader)?)?
                }
                S::Bookmarks(Some(deserializer)) => {
                    self.store_bookmarks(deserializer.finish(reader)?)?
                }
                S::Annotations(Some(deserializer)) => {
                    self.store_annotations(deserializer.finish(reader)?)?
                }
                S::CustomTags(Some(deserializer)) => {
                    self.store_custom_tags(deserializer.finish(reader)?)?
                }
                S::Attachments(Some(deserializer)) => {
                    self.store_attachments(deserializer.finish(reader)?)?
                }
                S::Extensions(Some(deserializer)) => {
                    self.store_extensions(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_common_data(
            &mut self,
            value: super::DocumentCommonDataXElementType,
        ) -> Result<(), Error> {
            if self.common_data.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CommonData",
                )))?;
            }
            self.common_data = Some(value);
            Ok(())
        }
        fn store_pages(&mut self, value: super::DocumentPagesXElementType) -> Result<(), Error> {
            if self.pages.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Pages",
                )))?;
            }
            self.pages = Some(value);
            Ok(())
        }
        fn store_outlines(
            &mut self,
            value: super::DocumentOutlinesXElementType,
        ) -> Result<(), Error> {
            if self.outlines.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Outlines",
                )))?;
            }
            self.outlines = Some(value);
            Ok(())
        }
        fn store_permissions(&mut self, value: super::CtPermissionXType) -> Result<(), Error> {
            if self.permissions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Permissions",
                )))?;
            }
            self.permissions = Some(value);
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_v_preferences(&mut self, value: super::CtVPreferencesXType) -> Result<(), Error> {
            if self.v_preferences.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"VPreferences",
                )))?;
            }
            self.v_preferences = Some(value);
            Ok(())
        }
        fn store_bookmarks(
            &mut self,
            value: super::DocumentBookmarksXElementType,
        ) -> Result<(), Error> {
            if self.bookmarks.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Bookmarks",
                )))?;
            }
            self.bookmarks = Some(value);
            Ok(())
        }
        fn store_annotations(&mut self, value: String) -> Result<(), Error> {
            if self.annotations.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Annotations",
                )))?;
            }
            self.annotations = Some(value);
            Ok(())
        }
        fn store_custom_tags(&mut self, value: String) -> Result<(), Error> {
            if self.custom_tags.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CustomTags",
                )))?;
            }
            self.custom_tags = Some(value);
            Ok(())
        }
        fn store_attachments(&mut self, value: String) -> Result<(), Error> {
            if self.attachments.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Attachments",
                )))?;
            }
            self.attachments = Some(value);
            Ok(())
        }
        fn store_extensions(&mut self, value: String) -> Result<(), Error> {
            if self.extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Extensions",
                )))?;
            }
            self.extensions = Some(value);
            Ok(())
        }
        fn handle_common_data<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentCommonDataXElementType>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.common_data.is_some() {
                    fallback.get_or_insert(DocumentXElementTypeDeserializerState::CommonData(None));
                    *self.state = DocumentXElementTypeDeserializerState::Pages(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DocumentXElementTypeDeserializerState::CommonData(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_common_data(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Pages(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::CommonData(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::Pages(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentXElementTypeDeserializerState::CommonData(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_pages<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentPagesXElementType>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.pages.is_some() {
                    fallback.get_or_insert(DocumentXElementTypeDeserializerState::Pages(None));
                    *self.state = DocumentXElementTypeDeserializerState::Outlines(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DocumentXElementTypeDeserializerState::Pages(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_pages(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Outlines(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(DocumentXElementTypeDeserializerState::Pages(
                                Some(deserializer),
                            ));
                            *self.state = DocumentXElementTypeDeserializerState::Outlines(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentXElementTypeDeserializerState::Pages(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_outlines<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentOutlinesXElementType>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::Outlines(None));
                *self.state = DocumentXElementTypeDeserializerState::Permissions(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_outlines(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Permissions(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::Outlines(Some(deserializer)),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::Permissions(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentXElementTypeDeserializerState::Outlines(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_permissions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPermissionXType>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::Permissions(None));
                *self.state = DocumentXElementTypeDeserializerState::Actions(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_permissions(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Actions(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::Permissions(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::Actions(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentXElementTypeDeserializerState::Permissions(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::Actions(None));
                *self.state = DocumentXElementTypeDeserializerState::VPreferences(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::VPreferences(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(DocumentXElementTypeDeserializerState::Actions(
                                Some(deserializer),
                            ));
                            *self.state = DocumentXElementTypeDeserializerState::VPreferences(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentXElementTypeDeserializerState::Actions(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_v_preferences<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtVPreferencesXType>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::VPreferences(None));
                *self.state = DocumentXElementTypeDeserializerState::Bookmarks(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_v_preferences(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Bookmarks(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::VPreferences(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::Bookmarks(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentXElementTypeDeserializerState::VPreferences(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_bookmarks<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentBookmarksXElementType>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::Bookmarks(None));
                *self.state = DocumentXElementTypeDeserializerState::Annotations(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_bookmarks(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Annotations(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::Bookmarks(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::Annotations(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentXElementTypeDeserializerState::Bookmarks(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_annotations<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::Annotations(None));
                *self.state = DocumentXElementTypeDeserializerState::CustomTags(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_annotations(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::CustomTags(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::Annotations(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::CustomTags(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentXElementTypeDeserializerState::Annotations(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_custom_tags<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::CustomTags(None));
                *self.state = DocumentXElementTypeDeserializerState::Attachments(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_custom_tags(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Attachments(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::CustomTags(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::Attachments(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentXElementTypeDeserializerState::CustomTags(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_attachments<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::Attachments(None));
                *self.state = DocumentXElementTypeDeserializerState::Extensions(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_attachments(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Extensions(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::Attachments(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::Extensions(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentXElementTypeDeserializerState::Attachments(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<DocumentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentXElementTypeDeserializerState::Extensions(None));
                *self.state = DocumentXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_extensions(data)?;
                    *self.state = DocumentXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentXElementTypeDeserializerState::Extensions(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentXElementTypeDeserializerState::Extensions(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocumentXElementType> for DocumentXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentXElementType>
        where
            R: DeserializeReader,
        {
            use DocumentXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CommonData(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_common_data(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Pages(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_pages(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Outlines(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_outlines(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Permissions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_permissions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::VPreferences(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_v_preferences(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Bookmarks(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_bookmarks(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Annotations(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_annotations(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CustomTags(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_custom_tags(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Attachments(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_attachments(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Extensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = DocumentXElementTypeDeserializerState::CommonData(None);
                        event
                    }
                    (S::CommonData(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CommonData",
                            false,
                        )?;
                        match self.handle_common_data(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Pages(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Pages",
                            false,
                        )?;
                        match self.handle_pages(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Outlines(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Outlines",
                            true,
                        )?;
                        match self.handle_outlines(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Permissions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Permissions",
                            false,
                        )?;
                        match self.handle_permissions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::VPreferences(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"VPreferences",
                            false,
                        )?;
                        match self.handle_v_preferences(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Bookmarks(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Bookmarks",
                            false,
                        )?;
                        match self.handle_bookmarks(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Annotations(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Annotations",
                            false,
                        )?;
                        match self.handle_annotations(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CustomTags(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CustomTags",
                            false,
                        )?;
                        match self.handle_custom_tags(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Attachments(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Attachments",
                            false,
                        )?;
                        match self.handle_attachments(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Extensions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Extensions",
                            false,
                        )?;
                        match self.handle_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentXElementType {
                common_data: self
                    .common_data
                    .ok_or_else(|| ErrorKind::MissingElement("CommonData".into()))?,
                pages: self
                    .pages
                    .ok_or_else(|| ErrorKind::MissingElement("Pages".into()))?,
                outlines: self.outlines,
                permissions: self.permissions,
                actions: self.actions,
                v_preferences: self.v_preferences,
                bookmarks: self.bookmarks,
                annotations: self.annotations,
                custom_tags: self.custom_tags,
                attachments: self.attachments,
                extensions: self.extensions,
            })
        }
    }
    #[derive(Debug)]
    pub struct ExtensionsXElementTypeDeserializer {
        extension: Vec<super::CtExtensionXType>,
        state: Box<ExtensionsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ExtensionsXElementTypeDeserializerState {
        Init__,
        Extension(Option<<super::CtExtensionXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ExtensionsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                extension: Vec::new(),
                state: Box::new(ExtensionsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ExtensionsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ExtensionsXElementTypeDeserializerState as S;
            match state {
                S::Extension(Some(deserializer)) => {
                    self.store_extension(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_extension(&mut self, value: super::CtExtensionXType) -> Result<(), Error> {
            self.extension.push(value);
            Ok(())
        }
        fn handle_extension<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtExtensionXType>,
            fallback: &mut Option<ExtensionsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.extension.len() < 1usize {
                    *self.state = ExtensionsXElementTypeDeserializerState::Extension(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(ExtensionsXElementTypeDeserializerState::Extension(None));
                    *self.state = ExtensionsXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_extension(data)?;
                    *self.state = ExtensionsXElementTypeDeserializerState::Extension(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ExtensionsXElementTypeDeserializerState::Extension(Some(
                                    deserializer,
                                )),
                            );
                            if self.extension.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ExtensionsXElementTypeDeserializerState::Extension(None);
                            } else {
                                *self.state = ExtensionsXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ExtensionsXElementTypeDeserializerState::Extension(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ExtensionsXElementType> for ExtensionsXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ExtensionsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ExtensionsXElementType>
        where
            R: DeserializeReader,
        {
            use ExtensionsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Extension(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_extension(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ExtensionsXElementTypeDeserializerState::Extension(None);
                        event
                    }
                    (S::Extension(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Extension",
                            true,
                        )?;
                        match self.handle_extension(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ExtensionsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ExtensionsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ExtensionsXElementType {
                extension: self.extension,
            })
        }
    }
    #[derive(Debug)]
    pub struct OfdXElementTypeDeserializer {
        version: String,
        doc_type: super::OfdDocTypeXType,
        doc_body: Vec<super::OfdDocBodyXElementType>,
        state: Box<OfdXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum OfdXElementTypeDeserializerState {
        Init__,
        DocBody(Option<<super::OfdDocBodyXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl OfdXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut version: Option<String> = None;
            let mut doc_type: Option<super::OfdDocTypeXType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Version")
                ) {
                    reader.read_attrib(&mut version, b"Version", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DocType")
                ) {
                    reader.read_attrib(&mut doc_type, b"DocType", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                version: version.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Version".into()))
                })?,
                doc_type: doc_type.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("DocType".into()))
                })?,
                doc_body: Vec::new(),
                state: Box::new(OfdXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: OfdXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use OfdXElementTypeDeserializerState as S;
            match state {
                S::DocBody(Some(deserializer)) => {
                    self.store_doc_body(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_doc_body(&mut self, value: super::OfdDocBodyXElementType) -> Result<(), Error> {
            self.doc_body.push(value);
            Ok(())
        }
        fn handle_doc_body<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::OfdDocBodyXElementType>,
            fallback: &mut Option<OfdXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.doc_body.len() < 1usize {
                    *self.state = OfdXElementTypeDeserializerState::DocBody(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(OfdXElementTypeDeserializerState::DocBody(None));
                    *self.state = OfdXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_doc_body(data)?;
                    *self.state = OfdXElementTypeDeserializerState::DocBody(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(OfdXElementTypeDeserializerState::DocBody(
                                Some(deserializer),
                            ));
                            if self.doc_body.len().saturating_add(1) < 1usize {
                                *self.state = OfdXElementTypeDeserializerState::DocBody(None);
                            } else {
                                *self.state = OfdXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                OfdXElementTypeDeserializerState::DocBody(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::OfdXElementType> for OfdXElementTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::OfdXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::OfdXElementType>
        where
            R: DeserializeReader,
        {
            use OfdXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DocBody(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_doc_body(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = OfdXElementTypeDeserializerState::DocBody(None);
                        event
                    }
                    (S::DocBody(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DocBody",
                            false,
                        )?;
                        match self.handle_doc_body(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::OfdXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                OfdXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::OfdXElementType {
                version: self.version,
                doc_type: self.doc_type,
                doc_body: self.doc_body,
            })
        }
    }
    #[derive(Debug)]
    pub struct PageXElementTypeDeserializer {
        template: Vec<super::PageTemplateXElementType>,
        page_res: Vec<String>,
        area: Option<super::CtPageAreaXType>,
        content: Option<super::PageContentXElementType>,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        state: Box<PageXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PageXElementTypeDeserializerState {
        Init__,
        Template(Option<<super::PageTemplateXElementType as WithDeserializer>::Deserializer>),
        PageRes(Option<<String as WithDeserializer>::Deserializer>),
        Area(Option<<super::CtPageAreaXType as WithDeserializer>::Deserializer>),
        Content(Option<<super::PageContentXElementType as WithDeserializer>::Deserializer>),
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl PageXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                template: Vec::new(),
                page_res: Vec::new(),
                area: None,
                content: None,
                actions: None,
                state: Box::new(PageXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PageXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use PageXElementTypeDeserializerState as S;
            match state {
                S::Template(Some(deserializer)) => {
                    self.store_template(deserializer.finish(reader)?)?
                }
                S::PageRes(Some(deserializer)) => {
                    self.store_page_res(deserializer.finish(reader)?)?
                }
                S::Area(Some(deserializer)) => self.store_area(deserializer.finish(reader)?)?,
                S::Content(Some(deserializer)) => {
                    self.store_content(deserializer.finish(reader)?)?
                }
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_template(&mut self, value: super::PageTemplateXElementType) -> Result<(), Error> {
            self.template.push(value);
            Ok(())
        }
        fn store_page_res(&mut self, value: String) -> Result<(), Error> {
            self.page_res.push(value);
            Ok(())
        }
        fn store_area(&mut self, value: super::CtPageAreaXType) -> Result<(), Error> {
            if self.area.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Area")))?;
            }
            self.area = Some(value);
            Ok(())
        }
        fn store_content(&mut self, value: super::PageContentXElementType) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Content",
                )))?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn handle_template<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PageTemplateXElementType>,
            fallback: &mut Option<PageXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(PageXElementTypeDeserializerState::Template(None));
                *self.state = PageXElementTypeDeserializerState::PageRes(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_template(data)?;
                    *self.state = PageXElementTypeDeserializerState::Template(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(PageXElementTypeDeserializerState::Template(
                                Some(deserializer),
                            ));
                            *self.state = PageXElementTypeDeserializerState::Template(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageXElementTypeDeserializerState::Template(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_page_res<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<PageXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(PageXElementTypeDeserializerState::PageRes(None));
                *self.state = PageXElementTypeDeserializerState::Area(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_page_res(data)?;
                    *self.state = PageXElementTypeDeserializerState::PageRes(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(PageXElementTypeDeserializerState::PageRes(
                                Some(deserializer),
                            ));
                            *self.state = PageXElementTypeDeserializerState::PageRes(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageXElementTypeDeserializerState::PageRes(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_area<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPageAreaXType>,
            fallback: &mut Option<PageXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(PageXElementTypeDeserializerState::Area(None));
                *self.state = PageXElementTypeDeserializerState::Content(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_area(data)?;
                    *self.state = PageXElementTypeDeserializerState::Content(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(PageXElementTypeDeserializerState::Area(Some(
                                deserializer,
                            )));
                            *self.state = PageXElementTypeDeserializerState::Content(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageXElementTypeDeserializerState::Area(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PageContentXElementType>,
            fallback: &mut Option<PageXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(PageXElementTypeDeserializerState::Content(None));
                *self.state = PageXElementTypeDeserializerState::Actions(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = PageXElementTypeDeserializerState::Actions(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(PageXElementTypeDeserializerState::Content(
                                Some(deserializer),
                            ));
                            *self.state = PageXElementTypeDeserializerState::Actions(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageXElementTypeDeserializerState::Content(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<PageXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(PageXElementTypeDeserializerState::Actions(None));
                *self.state = PageXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = PageXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(PageXElementTypeDeserializerState::Actions(
                                Some(deserializer),
                            ));
                            *self.state = PageXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageXElementTypeDeserializerState::Actions(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageXElementType> for PageXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageXElementType>
        where
            R: DeserializeReader,
        {
            use PageXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Template(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_template(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PageRes(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_res(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Area(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_area(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Content(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = PageXElementTypeDeserializerState::Template(None);
                        event
                    }
                    (S::Template(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Template",
                            false,
                        )?;
                        match self.handle_template(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PageRes(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageRes",
                            false,
                        )?;
                        match self.handle_page_res(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Area(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Area",
                            false,
                        )?;
                        match self.handle_area(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Content(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Content",
                            true,
                        )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PageXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PageXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PageXElementType {
                template: self.template,
                page_res: self.page_res,
                area: self.area,
                content: self.content,
                actions: self.actions,
            })
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotXElementTypeDeserializer {
        annot: Vec<super::PageAnnotAnnotXElementType>,
        state: Box<PageAnnotXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PageAnnotXElementTypeDeserializerState {
        Init__,
        Annot(Option<<super::PageAnnotAnnotXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl PageAnnotXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                annot: Vec::new(),
                state: Box::new(PageAnnotXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PageAnnotXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use PageAnnotXElementTypeDeserializerState as S;
            match state {
                S::Annot(Some(deserializer)) => self.store_annot(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_annot(&mut self, value: super::PageAnnotAnnotXElementType) -> Result<(), Error> {
            self.annot.push(value);
            Ok(())
        }
        fn handle_annot<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PageAnnotAnnotXElementType>,
            fallback: &mut Option<PageAnnotXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.annot.len() < 1usize {
                    *self.state = PageAnnotXElementTypeDeserializerState::Annot(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(PageAnnotXElementTypeDeserializerState::Annot(None));
                    *self.state = PageAnnotXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_annot(data)?;
                    *self.state = PageAnnotXElementTypeDeserializerState::Annot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(PageAnnotXElementTypeDeserializerState::Annot(
                                Some(deserializer),
                            ));
                            if self.annot.len().saturating_add(1) < 1usize {
                                *self.state = PageAnnotXElementTypeDeserializerState::Annot(None);
                            } else {
                                *self.state = PageAnnotXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageAnnotXElementTypeDeserializerState::Annot(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageAnnotXElementType> for PageAnnotXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotXElementType>
        where
            R: DeserializeReader,
        {
            use PageAnnotXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Annot(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_annot(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = PageAnnotXElementTypeDeserializerState::Annot(None);
                        event
                    }
                    (S::Annot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Annot",
                            false,
                        )?;
                        match self.handle_annot(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PageAnnotXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PageAnnotXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PageAnnotXElementType { annot: self.annot })
        }
    }
    #[derive(Debug)]
    pub struct ResXElementTypeDeserializer {
        base_loc: String,
        content: Vec<super::ResXElementTypeContent>,
        state: Box<ResXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResXElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::ResXElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl ResXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut base_loc: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"BaseLoc")
                ) {
                    reader.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                base_loc: base_loc.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("BaseLoc".into()))
                })?,
                content: Vec::new(),
                state: Box::new(ResXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let ResXElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::ResXElementTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ResXElementTypeContent>,
            fallback: &mut Option<ResXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(ResXElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = ResXElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ResXElementTypeDeserializerState::Content__(deserializer);
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ResXElementTypeDeserializerState::Content__(
                                deserializer,
                            ));
                            *self.state = ResXElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResXElementType> for ResXElementTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::ResXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResXElementType>
        where
            R: DeserializeReader,
        {
            use ResXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: ResXElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ResXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResXElementType {
                base_loc: self.base_loc,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResXElementTypeContentDeserializer {
        state: Box<ResXElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum ResXElementTypeContentDeserializerState {
        Init__,
        ColorSpaces(
            Option<super::ResColorSpacesXElementType>,
            Option<<super::ResColorSpacesXElementType as WithDeserializer>::Deserializer>,
        ),
        DrawParams(
            Option<super::ResDrawParamsXElementType>,
            Option<<super::ResDrawParamsXElementType as WithDeserializer>::Deserializer>,
        ),
        Fonts(
            Option<super::ResFontsXElementType>,
            Option<<super::ResFontsXElementType as WithDeserializer>::Deserializer>,
        ),
        MultiMedias(
            Option<super::ResMultiMediasXElementType>,
            Option<<super::ResMultiMediasXElementType as WithDeserializer>::Deserializer>,
        ),
        CompositeGraphicUnits(
            Option<super::ResCompositeGraphicUnitsXElementType>,
            Option<<super::ResCompositeGraphicUnitsXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::ResXElementTypeContent),
        Unknown__,
    }
    impl ResXElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<ResXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ColorSpaces")
                ) {
                    let output = < super :: ResColorSpacesXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_color_spaces(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"DrawParams")
                ) {
                    let output =
                        <super::ResDrawParamsXElementType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_draw_params(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Fonts")
                ) {
                    let output =
                        <super::ResFontsXElementType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_fonts(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"MultiMedias")
                ) {
                    let output = < super :: ResMultiMediasXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_multi_medias(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CompositeGraphicUnits")
                ) {
                    let output = < super :: ResCompositeGraphicUnitsXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_composite_graphic_units(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(ResXElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: ResXElementTypeContentDeserializerState,
        ) -> Result<super::ResXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use ResXElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::ColorSpaces(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_color_spaces(&mut values, value)?;
                    }
                    Ok(super::ResXElementTypeContent::ColorSpaces(
                        values.ok_or_else(|| ErrorKind::MissingElement("ColorSpaces".into()))?,
                    ))
                }
                S::DrawParams(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_draw_params(&mut values, value)?;
                    }
                    Ok(super::ResXElementTypeContent::DrawParams(
                        values.ok_or_else(|| ErrorKind::MissingElement("DrawParams".into()))?,
                    ))
                }
                S::Fonts(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_fonts(&mut values, value)?;
                    }
                    Ok(super::ResXElementTypeContent::Fonts(values.ok_or_else(
                        || ErrorKind::MissingElement("Fonts".into()),
                    )?))
                }
                S::MultiMedias(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_multi_medias(&mut values, value)?;
                    }
                    Ok(super::ResXElementTypeContent::MultiMedias(
                        values.ok_or_else(|| ErrorKind::MissingElement("MultiMedias".into()))?,
                    ))
                }
                S::CompositeGraphicUnits(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_composite_graphic_units(&mut values, value)?;
                    }
                    Ok(super::ResXElementTypeContent::CompositeGraphicUnits(
                        values.ok_or_else(|| {
                            ErrorKind::MissingElement("CompositeGraphicUnits".into())
                        })?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_color_spaces(
            values: &mut Option<super::ResColorSpacesXElementType>,
            value: super::ResColorSpacesXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ColorSpaces",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_draw_params(
            values: &mut Option<super::ResDrawParamsXElementType>,
            value: super::ResDrawParamsXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DrawParams",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_fonts(
            values: &mut Option<super::ResFontsXElementType>,
            value: super::ResFontsXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Fonts",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_multi_medias(
            values: &mut Option<super::ResMultiMediasXElementType>,
            value: super::ResMultiMediasXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MultiMedias",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_composite_graphic_units(
            values: &mut Option<super::ResCompositeGraphicUnitsXElementType>,
            value: super::ResCompositeGraphicUnitsXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompositeGraphicUnits",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_color_spaces<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::ResColorSpacesXElementType>,
            output: DeserializerOutput<'de, super::ResColorSpacesXElementType>,
            fallback: &mut Option<ResXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = ResXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => ResXElementTypeContentDeserializerState::ColorSpaces(values, None),
                    Some(ResXElementTypeContentDeserializerState::ColorSpaces(
                        _,
                        Some(deserializer),
                    )) => ResXElementTypeContentDeserializerState::ColorSpaces(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(ResXElementTypeContentDeserializerState::ColorSpaces(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_color_spaces(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_color_spaces(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        ResXElementTypeContentDeserializerState::ColorSpaces(values, None),
                    )?;
                    *self.state = ResXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = ResXElementTypeContentDeserializerState::ColorSpaces(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_draw_params<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::ResDrawParamsXElementType>,
            output: DeserializerOutput<'de, super::ResDrawParamsXElementType>,
            fallback: &mut Option<ResXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = ResXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => ResXElementTypeContentDeserializerState::DrawParams(values, None),
                    Some(ResXElementTypeContentDeserializerState::DrawParams(
                        _,
                        Some(deserializer),
                    )) => ResXElementTypeContentDeserializerState::DrawParams(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(ResXElementTypeContentDeserializerState::DrawParams(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_draw_params(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_draw_params(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        ResXElementTypeContentDeserializerState::DrawParams(values, None),
                    )?;
                    *self.state = ResXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = ResXElementTypeContentDeserializerState::DrawParams(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_fonts<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::ResFontsXElementType>,
            output: DeserializerOutput<'de, super::ResFontsXElementType>,
            fallback: &mut Option<ResXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = ResXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => ResXElementTypeContentDeserializerState::Fonts(values, None),
                    Some(ResXElementTypeContentDeserializerState::Fonts(_, Some(deserializer))) => {
                        ResXElementTypeContentDeserializerState::Fonts(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(ResXElementTypeContentDeserializerState::Fonts(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_fonts(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_fonts(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        ResXElementTypeContentDeserializerState::Fonts(values, None),
                    )?;
                    *self.state = ResXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        ResXElementTypeContentDeserializerState::Fonts(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_multi_medias<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::ResMultiMediasXElementType>,
            output: DeserializerOutput<'de, super::ResMultiMediasXElementType>,
            fallback: &mut Option<ResXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = ResXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => ResXElementTypeContentDeserializerState::MultiMedias(values, None),
                    Some(ResXElementTypeContentDeserializerState::MultiMedias(
                        _,
                        Some(deserializer),
                    )) => ResXElementTypeContentDeserializerState::MultiMedias(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(ResXElementTypeContentDeserializerState::MultiMedias(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_multi_medias(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_multi_medias(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        ResXElementTypeContentDeserializerState::MultiMedias(values, None),
                    )?;
                    *self.state = ResXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = ResXElementTypeContentDeserializerState::MultiMedias(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_composite_graphic_units<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::ResCompositeGraphicUnitsXElementType>,
            output: DeserializerOutput<'de, super::ResCompositeGraphicUnitsXElementType>,
            fallback: &mut Option<ResXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = ResXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => {
                        ResXElementTypeContentDeserializerState::CompositeGraphicUnits(values, None)
                    }
                    Some(ResXElementTypeContentDeserializerState::CompositeGraphicUnits(
                        _,
                        Some(deserializer),
                    )) => ResXElementTypeContentDeserializerState::CompositeGraphicUnits(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(ResXElementTypeContentDeserializerState::CompositeGraphicUnits(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_composite_graphic_units(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_composite_graphic_units(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        ResXElementTypeContentDeserializerState::CompositeGraphicUnits(
                            values, None,
                        ),
                    )?;
                    *self.state = ResXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = ResXElementTypeContentDeserializerState::CompositeGraphicUnits(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResXElementTypeContent> for ResXElementTypeContentDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResXElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(ResXElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, ResXElementTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResXElementTypeContent>
        where
            R: DeserializeReader,
        {
            use ResXElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ColorSpaces(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_color_spaces(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::DrawParams(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_draw_params(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Fonts(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fonts(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::MultiMedias(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_multi_medias(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeGraphicUnits(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_composite_graphic_units(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::ColorSpaces(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ColorSpaces",
                            false,
                        )?;
                        match self.handle_color_spaces(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::DrawParams(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DrawParams",
                            true,
                        )?;
                        match self.handle_draw_params(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Fonts(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Fonts",
                            false,
                        )?;
                        match self.handle_fonts(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::MultiMedias(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"MultiMedias",
                            false,
                        )?;
                        match self.handle_multi_medias(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeGraphicUnits(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CompositeGraphicUnits",
                            false,
                        )?;
                        match self.handle_composite_graphic_units(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::ResXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct SianatureXElementTypeDeserializer {
        siqned_info: Option<super::SianatureSiqnedInfoXElementType>,
        signed_value: Option<String>,
        state: Box<SianatureXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SianatureXElementTypeDeserializerState {
        Init__,
        SiqnedInfo(
            Option<<super::SianatureSiqnedInfoXElementType as WithDeserializer>::Deserializer>,
        ),
        SignedValue(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SianatureXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                siqned_info: None,
                signed_value: None,
                state: Box::new(SianatureXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SianatureXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SianatureXElementTypeDeserializerState as S;
            match state {
                S::SiqnedInfo(Some(deserializer)) => {
                    self.store_siqned_info(deserializer.finish(reader)?)?
                }
                S::SignedValue(Some(deserializer)) => {
                    self.store_signed_value(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_siqned_info(
            &mut self,
            value: super::SianatureSiqnedInfoXElementType,
        ) -> Result<(), Error> {
            if self.siqned_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SiqnedInfo",
                )))?;
            }
            self.siqned_info = Some(value);
            Ok(())
        }
        fn store_signed_value(&mut self, value: String) -> Result<(), Error> {
            if self.signed_value.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SignedValue",
                )))?;
            }
            self.signed_value = Some(value);
            Ok(())
        }
        fn handle_siqned_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SianatureSiqnedInfoXElementType>,
            fallback: &mut Option<SianatureXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.siqned_info.is_some() {
                    fallback
                        .get_or_insert(SianatureXElementTypeDeserializerState::SiqnedInfo(None));
                    *self.state = SianatureXElementTypeDeserializerState::SignedValue(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = SianatureXElementTypeDeserializerState::SiqnedInfo(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_siqned_info(data)?;
                    *self.state = SianatureXElementTypeDeserializerState::SignedValue(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureXElementTypeDeserializerState::SiqnedInfo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SianatureXElementTypeDeserializerState::SignedValue(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SianatureXElementTypeDeserializerState::SiqnedInfo(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_signed_value<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SianatureXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.signed_value.is_some() {
                    fallback
                        .get_or_insert(SianatureXElementTypeDeserializerState::SignedValue(None));
                    *self.state = SianatureXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = SianatureXElementTypeDeserializerState::SignedValue(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_signed_value(data)?;
                    *self.state = SianatureXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureXElementTypeDeserializerState::SignedValue(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SianatureXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SianatureXElementTypeDeserializerState::SignedValue(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SianatureXElementType> for SianatureXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureXElementType>
        where
            R: DeserializeReader,
        {
            use SianatureXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SiqnedInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_siqned_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SignedValue(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_signed_value(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = SianatureXElementTypeDeserializerState::SiqnedInfo(None);
                        event
                    }
                    (S::SiqnedInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"SiqnedInfo",
                            false,
                        )?;
                        match self.handle_siqned_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SignedValue(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"SignedValue",
                            false,
                        )?;
                        match self.handle_signed_value(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SianatureXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SianatureXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SianatureXElementType {
                siqned_info: self
                    .siqned_info
                    .ok_or_else(|| ErrorKind::MissingElement("SiqnedInfo".into()))?,
                signed_value: self
                    .signed_value
                    .ok_or_else(|| ErrorKind::MissingElement("SignedValue".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct SiqnaturesXElementTypeDeserializer {
        max_sign_id: Option<String>,
        signature: Vec<super::SiqnaturesSignatureXElementType>,
        state: Box<SiqnaturesXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SiqnaturesXElementTypeDeserializerState {
        Init__,
        MaxSignId(Option<<String as WithDeserializer>::Deserializer>),
        Signature(
            Option<<super::SiqnaturesSignatureXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl SiqnaturesXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                max_sign_id: None,
                signature: Vec::new(),
                state: Box::new(SiqnaturesXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SiqnaturesXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SiqnaturesXElementTypeDeserializerState as S;
            match state {
                S::MaxSignId(Some(deserializer)) => {
                    self.store_max_sign_id(deserializer.finish(reader)?)?
                }
                S::Signature(Some(deserializer)) => {
                    self.store_signature(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_max_sign_id(&mut self, value: String) -> Result<(), Error> {
            if self.max_sign_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MaxSignId",
                )))?;
            }
            self.max_sign_id = Some(value);
            Ok(())
        }
        fn store_signature(
            &mut self,
            value: super::SiqnaturesSignatureXElementType,
        ) -> Result<(), Error> {
            self.signature.push(value);
            Ok(())
        }
        fn handle_max_sign_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SiqnaturesXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SiqnaturesXElementTypeDeserializerState::MaxSignId(None));
                *self.state = SiqnaturesXElementTypeDeserializerState::Signature(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_max_sign_id(data)?;
                    *self.state = SiqnaturesXElementTypeDeserializerState::Signature(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SiqnaturesXElementTypeDeserializerState::MaxSignId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SiqnaturesXElementTypeDeserializerState::Signature(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SiqnaturesXElementTypeDeserializerState::MaxSignId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_signature<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SiqnaturesSignatureXElementType>,
            fallback: &mut Option<SiqnaturesXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SiqnaturesXElementTypeDeserializerState::Signature(None));
                *self.state = SiqnaturesXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_signature(data)?;
                    *self.state = SiqnaturesXElementTypeDeserializerState::Signature(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SiqnaturesXElementTypeDeserializerState::Signature(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SiqnaturesXElementTypeDeserializerState::Signature(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SiqnaturesXElementTypeDeserializerState::Signature(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SiqnaturesXElementType> for SiqnaturesXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SiqnaturesXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SiqnaturesXElementType>
        where
            R: DeserializeReader,
        {
            use SiqnaturesXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::MaxSignId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_max_sign_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Signature(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_signature(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = SiqnaturesXElementTypeDeserializerState::MaxSignId(None);
                        event
                    }
                    (S::MaxSignId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"MaxSignId",
                            false,
                        )?;
                        match self.handle_max_sign_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Signature(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Signature",
                            false,
                        )?;
                        match self.handle_signature(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SiqnaturesXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SiqnaturesXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SiqnaturesXElementType {
                max_sign_id: self.max_sign_id,
                signature: self.signature,
            })
        }
    }
    #[derive(Debug)]
    pub struct AnnotationsPageXElementTypeDeserializer {
        page_id: u32,
        file_loc: Option<String>,
        state: Box<AnnotationsPageXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum AnnotationsPageXElementTypeDeserializerState {
        Init__,
        FileLoc(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl AnnotationsPageXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut page_id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"PageID")
                ) {
                    reader.read_attrib(&mut page_id, b"PageID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                page_id: page_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("PageID".into()))
                })?,
                file_loc: None,
                state: Box::new(AnnotationsPageXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: AnnotationsPageXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use AnnotationsPageXElementTypeDeserializerState as S;
            match state {
                S::FileLoc(Some(deserializer)) => {
                    self.store_file_loc(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_file_loc(&mut self, value: String) -> Result<(), Error> {
            if self.file_loc.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FileLoc",
                )))?;
            }
            self.file_loc = Some(value);
            Ok(())
        }
        fn handle_file_loc<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<AnnotationsPageXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.file_loc.is_some() {
                    fallback
                        .get_or_insert(AnnotationsPageXElementTypeDeserializerState::FileLoc(None));
                    *self.state = AnnotationsPageXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = AnnotationsPageXElementTypeDeserializerState::FileLoc(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_file_loc(data)?;
                    *self.state = AnnotationsPageXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                AnnotationsPageXElementTypeDeserializerState::FileLoc(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = AnnotationsPageXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = AnnotationsPageXElementTypeDeserializerState::FileLoc(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::AnnotationsPageXElementType>
        for AnnotationsPageXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AnnotationsPageXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::AnnotationsPageXElementType>
        where
            R: DeserializeReader,
        {
            use AnnotationsPageXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::FileLoc(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_file_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = AnnotationsPageXElementTypeDeserializerState::FileLoc(None);
                        event
                    }
                    (S::FileLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FileLoc",
                            false,
                        )?;
                        match self.handle_file_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::AnnotationsPageXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                AnnotationsPageXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::AnnotationsPageXElementType {
                page_id: self.page_id,
                file_loc: self
                    .file_loc
                    .ok_or_else(|| ErrorKind::MissingElement("FileLoc".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtActionGotoXElementTypeDeserializer {
        state: Box<CtActionGotoXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtActionGotoXElementTypeDeserializerState {
        Init__,
        Dest(
            Option<super::CtDestXType>,
            Option<<super::CtDestXType as WithDeserializer>::Deserializer>,
        ),
        Bookmark(
            Option<super::CtActionGotoBookmarkXElementType>,
            Option<<super::CtActionGotoBookmarkXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtActionGotoXElementType),
        Unknown__,
    }
    impl CtActionGotoXElementTypeDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtActionGotoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Dest")
                ) {
                    let output = <super::CtDestXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_dest(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Bookmark")
                ) {
                    let output = < super :: CtActionGotoBookmarkXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_bookmark(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtActionGotoXElementTypeDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                state: Box::new(CtActionGotoXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            reader: &R,
            state: CtActionGotoXElementTypeDeserializerState,
        ) -> Result<super::CtActionGotoXElementType, Error>
        where
            R: DeserializeReader,
        {
            use CtActionGotoXElementTypeDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Dest(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_dest(&mut values, value)?;
                    }
                    Ok(super::CtActionGotoXElementType::Dest(
                        values.ok_or_else(|| ErrorKind::MissingElement("Dest".into()))?,
                    ))
                }
                S::Bookmark(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_bookmark(&mut values, value)?;
                    }
                    Ok(super::CtActionGotoXElementType::Bookmark(
                        values.ok_or_else(|| ErrorKind::MissingElement("Bookmark".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_dest(
            values: &mut Option<super::CtDestXType>,
            value: super::CtDestXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Dest")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_bookmark(
            values: &mut Option<super::CtActionGotoBookmarkXElementType>,
            value: super::CtActionGotoBookmarkXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Bookmark",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_dest<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtDestXType>,
            output: DeserializerOutput<'de, super::CtDestXType>,
            fallback: &mut Option<CtActionGotoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtActionGotoXElementTypeDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtActionGotoXElementTypeDeserializerState::Dest(values, None),
                    Some(CtActionGotoXElementTypeDeserializerState::Dest(
                        _,
                        Some(deserializer),
                    )) => {
                        CtActionGotoXElementTypeDeserializerState::Dest(values, Some(deserializer))
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtActionGotoXElementTypeDeserializerState::Dest(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_dest(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_dest(&mut values, data)?;
                    *self.state = CtActionGotoXElementTypeDeserializerState::Dest(values, None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtActionGotoXElementTypeDeserializerState::Dest(values, Some(deserializer));
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_bookmark<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtActionGotoBookmarkXElementType>,
            output: DeserializerOutput<'de, super::CtActionGotoBookmarkXElementType>,
            fallback: &mut Option<CtActionGotoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtActionGotoXElementTypeDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtActionGotoXElementTypeDeserializerState::Bookmark(values, None),
                    Some(CtActionGotoXElementTypeDeserializerState::Bookmark(
                        _,
                        Some(deserializer),
                    )) => CtActionGotoXElementTypeDeserializerState::Bookmark(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtActionGotoXElementTypeDeserializerState::Bookmark(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_bookmark(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_bookmark(&mut values, data)?;
                    *self.state = CtActionGotoXElementTypeDeserializerState::Bookmark(values, None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtActionGotoXElementTypeDeserializerState::Bookmark(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtActionGotoXElementType>
        for CtActionGotoXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionGotoXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionGotoXElementType>
        where
            R: DeserializeReader,
        {
            use CtActionGotoXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Dest(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_dest(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Bookmark(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_bookmark(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Dest(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Dest",
                            false,
                        )?;
                        match self.handle_dest(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Bookmark(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Bookmark",
                            false,
                        )?;
                        match self.handle_bookmark(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtActionGotoXElementType, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtActionUriXElementTypeDeserializer {
        uri: String,
        base: Option<String>,
        target: Option<String>,
        state: Box<CtActionUriXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtActionUriXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtActionUriXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut uri: Option<String> = None;
            let mut base: Option<String> = None;
            let mut target: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"URI")
                ) {
                    reader.read_attrib(&mut uri, b"URI", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Base")
                ) {
                    reader.read_attrib(&mut base, b"Base", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Target")
                ) {
                    reader.read_attrib(&mut target, b"Target", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                uri: uri
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("URI".into())))?,
                base: base,
                target: target,
                state: Box::new(CtActionUriXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtActionUriXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtActionUriXElementType>
        for CtActionUriXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionUriXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionUriXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtActionUriXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtActionUriXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtActionUriXElementType {
                uri: self.uri,
                base: self.base,
                target: self.target,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtActionGotoAxElementTypeDeserializer {
        attach_id: String,
        new_window: bool,
        state: Box<CtActionGotoAxElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtActionGotoAxElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtActionGotoAxElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut attach_id: Option<String> = None;
            let mut new_window: Option<bool> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"AttachID")
                ) {
                    reader.read_attrib(&mut attach_id, b"AttachID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"NewWindow")
                ) {
                    reader.read_attrib(&mut new_window, b"NewWindow", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                attach_id: attach_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("AttachID".into()))
                })?,
                new_window: new_window
                    .unwrap_or_else(super::CtActionGotoAxElementType::default_new_window),
                state: Box::new(CtActionGotoAxElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtActionGotoAxElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtActionGotoAxElementType>
        for CtActionGotoAxElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionGotoAxElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionGotoAxElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtActionGotoAxElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtActionGotoAxElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtActionGotoAxElementType {
                attach_id: self.attach_id,
                new_window: self.new_window,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtActionSoundXElementTypeDeserializer {
        resource_id: u32,
        volume: Option<i32>,
        repeat: Option<bool>,
        synchronous: Option<bool>,
        state: Box<CtActionSoundXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtActionSoundXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtActionSoundXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut resource_id: Option<u32> = None;
            let mut volume: Option<i32> = None;
            let mut repeat: Option<bool> = None;
            let mut synchronous: Option<bool> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ResourceID")
                ) {
                    reader.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Volume")
                ) {
                    reader.read_attrib(&mut volume, b"Volume", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Repeat")
                ) {
                    reader.read_attrib(&mut repeat, b"Repeat", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Synchronous")
                ) {
                    reader.read_attrib(&mut synchronous, b"Synchronous", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                resource_id: resource_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("ResourceID".into()))
                })?,
                volume: volume,
                repeat: repeat,
                synchronous: synchronous,
                state: Box::new(CtActionSoundXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtActionSoundXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtActionSoundXElementType>
        for CtActionSoundXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionSoundXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionSoundXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtActionSoundXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtActionSoundXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtActionSoundXElementType {
                resource_id: self.resource_id,
                volume: self.volume,
                repeat: self.repeat,
                synchronous: self.synchronous,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtActionMovieXElementTypeDeserializer {
        resource_id: u32,
        operator: super::CtActionMovieOperatorXType,
        state: Box<CtActionMovieXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtActionMovieXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtActionMovieXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut resource_id: Option<u32> = None;
            let mut operator: Option<super::CtActionMovieOperatorXType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ResourceID")
                ) {
                    reader.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Operator")
                ) {
                    reader.read_attrib(&mut operator, b"Operator", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                resource_id: resource_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("ResourceID".into()))
                })?,
                operator: operator
                    .unwrap_or_else(super::CtActionMovieXElementType::default_operator),
                state: Box::new(CtActionMovieXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtActionMovieXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtActionMovieXElementType>
        for CtActionMovieXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionMovieXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionMovieXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtActionMovieXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtActionMovieXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtActionMovieXElementType {
                resource_id: self.resource_id,
                operator: self.operator,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtAxialShdSegmentXElementTypeDeserializer {
        position: Option<f64>,
        color: Option<super::CtColorXType>,
        state: Box<CtAxialShdSegmentXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtAxialShdSegmentXElementTypeDeserializerState {
        Init__,
        Color(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtAxialShdSegmentXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut position: Option<f64> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Position")
                ) {
                    reader.read_attrib(&mut position, b"Position", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                position: position,
                color: None,
                state: Box::new(CtAxialShdSegmentXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtAxialShdSegmentXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtAxialShdSegmentXElementTypeDeserializerState as S;
            match state {
                S::Color(Some(deserializer)) => self.store_color(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Color",
                )))?;
            }
            self.color = Some(value);
            Ok(())
        }
        fn handle_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtAxialShdSegmentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.color.is_some() {
                    fallback
                        .get_or_insert(CtAxialShdSegmentXElementTypeDeserializerState::Color(None));
                    *self.state = CtAxialShdSegmentXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtAxialShdSegmentXElementTypeDeserializerState::Color(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_color(data)?;
                    *self.state = CtAxialShdSegmentXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtAxialShdSegmentXElementTypeDeserializerState::Color(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CtAxialShdSegmentXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtAxialShdSegmentXElementTypeDeserializerState::Color(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtAxialShdSegmentXElementType>
        for CtAxialShdSegmentXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtAxialShdSegmentXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtAxialShdSegmentXElementType>
        where
            R: DeserializeReader,
        {
            use CtAxialShdSegmentXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Color(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtAxialShdSegmentXElementTypeDeserializerState::Color(None);
                        event
                    }
                    (S::Color(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Color",
                            true,
                        )?;
                        match self.handle_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtAxialShdSegmentXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtAxialShdSegmentXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtAxialShdSegmentXElementType {
                position: self.position,
                color: self
                    .color
                    .ok_or_else(|| ErrorKind::MissingElement("Color".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtClipAreaXElementTypeDeserializer {
        draw_param: Option<u32>,
        ctm: Option<String>,
        content: Option<super::CtClipAreaXElementTypeContent>,
        state: Box<CtClipAreaXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtClipAreaXElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtClipAreaXElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtClipAreaXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut draw_param: Option<u32> = None;
            let mut ctm: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                draw_param: draw_param,
                ctm: ctm,
                content: None,
                state: Box::new(CtClipAreaXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtClipAreaXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtClipAreaXElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::CtClipAreaXElementTypeContent,
        ) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtClipAreaXElementTypeContent>,
            fallback: &mut Option<CtClipAreaXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtClipAreaXElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtClipAreaXElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtClipAreaXElementTypeDeserializerState::Content__(deserializer);
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtClipAreaXElementType> for CtClipAreaXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtClipAreaXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtClipAreaXElementType>
        where
            R: DeserializeReader,
        {
            use CtClipAreaXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: CtClipAreaXElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtClipAreaXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtClipAreaXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtClipAreaXElementType {
                draw_param: self.draw_param,
                ctm: self.ctm,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtClipAreaXElementTypeContentDeserializer {
        state: Box<CtClipAreaXElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtClipAreaXElementTypeContentDeserializerState {
        Init__,
        Path(
            Option<super::CtPathXType>,
            Option<<super::CtPathXType as WithDeserializer>::Deserializer>,
        ),
        Text(
            Option<super::CtTextXType>,
            Option<<super::CtTextXType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtClipAreaXElementTypeContent),
        Unknown__,
    }
    impl CtClipAreaXElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtClipAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Path")
                ) {
                    let output = <super::CtPathXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_path(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Text")
                ) {
                    let output = <super::CtTextXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_text(reader, Default::default(), output, &mut *fallback);
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtClipAreaXElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtClipAreaXElementTypeContentDeserializerState,
        ) -> Result<super::CtClipAreaXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtClipAreaXElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Path(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_path(&mut values, value)?;
                    }
                    Ok(super::CtClipAreaXElementTypeContent::Path(
                        values.ok_or_else(|| ErrorKind::MissingElement("Path".into()))?,
                    ))
                }
                S::Text(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text(&mut values, value)?;
                    }
                    Ok(super::CtClipAreaXElementTypeContent::Text(
                        values.ok_or_else(|| ErrorKind::MissingElement("Text".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_path(
            values: &mut Option<super::CtPathXType>,
            value: super::CtPathXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Path")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_text(
            values: &mut Option<super::CtTextXType>,
            value: super::CtTextXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Text")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_path<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPathXType>,
            output: DeserializerOutput<'de, super::CtPathXType>,
            fallback: &mut Option<CtClipAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtClipAreaXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtClipAreaXElementTypeContentDeserializerState::Path(values, None),
                    Some(CtClipAreaXElementTypeContentDeserializerState::Path(
                        _,
                        Some(deserializer),
                    )) => CtClipAreaXElementTypeContentDeserializerState::Path(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtClipAreaXElementTypeContentDeserializerState::Path(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_path(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_path(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtClipAreaXElementTypeContentDeserializerState::Path(values, None),
                    )?;
                    *self.state = CtClipAreaXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtClipAreaXElementTypeContentDeserializerState::Path(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_text<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtTextXType>,
            output: DeserializerOutput<'de, super::CtTextXType>,
            fallback: &mut Option<CtClipAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtClipAreaXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtClipAreaXElementTypeContentDeserializerState::Text(values, None),
                    Some(CtClipAreaXElementTypeContentDeserializerState::Text(
                        _,
                        Some(deserializer),
                    )) => CtClipAreaXElementTypeContentDeserializerState::Text(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtClipAreaXElementTypeContentDeserializerState::Text(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtClipAreaXElementTypeContentDeserializerState::Text(values, None),
                    )?;
                    *self.state = CtClipAreaXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtClipAreaXElementTypeContentDeserializerState::Text(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtClipAreaXElementTypeContent>
        for CtClipAreaXElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtClipAreaXElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtClipAreaXElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        CtClipAreaXElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtClipAreaXElementTypeContent>
        where
            R: DeserializeReader,
        {
            use CtClipAreaXElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Path(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_path(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Text(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Path(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Path",
                            true,
                        )?;
                        match self.handle_path(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Text(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Text",
                            true,
                        )?;
                        match self.handle_text(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtClipAreaXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtColorSpacePaletteXElementTypeDeserializer {
        cv: Vec<String>,
        state: Box<CtColorSpacePaletteXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtColorSpacePaletteXElementTypeDeserializerState {
        Init__,
        Cv(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtColorSpacePaletteXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                cv: Vec::new(),
                state: Box::new(CtColorSpacePaletteXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtColorSpacePaletteXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtColorSpacePaletteXElementTypeDeserializerState as S;
            match state {
                S::Cv(Some(deserializer)) => self.store_cv(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_cv(&mut self, value: String) -> Result<(), Error> {
            self.cv.push(value);
            Ok(())
        }
        fn handle_cv<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtColorSpacePaletteXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.cv.len() < 1usize {
                    *self.state = CtColorSpacePaletteXElementTypeDeserializerState::Cv(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(CtColorSpacePaletteXElementTypeDeserializerState::Cv(None));
                    *self.state = CtColorSpacePaletteXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_cv(data)?;
                    *self.state = CtColorSpacePaletteXElementTypeDeserializerState::Cv(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtColorSpacePaletteXElementTypeDeserializerState::Cv(Some(
                                    deserializer,
                                )),
                            );
                            if self.cv.len().saturating_add(1) < 1usize {
                                *self.state =
                                    CtColorSpacePaletteXElementTypeDeserializerState::Cv(None);
                            } else {
                                *self.state =
                                    CtColorSpacePaletteXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtColorSpacePaletteXElementTypeDeserializerState::Cv(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtColorSpacePaletteXElementType>
        for CtColorSpacePaletteXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtColorSpacePaletteXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtColorSpacePaletteXElementType>
        where
            R: DeserializeReader,
        {
            use CtColorSpacePaletteXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Cv(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_cv(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtColorSpacePaletteXElementTypeDeserializerState::Cv(None);
                        event
                    }
                    (S::Cv(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CV",
                            false,
                        )?;
                        match self.handle_cv(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtColorSpacePaletteXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtColorSpacePaletteXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtColorSpacePaletteXElementType { cv: self.cv })
        }
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitActionsXElementTypeDeserializer {
        action: Vec<super::CtActionXType>,
        state: Box<CtGraphicUnitActionsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtGraphicUnitActionsXElementTypeDeserializerState {
        Init__,
        Action(Option<<super::CtActionXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtGraphicUnitActionsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                action: Vec::new(),
                state: Box::new(CtGraphicUnitActionsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtGraphicUnitActionsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtGraphicUnitActionsXElementTypeDeserializerState as S;
            match state {
                S::Action(Some(deserializer)) => self.store_action(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_action(&mut self, value: super::CtActionXType) -> Result<(), Error> {
            self.action.push(value);
            Ok(())
        }
        fn handle_action<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtActionXType>,
            fallback: &mut Option<CtGraphicUnitActionsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.action.len() < 1usize {
                    *self.state = CtGraphicUnitActionsXElementTypeDeserializerState::Action(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        CtGraphicUnitActionsXElementTypeDeserializerState::Action(None),
                    );
                    *self.state = CtGraphicUnitActionsXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_action(data)?;
                    *self.state = CtGraphicUnitActionsXElementTypeDeserializerState::Action(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtGraphicUnitActionsXElementTypeDeserializerState::Action(Some(
                                    deserializer,
                                )),
                            );
                            if self.action.len().saturating_add(1) < 1usize {
                                *self.state =
                                    CtGraphicUnitActionsXElementTypeDeserializerState::Action(None);
                            } else {
                                *self.state =
                                    CtGraphicUnitActionsXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtGraphicUnitActionsXElementTypeDeserializerState::Action(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtGraphicUnitActionsXElementType>
        for CtGraphicUnitActionsXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGraphicUnitActionsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGraphicUnitActionsXElementType>
        where
            R: DeserializeReader,
        {
            use CtGraphicUnitActionsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Action(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_action(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CtGraphicUnitActionsXElementTypeDeserializerState::Action(None);
                        event
                    }
                    (S::Action(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Action",
                            true,
                        )?;
                        match self.handle_action(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtGraphicUnitActionsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtGraphicUnitActionsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtGraphicUnitActionsXElementType {
                action: self.action,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitClipsXElementTypeDeserializer {
        clip: Vec<super::CtClipXType>,
        state: Box<CtGraphicUnitClipsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtGraphicUnitClipsXElementTypeDeserializerState {
        Init__,
        Clip(Option<<super::CtClipXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtGraphicUnitClipsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                clip: Vec::new(),
                state: Box::new(CtGraphicUnitClipsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtGraphicUnitClipsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtGraphicUnitClipsXElementTypeDeserializerState as S;
            match state {
                S::Clip(Some(deserializer)) => self.store_clip(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_clip(&mut self, value: super::CtClipXType) -> Result<(), Error> {
            self.clip.push(value);
            Ok(())
        }
        fn handle_clip<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtClipXType>,
            fallback: &mut Option<CtGraphicUnitClipsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.clip.len() < 1usize {
                    *self.state = CtGraphicUnitClipsXElementTypeDeserializerState::Clip(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(CtGraphicUnitClipsXElementTypeDeserializerState::Clip(None));
                    *self.state = CtGraphicUnitClipsXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_clip(data)?;
                    *self.state = CtGraphicUnitClipsXElementTypeDeserializerState::Clip(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtGraphicUnitClipsXElementTypeDeserializerState::Clip(Some(
                                    deserializer,
                                )),
                            );
                            if self.clip.len().saturating_add(1) < 1usize {
                                *self.state =
                                    CtGraphicUnitClipsXElementTypeDeserializerState::Clip(None);
                            } else {
                                *self.state =
                                    CtGraphicUnitClipsXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtGraphicUnitClipsXElementTypeDeserializerState::Clip(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtGraphicUnitClipsXElementType>
        for CtGraphicUnitClipsXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGraphicUnitClipsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGraphicUnitClipsXElementType>
        where
            R: DeserializeReader,
        {
            use CtGraphicUnitClipsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Clip(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clip(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtGraphicUnitClipsXElementTypeDeserializerState::Clip(None);
                        event
                    }
                    (S::Clip(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clip",
                            true,
                        )?;
                        match self.handle_clip(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtGraphicUnitClipsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtGraphicUnitClipsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtGraphicUnitClipsXElementType { clip: self.clip })
        }
    }
    #[derive(Debug)]
    pub struct CtDocInfoKeywordsXElementTypeDeserializer {
        keyword: Vec<String>,
        state: Box<CtDocInfoKeywordsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtDocInfoKeywordsXElementTypeDeserializerState {
        Init__,
        Keyword(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtDocInfoKeywordsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                keyword: Vec::new(),
                state: Box::new(CtDocInfoKeywordsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtDocInfoKeywordsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtDocInfoKeywordsXElementTypeDeserializerState as S;
            match state {
                S::Keyword(Some(deserializer)) => {
                    self.store_keyword(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_keyword(&mut self, value: String) -> Result<(), Error> {
            self.keyword.push(value);
            Ok(())
        }
        fn handle_keyword<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtDocInfoKeywordsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.keyword.len() < 1usize {
                    *self.state = CtDocInfoKeywordsXElementTypeDeserializerState::Keyword(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        CtDocInfoKeywordsXElementTypeDeserializerState::Keyword(None),
                    );
                    *self.state = CtDocInfoKeywordsXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_keyword(data)?;
                    *self.state = CtDocInfoKeywordsXElementTypeDeserializerState::Keyword(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtDocInfoKeywordsXElementTypeDeserializerState::Keyword(Some(
                                    deserializer,
                                )),
                            );
                            if self.keyword.len().saturating_add(1) < 1usize {
                                *self.state =
                                    CtDocInfoKeywordsXElementTypeDeserializerState::Keyword(None);
                            } else {
                                *self.state =
                                    CtDocInfoKeywordsXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtDocInfoKeywordsXElementTypeDeserializerState::Keyword(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtDocInfoKeywordsXElementType>
        for CtDocInfoKeywordsXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDocInfoKeywordsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDocInfoKeywordsXElementType>
        where
            R: DeserializeReader,
        {
            use CtDocInfoKeywordsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Keyword(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_keyword(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtDocInfoKeywordsXElementTypeDeserializerState::Keyword(None);
                        event
                    }
                    (S::Keyword(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Keyword",
                            false,
                        )?;
                        match self.handle_keyword(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtDocInfoKeywordsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtDocInfoKeywordsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtDocInfoKeywordsXElementType {
                keyword: self.keyword,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtDocInfoCustomDatasXElementTypeDeserializer {
        custom_data: Vec<super::CtDocInfoCustomDatasCustomDataXElementType>,
        state: Box<CtDocInfoCustomDatasXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtDocInfoCustomDatasXElementTypeDeserializerState {
        Init__ , CustomData (Option << super :: CtDocInfoCustomDatasCustomDataXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl CtDocInfoCustomDatasXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                custom_data: Vec::new(),
                state: Box::new(CtDocInfoCustomDatasXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtDocInfoCustomDatasXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtDocInfoCustomDatasXElementTypeDeserializerState as S;
            match state {
                S::CustomData(Some(deserializer)) => {
                    self.store_custom_data(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_custom_data(
            &mut self,
            value: super::CtDocInfoCustomDatasCustomDataXElementType,
        ) -> Result<(), Error> {
            self.custom_data.push(value);
            Ok(())
        }
        fn handle_custom_data<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtDocInfoCustomDatasCustomDataXElementType>,
            fallback: &mut Option<CtDocInfoCustomDatasXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.custom_data.len() < 1usize {
                    *self.state =
                        CtDocInfoCustomDatasXElementTypeDeserializerState::CustomData(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        CtDocInfoCustomDatasXElementTypeDeserializerState::CustomData(None),
                    );
                    *self.state = CtDocInfoCustomDatasXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_custom_data(data)?;
                    *self.state =
                        CtDocInfoCustomDatasXElementTypeDeserializerState::CustomData(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtDocInfoCustomDatasXElementTypeDeserializerState::CustomData(
                                    Some(deserializer),
                                ),
                            );
                            if self.custom_data.len().saturating_add(1) < 1usize {
                                *self.state =
                                    CtDocInfoCustomDatasXElementTypeDeserializerState::CustomData(
                                        None,
                                    );
                            } else {
                                *self.state =
                                    CtDocInfoCustomDatasXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtDocInfoCustomDatasXElementTypeDeserializerState::CustomData(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtDocInfoCustomDatasXElementType>
        for CtDocInfoCustomDatasXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasXElementType>
        where
            R: DeserializeReader,
        {
            use CtDocInfoCustomDatasXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CustomData(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_custom_data(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CtDocInfoCustomDatasXElementTypeDeserializerState::CustomData(None);
                        event
                    }
                    (S::CustomData(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CustomData",
                            false,
                        )?;
                        match self.handle_custom_data(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtDocInfoCustomDatasXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtDocInfoCustomDatasXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtDocInfoCustomDatasXElementType {
                custom_data: self.custom_data,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtExtensionPropertyXElementTypeDeserializer {
        name: String,
        type_: Option<String>,
        content: Option<String>,
        state: Box<CtExtensionPropertyXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtExtensionPropertyXElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtExtensionPropertyXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut name: Option<String> = None;
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                name: name
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Name".into())))?,
                type_: type_,
                content: None,
                state: Box::new(CtExtensionPropertyXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtExtensionPropertyXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtExtensionPropertyXElementTypeDeserializerState::Content__(deserializer) = state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::CtExtensionPropertyXElementType>
        where
            R: DeserializeReader,
        {
            use CtExtensionPropertyXElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::CtExtensionPropertyXElementType>
        for CtExtensionPropertyXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtExtensionPropertyXElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtExtensionPropertyXElementType>
        where
            R: DeserializeReader,
        {
            use CtExtensionPropertyXElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtExtensionPropertyXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtExtensionPropertyXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtExtensionPropertyXElementType {
                name: self.name,
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtGouraudShdPointXElementTypeDeserializer {
        x: f64,
        y: f64,
        edge_flag: Option<super::CtGouraudShdPointEdgeFlagXType>,
        color: Option<super::CtColorXType>,
        state: Box<CtGouraudShdPointXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtGouraudShdPointXElementTypeDeserializerState {
        Init__,
        Color(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtGouraudShdPointXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut x: Option<f64> = None;
            let mut y: Option<f64> = None;
            let mut edge_flag: Option<super::CtGouraudShdPointEdgeFlagXType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"X")
                ) {
                    reader.read_attrib(&mut x, b"X", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"y")
                ) {
                    reader.read_attrib(&mut y, b"y", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"EdgeFlag")
                ) {
                    reader.read_attrib(&mut edge_flag, b"EdgeFlag", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                x: x.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("X".into())))?,
                y: y.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("y".into())))?,
                edge_flag: edge_flag,
                color: None,
                state: Box::new(CtGouraudShdPointXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtGouraudShdPointXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtGouraudShdPointXElementTypeDeserializerState as S;
            match state {
                S::Color(Some(deserializer)) => self.store_color(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Color",
                )))?;
            }
            self.color = Some(value);
            Ok(())
        }
        fn handle_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtGouraudShdPointXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.color.is_some() {
                    fallback
                        .get_or_insert(CtGouraudShdPointXElementTypeDeserializerState::Color(None));
                    *self.state = CtGouraudShdPointXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtGouraudShdPointXElementTypeDeserializerState::Color(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_color(data)?;
                    *self.state = CtGouraudShdPointXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtGouraudShdPointXElementTypeDeserializerState::Color(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CtGouraudShdPointXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtGouraudShdPointXElementTypeDeserializerState::Color(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtGouraudShdPointXElementType>
        for CtGouraudShdPointXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGouraudShdPointXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtGouraudShdPointXElementType>
        where
            R: DeserializeReader,
        {
            use CtGouraudShdPointXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Color(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtGouraudShdPointXElementTypeDeserializerState::Color(None);
                        event
                    }
                    (S::Color(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Color",
                            true,
                        )?;
                        match self.handle_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtGouraudShdPointXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtGouraudShdPointXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtGouraudShdPointXElementType {
                x: self.x,
                y: self.y,
                edge_flag: self.edge_flag,
                color: self
                    .color
                    .ok_or_else(|| ErrorKind::MissingElement("Color".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtImageBorderXElementTypeDeserializer {
        line_width: f64,
        horizonal_corner_radius: f64,
        vertical_corner_radius: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        border_color: Option<super::CtColorXType>,
        state: Box<CtImageBorderXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtImageBorderXElementTypeDeserializerState {
        Init__,
        BorderColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtImageBorderXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut line_width: Option<f64> = None;
            let mut horizonal_corner_radius: Option<f64> = None;
            let mut vertical_corner_radius: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"HorizonalCornerRadius")
                ) {
                    reader.read_attrib(
                        &mut horizonal_corner_radius,
                        b"HorizonalCornerRadius",
                        &attrib.value,
                    )?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"VerticalCornerRadius")
                ) {
                    reader.read_attrib(
                        &mut vertical_corner_radius,
                        b"VerticalCornerRadius",
                        &attrib.value,
                    )?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                line_width: line_width
                    .unwrap_or_else(super::CtImageBorderXElementType::default_line_width),
                horizonal_corner_radius: horizonal_corner_radius.unwrap_or_else(
                    super::CtImageBorderXElementType::default_horizonal_corner_radius,
                ),
                vertical_corner_radius: vertical_corner_radius.unwrap_or_else(
                    super::CtImageBorderXElementType::default_vertical_corner_radius,
                ),
                dash_offset: dash_offset
                    .unwrap_or_else(super::CtImageBorderXElementType::default_dash_offset),
                dash_pattern: dash_pattern,
                border_color: None,
                state: Box::new(CtImageBorderXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtImageBorderXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtImageBorderXElementTypeDeserializerState as S;
            match state {
                S::BorderColor(Some(deserializer)) => {
                    self.store_border_color(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_border_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.border_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BorderColor",
                )))?;
            }
            self.border_color = Some(value);
            Ok(())
        }
        fn handle_border_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtImageBorderXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtImageBorderXElementTypeDeserializerState::BorderColor(
                    None,
                ));
                *self.state = CtImageBorderXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_border_color(data)?;
                    *self.state = CtImageBorderXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtImageBorderXElementTypeDeserializerState::BorderColor(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CtImageBorderXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtImageBorderXElementTypeDeserializerState::BorderColor(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtImageBorderXElementType>
        for CtImageBorderXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtImageBorderXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtImageBorderXElementType>
        where
            R: DeserializeReader,
        {
            use CtImageBorderXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BorderColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_border_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtImageBorderXElementTypeDeserializerState::BorderColor(None);
                        event
                    }
                    (S::BorderColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"BorderColor",
                            true,
                        )?;
                        match self.handle_border_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtImageBorderXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtImageBorderXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtImageBorderXElementType {
                line_width: self.line_width,
                horizonal_corner_radius: self.horizonal_corner_radius,
                vertical_corner_radius: self.vertical_corner_radius,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                border_color: self.border_color,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtLaGouraudShdPointXElementTypeDeserializer {
        x: Option<f64>,
        y: Option<f64>,
        color: Option<super::CtColorXType>,
        state: Box<CtLaGouraudShdPointXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtLaGouraudShdPointXElementTypeDeserializerState {
        Init__,
        Color(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtLaGouraudShdPointXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut x: Option<f64> = None;
            let mut y: Option<f64> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"X")
                ) {
                    reader.read_attrib(&mut x, b"X", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"y")
                ) {
                    reader.read_attrib(&mut y, b"y", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                x: x,
                y: y,
                color: None,
                state: Box::new(CtLaGouraudShdPointXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtLaGouraudShdPointXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtLaGouraudShdPointXElementTypeDeserializerState as S;
            match state {
                S::Color(Some(deserializer)) => self.store_color(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Color",
                )))?;
            }
            self.color = Some(value);
            Ok(())
        }
        fn handle_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtLaGouraudShdPointXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.color.is_some() {
                    fallback.get_or_insert(
                        CtLaGouraudShdPointXElementTypeDeserializerState::Color(None),
                    );
                    *self.state = CtLaGouraudShdPointXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CtLaGouraudShdPointXElementTypeDeserializerState::Color(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_color(data)?;
                    *self.state = CtLaGouraudShdPointXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtLaGouraudShdPointXElementTypeDeserializerState::Color(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CtLaGouraudShdPointXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtLaGouraudShdPointXElementTypeDeserializerState::Color(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtLaGouraudShdPointXElementType>
        for CtLaGouraudShdPointXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtLaGouraudShdPointXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtLaGouraudShdPointXElementType>
        where
            R: DeserializeReader,
        {
            use CtLaGouraudShdPointXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Color(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CtLaGouraudShdPointXElementTypeDeserializerState::Color(None);
                        event
                    }
                    (S::Color(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Color",
                            true,
                        )?;
                        match self.handle_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtLaGouraudShdPointXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtLaGouraudShdPointXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtLaGouraudShdPointXElementType {
                x: self.x,
                y: self.y,
                color: self
                    .color
                    .ok_or_else(|| ErrorKind::MissingElement("Color".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockTextObjectXElementTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        font: u32,
        size: f64,
        stroke: bool,
        fill: bool,
        h_scale: f64,
        read_direction: i32,
        char_direction: i32,
        weight: super::CtTextWeightXType,
        italic: bool,
        id: u32,
        content: Vec<super::CtPageBlockTextObjectXElementTypeContent>,
        state: Box<CtPageBlockTextObjectXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPageBlockTextObjectXElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(
            <super::CtPageBlockTextObjectXElementTypeContent as WithDeserializer>::Deserializer,
        ),
        Unknown__,
    }
    impl CtPageBlockTextObjectXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            let mut font: Option<u32> = None;
            let mut size: Option<f64> = None;
            let mut stroke: Option<bool> = None;
            let mut fill: Option<bool> = None;
            let mut h_scale: Option<f64> = None;
            let mut read_direction: Option<i32> = None;
            let mut char_direction: Option<i32> = None;
            let mut weight: Option<super::CtTextWeightXType> = None;
            let mut italic: Option<bool> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Font")
                ) {
                    reader.read_attrib(&mut font, b"Font", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Size")
                ) {
                    reader.read_attrib(&mut size, b"Size", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Stroke")
                ) {
                    reader.read_attrib(&mut stroke, b"Stroke", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Fill")
                ) {
                    reader.read_attrib(&mut fill, b"Fill", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"HScale")
                ) {
                    reader.read_attrib(&mut h_scale, b"HScale", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ReadDirection")
                ) {
                    reader.read_attrib(&mut read_direction, b"ReadDirection", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CharDirection")
                ) {
                    reader.read_attrib(&mut char_direction, b"CharDirection", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Weight")
                ) {
                    reader.read_attrib(&mut weight, b"Weight", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Italic")
                ) {
                    reader.read_attrib(&mut italic, b"Italic", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_line_width),
                cap: cap.unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_cap),
                join: join.unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_join),
                miter_limit: miter_limit
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_miter_limit),
                dash_offset: dash_offset
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_dash_offset),
                dash_pattern: dash_pattern,
                alpha: alpha
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_alpha),
                font: font
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Font".into())))?,
                size: size
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Size".into())))?,
                stroke: stroke
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_stroke),
                fill: fill.unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_fill),
                h_scale: h_scale
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_h_scale),
                read_direction: read_direction.unwrap_or_else(
                    super::CtPageBlockTextObjectXElementType::default_read_direction,
                ),
                char_direction: char_direction.unwrap_or_else(
                    super::CtPageBlockTextObjectXElementType::default_char_direction,
                ),
                weight: weight
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_weight),
                italic: italic
                    .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_italic),
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                content: Vec::new(),
                state: Box::new(CtPageBlockTextObjectXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPageBlockTextObjectXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtPageBlockTextObjectXElementTypeDeserializerState::Content__(deserializer) =
                state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::CtPageBlockTextObjectXElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementTypeContent>,
            fallback: &mut Option<CtPageBlockTextObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtPageBlockTextObjectXElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtPageBlockTextObjectXElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockTextObjectXElementTypeDeserializerState::Content__(
                                    deserializer,
                                );
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockTextObjectXElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state =
                                CtPageBlockTextObjectXElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockTextObjectXElementType>
        for CtPageBlockTextObjectXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockTextObjectXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockTextObjectXElementType>
        where
            R: DeserializeReader,
        {
            use CtPageBlockTextObjectXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: CtPageBlockTextObjectXElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::CtPageBlockTextObjectXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPageBlockTextObjectXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPageBlockTextObjectXElementType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                font: self.font,
                size: self.size,
                stroke: self.stroke,
                fill: self.fill,
                h_scale: self.h_scale,
                read_direction: self.read_direction,
                char_direction: self.char_direction,
                weight: self.weight,
                italic: self.italic,
                id: self.id,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockTextObjectXElementTypeContentDeserializer {
        state: Box<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtPageBlockTextObjectXElementTypeContentDeserializerState {
        Init__,
        Actions(
            Option<super::CtGraphicUnitActionsXElementType>,
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(
            Option<super::CtGraphicUnitClipsXElementType>,
            Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
        ),
        FillColor(
            Option<super::CtColorXType>,
            Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
        ),
        StrokeColor(
            Option<super::CtColorXType>,
            Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
        ),
        CgTransform(
            Option<super::CtCgTransformXType>,
            Option<<super::CtCgTransformXType as WithDeserializer>::Deserializer>,
        ),
        TextCode(
            Option<super::CtTextTextCodeXElementType>,
            Option<<super::CtTextTextCodeXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtPageBlockTextObjectXElementTypeContent),
        Unknown__,
    }
    impl CtPageBlockTextObjectXElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Actions")
                ) {
                    let output = < super :: CtGraphicUnitActionsXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_actions(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Clips")
                ) {
                    let output = < super :: CtGraphicUnitClipsXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_clips(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"FillColor")
                ) {
                    let output = <super::CtColorXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_fill_color(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"StrokeColor")
                ) {
                    let output = <super::CtColorXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_stroke_color(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CGTransform")
                ) {
                    let output =
                        <super::CtCgTransformXType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                    return self.handle_cg_transform(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TextCode")
                ) {
                    let output = < super :: CtTextTextCodeXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_text_code(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtPageBlockTextObjectXElementTypeContentDeserializerState,
        ) -> Result<super::CtPageBlockTextObjectXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Actions(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_actions(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockTextObjectXElementTypeContent::Actions(
                        values.ok_or_else(|| ErrorKind::MissingElement("Actions".into()))?,
                    ))
                }
                S::Clips(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_clips(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockTextObjectXElementTypeContent::Clips(
                        values.ok_or_else(|| ErrorKind::MissingElement("Clips".into()))?,
                    ))
                }
                S::FillColor(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_fill_color(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockTextObjectXElementTypeContent::FillColor(
                        values.ok_or_else(|| ErrorKind::MissingElement("FillColor".into()))?,
                    ))
                }
                S::StrokeColor(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_stroke_color(&mut values, value)?;
                    }
                    Ok(
                        super::CtPageBlockTextObjectXElementTypeContent::StrokeColor(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("StrokeColor".into()))?,
                        ),
                    )
                }
                S::CgTransform(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_cg_transform(&mut values, value)?;
                    }
                    Ok(
                        super::CtPageBlockTextObjectXElementTypeContent::CgTransform(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("CGTransform".into()))?,
                        ),
                    )
                }
                S::TextCode(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text_code(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockTextObjectXElementTypeContent::TextCode(
                        values.ok_or_else(|| ErrorKind::MissingElement("TextCode".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_actions(
            values: &mut Option<super::CtGraphicUnitActionsXElementType>,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_clips(
            values: &mut Option<super::CtGraphicUnitClipsXElementType>,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_fill_color(
            values: &mut Option<super::CtColorXType>,
            value: super::CtColorXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FillColor",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_stroke_color(
            values: &mut Option<super::CtColorXType>,
            value: super::CtColorXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"StrokeColor",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_cg_transform(
            values: &mut Option<super::CtCgTransformXType>,
            value: super::CtCgTransformXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CGTransform",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_text_code(
            values: &mut Option<super::CtTextTextCodeXElementType>,
            value: super::CtTextTextCodeXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TextCode",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtGraphicUnitActionsXElementType>,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockTextObjectXElementTypeContentDeserializerState::Actions(
                        values, None,
                    ),
                    Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::Actions(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockTextObjectXElementTypeContentDeserializerState::Actions(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::Actions(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_actions(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_actions(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Actions(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Actions(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtGraphicUnitClipsXElementType>,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockTextObjectXElementTypeContentDeserializerState::Clips(
                        values, None,
                    ),
                    Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::Clips(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockTextObjectXElementTypeContentDeserializerState::Clips(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::Clips(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_clips(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_clips(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Clips(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtPageBlockTextObjectXElementTypeContentDeserializerState::Clips(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_fill_color<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtColorXType>,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockTextObjectXElementTypeContentDeserializerState::FillColor(
                        values, None,
                    ),
                    Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::FillColor(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockTextObjectXElementTypeContentDeserializerState::FillColor(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::FillColor(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_fill_color(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_fill_color(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::FillColor(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::FillColor(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_stroke_color<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtColorXType>,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockTextObjectXElementTypeContentDeserializerState::StrokeColor(
                        values, None,
                    ),
                    Some(
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::StrokeColor(
                            _,
                            Some(deserializer),
                        ),
                    ) => CtPageBlockTextObjectXElementTypeContentDeserializerState::StrokeColor(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::StrokeColor(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_stroke_color(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_stroke_color(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::StrokeColor(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::StrokeColor(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_cg_transform<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtCgTransformXType>,
            output: DeserializerOutput<'de, super::CtCgTransformXType>,
            fallback: &mut Option<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockTextObjectXElementTypeContentDeserializerState::CgTransform(
                        values, None,
                    ),
                    Some(
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::CgTransform(
                            _,
                            Some(deserializer),
                        ),
                    ) => CtPageBlockTextObjectXElementTypeContentDeserializerState::CgTransform(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::CgTransform(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_cg_transform(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_cg_transform(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::CgTransform(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::CgTransform(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_text_code<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtTextTextCodeXElementType>,
            output: DeserializerOutput<'de, super::CtTextTextCodeXElementType>,
            fallback: &mut Option<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockTextObjectXElementTypeContentDeserializerState::TextCode(
                        values, None,
                    ),
                    Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::TextCode(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockTextObjectXElementTypeContentDeserializerState::TextCode(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockTextObjectXElementTypeContentDeserializerState::TextCode(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text_code(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text_code(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::TextCode(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::TextCode(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockTextObjectXElementTypeContent>
        for CtPageBlockTextObjectXElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockTextObjectXElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockTextObjectXElementTypeContent>
        where
            R: DeserializeReader,
        {
            use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Clips(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::FillColor(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fill_color(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::StrokeColor(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_stroke_color(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CgTransform(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_cg_transform(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TextCode(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text_code(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Actions(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Clips(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::FillColor(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FillColor",
                            true,
                        )?;
                        match self.handle_fill_color(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::StrokeColor(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"StrokeColor",
                            true,
                        )?;
                        match self.handle_stroke_color(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CgTransform(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CGTransform",
                            false,
                        )?;
                        match self.handle_cg_transform(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TextCode(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TextCode",
                            false,
                        )?;
                        match self.handle_text_code(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            self,
            reader: &R,
        ) -> Result<super::CtPageBlockTextObjectXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockPathObjectXElementTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        stroke: bool,
        fill: bool,
        rule: super::CtPathRuleXType,
        id: u32,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        clips: Option<super::CtGraphicUnitClipsXElementType>,
        stroke_color: Option<super::CtColorXType>,
        fill_color: Option<super::CtColorXType>,
        abbreviated_data: Option<String>,
        state: Box<CtPageBlockPathObjectXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPageBlockPathObjectXElementTypeDeserializerState {
        Init__,
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>),
        StrokeColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        FillColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        AbbreviatedData(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtPageBlockPathObjectXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            let mut stroke: Option<bool> = None;
            let mut fill: Option<bool> = None;
            let mut rule: Option<super::CtPathRuleXType> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Stroke")
                ) {
                    reader.read_attrib(&mut stroke, b"Stroke", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Fill")
                ) {
                    reader.read_attrib(&mut fill, b"Fill", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Rule")
                ) {
                    reader.read_attrib(&mut rule, b"Rule", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible
                    .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width
                    .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_line_width),
                cap: cap.unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_cap),
                join: join.unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_join),
                miter_limit: miter_limit
                    .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_miter_limit),
                dash_offset: dash_offset
                    .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_dash_offset),
                dash_pattern: dash_pattern,
                alpha: alpha
                    .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_alpha),
                stroke: stroke
                    .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_stroke),
                fill: fill.unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_fill),
                rule: rule.unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_rule),
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                actions: None,
                clips: None,
                stroke_color: None,
                fill_color: None,
                abbreviated_data: None,
                state: Box::new(CtPageBlockPathObjectXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPageBlockPathObjectXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtPageBlockPathObjectXElementTypeDeserializerState as S;
            match state {
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::Clips(Some(deserializer)) => self.store_clips(deserializer.finish(reader)?)?,
                S::StrokeColor(Some(deserializer)) => {
                    self.store_stroke_color(deserializer.finish(reader)?)?
                }
                S::FillColor(Some(deserializer)) => {
                    self.store_fill_color(deserializer.finish(reader)?)?
                }
                S::AbbreviatedData(Some(deserializer)) => {
                    self.store_abbreviated_data(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_clips(
            &mut self,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if self.clips.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            self.clips = Some(value);
            Ok(())
        }
        fn store_stroke_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.stroke_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"StrokeColor",
                )))?;
            }
            self.stroke_color = Some(value);
            Ok(())
        }
        fn store_fill_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.fill_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FillColor",
                )))?;
            }
            self.fill_color = Some(value);
            Ok(())
        }
        fn store_abbreviated_data(&mut self, value: String) -> Result<(), Error> {
            if self.abbreviated_data.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"AbbreviatedData",
                )))?;
            }
            self.abbreviated_data = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CtPageBlockPathObjectXElementTypeDeserializerState::Actions(None),
                );
                *self.state = CtPageBlockPathObjectXElementTypeDeserializerState::Clips(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = CtPageBlockPathObjectXElementTypeDeserializerState::Clips(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockPathObjectXElementTypeDeserializerState::Actions(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::Clips(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::Actions(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPageBlockPathObjectXElementTypeDeserializerState::Clips(
                    None,
                ));
                *self.state = CtPageBlockPathObjectXElementTypeDeserializerState::StrokeColor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_clips(data)?;
                    *self.state =
                        CtPageBlockPathObjectXElementTypeDeserializerState::StrokeColor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockPathObjectXElementTypeDeserializerState::Clips(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::StrokeColor(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CtPageBlockPathObjectXElementTypeDeserializerState::Clips(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_stroke_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CtPageBlockPathObjectXElementTypeDeserializerState::StrokeColor(None),
                );
                *self.state = CtPageBlockPathObjectXElementTypeDeserializerState::FillColor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_stroke_color(data)?;
                    *self.state =
                        CtPageBlockPathObjectXElementTypeDeserializerState::FillColor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockPathObjectXElementTypeDeserializerState::StrokeColor(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::FillColor(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::StrokeColor(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_fill_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CtPageBlockPathObjectXElementTypeDeserializerState::FillColor(None),
                );
                *self.state =
                    CtPageBlockPathObjectXElementTypeDeserializerState::AbbreviatedData(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fill_color(data)?;
                    *self.state =
                        CtPageBlockPathObjectXElementTypeDeserializerState::AbbreviatedData(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockPathObjectXElementTypeDeserializerState::FillColor(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::AbbreviatedData(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::FillColor(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_abbreviated_data<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.abbreviated_data.is_some() {
                    fallback.get_or_insert(
                        CtPageBlockPathObjectXElementTypeDeserializerState::AbbreviatedData(None),
                    );
                    *self.state = CtPageBlockPathObjectXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        CtPageBlockPathObjectXElementTypeDeserializerState::AbbreviatedData(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_abbreviated_data(data)?;
                    *self.state = CtPageBlockPathObjectXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockPathObjectXElementTypeDeserializerState::AbbreviatedData(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockPathObjectXElementTypeDeserializerState::AbbreviatedData(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockPathObjectXElementType>
        for CtPageBlockPathObjectXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockPathObjectXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockPathObjectXElementType>
        where
            R: DeserializeReader,
        {
            use CtPageBlockPathObjectXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StrokeColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_stroke_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FillColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fill_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AbbreviatedData(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_abbreviated_data(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CtPageBlockPathObjectXElementTypeDeserializerState::Actions(None);
                        event
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StrokeColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"StrokeColor",
                            true,
                        )?;
                        match self.handle_stroke_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FillColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FillColor",
                            true,
                        )?;
                        match self.handle_fill_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::AbbreviatedData(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"AbbreviatedData",
                            false,
                        )?;
                        match self.handle_abbreviated_data(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::CtPageBlockPathObjectXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPageBlockPathObjectXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPageBlockPathObjectXElementType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                stroke: self.stroke,
                fill: self.fill,
                rule: self.rule,
                id: self.id,
                actions: self.actions,
                clips: self.clips,
                stroke_color: self.stroke_color,
                fill_color: self.fill_color,
                abbreviated_data: self
                    .abbreviated_data
                    .ok_or_else(|| ErrorKind::MissingElement("AbbreviatedData".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockImageObjectXElementTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        resource_id: u32,
        substitution: Option<u32>,
        image_mask: Option<u32>,
        id: u32,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        clips: Option<super::CtGraphicUnitClipsXElementType>,
        border: Option<super::CtImageBorderXElementType>,
        state: Box<CtPageBlockImageObjectXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPageBlockImageObjectXElementTypeDeserializerState {
        Init__,
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>),
        Border(Option<<super::CtImageBorderXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtPageBlockImageObjectXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            let mut resource_id: Option<u32> = None;
            let mut substitution: Option<u32> = None;
            let mut image_mask: Option<u32> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ResourceID")
                ) {
                    reader.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Substitution")
                ) {
                    reader.read_attrib(&mut substitution, b"Substitution", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ImageMask")
                ) {
                    reader.read_attrib(&mut image_mask, b"ImageMask", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible
                    .unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width
                    .unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_line_width),
                cap: cap.unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_cap),
                join: join.unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_join),
                miter_limit: miter_limit
                    .unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_miter_limit),
                dash_offset: dash_offset
                    .unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_dash_offset),
                dash_pattern: dash_pattern,
                alpha: alpha
                    .unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_alpha),
                resource_id: resource_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("ResourceID".into()))
                })?,
                substitution: substitution,
                image_mask: image_mask,
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                actions: None,
                clips: None,
                border: None,
                state: Box::new(CtPageBlockImageObjectXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPageBlockImageObjectXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtPageBlockImageObjectXElementTypeDeserializerState as S;
            match state {
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::Clips(Some(deserializer)) => self.store_clips(deserializer.finish(reader)?)?,
                S::Border(Some(deserializer)) => self.store_border(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_clips(
            &mut self,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if self.clips.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            self.clips = Some(value);
            Ok(())
        }
        fn store_border(&mut self, value: super::CtImageBorderXElementType) -> Result<(), Error> {
            if self.border.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Border",
                )))?;
            }
            self.border = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtPageBlockImageObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CtPageBlockImageObjectXElementTypeDeserializerState::Actions(None),
                );
                *self.state = CtPageBlockImageObjectXElementTypeDeserializerState::Clips(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state = CtPageBlockImageObjectXElementTypeDeserializerState::Clips(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockImageObjectXElementTypeDeserializerState::Actions(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CtPageBlockImageObjectXElementTypeDeserializerState::Clips(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockImageObjectXElementTypeDeserializerState::Actions(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtPageBlockImageObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CtPageBlockImageObjectXElementTypeDeserializerState::Clips(
                    None,
                ));
                *self.state = CtPageBlockImageObjectXElementTypeDeserializerState::Border(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_clips(data)?;
                    *self.state = CtPageBlockImageObjectXElementTypeDeserializerState::Border(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockImageObjectXElementTypeDeserializerState::Clips(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CtPageBlockImageObjectXElementTypeDeserializerState::Border(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockImageObjectXElementTypeDeserializerState::Clips(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_border<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtImageBorderXElementType>,
            fallback: &mut Option<CtPageBlockImageObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CtPageBlockImageObjectXElementTypeDeserializerState::Border(None),
                );
                *self.state = CtPageBlockImageObjectXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_border(data)?;
                    *self.state = CtPageBlockImageObjectXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockImageObjectXElementTypeDeserializerState::Border(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CtPageBlockImageObjectXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockImageObjectXElementTypeDeserializerState::Border(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockImageObjectXElementType>
        for CtPageBlockImageObjectXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockImageObjectXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockImageObjectXElementType>
        where
            R: DeserializeReader,
        {
            use CtPageBlockImageObjectXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Border(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_border(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CtPageBlockImageObjectXElementTypeDeserializerState::Actions(None);
                        event
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Border(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Border",
                            true,
                        )?;
                        match self.handle_border(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::CtPageBlockImageObjectXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPageBlockImageObjectXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPageBlockImageObjectXElementType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                resource_id: self.resource_id,
                substitution: self.substitution,
                image_mask: self.image_mask,
                id: self.id,
                actions: self.actions,
                clips: self.clips,
                border: self.border,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockCompositeObjectXElementTypeDeserializer {
        boundary: String,
        name: Option<String>,
        visible: bool,
        ctm: Option<String>,
        draw_param: Option<u32>,
        line_width: f64,
        cap: super::CtGraphicUnitCapXType,
        join: super::CtGraphicUnitJoinXType,
        miter_limit: f64,
        dash_offset: f64,
        dash_pattern: Option<String>,
        alpha: i32,
        resource_id: u32,
        id: u32,
        actions: Option<super::CtGraphicUnitActionsXElementType>,
        clips: Option<super::CtGraphicUnitClipsXElementType>,
        state: Box<CtPageBlockCompositeObjectXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPageBlockCompositeObjectXElementTypeDeserializerState {
        Init__,
        Actions(
            Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
        ),
        Clips(Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CtPageBlockCompositeObjectXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            let mut name: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut ctm: Option<String> = None;
            let mut draw_param: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut cap: Option<super::CtGraphicUnitCapXType> = None;
            let mut join: Option<super::CtGraphicUnitJoinXType> = None;
            let mut miter_limit: Option<f64> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut alpha: Option<i32> = None;
            let mut resource_id: Option<u32> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CTM")
                ) {
                    reader.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Alpha")
                ) {
                    reader.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ResourceID")
                ) {
                    reader.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                name: name,
                visible: visible
                    .unwrap_or_else(super::CtPageBlockCompositeObjectXElementType::default_visible),
                ctm: ctm,
                draw_param: draw_param,
                line_width: line_width.unwrap_or_else(
                    super::CtPageBlockCompositeObjectXElementType::default_line_width,
                ),
                cap: cap.unwrap_or_else(super::CtPageBlockCompositeObjectXElementType::default_cap),
                join: join
                    .unwrap_or_else(super::CtPageBlockCompositeObjectXElementType::default_join),
                miter_limit: miter_limit.unwrap_or_else(
                    super::CtPageBlockCompositeObjectXElementType::default_miter_limit,
                ),
                dash_offset: dash_offset.unwrap_or_else(
                    super::CtPageBlockCompositeObjectXElementType::default_dash_offset,
                ),
                dash_pattern: dash_pattern,
                alpha: alpha
                    .unwrap_or_else(super::CtPageBlockCompositeObjectXElementType::default_alpha),
                resource_id: resource_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("ResourceID".into()))
                })?,
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                actions: None,
                clips: None,
                state: Box::new(CtPageBlockCompositeObjectXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPageBlockCompositeObjectXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CtPageBlockCompositeObjectXElementTypeDeserializerState as S;
            match state {
                S::Actions(Some(deserializer)) => {
                    self.store_actions(deserializer.finish(reader)?)?
                }
                S::Clips(Some(deserializer)) => self.store_clips(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_actions(
            &mut self,
            value: super::CtGraphicUnitActionsXElementType,
        ) -> Result<(), Error> {
            if self.actions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Actions",
                )))?;
            }
            self.actions = Some(value);
            Ok(())
        }
        fn store_clips(
            &mut self,
            value: super::CtGraphicUnitClipsXElementType,
        ) -> Result<(), Error> {
            if self.clips.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Clips",
                )))?;
            }
            self.clips = Some(value);
            Ok(())
        }
        fn handle_actions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            fallback: &mut Option<CtPageBlockCompositeObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CtPageBlockCompositeObjectXElementTypeDeserializerState::Actions(None),
                );
                *self.state = CtPageBlockCompositeObjectXElementTypeDeserializerState::Clips(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_actions(data)?;
                    *self.state =
                        CtPageBlockCompositeObjectXElementTypeDeserializerState::Clips(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockCompositeObjectXElementTypeDeserializerState::Actions(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                CtPageBlockCompositeObjectXElementTypeDeserializerState::Clips(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockCompositeObjectXElementTypeDeserializerState::Actions(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_clips<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            fallback: &mut Option<CtPageBlockCompositeObjectXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CtPageBlockCompositeObjectXElementTypeDeserializerState::Clips(None),
                );
                *self.state = CtPageBlockCompositeObjectXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_clips(data)?;
                    *self.state = CtPageBlockCompositeObjectXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockCompositeObjectXElementTypeDeserializerState::Clips(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                CtPageBlockCompositeObjectXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockCompositeObjectXElementTypeDeserializerState::Clips(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockCompositeObjectXElementType>
        for CtPageBlockCompositeObjectXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockCompositeObjectXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockCompositeObjectXElementType>
        where
            R: DeserializeReader,
        {
            use CtPageBlockCompositeObjectXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Actions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CtPageBlockCompositeObjectXElementTypeDeserializerState::Actions(None);
                        event
                    }
                    (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Actions",
                            true,
                        )?;
                        match self.handle_actions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Clips",
                            true,
                        )?;
                        match self.handle_clips(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::CtPageBlockCompositeObjectXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPageBlockCompositeObjectXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPageBlockCompositeObjectXElementType {
                boundary: self.boundary,
                name: self.name,
                visible: self.visible,
                ctm: self.ctm,
                draw_param: self.draw_param,
                line_width: self.line_width,
                cap: self.cap,
                join: self.join,
                miter_limit: self.miter_limit,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                alpha: self.alpha,
                resource_id: self.resource_id,
                id: self.id,
                actions: self.actions,
                clips: self.clips,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockPageBlockXElementTypeDeserializer {
        id: u32,
        content: Vec<super::CtPageBlockPageBlockXElementTypeContent>,
        state: Box<CtPageBlockPageBlockXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPageBlockPageBlockXElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(
            <super::CtPageBlockPageBlockXElementTypeContent as WithDeserializer>::Deserializer,
        ),
        Unknown__,
    }
    impl CtPageBlockPageBlockXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                content: Vec::new(),
                state: Box::new(CtPageBlockPageBlockXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPageBlockPageBlockXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtPageBlockPageBlockXElementTypeDeserializerState::Content__(deserializer) =
                state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::CtPageBlockPageBlockXElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementTypeContent>,
            fallback: &mut Option<CtPageBlockPageBlockXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtPageBlockPageBlockXElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtPageBlockPageBlockXElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPageBlockPageBlockXElementTypeDeserializerState::Content__(
                                    deserializer,
                                );
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPageBlockPageBlockXElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state = CtPageBlockPageBlockXElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockPageBlockXElementType>
        for CtPageBlockPageBlockXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockPageBlockXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockPageBlockXElementType>
        where
            R: DeserializeReader,
        {
            use CtPageBlockPageBlockXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: CtPageBlockPageBlockXElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtPageBlockPageBlockXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPageBlockPageBlockXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPageBlockPageBlockXElementType {
                id: self.id,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockPageBlockXElementTypeContentDeserializer {
        state: Box<CtPageBlockPageBlockXElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtPageBlockPageBlockXElementTypeContentDeserializerState {
        Init__,
        TextObject(
            Option<super::CtPageBlockTextObjectXElementType>,
            Option<<super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        PathObject(
            Option<super::CtPageBlockPathObjectXElementType>,
            Option<<super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        ImageObject(
            Option<super::CtPageBlockImageObjectXElementType>,
            Option<<super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        CompositeObject(
            Option<super::CtPageBlockCompositeObjectXElementType>,
            Option<
                <super::CtPageBlockCompositeObjectXElementType as WithDeserializer>::Deserializer,
            >,
        ),
        PageBlock(
            Option<super::CtPageBlockPageBlockXElementType>,
            Option<<super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtPageBlockPageBlockXElementTypeContent),
        Unknown__,
    }
    impl CtPageBlockPageBlockXElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtPageBlockPageBlockXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TextObject")
                ) {
                    let output = < super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_text_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PathObject")
                ) {
                    let output = < super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_path_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ImageObject")
                ) {
                    let output = < super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_image_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CompositeObject")
                ) {
                    let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_composite_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PageBlock")
                ) {
                    let output = < super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_page_block(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtPageBlockPageBlockXElementTypeContentDeserializerState,
        ) -> Result<super::CtPageBlockPageBlockXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::TextObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text_object(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockPageBlockXElementTypeContent::TextObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("TextObject".into()))?,
                    ))
                }
                S::PathObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_path_object(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockPageBlockXElementTypeContent::PathObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("PathObject".into()))?,
                    ))
                }
                S::ImageObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_image_object(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockPageBlockXElementTypeContent::ImageObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("ImageObject".into()))?,
                    ))
                }
                S::CompositeObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_composite_object(&mut values, value)?;
                    }
                    Ok(
                        super::CtPageBlockPageBlockXElementTypeContent::CompositeObject(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("CompositeObject".into())
                            })?,
                        ),
                    )
                }
                S::PageBlock(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_page_block(&mut values, value)?;
                    }
                    Ok(super::CtPageBlockPageBlockXElementTypeContent::PageBlock(
                        values.ok_or_else(|| ErrorKind::MissingElement("PageBlock".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_text_object(
            values: &mut Option<super::CtPageBlockTextObjectXElementType>,
            value: super::CtPageBlockTextObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TextObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_path_object(
            values: &mut Option<super::CtPageBlockPathObjectXElementType>,
            value: super::CtPageBlockPathObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PathObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_image_object(
            values: &mut Option<super::CtPageBlockImageObjectXElementType>,
            value: super::CtPageBlockImageObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ImageObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_composite_object(
            values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
            value: super::CtPageBlockCompositeObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompositeObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_page_block(
            values: &mut Option<super::CtPageBlockPageBlockXElementType>,
            value: super::CtPageBlockPageBlockXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageBlock",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_text_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockTextObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            fallback: &mut Option<CtPageBlockPageBlockXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockPageBlockXElementTypeContentDeserializerState::TextObject(
                        values, None,
                    ),
                    Some(CtPageBlockPageBlockXElementTypeContentDeserializerState::TextObject(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockPageBlockXElementTypeContentDeserializerState::TextObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockPageBlockXElementTypeContentDeserializerState::TextObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::TextObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::TextObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_path_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPathObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            fallback: &mut Option<CtPageBlockPageBlockXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockPageBlockXElementTypeContentDeserializerState::PathObject(
                        values, None,
                    ),
                    Some(CtPageBlockPageBlockXElementTypeContentDeserializerState::PathObject(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockPageBlockXElementTypeContentDeserializerState::PathObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockPageBlockXElementTypeContentDeserializerState::PathObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_path_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_path_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::PathObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::PathObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_image_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockImageObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            fallback: &mut Option<CtPageBlockPageBlockXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockPageBlockXElementTypeContentDeserializerState::ImageObject(
                        values, None,
                    ),
                    Some(
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::ImageObject(
                            _,
                            Some(deserializer),
                        ),
                    ) => CtPageBlockPageBlockXElementTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockPageBlockXElementTypeContentDeserializerState::ImageObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_image_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_image_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::ImageObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::ImageObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_composite_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            fallback: &mut Option<CtPageBlockPageBlockXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => {
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::CompositeObject(
                            values, None,
                        )
                    }
                    Some(
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::CompositeObject(
                            _,
                            Some(deserializer),
                        ),
                    ) => CtPageBlockPageBlockXElementTypeContentDeserializerState::CompositeObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    CtPageBlockPageBlockXElementTypeContentDeserializerState::CompositeObject(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_composite_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::CompositeObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::CompositeObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_page_block<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPageBlockXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            fallback: &mut Option<CtPageBlockPageBlockXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPageBlockPageBlockXElementTypeContentDeserializerState::PageBlock(
                        values, None,
                    ),
                    Some(CtPageBlockPageBlockXElementTypeContentDeserializerState::PageBlock(
                        _,
                        Some(deserializer),
                    )) => CtPageBlockPageBlockXElementTypeContentDeserializerState::PageBlock(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPageBlockPageBlockXElementTypeContentDeserializerState::PageBlock(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_page_block(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_page_block(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::PageBlock(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::PageBlock(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPageBlockPageBlockXElementTypeContent>
        for CtPageBlockPageBlockXElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockPageBlockXElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPageBlockPageBlockXElementTypeContent>
        where
            R: DeserializeReader,
        {
            use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TextObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::TextObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TextObject",
                            true,
                        )?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PathObject",
                            true,
                        )?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ImageObject",
                            true,
                        )?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CompositeObject",
                            true,
                        )?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageBlock",
                            true,
                        )?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            self,
            reader: &R,
        ) -> Result<super::CtPageBlockPageBlockXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtPatternCellContentXElementTypeDeserializer {
        thumbnail: Option<u32>,
        content: Vec<super::CtPatternCellContentXElementTypeContent>,
        state: Box<CtPatternCellContentXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPatternCellContentXElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(
            <super::CtPatternCellContentXElementTypeContent as WithDeserializer>::Deserializer,
        ),
        Unknown__,
    }
    impl CtPatternCellContentXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut thumbnail: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Thumbnail")
                ) {
                    reader.read_attrib(&mut thumbnail, b"Thumbnail", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                thumbnail: thumbnail,
                content: Vec::new(),
                state: Box::new(CtPatternCellContentXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPatternCellContentXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtPatternCellContentXElementTypeDeserializerState::Content__(deserializer) =
                state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::CtPatternCellContentXElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPatternCellContentXElementTypeContent>,
            fallback: &mut Option<CtPatternCellContentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtPatternCellContentXElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtPatternCellContentXElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtPatternCellContentXElementTypeDeserializerState::Content__(
                                    deserializer,
                                );
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtPatternCellContentXElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state = CtPatternCellContentXElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPatternCellContentXElementType>
        for CtPatternCellContentXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPatternCellContentXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPatternCellContentXElementType>
        where
            R: DeserializeReader,
        {
            use CtPatternCellContentXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: CtPatternCellContentXElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtPatternCellContentXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPatternCellContentXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPatternCellContentXElementType {
                thumbnail: self.thumbnail,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPatternCellContentXElementTypeContentDeserializer {
        state: Box<CtPatternCellContentXElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtPatternCellContentXElementTypeContentDeserializerState {
        Init__,
        TextObject(
            Option<super::CtPageBlockTextObjectXElementType>,
            Option<<super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        PathObject(
            Option<super::CtPageBlockPathObjectXElementType>,
            Option<<super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        ImageObject(
            Option<super::CtPageBlockImageObjectXElementType>,
            Option<<super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        CompositeObject(
            Option<super::CtPageBlockCompositeObjectXElementType>,
            Option<
                <super::CtPageBlockCompositeObjectXElementType as WithDeserializer>::Deserializer,
            >,
        ),
        PageBlock(
            Option<super::CtPageBlockPageBlockXElementType>,
            Option<<super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtPatternCellContentXElementTypeContent),
        Unknown__,
    }
    impl CtPatternCellContentXElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtPatternCellContentXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TextObject")
                ) {
                    let output = < super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_text_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PathObject")
                ) {
                    let output = < super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_path_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ImageObject")
                ) {
                    let output = < super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_image_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CompositeObject")
                ) {
                    let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_composite_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PageBlock")
                ) {
                    let output = < super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_page_block(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtPatternCellContentXElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtPatternCellContentXElementTypeContentDeserializerState,
        ) -> Result<super::CtPatternCellContentXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtPatternCellContentXElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::TextObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text_object(&mut values, value)?;
                    }
                    Ok(super::CtPatternCellContentXElementTypeContent::TextObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("TextObject".into()))?,
                    ))
                }
                S::PathObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_path_object(&mut values, value)?;
                    }
                    Ok(super::CtPatternCellContentXElementTypeContent::PathObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("PathObject".into()))?,
                    ))
                }
                S::ImageObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_image_object(&mut values, value)?;
                    }
                    Ok(super::CtPatternCellContentXElementTypeContent::ImageObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("ImageObject".into()))?,
                    ))
                }
                S::CompositeObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_composite_object(&mut values, value)?;
                    }
                    Ok(
                        super::CtPatternCellContentXElementTypeContent::CompositeObject(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("CompositeObject".into())
                            })?,
                        ),
                    )
                }
                S::PageBlock(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_page_block(&mut values, value)?;
                    }
                    Ok(super::CtPatternCellContentXElementTypeContent::PageBlock(
                        values.ok_or_else(|| ErrorKind::MissingElement("PageBlock".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_text_object(
            values: &mut Option<super::CtPageBlockTextObjectXElementType>,
            value: super::CtPageBlockTextObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TextObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_path_object(
            values: &mut Option<super::CtPageBlockPathObjectXElementType>,
            value: super::CtPageBlockPathObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PathObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_image_object(
            values: &mut Option<super::CtPageBlockImageObjectXElementType>,
            value: super::CtPageBlockImageObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ImageObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_composite_object(
            values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
            value: super::CtPageBlockCompositeObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompositeObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_page_block(
            values: &mut Option<super::CtPageBlockPageBlockXElementType>,
            value: super::CtPageBlockPageBlockXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageBlock",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_text_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockTextObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            fallback: &mut Option<CtPatternCellContentXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPatternCellContentXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPatternCellContentXElementTypeContentDeserializerState::TextObject(
                        values, None,
                    ),
                    Some(CtPatternCellContentXElementTypeContentDeserializerState::TextObject(
                        _,
                        Some(deserializer),
                    )) => CtPatternCellContentXElementTypeContentDeserializerState::TextObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPatternCellContentXElementTypeContentDeserializerState::TextObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPatternCellContentXElementTypeContentDeserializerState::TextObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::TextObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_path_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPathObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            fallback: &mut Option<CtPatternCellContentXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPatternCellContentXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPatternCellContentXElementTypeContentDeserializerState::PathObject(
                        values, None,
                    ),
                    Some(CtPatternCellContentXElementTypeContentDeserializerState::PathObject(
                        _,
                        Some(deserializer),
                    )) => CtPatternCellContentXElementTypeContentDeserializerState::PathObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPatternCellContentXElementTypeContentDeserializerState::PathObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_path_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_path_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPatternCellContentXElementTypeContentDeserializerState::PathObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::PathObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_image_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockImageObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            fallback: &mut Option<CtPatternCellContentXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPatternCellContentXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPatternCellContentXElementTypeContentDeserializerState::ImageObject(
                        values, None,
                    ),
                    Some(
                        CtPatternCellContentXElementTypeContentDeserializerState::ImageObject(
                            _,
                            Some(deserializer),
                        ),
                    ) => CtPatternCellContentXElementTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPatternCellContentXElementTypeContentDeserializerState::ImageObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_image_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_image_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPatternCellContentXElementTypeContentDeserializerState::ImageObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::ImageObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_composite_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            fallback: &mut Option<CtPatternCellContentXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPatternCellContentXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => {
                        CtPatternCellContentXElementTypeContentDeserializerState::CompositeObject(
                            values, None,
                        )
                    }
                    Some(
                        CtPatternCellContentXElementTypeContentDeserializerState::CompositeObject(
                            _,
                            Some(deserializer),
                        ),
                    ) => CtPatternCellContentXElementTypeContentDeserializerState::CompositeObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    CtPatternCellContentXElementTypeContentDeserializerState::CompositeObject(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_composite_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPatternCellContentXElementTypeContentDeserializerState::CompositeObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::CompositeObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_page_block<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPageBlockXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            fallback: &mut Option<CtPatternCellContentXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            CtPatternCellContentXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtPatternCellContentXElementTypeContentDeserializerState::PageBlock(
                        values, None,
                    ),
                    Some(CtPatternCellContentXElementTypeContentDeserializerState::PageBlock(
                        _,
                        Some(deserializer),
                    )) => CtPatternCellContentXElementTypeContentDeserializerState::PageBlock(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtPatternCellContentXElementTypeContentDeserializerState::PageBlock(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_page_block(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_page_block(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtPatternCellContentXElementTypeContentDeserializerState::PageBlock(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        CtPatternCellContentXElementTypeContentDeserializerState::PageBlock(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtPatternCellContentXElementTypeContent>
        for CtPatternCellContentXElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPatternCellContentXElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtPatternCellContentXElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        CtPatternCellContentXElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPatternCellContentXElementTypeContent>
        where
            R: DeserializeReader,
        {
            use CtPatternCellContentXElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TextObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::TextObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TextObject",
                            true,
                        )?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PathObject",
                            true,
                        )?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ImageObject",
                            true,
                        )?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CompositeObject",
                            true,
                        )?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageBlock",
                            true,
                        )?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            self,
            reader: &R,
        ) -> Result<super::CtPatternCellContentXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtPermissionPrintXElementTypeDeserializer {
        printable: bool,
        copies: i32,
        state: Box<CtPermissionPrintXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPermissionPrintXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtPermissionPrintXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut printable: Option<bool> = None;
            let mut copies: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Printable")
                ) {
                    reader.read_attrib(&mut printable, b"Printable", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Copies")
                ) {
                    reader.read_attrib(&mut copies, b"Copies", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                printable: printable.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Printable".into()))
                })?,
                copies: copies.unwrap_or_else(super::CtPermissionPrintXElementType::default_copies),
                state: Box::new(CtPermissionPrintXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPermissionPrintXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtPermissionPrintXElementType>
        for CtPermissionPrintXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPermissionPrintXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPermissionPrintXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtPermissionPrintXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPermissionPrintXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPermissionPrintXElementType {
                printable: self.printable,
                copies: self.copies,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtPermissionValidPeriodXElementTypeDeserializer {
        start_date: Option<String>,
        end_date: Option<String>,
        state: Box<CtPermissionValidPeriodXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtPermissionValidPeriodXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtPermissionValidPeriodXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut start_date: Option<String> = None;
            let mut end_date: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"StartDate")
                ) {
                    reader.read_attrib(&mut start_date, b"StartDate", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"EndDate")
                ) {
                    reader.read_attrib(&mut end_date, b"EndDate", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                start_date: start_date,
                end_date: end_date,
                state: Box::new(CtPermissionValidPeriodXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtPermissionValidPeriodXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtPermissionValidPeriodXElementType>
        for CtPermissionValidPeriodXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPermissionValidPeriodXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtPermissionValidPeriodXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::CtPermissionValidPeriodXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtPermissionValidPeriodXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtPermissionValidPeriodXElementType {
                start_date: self.start_date,
                end_date: self.end_date,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaXElementTypeDeserializer {
        start: String,
        content: Vec<super::CtRegionAreaXElementTypeContent>,
        state: Box<CtRegionAreaXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtRegionAreaXElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::CtRegionAreaXElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtRegionAreaXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut start: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Start")
                ) {
                    reader.read_attrib(&mut start, b"Start", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                start: start
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Start".into())))?,
                content: Vec::new(),
                state: Box::new(CtRegionAreaXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtRegionAreaXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtRegionAreaXElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::CtRegionAreaXElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtRegionAreaXElementTypeContent>,
            fallback: &mut Option<CtRegionAreaXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(CtRegionAreaXElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = CtRegionAreaXElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CtRegionAreaXElementTypeDeserializerState::Content__(deserializer);
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CtRegionAreaXElementTypeDeserializerState::Content__(deserializer),
                            );
                            *self.state = CtRegionAreaXElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtRegionAreaXElementType>
        for CtRegionAreaXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaXElementType>
        where
            R: DeserializeReader,
        {
            use CtRegionAreaXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: CtRegionAreaXElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtRegionAreaXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtRegionAreaXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtRegionAreaXElementType {
                start: self.start,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaXElementTypeContentDeserializer {
        state: Box<CtRegionAreaXElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum CtRegionAreaXElementTypeContentDeserializerState {
        Init__,
        Move(
            Option<super::CtRegionAreaLineXElementType>,
            Option<<super::CtRegionAreaLineXElementType as WithDeserializer>::Deserializer>,
        ),
        Line(
            Option<super::CtRegionAreaLineXElementType>,
            Option<<super::CtRegionAreaLineXElementType as WithDeserializer>::Deserializer>,
        ),
        OuadraticBezier(
            Option<super::CtRegionAreaOuadraticBezierXElementType>,
            Option<
                <super::CtRegionAreaOuadraticBezierXElementType as WithDeserializer>::Deserializer,
            >,
        ),
        CubicBezier(
            Option<super::CtRegionAreaCubicBezierXElementType>,
            Option<<super::CtRegionAreaCubicBezierXElementType as WithDeserializer>::Deserializer>,
        ),
        Arc(
            Option<super::CtRegionAreaArcXElementType>,
            Option<<super::CtRegionAreaArcXElementType as WithDeserializer>::Deserializer>,
        ),
        Close(
            Option<super::xs::AnyTypeXType>,
            Option<<super::xs::AnyTypeXType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::CtRegionAreaXElementTypeContent),
        Unknown__,
    }
    impl CtRegionAreaXElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<CtRegionAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Move")
                ) {
                    let output = < super :: CtRegionAreaLineXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_move_(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Line")
                ) {
                    let output = < super :: CtRegionAreaLineXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_line(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"OuadraticBezier")
                ) {
                    let output = < super :: CtRegionAreaOuadraticBezierXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_ouadratic_bezier(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CubicBezier")
                ) {
                    let output = < super :: CtRegionAreaCubicBezierXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_cubic_bezier(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Arc")
                ) {
                    let output = < super :: CtRegionAreaArcXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_arc(reader, Default::default(), output, &mut *fallback);
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"Close")
                ) {
                    let output = <super::xs::AnyTypeXType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                    return self.handle_close(reader, Default::default(), output, &mut *fallback);
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(CtRegionAreaXElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: CtRegionAreaXElementTypeContentDeserializerState,
        ) -> Result<super::CtRegionAreaXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use CtRegionAreaXElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Move(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_move_(&mut values, value)?;
                    }
                    Ok(super::CtRegionAreaXElementTypeContent::Move(
                        values.ok_or_else(|| ErrorKind::MissingElement("Move".into()))?,
                    ))
                }
                S::Line(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_line(&mut values, value)?;
                    }
                    Ok(super::CtRegionAreaXElementTypeContent::Line(
                        values.ok_or_else(|| ErrorKind::MissingElement("Line".into()))?,
                    ))
                }
                S::OuadraticBezier(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_ouadratic_bezier(&mut values, value)?;
                    }
                    Ok(super::CtRegionAreaXElementTypeContent::OuadraticBezier(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("OuadraticBezier".into()))?,
                    ))
                }
                S::CubicBezier(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_cubic_bezier(&mut values, value)?;
                    }
                    Ok(super::CtRegionAreaXElementTypeContent::CubicBezier(
                        values.ok_or_else(|| ErrorKind::MissingElement("CubicBezier".into()))?,
                    ))
                }
                S::Arc(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_arc(&mut values, value)?;
                    }
                    Ok(super::CtRegionAreaXElementTypeContent::Arc(
                        values.ok_or_else(|| ErrorKind::MissingElement("Arc".into()))?,
                    ))
                }
                S::Close(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_close(&mut values, value)?;
                    }
                    Ok(super::CtRegionAreaXElementTypeContent::Close(
                        values.ok_or_else(|| ErrorKind::MissingElement("Close".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_move_(
            values: &mut Option<super::CtRegionAreaLineXElementType>,
            value: super::CtRegionAreaLineXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Move")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_line(
            values: &mut Option<super::CtRegionAreaLineXElementType>,
            value: super::CtRegionAreaLineXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Line")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_ouadratic_bezier(
            values: &mut Option<super::CtRegionAreaOuadraticBezierXElementType>,
            value: super::CtRegionAreaOuadraticBezierXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"OuadraticBezier",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_cubic_bezier(
            values: &mut Option<super::CtRegionAreaCubicBezierXElementType>,
            value: super::CtRegionAreaCubicBezierXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CubicBezier",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_arc(
            values: &mut Option<super::CtRegionAreaArcXElementType>,
            value: super::CtRegionAreaArcXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Arc")))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_close(
            values: &mut Option<super::xs::AnyTypeXType>,
            value: super::xs::AnyTypeXType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Close",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_move_<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtRegionAreaLineXElementType>,
            output: DeserializerOutput<'de, super::CtRegionAreaLineXElementType>,
            fallback: &mut Option<CtRegionAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtRegionAreaXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtRegionAreaXElementTypeContentDeserializerState::Move(values, None),
                    Some(CtRegionAreaXElementTypeContentDeserializerState::Move(
                        _,
                        Some(deserializer),
                    )) => CtRegionAreaXElementTypeContentDeserializerState::Move(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtRegionAreaXElementTypeContentDeserializerState::Move(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_move_(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_move_(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtRegionAreaXElementTypeContentDeserializerState::Move(values, None),
                    )?;
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Move(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_line<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtRegionAreaLineXElementType>,
            output: DeserializerOutput<'de, super::CtRegionAreaLineXElementType>,
            fallback: &mut Option<CtRegionAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtRegionAreaXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtRegionAreaXElementTypeContentDeserializerState::Line(values, None),
                    Some(CtRegionAreaXElementTypeContentDeserializerState::Line(
                        _,
                        Some(deserializer),
                    )) => CtRegionAreaXElementTypeContentDeserializerState::Line(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtRegionAreaXElementTypeContentDeserializerState::Line(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_line(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_line(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtRegionAreaXElementTypeContentDeserializerState::Line(values, None),
                    )?;
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Line(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_ouadratic_bezier<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtRegionAreaOuadraticBezierXElementType>,
            output: DeserializerOutput<'de, super::CtRegionAreaOuadraticBezierXElementType>,
            fallback: &mut Option<CtRegionAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtRegionAreaXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtRegionAreaXElementTypeContentDeserializerState::OuadraticBezier(
                        values, None,
                    ),
                    Some(CtRegionAreaXElementTypeContentDeserializerState::OuadraticBezier(
                        _,
                        Some(deserializer),
                    )) => CtRegionAreaXElementTypeContentDeserializerState::OuadraticBezier(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtRegionAreaXElementTypeContentDeserializerState::OuadraticBezier(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_ouadratic_bezier(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_ouadratic_bezier(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtRegionAreaXElementTypeContentDeserializerState::OuadraticBezier(
                            values, None,
                        ),
                    )?;
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::OuadraticBezier(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_cubic_bezier<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtRegionAreaCubicBezierXElementType>,
            output: DeserializerOutput<'de, super::CtRegionAreaCubicBezierXElementType>,
            fallback: &mut Option<CtRegionAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtRegionAreaXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => {
                        CtRegionAreaXElementTypeContentDeserializerState::CubicBezier(values, None)
                    }
                    Some(CtRegionAreaXElementTypeContentDeserializerState::CubicBezier(
                        _,
                        Some(deserializer),
                    )) => CtRegionAreaXElementTypeContentDeserializerState::CubicBezier(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtRegionAreaXElementTypeContentDeserializerState::CubicBezier(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_cubic_bezier(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_cubic_bezier(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtRegionAreaXElementTypeContentDeserializerState::CubicBezier(values, None),
                    )?;
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::CubicBezier(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_arc<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtRegionAreaArcXElementType>,
            output: DeserializerOutput<'de, super::CtRegionAreaArcXElementType>,
            fallback: &mut Option<CtRegionAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtRegionAreaXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtRegionAreaXElementTypeContentDeserializerState::Arc(values, None),
                    Some(CtRegionAreaXElementTypeContentDeserializerState::Arc(
                        _,
                        Some(deserializer),
                    )) => CtRegionAreaXElementTypeContentDeserializerState::Arc(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtRegionAreaXElementTypeContentDeserializerState::Arc(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_arc(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_arc(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtRegionAreaXElementTypeContentDeserializerState::Arc(values, None),
                    )?;
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Arc(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_close<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::xs::AnyTypeXType>,
            output: DeserializerOutput<'de, super::xs::AnyTypeXType>,
            fallback: &mut Option<CtRegionAreaXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = CtRegionAreaXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => CtRegionAreaXElementTypeContentDeserializerState::Close(values, None),
                    Some(CtRegionAreaXElementTypeContentDeserializerState::Close(
                        _,
                        Some(deserializer),
                    )) => CtRegionAreaXElementTypeContentDeserializerState::Close(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(CtRegionAreaXElementTypeContentDeserializerState::Close(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_close(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_close(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        CtRegionAreaXElementTypeContentDeserializerState::Close(values, None),
                    )?;
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = CtRegionAreaXElementTypeContentDeserializerState::Close(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CtRegionAreaXElementTypeContent>
        for CtRegionAreaXElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaXElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(CtRegionAreaXElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        CtRegionAreaXElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaXElementTypeContent>
        where
            R: DeserializeReader,
        {
            use CtRegionAreaXElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Move(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_move_(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Line(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_line(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::OuadraticBezier(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_ouadratic_bezier(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CubicBezier(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_cubic_bezier(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Arc(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_arc(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Close(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_close(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Move(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Move",
                            false,
                        )?;
                        match self.handle_move_(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Line(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Line",
                            false,
                        )?;
                        match self.handle_line(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::OuadraticBezier(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"OuadraticBezier",
                            false,
                        )?;
                        match self.handle_ouadratic_bezier(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CubicBezier(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CubicBezier",
                            false,
                        )?;
                        match self.handle_cubic_bezier(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Arc(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Arc",
                            false,
                        )?;
                        match self.handle_arc(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Close(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Close",
                            true,
                        )?;
                        match self.handle_close(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::CtRegionAreaXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct CtTextTextCodeXElementTypeDeserializer {
        x: Option<f64>,
        y: Option<f64>,
        delta_x: Option<String>,
        deltay: Option<String>,
        content: Option<String>,
        state: Box<CtTextTextCodeXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtTextTextCodeXElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtTextTextCodeXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut x: Option<f64> = None;
            let mut y: Option<f64> = None;
            let mut delta_x: Option<String> = None;
            let mut deltay: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"X")
                ) {
                    reader.read_attrib(&mut x, b"X", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"y")
                ) {
                    reader.read_attrib(&mut y, b"y", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DeltaX")
                ) {
                    reader.read_attrib(&mut delta_x, b"DeltaX", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Deltay")
                ) {
                    reader.read_attrib(&mut deltay, b"Deltay", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                x: x,
                y: y,
                delta_x: delta_x,
                deltay: deltay,
                content: None,
                state: Box::new(CtTextTextCodeXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtTextTextCodeXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtTextTextCodeXElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::CtTextTextCodeXElementType>
        where
            R: DeserializeReader,
        {
            use CtTextTextCodeXElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::CtTextTextCodeXElementType>
        for CtTextTextCodeXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtTextTextCodeXElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtTextTextCodeXElementType>
        where
            R: DeserializeReader,
        {
            use CtTextTextCodeXElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtTextTextCodeXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtTextTextCodeXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtTextTextCodeXElementType {
                x: self.x,
                y: self.y,
                delta_x: self.delta_x,
                deltay: self.deltay,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CustomTagsCustomTagXElementTypeDeserializer {
        name_space: String,
        schema_loc: Option<String>,
        file_loc: Option<String>,
        state: Box<CustomTagsCustomTagXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CustomTagsCustomTagXElementTypeDeserializerState {
        Init__,
        SchemaLoc(Option<<String as WithDeserializer>::Deserializer>),
        FileLoc(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CustomTagsCustomTagXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut name_space: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"NameSpace")
                ) {
                    reader.read_attrib(&mut name_space, b"NameSpace", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                name_space: name_space.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("NameSpace".into()))
                })?,
                schema_loc: None,
                file_loc: None,
                state: Box::new(CustomTagsCustomTagXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CustomTagsCustomTagXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CustomTagsCustomTagXElementTypeDeserializerState as S;
            match state {
                S::SchemaLoc(Some(deserializer)) => {
                    self.store_schema_loc(deserializer.finish(reader)?)?
                }
                S::FileLoc(Some(deserializer)) => {
                    self.store_file_loc(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_schema_loc(&mut self, value: String) -> Result<(), Error> {
            if self.schema_loc.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SchemaLoc",
                )))?;
            }
            self.schema_loc = Some(value);
            Ok(())
        }
        fn store_file_loc(&mut self, value: String) -> Result<(), Error> {
            if self.file_loc.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FileLoc",
                )))?;
            }
            self.file_loc = Some(value);
            Ok(())
        }
        fn handle_schema_loc<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CustomTagsCustomTagXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    CustomTagsCustomTagXElementTypeDeserializerState::SchemaLoc(None),
                );
                *self.state = CustomTagsCustomTagXElementTypeDeserializerState::FileLoc(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_schema_loc(data)?;
                    *self.state = CustomTagsCustomTagXElementTypeDeserializerState::FileLoc(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CustomTagsCustomTagXElementTypeDeserializerState::SchemaLoc(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CustomTagsCustomTagXElementTypeDeserializerState::FileLoc(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CustomTagsCustomTagXElementTypeDeserializerState::SchemaLoc(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_file_loc<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CustomTagsCustomTagXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.file_loc.is_some() {
                    fallback.get_or_insert(
                        CustomTagsCustomTagXElementTypeDeserializerState::FileLoc(None),
                    );
                    *self.state = CustomTagsCustomTagXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CustomTagsCustomTagXElementTypeDeserializerState::FileLoc(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_file_loc(data)?;
                    *self.state = CustomTagsCustomTagXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CustomTagsCustomTagXElementTypeDeserializerState::FileLoc(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CustomTagsCustomTagXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CustomTagsCustomTagXElementTypeDeserializerState::FileLoc(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CustomTagsCustomTagXElementType>
        for CustomTagsCustomTagXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CustomTagsCustomTagXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CustomTagsCustomTagXElementType>
        where
            R: DeserializeReader,
        {
            use CustomTagsCustomTagXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SchemaLoc(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_schema_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FileLoc(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_file_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CustomTagsCustomTagXElementTypeDeserializerState::SchemaLoc(None);
                        event
                    }
                    (S::SchemaLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"SchemaLoc",
                            false,
                        )?;
                        match self.handle_schema_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FileLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FileLoc",
                            false,
                        )?;
                        match self.handle_file_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CustomTagsCustomTagXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CustomTagsCustomTagXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CustomTagsCustomTagXElementType {
                name_space: self.name_space,
                schema_loc: self.schema_loc,
                file_loc: self
                    .file_loc
                    .ok_or_else(|| ErrorKind::MissingElement("FileLoc".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocVersionFileListXElementTypeDeserializer {
        file: Vec<super::DocVersionFileListFileXElementType>,
        state: Box<DocVersionFileListXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocVersionFileListXElementTypeDeserializerState {
        Init__,
        File(Option<<super::DocVersionFileListFileXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DocVersionFileListXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                file: Vec::new(),
                state: Box::new(DocVersionFileListXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocVersionFileListXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocVersionFileListXElementTypeDeserializerState as S;
            match state {
                S::File(Some(deserializer)) => self.store_file(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_file(
            &mut self,
            value: super::DocVersionFileListFileXElementType,
        ) -> Result<(), Error> {
            self.file.push(value);
            Ok(())
        }
        fn handle_file<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocVersionFileListFileXElementType>,
            fallback: &mut Option<DocVersionFileListXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.file.len() < 1usize {
                    *self.state = DocVersionFileListXElementTypeDeserializerState::File(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(DocVersionFileListXElementTypeDeserializerState::File(None));
                    *self.state = DocVersionFileListXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_file(data)?;
                    *self.state = DocVersionFileListXElementTypeDeserializerState::File(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocVersionFileListXElementTypeDeserializerState::File(Some(
                                    deserializer,
                                )),
                            );
                            if self.file.len().saturating_add(1) < 1usize {
                                *self.state =
                                    DocVersionFileListXElementTypeDeserializerState::File(None);
                            } else {
                                *self.state =
                                    DocVersionFileListXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocVersionFileListXElementTypeDeserializerState::File(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocVersionFileListXElementType>
        for DocVersionFileListXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocVersionFileListXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocVersionFileListXElementType>
        where
            R: DeserializeReader,
        {
            use DocVersionFileListXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::File(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = DocVersionFileListXElementTypeDeserializerState::File(None);
                        event
                    }
                    (S::File(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"File",
                            false,
                        )?;
                        match self.handle_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocVersionFileListXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocVersionFileListXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocVersionFileListXElementType { file: self.file })
        }
    }
    #[derive(Debug)]
    pub struct DocumentCommonDataXElementTypeDeserializer {
        max_unit_id: Option<u32>,
        page_area: Option<super::CtPageAreaXType>,
        public_res: Vec<String>,
        document_res: Vec<String>,
        template_page: Vec<super::DocumentCommonDataTemplatePageXElementType>,
        default_cs: Option<u32>,
        state: Box<DocumentCommonDataXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentCommonDataXElementTypeDeserializerState {
        Init__ , MaxUnitId (Option << u32 as WithDeserializer > :: Deserializer >) , PageArea (Option << super :: CtPageAreaXType as WithDeserializer > :: Deserializer >) , PublicRes (Option << String as WithDeserializer > :: Deserializer >) , DocumentRes (Option << String as WithDeserializer > :: Deserializer >) , TemplatePage (Option << super :: DocumentCommonDataTemplatePageXElementType as WithDeserializer > :: Deserializer >) , DefaultCs (Option << u32 as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl DocumentCommonDataXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                max_unit_id: None,
                page_area: None,
                public_res: Vec::new(),
                document_res: Vec::new(),
                template_page: Vec::new(),
                default_cs: None,
                state: Box::new(DocumentCommonDataXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentCommonDataXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocumentCommonDataXElementTypeDeserializerState as S;
            match state {
                S::MaxUnitId(Some(deserializer)) => {
                    self.store_max_unit_id(deserializer.finish(reader)?)?
                }
                S::PageArea(Some(deserializer)) => {
                    self.store_page_area(deserializer.finish(reader)?)?
                }
                S::PublicRes(Some(deserializer)) => {
                    self.store_public_res(deserializer.finish(reader)?)?
                }
                S::DocumentRes(Some(deserializer)) => {
                    self.store_document_res(deserializer.finish(reader)?)?
                }
                S::TemplatePage(Some(deserializer)) => {
                    self.store_template_page(deserializer.finish(reader)?)?
                }
                S::DefaultCs(Some(deserializer)) => {
                    self.store_default_cs(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_max_unit_id(&mut self, value: u32) -> Result<(), Error> {
            if self.max_unit_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MaxUnitID",
                )))?;
            }
            self.max_unit_id = Some(value);
            Ok(())
        }
        fn store_page_area(&mut self, value: super::CtPageAreaXType) -> Result<(), Error> {
            if self.page_area.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageArea",
                )))?;
            }
            self.page_area = Some(value);
            Ok(())
        }
        fn store_public_res(&mut self, value: String) -> Result<(), Error> {
            self.public_res.push(value);
            Ok(())
        }
        fn store_document_res(&mut self, value: String) -> Result<(), Error> {
            self.document_res.push(value);
            Ok(())
        }
        fn store_template_page(
            &mut self,
            value: super::DocumentCommonDataTemplatePageXElementType,
        ) -> Result<(), Error> {
            self.template_page.push(value);
            Ok(())
        }
        fn store_default_cs(&mut self, value: u32) -> Result<(), Error> {
            if self.default_cs.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DefaultCs",
                )))?;
            }
            self.default_cs = Some(value);
            Ok(())
        }
        fn handle_max_unit_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, u32>,
            fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.max_unit_id.is_some() {
                    fallback.get_or_insert(
                        DocumentCommonDataXElementTypeDeserializerState::MaxUnitId(None),
                    );
                    *self.state = DocumentCommonDataXElementTypeDeserializerState::PageArea(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DocumentCommonDataXElementTypeDeserializerState::MaxUnitId(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_max_unit_id(data)?;
                    *self.state = DocumentCommonDataXElementTypeDeserializerState::PageArea(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentCommonDataXElementTypeDeserializerState::MaxUnitId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::PageArea(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::MaxUnitId(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_page_area<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPageAreaXType>,
            fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.page_area.is_some() {
                    fallback.get_or_insert(
                        DocumentCommonDataXElementTypeDeserializerState::PageArea(None),
                    );
                    *self.state = DocumentCommonDataXElementTypeDeserializerState::PublicRes(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = DocumentCommonDataXElementTypeDeserializerState::PageArea(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_page_area(data)?;
                    *self.state = DocumentCommonDataXElementTypeDeserializerState::PublicRes(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentCommonDataXElementTypeDeserializerState::PageArea(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::PublicRes(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentCommonDataXElementTypeDeserializerState::PageArea(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_public_res<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentCommonDataXElementTypeDeserializerState::PublicRes(
                    None,
                ));
                *self.state = DocumentCommonDataXElementTypeDeserializerState::DocumentRes(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_public_res(data)?;
                    *self.state = DocumentCommonDataXElementTypeDeserializerState::PublicRes(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentCommonDataXElementTypeDeserializerState::PublicRes(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::PublicRes(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::PublicRes(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_document_res<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    DocumentCommonDataXElementTypeDeserializerState::DocumentRes(None),
                );
                *self.state = DocumentCommonDataXElementTypeDeserializerState::TemplatePage(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_document_res(data)?;
                    *self.state =
                        DocumentCommonDataXElementTypeDeserializerState::DocumentRes(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentCommonDataXElementTypeDeserializerState::DocumentRes(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::DocumentRes(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::DocumentRes(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_template_page<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentCommonDataTemplatePageXElementType>,
            fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    DocumentCommonDataXElementTypeDeserializerState::TemplatePage(None),
                );
                *self.state = DocumentCommonDataXElementTypeDeserializerState::DefaultCs(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_template_page(data)?;
                    *self.state =
                        DocumentCommonDataXElementTypeDeserializerState::TemplatePage(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentCommonDataXElementTypeDeserializerState::TemplatePage(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::TemplatePage(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::TemplatePage(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_default_cs<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, u32>,
            fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(DocumentCommonDataXElementTypeDeserializerState::DefaultCs(
                    None,
                ));
                *self.state = DocumentCommonDataXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_default_cs(data)?;
                    *self.state = DocumentCommonDataXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentCommonDataXElementTypeDeserializerState::DefaultCs(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = DocumentCommonDataXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentCommonDataXElementTypeDeserializerState::DefaultCs(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocumentCommonDataXElementType>
        for DocumentCommonDataXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentCommonDataXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentCommonDataXElementType>
        where
            R: DeserializeReader,
        {
            use DocumentCommonDataXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::MaxUnitId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_max_unit_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PageArea(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_area(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PublicRes(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_public_res(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DocumentRes(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_document_res(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TemplatePage(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_template_page(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DefaultCs(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_default_cs(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            DocumentCommonDataXElementTypeDeserializerState::MaxUnitId(None);
                        event
                    }
                    (S::MaxUnitId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"MaxUnitID",
                            false,
                        )?;
                        match self.handle_max_unit_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PageArea(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageArea",
                            false,
                        )?;
                        match self.handle_page_area(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PublicRes(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PublicRes",
                            false,
                        )?;
                        match self.handle_public_res(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DocumentRes(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DocumentRes",
                            false,
                        )?;
                        match self.handle_document_res(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::TemplatePage(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TemplatePage",
                            false,
                        )?;
                        match self.handle_template_page(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DefaultCs(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DefaultCs",
                            false,
                        )?;
                        match self.handle_default_cs(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentCommonDataXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentCommonDataXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentCommonDataXElementType {
                max_unit_id: self
                    .max_unit_id
                    .ok_or_else(|| ErrorKind::MissingElement("MaxUnitID".into()))?,
                page_area: self
                    .page_area
                    .ok_or_else(|| ErrorKind::MissingElement("PageArea".into()))?,
                public_res: self.public_res,
                document_res: self.document_res,
                template_page: self.template_page,
                default_cs: self.default_cs,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocumentPagesXElementTypeDeserializer {
        page: Vec<super::DocumentPagesPageXElementType>,
        state: Box<DocumentPagesXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentPagesXElementTypeDeserializerState {
        Init__,
        Page(Option<<super::DocumentPagesPageXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DocumentPagesXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                page: Vec::new(),
                state: Box::new(DocumentPagesXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentPagesXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocumentPagesXElementTypeDeserializerState as S;
            match state {
                S::Page(Some(deserializer)) => self.store_page(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_page(&mut self, value: super::DocumentPagesPageXElementType) -> Result<(), Error> {
            self.page.push(value);
            Ok(())
        }
        fn handle_page<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DocumentPagesPageXElementType>,
            fallback: &mut Option<DocumentPagesXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.page.len() < 1usize {
                    *self.state = DocumentPagesXElementTypeDeserializerState::Page(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(DocumentPagesXElementTypeDeserializerState::Page(None));
                    *self.state = DocumentPagesXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_page(data)?;
                    *self.state = DocumentPagesXElementTypeDeserializerState::Page(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentPagesXElementTypeDeserializerState::Page(Some(
                                    deserializer,
                                )),
                            );
                            if self.page.len().saturating_add(1) < 1usize {
                                *self.state =
                                    DocumentPagesXElementTypeDeserializerState::Page(None);
                            } else {
                                *self.state = DocumentPagesXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentPagesXElementTypeDeserializerState::Page(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocumentPagesXElementType>
        for DocumentPagesXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentPagesXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentPagesXElementType>
        where
            R: DeserializeReader,
        {
            use DocumentPagesXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Page(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = DocumentPagesXElementTypeDeserializerState::Page(None);
                        event
                    }
                    (S::Page(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Page",
                            false,
                        )?;
                        match self.handle_page(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentPagesXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentPagesXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentPagesXElementType { page: self.page })
        }
    }
    #[derive(Debug)]
    pub struct DocumentOutlinesXElementTypeDeserializer {
        outline_elem: Vec<super::CtOutlineElemXType>,
        state: Box<DocumentOutlinesXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentOutlinesXElementTypeDeserializerState {
        Init__,
        OutlineElem(Option<<super::CtOutlineElemXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DocumentOutlinesXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                outline_elem: Vec::new(),
                state: Box::new(DocumentOutlinesXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentOutlinesXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocumentOutlinesXElementTypeDeserializerState as S;
            match state {
                S::OutlineElem(Some(deserializer)) => {
                    self.store_outline_elem(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_outline_elem(&mut self, value: super::CtOutlineElemXType) -> Result<(), Error> {
            self.outline_elem.push(value);
            Ok(())
        }
        fn handle_outline_elem<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtOutlineElemXType>,
            fallback: &mut Option<DocumentOutlinesXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.outline_elem.len() < 1usize {
                    *self.state = DocumentOutlinesXElementTypeDeserializerState::OutlineElem(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        DocumentOutlinesXElementTypeDeserializerState::OutlineElem(None),
                    );
                    *self.state = DocumentOutlinesXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_outline_elem(data)?;
                    *self.state = DocumentOutlinesXElementTypeDeserializerState::OutlineElem(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentOutlinesXElementTypeDeserializerState::OutlineElem(Some(
                                    deserializer,
                                )),
                            );
                            if self.outline_elem.len().saturating_add(1) < 1usize {
                                *self.state =
                                    DocumentOutlinesXElementTypeDeserializerState::OutlineElem(
                                        None,
                                    );
                            } else {
                                *self.state = DocumentOutlinesXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                DocumentOutlinesXElementTypeDeserializerState::OutlineElem(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocumentOutlinesXElementType>
        for DocumentOutlinesXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentOutlinesXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentOutlinesXElementType>
        where
            R: DeserializeReader,
        {
            use DocumentOutlinesXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::OutlineElem(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_outline_elem(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            DocumentOutlinesXElementTypeDeserializerState::OutlineElem(None);
                        event
                    }
                    (S::OutlineElem(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"OutlineElem",
                            true,
                        )?;
                        match self.handle_outline_elem(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentOutlinesXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentOutlinesXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentOutlinesXElementType {
                outline_elem: self.outline_elem,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocumentBookmarksXElementTypeDeserializer {
        bookmark: Vec<super::CtBookmarkXType>,
        state: Box<DocumentBookmarksXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentBookmarksXElementTypeDeserializerState {
        Init__,
        Bookmark(Option<<super::CtBookmarkXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl DocumentBookmarksXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                bookmark: Vec::new(),
                state: Box::new(DocumentBookmarksXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentBookmarksXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use DocumentBookmarksXElementTypeDeserializerState as S;
            match state {
                S::Bookmark(Some(deserializer)) => {
                    self.store_bookmark(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_bookmark(&mut self, value: super::CtBookmarkXType) -> Result<(), Error> {
            self.bookmark.push(value);
            Ok(())
        }
        fn handle_bookmark<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtBookmarkXType>,
            fallback: &mut Option<DocumentBookmarksXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.bookmark.len() < 1usize {
                    *self.state = DocumentBookmarksXElementTypeDeserializerState::Bookmark(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        DocumentBookmarksXElementTypeDeserializerState::Bookmark(None),
                    );
                    *self.state = DocumentBookmarksXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_bookmark(data)?;
                    *self.state = DocumentBookmarksXElementTypeDeserializerState::Bookmark(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                DocumentBookmarksXElementTypeDeserializerState::Bookmark(Some(
                                    deserializer,
                                )),
                            );
                            if self.bookmark.len().saturating_add(1) < 1usize {
                                *self.state =
                                    DocumentBookmarksXElementTypeDeserializerState::Bookmark(None);
                            } else {
                                *self.state =
                                    DocumentBookmarksXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = DocumentBookmarksXElementTypeDeserializerState::Bookmark(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::DocumentBookmarksXElementType>
        for DocumentBookmarksXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentBookmarksXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentBookmarksXElementType>
        where
            R: DeserializeReader,
        {
            use DocumentBookmarksXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Bookmark(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_bookmark(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            DocumentBookmarksXElementTypeDeserializerState::Bookmark(None);
                        event
                    }
                    (S::Bookmark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Bookmark",
                            false,
                        )?;
                        match self.handle_bookmark(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentBookmarksXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentBookmarksXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentBookmarksXElementType {
                bookmark: self.bookmark,
            })
        }
    }
    #[derive(Debug)]
    pub struct OfdDocBodyXElementTypeDeserializer {
        doc_info: Option<super::CtDocInfoXType>,
        doc_root: Option<String>,
        versions: Option<super::OfdDocBodyVersionsXElementType>,
        signatures: Option<String>,
        state: Box<OfdDocBodyXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum OfdDocBodyXElementTypeDeserializerState {
        Init__,
        DocInfo(Option<<super::CtDocInfoXType as WithDeserializer>::Deserializer>),
        DocRoot(Option<<String as WithDeserializer>::Deserializer>),
        Versions(Option<<super::OfdDocBodyVersionsXElementType as WithDeserializer>::Deserializer>),
        Signatures(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl OfdDocBodyXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                doc_info: None,
                doc_root: None,
                versions: None,
                signatures: None,
                state: Box::new(OfdDocBodyXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: OfdDocBodyXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use OfdDocBodyXElementTypeDeserializerState as S;
            match state {
                S::DocInfo(Some(deserializer)) => {
                    self.store_doc_info(deserializer.finish(reader)?)?
                }
                S::DocRoot(Some(deserializer)) => {
                    self.store_doc_root(deserializer.finish(reader)?)?
                }
                S::Versions(Some(deserializer)) => {
                    self.store_versions(deserializer.finish(reader)?)?
                }
                S::Signatures(Some(deserializer)) => {
                    self.store_signatures(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_doc_info(&mut self, value: super::CtDocInfoXType) -> Result<(), Error> {
            if self.doc_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DocInfo",
                )))?;
            }
            self.doc_info = Some(value);
            Ok(())
        }
        fn store_doc_root(&mut self, value: String) -> Result<(), Error> {
            if self.doc_root.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DocRoot",
                )))?;
            }
            self.doc_root = Some(value);
            Ok(())
        }
        fn store_versions(
            &mut self,
            value: super::OfdDocBodyVersionsXElementType,
        ) -> Result<(), Error> {
            if self.versions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Versions",
                )))?;
            }
            self.versions = Some(value);
            Ok(())
        }
        fn store_signatures(&mut self, value: String) -> Result<(), Error> {
            if self.signatures.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Signatures",
                )))?;
            }
            self.signatures = Some(value);
            Ok(())
        }
        fn handle_doc_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtDocInfoXType>,
            fallback: &mut Option<OfdDocBodyXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.doc_info.is_some() {
                    fallback.get_or_insert(OfdDocBodyXElementTypeDeserializerState::DocInfo(None));
                    *self.state = OfdDocBodyXElementTypeDeserializerState::DocRoot(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = OfdDocBodyXElementTypeDeserializerState::DocInfo(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_doc_info(data)?;
                    *self.state = OfdDocBodyXElementTypeDeserializerState::DocRoot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                OfdDocBodyXElementTypeDeserializerState::DocInfo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = OfdDocBodyXElementTypeDeserializerState::DocRoot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = OfdDocBodyXElementTypeDeserializerState::DocInfo(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_doc_root<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<OfdDocBodyXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.doc_root.is_some() {
                    fallback.get_or_insert(OfdDocBodyXElementTypeDeserializerState::DocRoot(None));
                    *self.state = OfdDocBodyXElementTypeDeserializerState::Versions(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = OfdDocBodyXElementTypeDeserializerState::DocRoot(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_doc_root(data)?;
                    *self.state = OfdDocBodyXElementTypeDeserializerState::Versions(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                OfdDocBodyXElementTypeDeserializerState::DocRoot(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = OfdDocBodyXElementTypeDeserializerState::Versions(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = OfdDocBodyXElementTypeDeserializerState::DocRoot(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_versions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::OfdDocBodyVersionsXElementType>,
            fallback: &mut Option<OfdDocBodyXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(OfdDocBodyXElementTypeDeserializerState::Versions(None));
                *self.state = OfdDocBodyXElementTypeDeserializerState::Signatures(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_versions(data)?;
                    *self.state = OfdDocBodyXElementTypeDeserializerState::Signatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                OfdDocBodyXElementTypeDeserializerState::Versions(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = OfdDocBodyXElementTypeDeserializerState::Signatures(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = OfdDocBodyXElementTypeDeserializerState::Versions(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_signatures<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<OfdDocBodyXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(OfdDocBodyXElementTypeDeserializerState::Signatures(None));
                *self.state = OfdDocBodyXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_signatures(data)?;
                    *self.state = OfdDocBodyXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                OfdDocBodyXElementTypeDeserializerState::Signatures(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = OfdDocBodyXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = OfdDocBodyXElementTypeDeserializerState::Signatures(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::OfdDocBodyXElementType> for OfdDocBodyXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::OfdDocBodyXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::OfdDocBodyXElementType>
        where
            R: DeserializeReader,
        {
            use OfdDocBodyXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DocInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_doc_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DocRoot(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_doc_root(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Versions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_versions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Signatures(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_signatures(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = OfdDocBodyXElementTypeDeserializerState::DocInfo(None);
                        event
                    }
                    (S::DocInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DocInfo",
                            false,
                        )?;
                        match self.handle_doc_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DocRoot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DocRoot",
                            false,
                        )?;
                        match self.handle_doc_root(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Versions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Versions",
                            false,
                        )?;
                        match self.handle_versions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Signatures(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Signatures",
                            false,
                        )?;
                        match self.handle_signatures(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::OfdDocBodyXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                OfdDocBodyXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::OfdDocBodyXElementType {
                doc_info: self
                    .doc_info
                    .ok_or_else(|| ErrorKind::MissingElement("DocInfo".into()))?,
                doc_root: self
                    .doc_root
                    .ok_or_else(|| ErrorKind::MissingElement("DocRoot".into()))?,
                versions: self.versions,
                signatures: self.signatures,
            })
        }
    }
    #[derive(Debug)]
    pub struct PageTemplateXElementTypeDeserializer {
        template_id: u32,
        z_order: super::PageTemplateZOrderXType,
        state: Box<PageTemplateXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PageTemplateXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl PageTemplateXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut template_id: Option<u32> = None;
            let mut z_order: Option<super::PageTemplateZOrderXType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"TemplateID")
                ) {
                    reader.read_attrib(&mut template_id, b"TemplateID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ZOrder")
                ) {
                    reader.read_attrib(&mut z_order, b"ZOrder", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                template_id: template_id.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("TemplateID".into()))
                })?,
                z_order: z_order.unwrap_or_else(super::PageTemplateXElementType::default_z_order),
                state: Box::new(PageTemplateXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PageTemplateXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::PageTemplateXElementType>
        for PageTemplateXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageTemplateXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageTemplateXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PageTemplateXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PageTemplateXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PageTemplateXElementType {
                template_id: self.template_id,
                z_order: self.z_order,
            })
        }
    }
    #[derive(Debug)]
    pub struct PageContentXElementTypeDeserializer {
        layer: Vec<super::PageContentLayerXElementType>,
        state: Box<PageContentXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PageContentXElementTypeDeserializerState {
        Init__,
        Layer(Option<<super::PageContentLayerXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl PageContentXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                layer: Vec::new(),
                state: Box::new(PageContentXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PageContentXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use PageContentXElementTypeDeserializerState as S;
            match state {
                S::Layer(Some(deserializer)) => self.store_layer(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_layer(&mut self, value: super::PageContentLayerXElementType) -> Result<(), Error> {
            self.layer.push(value);
            Ok(())
        }
        fn handle_layer<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PageContentLayerXElementType>,
            fallback: &mut Option<PageContentXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.layer.len() < 1usize {
                    *self.state = PageContentXElementTypeDeserializerState::Layer(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(PageContentXElementTypeDeserializerState::Layer(None));
                    *self.state = PageContentXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_layer(data)?;
                    *self.state = PageContentXElementTypeDeserializerState::Layer(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PageContentXElementTypeDeserializerState::Layer(Some(deserializer)),
                            );
                            if self.layer.len().saturating_add(1) < 1usize {
                                *self.state = PageContentXElementTypeDeserializerState::Layer(None);
                            } else {
                                *self.state = PageContentXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageContentXElementTypeDeserializerState::Layer(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageContentXElementType>
        for PageContentXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageContentXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageContentXElementType>
        where
            R: DeserializeReader,
        {
            use PageContentXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Layer(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_layer(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = PageContentXElementTypeDeserializerState::Layer(None);
                        event
                    }
                    (S::Layer(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Layer",
                            true,
                        )?;
                        match self.handle_layer(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PageContentXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PageContentXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PageContentXElementType { layer: self.layer })
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotXElementTypeDeserializer {
        id: u32,
        type_: super::PageAnnotAnnotTypeXType,
        creator: String,
        last_mod_date: String,
        visible: bool,
        subtype: Option<String>,
        print: bool,
        no_zoom: bool,
        no_rotate: bool,
        read_only: bool,
        remark: Option<String>,
        parameters: Option<super::PageAnnotAnnotParametersXElementType>,
        appearance: Option<super::PageAnnotAnnotAppearanceXElementType>,
        state: Box<PageAnnotAnnotXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PageAnnotAnnotXElementTypeDeserializerState {
        Init__,
        Remark(Option<<String as WithDeserializer>::Deserializer>),
        Parameters(
            Option<<super::PageAnnotAnnotParametersXElementType as WithDeserializer>::Deserializer>,
        ),
        Appearance(
            Option<<super::PageAnnotAnnotAppearanceXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl PageAnnotAnnotXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<u32> = None;
            let mut type_: Option<super::PageAnnotAnnotTypeXType> = None;
            let mut creator: Option<String> = None;
            let mut last_mod_date: Option<String> = None;
            let mut visible: Option<bool> = None;
            let mut subtype: Option<String> = None;
            let mut print: Option<bool> = None;
            let mut no_zoom: Option<bool> = None;
            let mut no_rotate: Option<bool> = None;
            let mut read_only: Option<bool> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Creator")
                ) {
                    reader.read_attrib(&mut creator, b"Creator", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LastModDate")
                ) {
                    reader.read_attrib(&mut last_mod_date, b"LastModDate", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Visible")
                ) {
                    reader.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Subtype")
                ) {
                    reader.read_attrib(&mut subtype, b"Subtype", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Print")
                ) {
                    reader.read_attrib(&mut print, b"Print", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"NoZoom")
                ) {
                    reader.read_attrib(&mut no_zoom, b"NoZoom", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"NoRotate")
                ) {
                    reader.read_attrib(&mut no_rotate, b"NoRotate", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ReadOnly")
                ) {
                    reader.read_attrib(&mut read_only, b"ReadOnly", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Type".into())))?,
                creator: creator.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Creator".into()))
                })?,
                last_mod_date: last_mod_date.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("LastModDate".into()))
                })?,
                visible: visible.unwrap_or_else(super::PageAnnotAnnotXElementType::default_visible),
                subtype: subtype,
                print: print.unwrap_or_else(super::PageAnnotAnnotXElementType::default_print),
                no_zoom: no_zoom.unwrap_or_else(super::PageAnnotAnnotXElementType::default_no_zoom),
                no_rotate: no_rotate
                    .unwrap_or_else(super::PageAnnotAnnotXElementType::default_no_rotate),
                read_only: read_only
                    .unwrap_or_else(super::PageAnnotAnnotXElementType::default_read_only),
                remark: None,
                parameters: None,
                appearance: None,
                state: Box::new(PageAnnotAnnotXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PageAnnotAnnotXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use PageAnnotAnnotXElementTypeDeserializerState as S;
            match state {
                S::Remark(Some(deserializer)) => self.store_remark(deserializer.finish(reader)?)?,
                S::Parameters(Some(deserializer)) => {
                    self.store_parameters(deserializer.finish(reader)?)?
                }
                S::Appearance(Some(deserializer)) => {
                    self.store_appearance(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_remark(&mut self, value: String) -> Result<(), Error> {
            if self.remark.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Remark",
                )))?;
            }
            self.remark = Some(value);
            Ok(())
        }
        fn store_parameters(
            &mut self,
            value: super::PageAnnotAnnotParametersXElementType,
        ) -> Result<(), Error> {
            if self.parameters.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Parameters",
                )))?;
            }
            self.parameters = Some(value);
            Ok(())
        }
        fn store_appearance(
            &mut self,
            value: super::PageAnnotAnnotAppearanceXElementType,
        ) -> Result<(), Error> {
            if self.appearance.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Appearance",
                )))?;
            }
            self.appearance = Some(value);
            Ok(())
        }
        fn handle_remark<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<PageAnnotAnnotXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(PageAnnotAnnotXElementTypeDeserializerState::Remark(None));
                *self.state = PageAnnotAnnotXElementTypeDeserializerState::Parameters(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_remark(data)?;
                    *self.state = PageAnnotAnnotXElementTypeDeserializerState::Parameters(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PageAnnotAnnotXElementTypeDeserializerState::Remark(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                PageAnnotAnnotXElementTypeDeserializerState::Parameters(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = PageAnnotAnnotXElementTypeDeserializerState::Remark(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_parameters<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PageAnnotAnnotParametersXElementType>,
            fallback: &mut Option<PageAnnotAnnotXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(PageAnnotAnnotXElementTypeDeserializerState::Parameters(
                    None,
                ));
                *self.state = PageAnnotAnnotXElementTypeDeserializerState::Appearance(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_parameters(data)?;
                    *self.state = PageAnnotAnnotXElementTypeDeserializerState::Appearance(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PageAnnotAnnotXElementTypeDeserializerState::Parameters(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                PageAnnotAnnotXElementTypeDeserializerState::Appearance(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = PageAnnotAnnotXElementTypeDeserializerState::Parameters(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_appearance<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PageAnnotAnnotAppearanceXElementType>,
            fallback: &mut Option<PageAnnotAnnotXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.appearance.is_some() {
                    fallback.get_or_insert(
                        PageAnnotAnnotXElementTypeDeserializerState::Appearance(None),
                    );
                    *self.state = PageAnnotAnnotXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = PageAnnotAnnotXElementTypeDeserializerState::Appearance(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_appearance(data)?;
                    *self.state = PageAnnotAnnotXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PageAnnotAnnotXElementTypeDeserializerState::Appearance(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = PageAnnotAnnotXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = PageAnnotAnnotXElementTypeDeserializerState::Appearance(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageAnnotAnnotXElementType>
        for PageAnnotAnnotXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotAnnotXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotAnnotXElementType>
        where
            R: DeserializeReader,
        {
            use PageAnnotAnnotXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Remark(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_remark(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Parameters(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_parameters(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Appearance(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_appearance(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = PageAnnotAnnotXElementTypeDeserializerState::Remark(None);
                        event
                    }
                    (S::Remark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Remark",
                            false,
                        )?;
                        match self.handle_remark(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Parameters(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Parameters",
                            false,
                        )?;
                        match self.handle_parameters(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Appearance(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Appearance",
                            true,
                        )?;
                        match self.handle_appearance(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PageAnnotAnnotXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PageAnnotAnnotXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PageAnnotAnnotXElementType {
                id: self.id,
                type_: self.type_,
                creator: self.creator,
                last_mod_date: self.last_mod_date,
                visible: self.visible,
                subtype: self.subtype,
                print: self.print,
                no_zoom: self.no_zoom,
                no_rotate: self.no_rotate,
                read_only: self.read_only,
                remark: self.remark,
                parameters: self.parameters,
                appearance: self
                    .appearance
                    .ok_or_else(|| ErrorKind::MissingElement("Appearance".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResColorSpacesXElementTypeDeserializer {
        color_space: Vec<super::ResColorSpacesColorSpaceXElementType>,
        state: Box<ResColorSpacesXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResColorSpacesXElementTypeDeserializerState {
        Init__,
        ColorSpace(
            Option<<super::ResColorSpacesColorSpaceXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl ResColorSpacesXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                color_space: Vec::new(),
                state: Box::new(ResColorSpacesXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResColorSpacesXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResColorSpacesXElementTypeDeserializerState as S;
            match state {
                S::ColorSpace(Some(deserializer)) => {
                    self.store_color_space(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_color_space(
            &mut self,
            value: super::ResColorSpacesColorSpaceXElementType,
        ) -> Result<(), Error> {
            self.color_space.push(value);
            Ok(())
        }
        fn handle_color_space<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ResColorSpacesColorSpaceXElementType>,
            fallback: &mut Option<ResColorSpacesXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.color_space.len() < 1usize {
                    *self.state = ResColorSpacesXElementTypeDeserializerState::ColorSpace(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ResColorSpacesXElementTypeDeserializerState::ColorSpace(None),
                    );
                    *self.state = ResColorSpacesXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_color_space(data)?;
                    *self.state = ResColorSpacesXElementTypeDeserializerState::ColorSpace(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ResColorSpacesXElementTypeDeserializerState::ColorSpace(Some(
                                    deserializer,
                                )),
                            );
                            if self.color_space.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ResColorSpacesXElementTypeDeserializerState::ColorSpace(None);
                            } else {
                                *self.state = ResColorSpacesXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ResColorSpacesXElementTypeDeserializerState::ColorSpace(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResColorSpacesXElementType>
        for ResColorSpacesXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResColorSpacesXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResColorSpacesXElementType>
        where
            R: DeserializeReader,
        {
            use ResColorSpacesXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ColorSpace(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_color_space(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ResColorSpacesXElementTypeDeserializerState::ColorSpace(None);
                        event
                    }
                    (S::ColorSpace(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ColorSpace",
                            false,
                        )?;
                        match self.handle_color_space(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ResColorSpacesXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResColorSpacesXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResColorSpacesXElementType {
                color_space: self.color_space,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResDrawParamsXElementTypeDeserializer {
        draw_param: Vec<super::ResDrawParamsDrawParamXElementType>,
        state: Box<ResDrawParamsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResDrawParamsXElementTypeDeserializerState {
        Init__,
        DrawParam(
            Option<<super::ResDrawParamsDrawParamXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl ResDrawParamsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                draw_param: Vec::new(),
                state: Box::new(ResDrawParamsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResDrawParamsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResDrawParamsXElementTypeDeserializerState as S;
            match state {
                S::DrawParam(Some(deserializer)) => {
                    self.store_draw_param(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_draw_param(
            &mut self,
            value: super::ResDrawParamsDrawParamXElementType,
        ) -> Result<(), Error> {
            self.draw_param.push(value);
            Ok(())
        }
        fn handle_draw_param<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ResDrawParamsDrawParamXElementType>,
            fallback: &mut Option<ResDrawParamsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.draw_param.len() < 1usize {
                    *self.state = ResDrawParamsXElementTypeDeserializerState::DrawParam(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(ResDrawParamsXElementTypeDeserializerState::DrawParam(None));
                    *self.state = ResDrawParamsXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_draw_param(data)?;
                    *self.state = ResDrawParamsXElementTypeDeserializerState::DrawParam(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ResDrawParamsXElementTypeDeserializerState::DrawParam(Some(
                                    deserializer,
                                )),
                            );
                            if self.draw_param.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ResDrawParamsXElementTypeDeserializerState::DrawParam(None);
                            } else {
                                *self.state = ResDrawParamsXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ResDrawParamsXElementTypeDeserializerState::DrawParam(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResDrawParamsXElementType>
        for ResDrawParamsXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResDrawParamsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResDrawParamsXElementType>
        where
            R: DeserializeReader,
        {
            use ResDrawParamsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DrawParam(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_draw_param(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ResDrawParamsXElementTypeDeserializerState::DrawParam(None);
                        event
                    }
                    (S::DrawParam(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"DrawParam",
                            true,
                        )?;
                        match self.handle_draw_param(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ResDrawParamsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResDrawParamsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResDrawParamsXElementType {
                draw_param: self.draw_param,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResFontsXElementTypeDeserializer {
        font: Vec<super::ResFontsFontXElementType>,
        state: Box<ResFontsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResFontsXElementTypeDeserializerState {
        Init__,
        Font(Option<<super::ResFontsFontXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ResFontsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                font: Vec::new(),
                state: Box::new(ResFontsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResFontsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResFontsXElementTypeDeserializerState as S;
            match state {
                S::Font(Some(deserializer)) => self.store_font(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_font(&mut self, value: super::ResFontsFontXElementType) -> Result<(), Error> {
            self.font.push(value);
            Ok(())
        }
        fn handle_font<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ResFontsFontXElementType>,
            fallback: &mut Option<ResFontsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.font.len() < 1usize {
                    *self.state = ResFontsXElementTypeDeserializerState::Font(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(ResFontsXElementTypeDeserializerState::Font(None));
                    *self.state = ResFontsXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_font(data)?;
                    *self.state = ResFontsXElementTypeDeserializerState::Font(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ResFontsXElementTypeDeserializerState::Font(
                                Some(deserializer),
                            ));
                            if self.font.len().saturating_add(1) < 1usize {
                                *self.state = ResFontsXElementTypeDeserializerState::Font(None);
                            } else {
                                *self.state = ResFontsXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ResFontsXElementTypeDeserializerState::Font(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResFontsXElementType> for ResFontsXElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResFontsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResFontsXElementType>
        where
            R: DeserializeReader,
        {
            use ResFontsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Font(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_font(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ResFontsXElementTypeDeserializerState::Font(None);
                        event
                    }
                    (S::Font(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Font",
                            false,
                        )?;
                        match self.handle_font(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ResFontsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResFontsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResFontsXElementType { font: self.font })
        }
    }
    #[derive(Debug)]
    pub struct ResMultiMediasXElementTypeDeserializer {
        multi_media: Vec<super::ResMultiMediasMultiMediaXElementType>,
        state: Box<ResMultiMediasXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResMultiMediasXElementTypeDeserializerState {
        Init__,
        MultiMedia(
            Option<<super::ResMultiMediasMultiMediaXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl ResMultiMediasXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                multi_media: Vec::new(),
                state: Box::new(ResMultiMediasXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResMultiMediasXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResMultiMediasXElementTypeDeserializerState as S;
            match state {
                S::MultiMedia(Some(deserializer)) => {
                    self.store_multi_media(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_multi_media(
            &mut self,
            value: super::ResMultiMediasMultiMediaXElementType,
        ) -> Result<(), Error> {
            self.multi_media.push(value);
            Ok(())
        }
        fn handle_multi_media<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ResMultiMediasMultiMediaXElementType>,
            fallback: &mut Option<ResMultiMediasXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.multi_media.len() < 1usize {
                    *self.state = ResMultiMediasXElementTypeDeserializerState::MultiMedia(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ResMultiMediasXElementTypeDeserializerState::MultiMedia(None),
                    );
                    *self.state = ResMultiMediasXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_multi_media(data)?;
                    *self.state = ResMultiMediasXElementTypeDeserializerState::MultiMedia(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ResMultiMediasXElementTypeDeserializerState::MultiMedia(Some(
                                    deserializer,
                                )),
                            );
                            if self.multi_media.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ResMultiMediasXElementTypeDeserializerState::MultiMedia(None);
                            } else {
                                *self.state = ResMultiMediasXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ResMultiMediasXElementTypeDeserializerState::MultiMedia(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResMultiMediasXElementType>
        for ResMultiMediasXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResMultiMediasXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResMultiMediasXElementType>
        where
            R: DeserializeReader,
        {
            use ResMultiMediasXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::MultiMedia(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_multi_media(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ResMultiMediasXElementTypeDeserializerState::MultiMedia(None);
                        event
                    }
                    (S::MultiMedia(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"MultiMedia",
                            false,
                        )?;
                        match self.handle_multi_media(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ResMultiMediasXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResMultiMediasXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResMultiMediasXElementType {
                multi_media: self.multi_media,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResCompositeGraphicUnitsXElementTypeDeserializer {
        composite_graphic_unit:
            Vec<super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType>,
        state: Box<ResCompositeGraphicUnitsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResCompositeGraphicUnitsXElementTypeDeserializerState {
        Init__ , CompositeGraphicUnit (Option << super :: ResCompositeGraphicUnitsCompositeGraphicUnitXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl ResCompositeGraphicUnitsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                composite_graphic_unit: Vec::new(),
                state: Box::new(ResCompositeGraphicUnitsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResCompositeGraphicUnitsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResCompositeGraphicUnitsXElementTypeDeserializerState as S;
            match state {
                S::CompositeGraphicUnit(Some(deserializer)) => {
                    self.store_composite_graphic_unit(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_composite_graphic_unit(
            &mut self,
            value: super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
        ) -> Result<(), Error> {
            self.composite_graphic_unit.push(value);
            Ok(())
        }
        fn handle_composite_graphic_unit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<
                'de,
                super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
            >,
            fallback: &mut Option<ResCompositeGraphicUnitsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.composite_graphic_unit.len() < 1usize {
                    *self.state =
                        ResCompositeGraphicUnitsXElementTypeDeserializerState::CompositeGraphicUnit(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ResCompositeGraphicUnitsXElementTypeDeserializerState::CompositeGraphicUnit(
                            None,
                        ),
                    );
                    *self.state = ResCompositeGraphicUnitsXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_composite_graphic_unit(data)?;
                    *self.state =
                        ResCompositeGraphicUnitsXElementTypeDeserializerState::CompositeGraphicUnit(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ResCompositeGraphicUnitsXElementTypeDeserializerState :: CompositeGraphicUnit (Some (deserializer))) ;
                            if self.composite_graphic_unit.len().saturating_add(1) < 1usize {
                                * self . state = ResCompositeGraphicUnitsXElementTypeDeserializerState :: CompositeGraphicUnit (None) ;
                            } else {
                                *self.state =
                                    ResCompositeGraphicUnitsXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ResCompositeGraphicUnitsXElementTypeDeserializerState :: CompositeGraphicUnit (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResCompositeGraphicUnitsXElementType>
        for ResCompositeGraphicUnitsXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResCompositeGraphicUnitsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResCompositeGraphicUnitsXElementType>
        where
            R: DeserializeReader,
        {
            use ResCompositeGraphicUnitsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CompositeGraphicUnit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_composite_graphic_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = ResCompositeGraphicUnitsXElementTypeDeserializerState :: CompositeGraphicUnit (None) ;
                        event
                    }
                    (
                        S::CompositeGraphicUnit(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CompositeGraphicUnit",
                            false,
                        )?;
                        match self.handle_composite_graphic_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ResCompositeGraphicUnitsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResCompositeGraphicUnitsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResCompositeGraphicUnitsXElementType {
                composite_graphic_unit: self.composite_graphic_unit,
            })
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoXElementTypeDeserializer {
        provider: Option<super::SianatureSiqnedInfoProviderXElementType>,
        signature_method: Option<String>,
        sianature_date_time: Option<String>,
        references: Option<super::SianatureSiqnedInfoReferencesXElementType>,
        stamp_annot: Vec<super::SianatureSiqnedInfoStampAnnotXElementType>,
        seal: Option<super::SianatureSiqnedInfoSealXElementType>,
        state: Box<SianatureSiqnedInfoXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SianatureSiqnedInfoXElementTypeDeserializerState {
        Init__ , Provider (Option << super :: SianatureSiqnedInfoProviderXElementType as WithDeserializer > :: Deserializer >) , SignatureMethod (Option << String as WithDeserializer > :: Deserializer >) , SianatureDateTime (Option << String as WithDeserializer > :: Deserializer >) , References (Option << super :: SianatureSiqnedInfoReferencesXElementType as WithDeserializer > :: Deserializer >) , StampAnnot (Option << super :: SianatureSiqnedInfoStampAnnotXElementType as WithDeserializer > :: Deserializer >) , Seal (Option << super :: SianatureSiqnedInfoSealXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl SianatureSiqnedInfoXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                provider: None,
                signature_method: None,
                sianature_date_time: None,
                references: None,
                stamp_annot: Vec::new(),
                seal: None,
                state: Box::new(SianatureSiqnedInfoXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SianatureSiqnedInfoXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SianatureSiqnedInfoXElementTypeDeserializerState as S;
            match state {
                S::Provider(Some(deserializer)) => {
                    self.store_provider(deserializer.finish(reader)?)?
                }
                S::SignatureMethod(Some(deserializer)) => {
                    self.store_signature_method(deserializer.finish(reader)?)?
                }
                S::SianatureDateTime(Some(deserializer)) => {
                    self.store_sianature_date_time(deserializer.finish(reader)?)?
                }
                S::References(Some(deserializer)) => {
                    self.store_references(deserializer.finish(reader)?)?
                }
                S::StampAnnot(Some(deserializer)) => {
                    self.store_stamp_annot(deserializer.finish(reader)?)?
                }
                S::Seal(Some(deserializer)) => self.store_seal(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_provider(
            &mut self,
            value: super::SianatureSiqnedInfoProviderXElementType,
        ) -> Result<(), Error> {
            if self.provider.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Provider",
                )))?;
            }
            self.provider = Some(value);
            Ok(())
        }
        fn store_signature_method(&mut self, value: String) -> Result<(), Error> {
            if self.signature_method.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SignatureMethod",
                )))?;
            }
            self.signature_method = Some(value);
            Ok(())
        }
        fn store_sianature_date_time(&mut self, value: String) -> Result<(), Error> {
            if self.sianature_date_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SianatureDateTime",
                )))?;
            }
            self.sianature_date_time = Some(value);
            Ok(())
        }
        fn store_references(
            &mut self,
            value: super::SianatureSiqnedInfoReferencesXElementType,
        ) -> Result<(), Error> {
            if self.references.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"References",
                )))?;
            }
            self.references = Some(value);
            Ok(())
        }
        fn store_stamp_annot(
            &mut self,
            value: super::SianatureSiqnedInfoStampAnnotXElementType,
        ) -> Result<(), Error> {
            self.stamp_annot.push(value);
            Ok(())
        }
        fn store_seal(
            &mut self,
            value: super::SianatureSiqnedInfoSealXElementType,
        ) -> Result<(), Error> {
            if self.seal.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Seal")))?;
            }
            self.seal = Some(value);
            Ok(())
        }
        fn handle_provider<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SianatureSiqnedInfoProviderXElementType>,
            fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.provider.is_some() {
                    fallback.get_or_insert(
                        SianatureSiqnedInfoXElementTypeDeserializerState::Provider(None),
                    );
                    *self.state =
                        SianatureSiqnedInfoXElementTypeDeserializerState::SignatureMethod(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = SianatureSiqnedInfoXElementTypeDeserializerState::Provider(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_provider(data)?;
                    *self.state =
                        SianatureSiqnedInfoXElementTypeDeserializerState::SignatureMethod(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureSiqnedInfoXElementTypeDeserializerState::Provider(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::SignatureMethod(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::Provider(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_signature_method<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    SianatureSiqnedInfoXElementTypeDeserializerState::SignatureMethod(None),
                );
                *self.state =
                    SianatureSiqnedInfoXElementTypeDeserializerState::SianatureDateTime(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_signature_method(data)?;
                    *self.state =
                        SianatureSiqnedInfoXElementTypeDeserializerState::SianatureDateTime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureSiqnedInfoXElementTypeDeserializerState::SignatureMethod(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::SianatureDateTime(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::SignatureMethod(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_sianature_date_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    SianatureSiqnedInfoXElementTypeDeserializerState::SianatureDateTime(None),
                );
                *self.state = SianatureSiqnedInfoXElementTypeDeserializerState::References(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_sianature_date_time(data)?;
                    *self.state =
                        SianatureSiqnedInfoXElementTypeDeserializerState::References(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureSiqnedInfoXElementTypeDeserializerState::SianatureDateTime(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::References(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::SianatureDateTime(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_references<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SianatureSiqnedInfoReferencesXElementType>,
            fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.references.is_some() {
                    fallback.get_or_insert(
                        SianatureSiqnedInfoXElementTypeDeserializerState::References(None),
                    );
                    *self.state =
                        SianatureSiqnedInfoXElementTypeDeserializerState::StampAnnot(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        SianatureSiqnedInfoXElementTypeDeserializerState::References(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_references(data)?;
                    *self.state =
                        SianatureSiqnedInfoXElementTypeDeserializerState::StampAnnot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureSiqnedInfoXElementTypeDeserializerState::References(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::StampAnnot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::References(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_stamp_annot<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SianatureSiqnedInfoStampAnnotXElementType>,
            fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    SianatureSiqnedInfoXElementTypeDeserializerState::StampAnnot(None),
                );
                *self.state = SianatureSiqnedInfoXElementTypeDeserializerState::Seal(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_stamp_annot(data)?;
                    *self.state =
                        SianatureSiqnedInfoXElementTypeDeserializerState::StampAnnot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureSiqnedInfoXElementTypeDeserializerState::StampAnnot(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::StampAnnot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SianatureSiqnedInfoXElementTypeDeserializerState::StampAnnot(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_seal<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SianatureSiqnedInfoSealXElementType>,
            fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(SianatureSiqnedInfoXElementTypeDeserializerState::Seal(None));
                *self.state = SianatureSiqnedInfoXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_seal(data)?;
                    *self.state = SianatureSiqnedInfoXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureSiqnedInfoXElementTypeDeserializerState::Seal(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SianatureSiqnedInfoXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SianatureSiqnedInfoXElementTypeDeserializerState::Seal(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SianatureSiqnedInfoXElementType>
        for SianatureSiqnedInfoXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoXElementType>
        where
            R: DeserializeReader,
        {
            use SianatureSiqnedInfoXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Provider(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_provider(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SignatureMethod(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_signature_method(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SianatureDateTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_sianature_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::References(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_references(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StampAnnot(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_stamp_annot(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Seal(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_seal(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            SianatureSiqnedInfoXElementTypeDeserializerState::Provider(None);
                        event
                    }
                    (S::Provider(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Provider",
                            false,
                        )?;
                        match self.handle_provider(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SignatureMethod(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"SignatureMethod",
                            false,
                        )?;
                        match self.handle_signature_method(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SianatureDateTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"SianatureDateTime",
                            false,
                        )?;
                        match self.handle_sianature_date_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::References(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"References",
                            false,
                        )?;
                        match self.handle_references(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StampAnnot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"StampAnnot",
                            false,
                        )?;
                        match self.handle_stamp_annot(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Seal(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Seal",
                            false,
                        )?;
                        match self.handle_seal(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SianatureSiqnedInfoXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SianatureSiqnedInfoXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SianatureSiqnedInfoXElementType {
                provider: self
                    .provider
                    .ok_or_else(|| ErrorKind::MissingElement("Provider".into()))?,
                signature_method: self.signature_method,
                sianature_date_time: self.sianature_date_time,
                references: self
                    .references
                    .ok_or_else(|| ErrorKind::MissingElement("References".into()))?,
                stamp_annot: self.stamp_annot,
                seal: self.seal,
            })
        }
    }
    #[derive(Debug)]
    pub struct SiqnaturesSignatureXElementTypeDeserializer {
        id: String,
        type_: super::SiqnaturesSignatureTypeXType,
        base_loc: String,
        state: Box<SiqnaturesSignatureXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SiqnaturesSignatureXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl SiqnaturesSignatureXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<String> = None;
            let mut type_: Option<super::SiqnaturesSignatureTypeXType> = None;
            let mut base_loc: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"BaseLoc")
                ) {
                    reader.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                type_: type_.unwrap_or_else(super::SiqnaturesSignatureXElementType::default_type_),
                base_loc: base_loc.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("BaseLoc".into()))
                })?,
                state: Box::new(SiqnaturesSignatureXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SiqnaturesSignatureXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::SiqnaturesSignatureXElementType>
        for SiqnaturesSignatureXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SiqnaturesSignatureXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SiqnaturesSignatureXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SiqnaturesSignatureXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SiqnaturesSignatureXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SiqnaturesSignatureXElementType {
                id: self.id,
                type_: self.type_,
                base_loc: self.base_loc,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtActionGotoBookmarkXElementTypeDeserializer {
        name: String,
        state: Box<CtActionGotoBookmarkXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtActionGotoBookmarkXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtActionGotoBookmarkXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut name: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                name: name
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Name".into())))?,
                state: Box::new(CtActionGotoBookmarkXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtActionGotoBookmarkXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtActionGotoBookmarkXElementType>
        for CtActionGotoBookmarkXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionGotoBookmarkXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtActionGotoBookmarkXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtActionGotoBookmarkXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtActionGotoBookmarkXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtActionGotoBookmarkXElementType { name: self.name })
        }
    }
    #[derive(Debug)]
    pub struct CtDocInfoCustomDatasCustomDataXElementTypeDeserializer {
        name: String,
        content: Option<String>,
        state: Box<CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl CtDocInfoCustomDatasCustomDataXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut name: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                name: name
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Name".into())))?,
                content: None,
                state: Box::new(
                    CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState::Init__,
                ),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState::Content__(
                deserializer,
            ) = state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasCustomDataXElementType>
        where
            R: DeserializeReader,
        {
            use CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::CtDocInfoCustomDatasCustomDataXElementType>
        for CtDocInfoCustomDatasCustomDataXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasCustomDataXElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasCustomDataXElementType>
        where
            R: DeserializeReader,
        {
            use CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::CtDocInfoCustomDatasCustomDataXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtDocInfoCustomDatasCustomDataXElementType {
                name: self.name,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaLineXElementTypeDeserializer {
        point_1: String,
        state: Box<CtRegionAreaLineXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtRegionAreaLineXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtRegionAreaLineXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut point_1: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Point1")
                ) {
                    reader.read_attrib(&mut point_1, b"Point1", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                point_1: point_1.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Point1".into()))
                })?,
                state: Box::new(CtRegionAreaLineXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtRegionAreaLineXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtRegionAreaLineXElementType>
        for CtRegionAreaLineXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaLineXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaLineXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtRegionAreaLineXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtRegionAreaLineXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtRegionAreaLineXElementType {
                point_1: self.point_1,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaOuadraticBezierXElementTypeDeserializer {
        pointl: String,
        point_2: String,
        state: Box<CtRegionAreaOuadraticBezierXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtRegionAreaOuadraticBezierXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtRegionAreaOuadraticBezierXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut pointl: Option<String> = None;
            let mut point_2: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Pointl")
                ) {
                    reader.read_attrib(&mut pointl, b"Pointl", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Point2")
                ) {
                    reader.read_attrib(&mut point_2, b"Point2", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                pointl: pointl.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Pointl".into()))
                })?,
                point_2: point_2.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Point2".into()))
                })?,
                state: Box::new(CtRegionAreaOuadraticBezierXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtRegionAreaOuadraticBezierXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtRegionAreaOuadraticBezierXElementType>
        for CtRegionAreaOuadraticBezierXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaOuadraticBezierXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaOuadraticBezierXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::CtRegionAreaOuadraticBezierXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtRegionAreaOuadraticBezierXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtRegionAreaOuadraticBezierXElementType {
                pointl: self.pointl,
                point_2: self.point_2,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaCubicBezierXElementTypeDeserializer {
        point_1: Option<String>,
        point_2: Option<String>,
        point_3: String,
        state: Box<CtRegionAreaCubicBezierXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtRegionAreaCubicBezierXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtRegionAreaCubicBezierXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut point_1: Option<String> = None;
            let mut point_2: Option<String> = None;
            let mut point_3: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Point1")
                ) {
                    reader.read_attrib(&mut point_1, b"Point1", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Point2")
                ) {
                    reader.read_attrib(&mut point_2, b"Point2", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Point3")
                ) {
                    reader.read_attrib(&mut point_3, b"Point3", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                point_1: point_1,
                point_2: point_2,
                point_3: point_3.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Point3".into()))
                })?,
                state: Box::new(CtRegionAreaCubicBezierXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtRegionAreaCubicBezierXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtRegionAreaCubicBezierXElementType>
        for CtRegionAreaCubicBezierXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaCubicBezierXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaCubicBezierXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::CtRegionAreaCubicBezierXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtRegionAreaCubicBezierXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtRegionAreaCubicBezierXElementType {
                point_1: self.point_1,
                point_2: self.point_2,
                point_3: self.point_3,
            })
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaArcXElementTypeDeserializer {
        sweep_direction: bool,
        large_arc: bool,
        rotation_anglet: f64,
        ellipse_size: String,
        end_point: String,
        state: Box<CtRegionAreaArcXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CtRegionAreaArcXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl CtRegionAreaArcXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut sweep_direction: Option<bool> = None;
            let mut large_arc: Option<bool> = None;
            let mut rotation_anglet: Option<f64> = None;
            let mut ellipse_size: Option<String> = None;
            let mut end_point: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"SweepDirection")
                ) {
                    reader.read_attrib(&mut sweep_direction, b"SweepDirection", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LargeArc")
                ) {
                    reader.read_attrib(&mut large_arc, b"LargeArc", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"RotationAnglet")
                ) {
                    reader.read_attrib(&mut rotation_anglet, b"RotationAnglet", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"EllipseSize")
                ) {
                    reader.read_attrib(&mut ellipse_size, b"EllipseSize", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"EndPoint")
                ) {
                    reader.read_attrib(&mut end_point, b"EndPoint", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                sweep_direction: sweep_direction.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("SweepDirection".into()))
                })?,
                large_arc: large_arc.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("LargeArc".into()))
                })?,
                rotation_anglet: rotation_anglet.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("RotationAnglet".into()))
                })?,
                ellipse_size: ellipse_size.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("EllipseSize".into()))
                })?,
                end_point: end_point.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("EndPoint".into()))
                })?,
                state: Box::new(CtRegionAreaArcXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CtRegionAreaArcXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::CtRegionAreaArcXElementType>
        for CtRegionAreaArcXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaArcXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CtRegionAreaArcXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CtRegionAreaArcXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CtRegionAreaArcXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CtRegionAreaArcXElementType {
                sweep_direction: self.sweep_direction,
                large_arc: self.large_arc,
                rotation_anglet: self.rotation_anglet,
                ellipse_size: self.ellipse_size,
                end_point: self.end_point,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocVersionFileListFileXElementTypeDeserializer {
        id: String,
        content: Option<String>,
        state: Box<DocVersionFileListFileXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocVersionFileListFileXElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DocVersionFileListFileXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                content: None,
                state: Box::new(DocVersionFileListFileXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocVersionFileListFileXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DocVersionFileListFileXElementTypeDeserializerState::Content__(deserializer) =
                state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::DocVersionFileListFileXElementType>
        where
            R: DeserializeReader,
        {
            use DocVersionFileListFileXElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::DocVersionFileListFileXElementType>
        for DocVersionFileListFileXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocVersionFileListFileXElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocVersionFileListFileXElementType>
        where
            R: DeserializeReader,
        {
            use DocVersionFileListFileXElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::DocVersionFileListFileXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocVersionFileListFileXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocVersionFileListFileXElementType {
                id: self.id,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocumentCommonDataTemplatePageXElementTypeDeserializer {
        id: String,
        name: Option<String>,
        z_order: Option<super::DocumentCommonDataTemplatePageZOrderXType>,
        base_loc: String,
        state: Box<DocumentCommonDataTemplatePageXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentCommonDataTemplatePageXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl DocumentCommonDataTemplatePageXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<String> = None;
            let mut name: Option<String> = None;
            let mut z_order: Option<super::DocumentCommonDataTemplatePageZOrderXType> = None;
            let mut base_loc: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Name")
                ) {
                    reader.read_attrib(&mut name, b"Name", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ZOrder")
                ) {
                    reader.read_attrib(&mut z_order, b"ZOrder", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"BaseLoc")
                ) {
                    reader.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                name: name,
                z_order: z_order,
                base_loc: base_loc.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("BaseLoc".into()))
                })?,
                state: Box::new(
                    DocumentCommonDataTemplatePageXElementTypeDeserializerState::Init__,
                ),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentCommonDataTemplatePageXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::DocumentCommonDataTemplatePageXElementType>
        for DocumentCommonDataTemplatePageXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentCommonDataTemplatePageXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentCommonDataTemplatePageXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::DocumentCommonDataTemplatePageXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentCommonDataTemplatePageXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentCommonDataTemplatePageXElementType {
                id: self.id,
                name: self.name,
                z_order: self.z_order,
                base_loc: self.base_loc,
            })
        }
    }
    #[derive(Debug)]
    pub struct DocumentPagesPageXElementTypeDeserializer {
        id: u32,
        base_loc: String,
        state: Box<DocumentPagesPageXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DocumentPagesPageXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl DocumentPagesPageXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<u32> = None;
            let mut base_loc: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"BaseLoc")
                ) {
                    reader.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                base_loc: base_loc.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("BaseLoc".into()))
                })?,
                state: Box::new(DocumentPagesPageXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DocumentPagesPageXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::DocumentPagesPageXElementType>
        for DocumentPagesPageXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentPagesPageXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DocumentPagesPageXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DocumentPagesPageXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                DocumentPagesPageXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::DocumentPagesPageXElementType {
                id: self.id,
                base_loc: self.base_loc,
            })
        }
    }
    #[derive(Debug)]
    pub struct OfdDocBodyVersionsXElementTypeDeserializer {
        version: Vec<super::OfdDocBodyVersionsVersionXElementType>,
        state: Box<OfdDocBodyVersionsXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum OfdDocBodyVersionsXElementTypeDeserializerState {
        Init__,
        Version(
            Option<
                <super::OfdDocBodyVersionsVersionXElementType as WithDeserializer>::Deserializer,
            >,
        ),
        Done__,
        Unknown__,
    }
    impl OfdDocBodyVersionsXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                version: Vec::new(),
                state: Box::new(OfdDocBodyVersionsXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: OfdDocBodyVersionsXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use OfdDocBodyVersionsXElementTypeDeserializerState as S;
            match state {
                S::Version(Some(deserializer)) => {
                    self.store_version(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_version(
            &mut self,
            value: super::OfdDocBodyVersionsVersionXElementType,
        ) -> Result<(), Error> {
            self.version.push(value);
            Ok(())
        }
        fn handle_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::OfdDocBodyVersionsVersionXElementType>,
            fallback: &mut Option<OfdDocBodyVersionsXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.version.len() < 1usize {
                    *self.state = OfdDocBodyVersionsXElementTypeDeserializerState::Version(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        OfdDocBodyVersionsXElementTypeDeserializerState::Version(None),
                    );
                    *self.state = OfdDocBodyVersionsXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_version(data)?;
                    *self.state = OfdDocBodyVersionsXElementTypeDeserializerState::Version(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                OfdDocBodyVersionsXElementTypeDeserializerState::Version(Some(
                                    deserializer,
                                )),
                            );
                            if self.version.len().saturating_add(1) < 1usize {
                                *self.state =
                                    OfdDocBodyVersionsXElementTypeDeserializerState::Version(None);
                            } else {
                                *self.state =
                                    OfdDocBodyVersionsXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = OfdDocBodyVersionsXElementTypeDeserializerState::Version(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::OfdDocBodyVersionsXElementType>
        for OfdDocBodyVersionsXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::OfdDocBodyVersionsXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::OfdDocBodyVersionsXElementType>
        where
            R: DeserializeReader,
        {
            use OfdDocBodyVersionsXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Version(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            OfdDocBodyVersionsXElementTypeDeserializerState::Version(None);
                        event
                    }
                    (S::Version(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Version",
                            false,
                        )?;
                        match self.handle_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::OfdDocBodyVersionsXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                OfdDocBodyVersionsXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::OfdDocBodyVersionsXElementType {
                version: self.version,
            })
        }
    }
    #[derive(Debug)]
    pub struct PageContentLayerXElementTypeDeserializer {
        type_: super::CtLayerTypeXType,
        draw_param: Option<u32>,
        id: u32,
        content: Vec<super::PageContentLayerXElementTypeContent>,
        state: Box<PageContentLayerXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PageContentLayerXElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::PageContentLayerXElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl PageContentLayerXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CtLayerTypeXType> = None;
            let mut draw_param: Option<u32> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DrawParam")
                ) {
                    reader.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_.unwrap_or_else(super::PageContentLayerXElementType::default_type_),
                draw_param: draw_param,
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                content: Vec::new(),
                state: Box::new(PageContentLayerXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PageContentLayerXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let PageContentLayerXElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::PageContentLayerXElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PageContentLayerXElementTypeContent>,
            fallback: &mut Option<PageContentLayerXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(PageContentLayerXElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = PageContentLayerXElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = PageContentLayerXElementTypeDeserializerState::Content__(
                                deserializer,
                            );
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PageContentLayerXElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state = PageContentLayerXElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageContentLayerXElementType>
        for PageContentLayerXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageContentLayerXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageContentLayerXElementType>
        where
            R: DeserializeReader,
        {
            use PageContentLayerXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: PageContentLayerXElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PageContentLayerXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PageContentLayerXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PageContentLayerXElementType {
                type_: self.type_,
                draw_param: self.draw_param,
                id: self.id,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct PageContentLayerXElementTypeContentDeserializer {
        state: Box<PageContentLayerXElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum PageContentLayerXElementTypeContentDeserializerState {
        Init__,
        TextObject(
            Option<super::CtPageBlockTextObjectXElementType>,
            Option<<super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        PathObject(
            Option<super::CtPageBlockPathObjectXElementType>,
            Option<<super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        ImageObject(
            Option<super::CtPageBlockImageObjectXElementType>,
            Option<<super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        CompositeObject(
            Option<super::CtPageBlockCompositeObjectXElementType>,
            Option<
                <super::CtPageBlockCompositeObjectXElementType as WithDeserializer>::Deserializer,
            >,
        ),
        PageBlock(
            Option<super::CtPageBlockPageBlockXElementType>,
            Option<<super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::PageContentLayerXElementTypeContent),
        Unknown__,
    }
    impl PageContentLayerXElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<PageContentLayerXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TextObject")
                ) {
                    let output = < super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_text_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PathObject")
                ) {
                    let output = < super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_path_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ImageObject")
                ) {
                    let output = < super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_image_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CompositeObject")
                ) {
                    let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_composite_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PageBlock")
                ) {
                    let output = < super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_page_block(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(PageContentLayerXElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: PageContentLayerXElementTypeContentDeserializerState,
        ) -> Result<super::PageContentLayerXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use PageContentLayerXElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::TextObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text_object(&mut values, value)?;
                    }
                    Ok(super::PageContentLayerXElementTypeContent::TextObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("TextObject".into()))?,
                    ))
                }
                S::PathObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_path_object(&mut values, value)?;
                    }
                    Ok(super::PageContentLayerXElementTypeContent::PathObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("PathObject".into()))?,
                    ))
                }
                S::ImageObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_image_object(&mut values, value)?;
                    }
                    Ok(super::PageContentLayerXElementTypeContent::ImageObject(
                        values.ok_or_else(|| ErrorKind::MissingElement("ImageObject".into()))?,
                    ))
                }
                S::CompositeObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_composite_object(&mut values, value)?;
                    }
                    Ok(super::PageContentLayerXElementTypeContent::CompositeObject(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("CompositeObject".into()))?,
                    ))
                }
                S::PageBlock(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_page_block(&mut values, value)?;
                    }
                    Ok(super::PageContentLayerXElementTypeContent::PageBlock(
                        values.ok_or_else(|| ErrorKind::MissingElement("PageBlock".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_text_object(
            values: &mut Option<super::CtPageBlockTextObjectXElementType>,
            value: super::CtPageBlockTextObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TextObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_path_object(
            values: &mut Option<super::CtPageBlockPathObjectXElementType>,
            value: super::CtPageBlockPathObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PathObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_image_object(
            values: &mut Option<super::CtPageBlockImageObjectXElementType>,
            value: super::CtPageBlockImageObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ImageObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_composite_object(
            values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
            value: super::CtPageBlockCompositeObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompositeObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_page_block(
            values: &mut Option<super::CtPageBlockPageBlockXElementType>,
            value: super::CtPageBlockPageBlockXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageBlock",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_text_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockTextObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            fallback: &mut Option<PageContentLayerXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = PageContentLayerXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => PageContentLayerXElementTypeContentDeserializerState::TextObject(
                        values, None,
                    ),
                    Some(PageContentLayerXElementTypeContentDeserializerState::TextObject(
                        _,
                        Some(deserializer),
                    )) => PageContentLayerXElementTypeContentDeserializerState::TextObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(PageContentLayerXElementTypeContentDeserializerState::TextObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageContentLayerXElementTypeContentDeserializerState::TextObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageContentLayerXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = PageContentLayerXElementTypeContentDeserializerState::TextObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_path_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPathObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            fallback: &mut Option<PageContentLayerXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = PageContentLayerXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => PageContentLayerXElementTypeContentDeserializerState::PathObject(
                        values, None,
                    ),
                    Some(PageContentLayerXElementTypeContentDeserializerState::PathObject(
                        _,
                        Some(deserializer),
                    )) => PageContentLayerXElementTypeContentDeserializerState::PathObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(PageContentLayerXElementTypeContentDeserializerState::PathObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_path_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_path_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageContentLayerXElementTypeContentDeserializerState::PathObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageContentLayerXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = PageContentLayerXElementTypeContentDeserializerState::PathObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_image_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockImageObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            fallback: &mut Option<PageContentLayerXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = PageContentLayerXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => PageContentLayerXElementTypeContentDeserializerState::ImageObject(
                        values, None,
                    ),
                    Some(PageContentLayerXElementTypeContentDeserializerState::ImageObject(
                        _,
                        Some(deserializer),
                    )) => PageContentLayerXElementTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(PageContentLayerXElementTypeContentDeserializerState::ImageObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_image_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_image_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageContentLayerXElementTypeContentDeserializerState::ImageObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageContentLayerXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = PageContentLayerXElementTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_composite_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            fallback: &mut Option<PageContentLayerXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = PageContentLayerXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => PageContentLayerXElementTypeContentDeserializerState::CompositeObject(
                        values, None,
                    ),
                    Some(
                        PageContentLayerXElementTypeContentDeserializerState::CompositeObject(
                            _,
                            Some(deserializer),
                        ),
                    ) => PageContentLayerXElementTypeContentDeserializerState::CompositeObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(PageContentLayerXElementTypeContentDeserializerState::CompositeObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_composite_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageContentLayerXElementTypeContentDeserializerState::CompositeObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageContentLayerXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        PageContentLayerXElementTypeContentDeserializerState::CompositeObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_page_block<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPageBlockXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            fallback: &mut Option<PageContentLayerXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state = PageContentLayerXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => PageContentLayerXElementTypeContentDeserializerState::PageBlock(
                        values, None,
                    ),
                    Some(PageContentLayerXElementTypeContentDeserializerState::PageBlock(
                        _,
                        Some(deserializer),
                    )) => PageContentLayerXElementTypeContentDeserializerState::PageBlock(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(PageContentLayerXElementTypeContentDeserializerState::PageBlock(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_page_block(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_page_block(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageContentLayerXElementTypeContentDeserializerState::PageBlock(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageContentLayerXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = PageContentLayerXElementTypeContentDeserializerState::PageBlock(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageContentLayerXElementTypeContent>
        for PageContentLayerXElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageContentLayerXElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(PageContentLayerXElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        PageContentLayerXElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageContentLayerXElementTypeContent>
        where
            R: DeserializeReader,
        {
            use PageContentLayerXElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TextObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::TextObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TextObject",
                            true,
                        )?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PathObject",
                            true,
                        )?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ImageObject",
                            true,
                        )?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CompositeObject",
                            true,
                        )?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageBlock",
                            true,
                        )?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::PageContentLayerXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotParametersXElementTypeDeserializer {
        parameter: Vec<super::CtDocInfoCustomDatasCustomDataXElementType>,
        state: Box<PageAnnotAnnotParametersXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PageAnnotAnnotParametersXElementTypeDeserializerState {
        Init__ , Parameter (Option << super :: CtDocInfoCustomDatasCustomDataXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl PageAnnotAnnotParametersXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                parameter: Vec::new(),
                state: Box::new(PageAnnotAnnotParametersXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PageAnnotAnnotParametersXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use PageAnnotAnnotParametersXElementTypeDeserializerState as S;
            match state {
                S::Parameter(Some(deserializer)) => {
                    self.store_parameter(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_parameter(
            &mut self,
            value: super::CtDocInfoCustomDatasCustomDataXElementType,
        ) -> Result<(), Error> {
            self.parameter.push(value);
            Ok(())
        }
        fn handle_parameter<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtDocInfoCustomDatasCustomDataXElementType>,
            fallback: &mut Option<PageAnnotAnnotParametersXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.parameter.len() < 1usize {
                    *self.state =
                        PageAnnotAnnotParametersXElementTypeDeserializerState::Parameter(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        PageAnnotAnnotParametersXElementTypeDeserializerState::Parameter(None),
                    );
                    *self.state = PageAnnotAnnotParametersXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_parameter(data)?;
                    *self.state =
                        PageAnnotAnnotParametersXElementTypeDeserializerState::Parameter(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PageAnnotAnnotParametersXElementTypeDeserializerState::Parameter(
                                    Some(deserializer),
                                ),
                            );
                            if self.parameter.len().saturating_add(1) < 1usize {
                                * self . state = PageAnnotAnnotParametersXElementTypeDeserializerState :: Parameter (None) ;
                            } else {
                                *self.state =
                                    PageAnnotAnnotParametersXElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageAnnotAnnotParametersXElementTypeDeserializerState::Parameter(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageAnnotAnnotParametersXElementType>
        for PageAnnotAnnotParametersXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotAnnotParametersXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotAnnotParametersXElementType>
        where
            R: DeserializeReader,
        {
            use PageAnnotAnnotParametersXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Parameter(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_parameter(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            PageAnnotAnnotParametersXElementTypeDeserializerState::Parameter(None);
                        event
                    }
                    (S::Parameter(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Parameter",
                            false,
                        )?;
                        match self.handle_parameter(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::PageAnnotAnnotParametersXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PageAnnotAnnotParametersXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PageAnnotAnnotParametersXElementType {
                parameter: self.parameter,
            })
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotAppearanceXElementTypeDeserializer {
        boundary: Option<String>,
        content: Vec<super::PageAnnotAnnotAppearanceXElementTypeContent>,
        state: Box<PageAnnotAnnotAppearanceXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PageAnnotAnnotAppearanceXElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(
            <super::PageAnnotAnnotAppearanceXElementTypeContent as WithDeserializer>::Deserializer,
        ),
        Unknown__,
    }
    impl PageAnnotAnnotAppearanceXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut boundary: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                boundary: boundary,
                content: Vec::new(),
                state: Box::new(PageAnnotAnnotAppearanceXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PageAnnotAnnotAppearanceXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let PageAnnotAnnotAppearanceXElementTypeDeserializerState::Content__(deserializer) =
                state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::PageAnnotAnnotAppearanceXElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PageAnnotAnnotAppearanceXElementTypeContent>,
            fallback: &mut Option<PageAnnotAnnotAppearanceXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(PageAnnotAnnotAppearanceXElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = PageAnnotAnnotAppearanceXElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                PageAnnotAnnotAppearanceXElementTypeDeserializerState::Content__(
                                    deserializer,
                                );
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PageAnnotAnnotAppearanceXElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state =
                                PageAnnotAnnotAppearanceXElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageAnnotAnnotAppearanceXElementType>
        for PageAnnotAnnotAppearanceXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotAnnotAppearanceXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotAnnotAppearanceXElementType>
        where
            R: DeserializeReader,
        {
            use PageAnnotAnnotAppearanceXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: PageAnnotAnnotAppearanceXElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::PageAnnotAnnotAppearanceXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PageAnnotAnnotAppearanceXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PageAnnotAnnotAppearanceXElementType {
                boundary: self.boundary,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotAppearanceXElementTypeContentDeserializer {
        state: Box<PageAnnotAnnotAppearanceXElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum PageAnnotAnnotAppearanceXElementTypeContentDeserializerState {
        Init__,
        TextObject(
            Option<super::CtPageBlockTextObjectXElementType>,
            Option<<super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        PathObject(
            Option<super::CtPageBlockPathObjectXElementType>,
            Option<<super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        ImageObject(
            Option<super::CtPageBlockImageObjectXElementType>,
            Option<<super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer>,
        ),
        CompositeObject(
            Option<super::CtPageBlockCompositeObjectXElementType>,
            Option<
                <super::CtPageBlockCompositeObjectXElementType as WithDeserializer>::Deserializer,
            >,
        ),
        PageBlock(
            Option<super::CtPageBlockPageBlockXElementType>,
            Option<<super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::PageAnnotAnnotAppearanceXElementTypeContent),
        Unknown__,
    }
    impl PageAnnotAnnotAppearanceXElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<PageAnnotAnnotAppearanceXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            if let Event::Start(x) | Event::Empty(x) = &event {
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"TextObject")
                ) {
                    let output = < super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_text_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PathObject")
                ) {
                    let output = < super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_path_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"ImageObject")
                ) {
                    let output = < super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_image_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"CompositeObject")
                ) {
                    let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_composite_object(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
                if matches!(
                    reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                    Some(b"PageBlock")
                ) {
                    let output = < super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                    return self.handle_page_block(
                        reader,
                        Default::default(),
                        output,
                        &mut *fallback,
                    );
                }
            }
            *self.state = fallback
                .take()
                .unwrap_or(PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: PageAnnotAnnotAppearanceXElementTypeContentDeserializerState,
        ) -> Result<super::PageAnnotAnnotAppearanceXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::TextObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_text_object(&mut values, value)?;
                    }
                    Ok(
                        super::PageAnnotAnnotAppearanceXElementTypeContent::TextObject(
                            values.ok_or_else(|| ErrorKind::MissingElement("TextObject".into()))?,
                        ),
                    )
                }
                S::PathObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_path_object(&mut values, value)?;
                    }
                    Ok(
                        super::PageAnnotAnnotAppearanceXElementTypeContent::PathObject(
                            values.ok_or_else(|| ErrorKind::MissingElement("PathObject".into()))?,
                        ),
                    )
                }
                S::ImageObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_image_object(&mut values, value)?;
                    }
                    Ok(
                        super::PageAnnotAnnotAppearanceXElementTypeContent::ImageObject(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("ImageObject".into()))?,
                        ),
                    )
                }
                S::CompositeObject(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_composite_object(&mut values, value)?;
                    }
                    Ok(
                        super::PageAnnotAnnotAppearanceXElementTypeContent::CompositeObject(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("CompositeObject".into())
                            })?,
                        ),
                    )
                }
                S::PageBlock(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_page_block(&mut values, value)?;
                    }
                    Ok(
                        super::PageAnnotAnnotAppearanceXElementTypeContent::PageBlock(
                            values.ok_or_else(|| ErrorKind::MissingElement("PageBlock".into()))?,
                        ),
                    )
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_text_object(
            values: &mut Option<super::CtPageBlockTextObjectXElementType>,
            value: super::CtPageBlockTextObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TextObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_path_object(
            values: &mut Option<super::CtPageBlockPathObjectXElementType>,
            value: super::CtPageBlockPathObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PathObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_image_object(
            values: &mut Option<super::CtPageBlockImageObjectXElementType>,
            value: super::CtPageBlockImageObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ImageObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_composite_object(
            values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
            value: super::CtPageBlockCompositeObjectXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CompositeObject",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_page_block(
            values: &mut Option<super::CtPageBlockPageBlockXElementType>,
            value: super::CtPageBlockPageBlockXElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PageBlock",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_text_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockTextObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            fallback: &mut Option<PageAnnotAnnotAppearanceXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => {
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::TextObject(
                            values, None,
                        )
                    }
                    Some(
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::TextObject(
                            _,
                            Some(deserializer),
                        ),
                    ) => PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::TextObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::TextObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_text_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_text_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::TextObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::TextObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_path_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPathObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            fallback: &mut Option<PageAnnotAnnotAppearanceXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => {
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PathObject(
                            values, None,
                        )
                    }
                    Some(
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PathObject(
                            _,
                            Some(deserializer),
                        ),
                    ) => PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PathObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PathObject(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_path_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_path_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PathObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PathObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_image_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockImageObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            fallback: &mut Option<PageAnnotAnnotAppearanceXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => {
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::ImageObject(
                            values, None,
                        )
                    }
                    Some(
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::ImageObject(
                            _,
                            Some(deserializer),
                        ),
                    ) => PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::ImageObject(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::ImageObject(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_image_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_image_object(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::ImageObject(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::ImageObject(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_composite_object<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            fallback: &mut Option<PageAnnotAnnotAppearanceXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None if values . is_none () => { * self . state = PageAnnotAnnotAppearanceXElementTypeContentDeserializerState :: Init__ ; return Ok (ElementHandlerOutput :: from_event (event , allow_any)) ; } , None => PageAnnotAnnotAppearanceXElementTypeContentDeserializerState :: CompositeObject (values , None) , Some (PageAnnotAnnotAppearanceXElementTypeContentDeserializerState :: CompositeObject (_ , Some (deserializer))) => PageAnnotAnnotAppearanceXElementTypeContentDeserializerState :: CompositeObject (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::CompositeObject(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_composite_object(&mut values, data)?;
                    let data = Self :: finish_state (reader , PageAnnotAnnotAppearanceXElementTypeContentDeserializerState :: CompositeObject (values , None)) ? ;
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = PageAnnotAnnotAppearanceXElementTypeContentDeserializerState :: CompositeObject (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_page_block<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::CtPageBlockPageBlockXElementType>,
            output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            fallback: &mut Option<PageAnnotAnnotAppearanceXElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None if values.is_none() => {
                        *self.state =
                            PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                    None => {
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PageBlock(
                            values, None,
                        )
                    }
                    Some(
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PageBlock(
                            _,
                            Some(deserializer),
                        ),
                    ) => PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PageBlock(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PageBlock(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_page_block(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_page_block(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PageBlock(
                            values, None,
                        ),
                    )?;
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::PageBlock(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PageAnnotAnnotAppearanceXElementTypeContent>
        for PageAnnotAnnotAppearanceXElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotAnnotAppearanceXElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(
                    PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__,
                ),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PageAnnotAnnotAppearanceXElementTypeContent>
        where
            R: DeserializeReader,
        {
            use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::TextObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::TextObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"TextObject",
                            true,
                        )?;
                        match self.handle_text_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PathObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PathObject",
                            true,
                        )?;
                        match self.handle_path_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::ImageObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"ImageObject",
                            true,
                        )?;
                        match self.handle_image_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::CompositeObject(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CompositeObject",
                            true,
                        )?;
                        match self.handle_composite_object(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::PageBlock(values, None), event) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"PageBlock",
                            true,
                        )?;
                        match self.handle_page_block(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            self,
            reader: &R,
        ) -> Result<super::PageAnnotAnnotAppearanceXElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct ResColorSpacesColorSpaceXElementTypeDeserializer {
        type_: super::CtColorSpaceTypeXType,
        bits_per_component: i32,
        profile: Option<String>,
        id: u32,
        palette: Option<super::CtColorSpacePaletteXElementType>,
        state: Box<ResColorSpacesColorSpaceXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResColorSpacesColorSpaceXElementTypeDeserializerState {
        Init__,
        Palette(Option<<super::CtColorSpacePaletteXElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ResColorSpacesColorSpaceXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CtColorSpaceTypeXType> = None;
            let mut bits_per_component: Option<i32> = None;
            let mut profile: Option<String> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"BitsPerComponent")
                ) {
                    reader.read_attrib(
                        &mut bits_per_component,
                        b"BitsPerComponent",
                        &attrib.value,
                    )?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Profile")
                ) {
                    reader.read_attrib(&mut profile, b"Profile", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Type".into())))?,
                bits_per_component: bits_per_component.unwrap_or_else(
                    super::ResColorSpacesColorSpaceXElementType::default_bits_per_component,
                ),
                profile: profile,
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                palette: None,
                state: Box::new(ResColorSpacesColorSpaceXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResColorSpacesColorSpaceXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResColorSpacesColorSpaceXElementTypeDeserializerState as S;
            match state {
                S::Palette(Some(deserializer)) => {
                    self.store_palette(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_palette(
            &mut self,
            value: super::CtColorSpacePaletteXElementType,
        ) -> Result<(), Error> {
            if self.palette.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Palette",
                )))?;
            }
            self.palette = Some(value);
            Ok(())
        }
        fn handle_palette<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorSpacePaletteXElementType>,
            fallback: &mut Option<ResColorSpacesColorSpaceXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ResColorSpacesColorSpaceXElementTypeDeserializerState::Palette(None),
                );
                *self.state = ResColorSpacesColorSpaceXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_palette(data)?;
                    *self.state = ResColorSpacesColorSpaceXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ResColorSpacesColorSpaceXElementTypeDeserializerState::Palette(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ResColorSpacesColorSpaceXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ResColorSpacesColorSpaceXElementTypeDeserializerState::Palette(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResColorSpacesColorSpaceXElementType>
        for ResColorSpacesColorSpaceXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResColorSpacesColorSpaceXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResColorSpacesColorSpaceXElementType>
        where
            R: DeserializeReader,
        {
            use ResColorSpacesColorSpaceXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Palette(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_palette(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ResColorSpacesColorSpaceXElementTypeDeserializerState::Palette(None);
                        event
                    }
                    (S::Palette(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Palette",
                            false,
                        )?;
                        match self.handle_palette(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ResColorSpacesColorSpaceXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResColorSpacesColorSpaceXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResColorSpacesColorSpaceXElementType {
                type_: self.type_,
                bits_per_component: self.bits_per_component,
                profile: self.profile,
                id: self.id,
                palette: self.palette,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResDrawParamsDrawParamXElementTypeDeserializer {
        relative: Option<u32>,
        line_width: f64,
        join: String,
        cap: String,
        dash_offset: f64,
        dash_pattern: Option<String>,
        miter_limit: f64,
        id: u32,
        fill_color: Option<super::CtColorXType>,
        stroke_color: Option<super::CtColorXType>,
        state: Box<ResDrawParamsDrawParamXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResDrawParamsDrawParamXElementTypeDeserializerState {
        Init__,
        FillColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        StrokeColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ResDrawParamsDrawParamXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut relative: Option<u32> = None;
            let mut line_width: Option<f64> = None;
            let mut join: Option<String> = None;
            let mut cap: Option<String> = None;
            let mut dash_offset: Option<f64> = None;
            let mut dash_pattern: Option<String> = None;
            let mut miter_limit: Option<f64> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Relative")
                ) {
                    reader.read_attrib(&mut relative, b"Relative", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"LineWidth")
                ) {
                    reader.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Join")
                ) {
                    reader.read_attrib(&mut join, b"Join", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Cap")
                ) {
                    reader.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashOffset")
                ) {
                    reader.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"DashPattern")
                ) {
                    reader.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"MiterLimit")
                ) {
                    reader.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                relative: relative,
                line_width: line_width
                    .unwrap_or_else(super::ResDrawParamsDrawParamXElementType::default_line_width),
                join: join.unwrap_or_else(super::ResDrawParamsDrawParamXElementType::default_join),
                cap: cap.unwrap_or_else(super::ResDrawParamsDrawParamXElementType::default_cap),
                dash_offset: dash_offset
                    .unwrap_or_else(super::ResDrawParamsDrawParamXElementType::default_dash_offset),
                dash_pattern: dash_pattern,
                miter_limit: miter_limit
                    .unwrap_or_else(super::ResDrawParamsDrawParamXElementType::default_miter_limit),
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                fill_color: None,
                stroke_color: None,
                state: Box::new(ResDrawParamsDrawParamXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResDrawParamsDrawParamXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResDrawParamsDrawParamXElementTypeDeserializerState as S;
            match state {
                S::FillColor(Some(deserializer)) => {
                    self.store_fill_color(deserializer.finish(reader)?)?
                }
                S::StrokeColor(Some(deserializer)) => {
                    self.store_stroke_color(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_fill_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.fill_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FillColor",
                )))?;
            }
            self.fill_color = Some(value);
            Ok(())
        }
        fn store_stroke_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
            if self.stroke_color.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"StrokeColor",
                )))?;
            }
            self.stroke_color = Some(value);
            Ok(())
        }
        fn handle_fill_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<ResDrawParamsDrawParamXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ResDrawParamsDrawParamXElementTypeDeserializerState::FillColor(None),
                );
                *self.state =
                    ResDrawParamsDrawParamXElementTypeDeserializerState::StrokeColor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fill_color(data)?;
                    *self.state =
                        ResDrawParamsDrawParamXElementTypeDeserializerState::StrokeColor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ResDrawParamsDrawParamXElementTypeDeserializerState::FillColor(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ResDrawParamsDrawParamXElementTypeDeserializerState::StrokeColor(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ResDrawParamsDrawParamXElementTypeDeserializerState::FillColor(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_stroke_color<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtColorXType>,
            fallback: &mut Option<ResDrawParamsDrawParamXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ResDrawParamsDrawParamXElementTypeDeserializerState::StrokeColor(None),
                );
                *self.state = ResDrawParamsDrawParamXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_stroke_color(data)?;
                    *self.state = ResDrawParamsDrawParamXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ResDrawParamsDrawParamXElementTypeDeserializerState::StrokeColor(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ResDrawParamsDrawParamXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ResDrawParamsDrawParamXElementTypeDeserializerState::StrokeColor(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResDrawParamsDrawParamXElementType>
        for ResDrawParamsDrawParamXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResDrawParamsDrawParamXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResDrawParamsDrawParamXElementType>
        where
            R: DeserializeReader,
        {
            use ResDrawParamsDrawParamXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::FillColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fill_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StrokeColor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_stroke_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ResDrawParamsDrawParamXElementTypeDeserializerState::FillColor(None);
                        event
                    }
                    (S::FillColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FillColor",
                            true,
                        )?;
                        match self.handle_fill_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StrokeColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"StrokeColor",
                            true,
                        )?;
                        match self.handle_stroke_color(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ResDrawParamsDrawParamXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResDrawParamsDrawParamXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResDrawParamsDrawParamXElementType {
                relative: self.relative,
                line_width: self.line_width,
                join: self.join,
                cap: self.cap,
                dash_offset: self.dash_offset,
                dash_pattern: self.dash_pattern,
                miter_limit: self.miter_limit,
                id: self.id,
                fill_color: self.fill_color,
                stroke_color: self.stroke_color,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResFontsFontXElementTypeDeserializer {
        font_name: String,
        family_name: Option<String>,
        charset: super::CtFontCharsetXType,
        italic: bool,
        bold: bool,
        serif: bool,
        fixed_width: bool,
        id: u32,
        font_file: Option<String>,
        state: Box<ResFontsFontXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResFontsFontXElementTypeDeserializerState {
        Init__,
        FontFile(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ResFontsFontXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut font_name: Option<String> = None;
            let mut family_name: Option<String> = None;
            let mut charset: Option<super::CtFontCharsetXType> = None;
            let mut italic: Option<bool> = None;
            let mut bold: Option<bool> = None;
            let mut serif: Option<bool> = None;
            let mut fixed_width: Option<bool> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"FontName")
                ) {
                    reader.read_attrib(&mut font_name, b"FontName", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"FamilyName")
                ) {
                    reader.read_attrib(&mut family_name, b"FamilyName", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Charset")
                ) {
                    reader.read_attrib(&mut charset, b"Charset", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Italic")
                ) {
                    reader.read_attrib(&mut italic, b"Italic", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Bold")
                ) {
                    reader.read_attrib(&mut bold, b"Bold", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Serif")
                ) {
                    reader.read_attrib(&mut serif, b"Serif", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"FixedWidth")
                ) {
                    reader.read_attrib(&mut fixed_width, b"FixedWidth", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                font_name: font_name.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("FontName".into()))
                })?,
                family_name: family_name,
                charset: charset.unwrap_or_else(super::ResFontsFontXElementType::default_charset),
                italic: italic.unwrap_or_else(super::ResFontsFontXElementType::default_italic),
                bold: bold.unwrap_or_else(super::ResFontsFontXElementType::default_bold),
                serif: serif.unwrap_or_else(super::ResFontsFontXElementType::default_serif),
                fixed_width: fixed_width
                    .unwrap_or_else(super::ResFontsFontXElementType::default_fixed_width),
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                font_file: None,
                state: Box::new(ResFontsFontXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResFontsFontXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResFontsFontXElementTypeDeserializerState as S;
            match state {
                S::FontFile(Some(deserializer)) => {
                    self.store_font_file(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_font_file(&mut self, value: String) -> Result<(), Error> {
            if self.font_file.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FontFile",
                )))?;
            }
            self.font_file = Some(value);
            Ok(())
        }
        fn handle_font_file<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ResFontsFontXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ResFontsFontXElementTypeDeserializerState::FontFile(None));
                *self.state = ResFontsFontXElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_font_file(data)?;
                    *self.state = ResFontsFontXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ResFontsFontXElementTypeDeserializerState::FontFile(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ResFontsFontXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ResFontsFontXElementTypeDeserializerState::FontFile(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResFontsFontXElementType>
        for ResFontsFontXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResFontsFontXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResFontsFontXElementType>
        where
            R: DeserializeReader,
        {
            use ResFontsFontXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::FontFile(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_font_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ResFontsFontXElementTypeDeserializerState::FontFile(None);
                        event
                    }
                    (S::FontFile(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"FontFile",
                            false,
                        )?;
                        match self.handle_font_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ResFontsFontXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResFontsFontXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResFontsFontXElementType {
                font_name: self.font_name,
                family_name: self.family_name,
                charset: self.charset,
                italic: self.italic,
                bold: self.bold,
                serif: self.serif,
                fixed_width: self.fixed_width,
                id: self.id,
                font_file: self.font_file,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResMultiMediasMultiMediaXElementTypeDeserializer {
        type_: super::CtMultiMediaTypeXType,
        format: Option<String>,
        id: u32,
        media_file: Option<String>,
        state: Box<ResMultiMediasMultiMediaXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResMultiMediasMultiMediaXElementTypeDeserializerState {
        Init__,
        MediaFile(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ResMultiMediasMultiMediaXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CtMultiMediaTypeXType> = None;
            let mut format: Option<String> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Type")
                ) {
                    reader.read_attrib(&mut type_, b"Type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Format")
                ) {
                    reader.read_attrib(&mut format, b"Format", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Type".into())))?,
                format: format,
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                media_file: None,
                state: Box::new(ResMultiMediasMultiMediaXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResMultiMediasMultiMediaXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResMultiMediasMultiMediaXElementTypeDeserializerState as S;
            match state {
                S::MediaFile(Some(deserializer)) => {
                    self.store_media_file(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_media_file(&mut self, value: String) -> Result<(), Error> {
            if self.media_file.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MediaFile",
                )))?;
            }
            self.media_file = Some(value);
            Ok(())
        }
        fn handle_media_file<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ResMultiMediasMultiMediaXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.media_file.is_some() {
                    fallback.get_or_insert(
                        ResMultiMediasMultiMediaXElementTypeDeserializerState::MediaFile(None),
                    );
                    *self.state = ResMultiMediasMultiMediaXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ResMultiMediasMultiMediaXElementTypeDeserializerState::MediaFile(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_media_file(data)?;
                    *self.state = ResMultiMediasMultiMediaXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ResMultiMediasMultiMediaXElementTypeDeserializerState::MediaFile(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ResMultiMediasMultiMediaXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ResMultiMediasMultiMediaXElementTypeDeserializerState::MediaFile(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResMultiMediasMultiMediaXElementType>
        for ResMultiMediasMultiMediaXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResMultiMediasMultiMediaXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResMultiMediasMultiMediaXElementType>
        where
            R: DeserializeReader,
        {
            use ResMultiMediasMultiMediaXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::MediaFile(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_media_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ResMultiMediasMultiMediaXElementTypeDeserializerState::MediaFile(None);
                        event
                    }
                    (S::MediaFile(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"MediaFile",
                            false,
                        )?;
                        match self.handle_media_file(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ResMultiMediasMultiMediaXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ResMultiMediasMultiMediaXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ResMultiMediasMultiMediaXElementType {
                type_: self.type_,
                format: self.format,
                id: self.id,
                media_file: self
                    .media_file
                    .ok_or_else(|| ErrorKind::MissingElement("MediaFile".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializer {
        width: f64,
        height: f64,
        id: u32,
        thumbnail: Option<u32>,
        substitution: Option<u32>,
        content: Option<super::CtPageBlockXType>,
        state: Box<ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState {
        Init__,
        Thumbnail(Option<<u32 as WithDeserializer>::Deserializer>),
        Substitution(Option<<u32 as WithDeserializer>::Deserializer>),
        Content(Option<<super::CtPageBlockXType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut width: Option<f64> = None;
            let mut height: Option<f64> = None;
            let mut id: Option<u32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Width")
                ) {
                    reader.read_attrib(&mut width, b"Width", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Height")
                ) {
                    reader.read_attrib(&mut height, b"Height", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok (Self { width : width . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("Width" . into ()))) ? , height : height . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("Height" . into ()))) ? , id : id . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("ID" . into ()))) ? , thumbnail : None , substitution : None , content : None , state : Box :: new (ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Init__) , })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState as S;
            match state {
                S::Thumbnail(Some(deserializer)) => {
                    self.store_thumbnail(deserializer.finish(reader)?)?
                }
                S::Substitution(Some(deserializer)) => {
                    self.store_substitution(deserializer.finish(reader)?)?
                }
                S::Content(Some(deserializer)) => {
                    self.store_content(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_thumbnail(&mut self, value: u32) -> Result<(), Error> {
            if self.thumbnail.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Thumbnail",
                )))?;
            }
            self.thumbnail = Some(value);
            Ok(())
        }
        fn store_substitution(&mut self, value: u32) -> Result<(), Error> {
            if self.substitution.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Substitution",
                )))?;
            }
            self.substitution = Some(value);
            Ok(())
        }
        fn store_content(&mut self, value: super::CtPageBlockXType) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"Content",
                )))?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_thumbnail<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, u32>,
            fallback: &mut Option<
                ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState,
            >,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Thumbnail (None)) ;
                * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Substitution (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_thumbnail(data)?;
                    * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Substitution (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Thumbnail (Some (deserializer))) ;
                            * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Substitution (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Thumbnail (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_substitution<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, u32>,
            fallback: &mut Option<
                ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState,
            >,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Substitution (None)) ;
                * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Content (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_substitution(data)?;
                    * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Content (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Substitution (Some (deserializer))) ;
                            * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Content (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Substitution (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CtPageBlockXType>,
            fallback: &mut Option<
                ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState,
            >,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.content.is_some() {
                    fallback . get_or_insert (ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Content (None)) ;
                    * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Done__ ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Content (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Done__ ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Content (Some (deserializer))) ;
                            * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Done__ ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Content (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType>
        for ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType>
        where
            R: DeserializeReader,
        {
            use ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Thumbnail(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_thumbnail(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Substitution(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_substitution(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Content(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Thumbnail (None) ;
                        event
                    }
                    (S::Thumbnail(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Thumbnail",
                            false,
                        )?;
                        match self.handle_thumbnail(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Substitution(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Substitution",
                            false,
                        )?;
                        match self.handle_substitution(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Content(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Content",
                            true,
                        )?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace (& mut * self . state , ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Unknown__) ;
            self.finish_state(reader, state)?;
            Ok(
                super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType {
                    width: self.width,
                    height: self.height,
                    id: self.id,
                    thumbnail: self.thumbnail,
                    substitution: self.substitution,
                    content: self
                        .content
                        .ok_or_else(|| ErrorKind::MissingElement("Content".into()))?,
                },
            )
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoProviderXElementTypeDeserializer {
        provider_name: String,
        version: Option<String>,
        company: Option<String>,
        state: Box<SianatureSiqnedInfoProviderXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SianatureSiqnedInfoProviderXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl SianatureSiqnedInfoProviderXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut provider_name: Option<String> = None;
            let mut version: Option<String> = None;
            let mut company: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ProviderName")
                ) {
                    reader.read_attrib(&mut provider_name, b"ProviderName", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Version")
                ) {
                    reader.read_attrib(&mut version, b"Version", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Company")
                ) {
                    reader.read_attrib(&mut company, b"Company", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                provider_name: provider_name.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("ProviderName".into()))
                })?,
                version: version,
                company: company,
                state: Box::new(SianatureSiqnedInfoProviderXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SianatureSiqnedInfoProviderXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::SianatureSiqnedInfoProviderXElementType>
        for SianatureSiqnedInfoProviderXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoProviderXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoProviderXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::SianatureSiqnedInfoProviderXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SianatureSiqnedInfoProviderXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SianatureSiqnedInfoProviderXElementType {
                provider_name: self.provider_name,
                version: self.version,
                company: self.company,
            })
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoReferencesXElementTypeDeserializer {
        check_method: super::SianatureSiqnedInfoReferencesCheckMethodXType,
        reference: Vec<super::SianatureSiqnedInfoReferencesReferenceXElementType>,
        state: Box<SianatureSiqnedInfoReferencesXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SianatureSiqnedInfoReferencesXElementTypeDeserializerState {
        Init__ , Reference (Option << super :: SianatureSiqnedInfoReferencesReferenceXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl SianatureSiqnedInfoReferencesXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut check_method: Option<super::SianatureSiqnedInfoReferencesCheckMethodXType> =
                None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"CheckMethod")
                ) {
                    reader.read_attrib(&mut check_method, b"CheckMethod", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                check_method: check_method.unwrap_or_else(
                    super::SianatureSiqnedInfoReferencesXElementType::default_check_method,
                ),
                reference: Vec::new(),
                state: Box::new(SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SianatureSiqnedInfoReferencesXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SianatureSiqnedInfoReferencesXElementTypeDeserializerState as S;
            match state {
                S::Reference(Some(deserializer)) => {
                    self.store_reference(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_reference(
            &mut self,
            value: super::SianatureSiqnedInfoReferencesReferenceXElementType,
        ) -> Result<(), Error> {
            self.reference.push(value);
            Ok(())
        }
        fn handle_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<
                'de,
                super::SianatureSiqnedInfoReferencesReferenceXElementType,
            >,
            fallback: &mut Option<SianatureSiqnedInfoReferencesXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.reference.len() < 1usize {
                    *self.state =
                        SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Reference(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Reference(None),
                    );
                    *self.state =
                        SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reference(data)?;
                    *self.state =
                        SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Reference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SianatureSiqnedInfoReferencesXElementTypeDeserializerState :: Reference (Some (deserializer))) ;
                            if self.reference.len().saturating_add(1) < 1usize {
                                * self . state = SianatureSiqnedInfoReferencesXElementTypeDeserializerState :: Reference (None) ;
                            } else {
                                * self . state = SianatureSiqnedInfoReferencesXElementTypeDeserializerState :: Done__ ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SianatureSiqnedInfoReferencesXElementTypeDeserializerState :: Reference (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SianatureSiqnedInfoReferencesXElementType>
        for SianatureSiqnedInfoReferencesXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoReferencesXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoReferencesXElementType>
        where
            R: DeserializeReader,
        {
            use SianatureSiqnedInfoReferencesXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Reference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Reference(
                                None,
                            );
                        event
                    }
                    (S::Reference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"Reference",
                            false,
                        )?;
                        match self.handle_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::SianatureSiqnedInfoReferencesXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SianatureSiqnedInfoReferencesXElementType {
                check_method: self.check_method,
                reference: self.reference,
            })
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoStampAnnotXElementTypeDeserializer {
        id: String,
        page_ref: u32,
        boundary: String,
        clip: Option<String>,
        state: Box<SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl SianatureSiqnedInfoStampAnnotXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<String> = None;
            let mut page_ref: Option<u32> = None;
            let mut boundary: Option<String> = None;
            let mut clip: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"PageRef")
                ) {
                    reader.read_attrib(&mut page_ref, b"PageRef", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Boundary")
                ) {
                    reader.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Clip")
                ) {
                    reader.read_attrib(&mut clip, b"Clip", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                page_ref: page_ref.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("PageRef".into()))
                })?,
                boundary: boundary.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("Boundary".into()))
                })?,
                clip: clip,
                state: Box::new(SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::SianatureSiqnedInfoStampAnnotXElementType>
        for SianatureSiqnedInfoStampAnnotXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoStampAnnotXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoStampAnnotXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::SianatureSiqnedInfoStampAnnotXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SianatureSiqnedInfoStampAnnotXElementType {
                id: self.id,
                page_ref: self.page_ref,
                boundary: self.boundary,
                clip: self.clip,
            })
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoSealXElementTypeDeserializer {
        base_loc: Option<String>,
        state: Box<SianatureSiqnedInfoSealXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SianatureSiqnedInfoSealXElementTypeDeserializerState {
        Init__,
        BaseLoc(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SianatureSiqnedInfoSealXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                base_loc: None,
                state: Box::new(SianatureSiqnedInfoSealXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SianatureSiqnedInfoSealXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SianatureSiqnedInfoSealXElementTypeDeserializerState as S;
            match state {
                S::BaseLoc(Some(deserializer)) => {
                    self.store_base_loc(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_base_loc(&mut self, value: String) -> Result<(), Error> {
            if self.base_loc.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BaseLoc",
                )))?;
            }
            self.base_loc = Some(value);
            Ok(())
        }
        fn handle_base_loc<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SianatureSiqnedInfoSealXElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.base_loc.is_some() {
                    fallback.get_or_insert(
                        SianatureSiqnedInfoSealXElementTypeDeserializerState::BaseLoc(None),
                    );
                    *self.state = SianatureSiqnedInfoSealXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        SianatureSiqnedInfoSealXElementTypeDeserializerState::BaseLoc(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_base_loc(data)?;
                    *self.state = SianatureSiqnedInfoSealXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SianatureSiqnedInfoSealXElementTypeDeserializerState::BaseLoc(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                SianatureSiqnedInfoSealXElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SianatureSiqnedInfoSealXElementTypeDeserializerState::BaseLoc(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SianatureSiqnedInfoSealXElementType>
        for SianatureSiqnedInfoSealXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoSealXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoSealXElementType>
        where
            R: DeserializeReader,
        {
            use SianatureSiqnedInfoSealXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BaseLoc(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_base_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            SianatureSiqnedInfoSealXElementTypeDeserializerState::BaseLoc(None);
                        event
                    }
                    (S::BaseLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"BaseLoc",
                            false,
                        )?;
                        match self.handle_base_loc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::SianatureSiqnedInfoSealXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SianatureSiqnedInfoSealXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SianatureSiqnedInfoSealXElementType {
                base_loc: self
                    .base_loc
                    .ok_or_else(|| ErrorKind::MissingElement("BaseLoc".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct OfdDocBodyVersionsVersionXElementTypeDeserializer {
        id: String,
        index: i32,
        current: bool,
        base_loc: String,
        state: Box<OfdDocBodyVersionsVersionXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum OfdDocBodyVersionsVersionXElementTypeDeserializerState {
        Init__,
        Unknown__,
    }
    impl OfdDocBodyVersionsVersionXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut id: Option<String> = None;
            let mut index: Option<i32> = None;
            let mut current: Option<bool> = None;
            let mut base_loc: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"ID")
                ) {
                    reader.read_attrib(&mut id, b"ID", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Index")
                ) {
                    reader.read_attrib(&mut index, b"Index", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"Current")
                ) {
                    reader.read_attrib(&mut current, b"Current", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"BaseLoc")
                ) {
                    reader.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                id: id.ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("ID".into())))?,
                index: index
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("Index".into())))?,
                current: current
                    .unwrap_or_else(super::OfdDocBodyVersionsVersionXElementType::default_current),
                base_loc: base_loc.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("BaseLoc".into()))
                })?,
                state: Box::new(OfdDocBodyVersionsVersionXElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: OfdDocBodyVersionsVersionXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            Ok(())
        }
    }
    impl<'de> Deserializer<'de, super::OfdDocBodyVersionsVersionXElementType>
        for OfdDocBodyVersionsVersionXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::OfdDocBodyVersionsVersionXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::OfdDocBodyVersionsVersionXElementType>
        where
            R: DeserializeReader,
        {
            if let Event::End(_) = &event {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Data(self.finish(reader)?),
                    event: DeserializerEvent::None,
                    allow_any: false,
                })
            } else {
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                })
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::OfdDocBodyVersionsVersionXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                OfdDocBodyVersionsVersionXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::OfdDocBodyVersionsVersionXElementType {
                id: self.id,
                index: self.index,
                current: self.current,
                base_loc: self.base_loc,
            })
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializer {
        file_ref: String,
        check_value: Option<String>,
        state: Box<SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState {
        Init__,
        CheckValue(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut file_ref: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"FileRef")
                ) {
                    reader.read_attrib(&mut file_ref, b"FileRef", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                file_ref: file_ref.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("FileRef".into()))
                })?,
                check_value: None,
                state: Box::new(
                    SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState::Init__,
                ),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState as S;
            match state {
                S::CheckValue(Some(deserializer)) => {
                    self.store_check_value(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_check_value(&mut self, value: String) -> Result<(), Error> {
            if self.check_value.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CheckValue",
                )))?;
            }
            self.check_value = Some(value);
            Ok(())
        }
        fn handle_check_value<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<
                SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState,
            >,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.check_value.is_some() {
                    fallback . get_or_insert (SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState :: CheckValue (None)) ;
                    *self.state =
                        SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState :: CheckValue (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_check_value(data)?;
                    *self.state =
                        SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState :: CheckValue (Some (deserializer))) ;
                            * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState :: Done__ ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState :: CheckValue (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SianatureSiqnedInfoReferencesReferenceXElementType>
        for SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoReferencesReferenceXElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SianatureSiqnedInfoReferencesReferenceXElementType>
        where
            R: DeserializeReader,
        {
            use SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CheckValue(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_check_value(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState :: CheckValue (None) ;
                        event
                    }
                    (S::CheckValue(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        let output = reader.init_start_tag_deserializer(
                            event,
                            Some(&super::NS_DEFAULT),
                            b"CheckValue",
                            false,
                        )?;
                        match self.handle_check_value(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::SianatureSiqnedInfoReferencesReferenceXElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SianatureSiqnedInfoReferencesReferenceXElementType {
                file_ref: self.file_ref,
                check_value: self
                    .check_value
                    .ok_or_else(|| ErrorKind::MissingElement("CheckValue".into()))?,
            })
        }
    }
}
pub mod quick_xml_serialize {
    use core::iter::Iterator;
    use xsd_parser::quick_xml::{
        write_attrib, write_attrib_opt, BytesEnd, BytesStart, Error, Event, IterSerializer,
        WithSerializer,
    };
    #[derive(Debug)]
    pub struct AnnotationsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::AnnotationsXElementType,
        pub(super) state: Box<AnnotationsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum AnnotationsXElementTypeSerializerState<'ser> {
        Init__,
        Page(
            IterSerializer<
                'ser,
                &'ser [super::AnnotationsPageXElementType],
                super::AnnotationsPageXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> AnnotationsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    AnnotationsXElementTypeSerializerState::Init__ => {
                        *self.state = AnnotationsXElementTypeSerializerState::Page(
                            IterSerializer::new(&self.value.page[..], Some("Page"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    AnnotationsXElementTypeSerializerState::Page(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = AnnotationsXElementTypeSerializerState::End__,
                        }
                    }
                    AnnotationsXElementTypeSerializerState::End__ => {
                        *self.state = AnnotationsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    AnnotationsXElementTypeSerializerState::Done__ => return Ok(None),
                    AnnotationsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for AnnotationsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = AnnotationsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct AttachmentsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::AttachmentsXElementType,
        pub(super) state: Box<AttachmentsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum AttachmentsXElementTypeSerializerState<'ser> {
        Init__,
        Attachment(
            IterSerializer<'ser, &'ser [super::CtAttachmentXType], super::CtAttachmentXType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> AttachmentsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    AttachmentsXElementTypeSerializerState::Init__ => {
                        *self.state = AttachmentsXElementTypeSerializerState::Attachment(
                            IterSerializer::new(
                                &self.value.attachment[..],
                                Some("Attachment"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    AttachmentsXElementTypeSerializerState::Attachment(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = AttachmentsXElementTypeSerializerState::End__,
                        }
                    }
                    AttachmentsXElementTypeSerializerState::End__ => {
                        *self.state = AttachmentsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    AttachmentsXElementTypeSerializerState::Done__ => return Ok(None),
                    AttachmentsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for AttachmentsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = AttachmentsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtActionXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtActionXType,
        pub(super) state: Box<CtActionXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtActionXTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<'ser, &'ser [super::CtActionXTypeContent], super::CtActionXTypeContent>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtActionXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtActionXTypeSerializerState::Init__ => {
                        *self.state = CtActionXTypeSerializerState::Content__(IterSerializer::new(
                            &self.value.content[..],
                            None,
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Event", &self.value.event)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtActionXTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtActionXTypeSerializerState::End__,
                    },
                    CtActionXTypeSerializerState::End__ => {
                        *self.state = CtActionXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtActionXTypeSerializerState::Done__ => return Ok(None),
                    CtActionXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtActionXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtActionXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtActionXTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtActionXTypeContent,
        pub(super) state: Box<CtActionXTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtActionXTypeContentSerializerState<'ser> {
        Init__,
        Region(<super::CtRegionXType as WithSerializer>::Serializer<'ser>),
        Goto(<super::CtActionGotoXElementType as WithSerializer>::Serializer<'ser>),
        Uri(<super::CtActionUriXElementType as WithSerializer>::Serializer<'ser>),
        GotoA(<super::CtActionGotoAxElementType as WithSerializer>::Serializer<'ser>),
        Sound(<super::CtActionSoundXElementType as WithSerializer>::Serializer<'ser>),
        Movie(<super::CtActionMovieXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtActionXTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtActionXTypeContentSerializerState::Init__ => match self.value {
                        super::CtActionXTypeContent::Region(x) => {
                            *self.state = CtActionXTypeContentSerializerState::Region(
                                WithSerializer::serializer(x, Some("Region"), false)?,
                            )
                        }
                        super::CtActionXTypeContent::Goto(x) => {
                            *self.state = CtActionXTypeContentSerializerState::Goto(
                                WithSerializer::serializer(x, Some("Goto"), false)?,
                            )
                        }
                        super::CtActionXTypeContent::Uri(x) => {
                            *self.state = CtActionXTypeContentSerializerState::Uri(
                                WithSerializer::serializer(x, Some("URI"), false)?,
                            )
                        }
                        super::CtActionXTypeContent::GotoA(x) => {
                            *self.state = CtActionXTypeContentSerializerState::GotoA(
                                WithSerializer::serializer(x, Some("GotoA"), false)?,
                            )
                        }
                        super::CtActionXTypeContent::Sound(x) => {
                            *self.state = CtActionXTypeContentSerializerState::Sound(
                                WithSerializer::serializer(x, Some("Sound"), false)?,
                            )
                        }
                        super::CtActionXTypeContent::Movie(x) => {
                            *self.state = CtActionXTypeContentSerializerState::Movie(
                                WithSerializer::serializer(x, Some("Movie"), false)?,
                            )
                        }
                    },
                    CtActionXTypeContentSerializerState::Region(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtActionXTypeContentSerializerState::Done__,
                        }
                    }
                    CtActionXTypeContentSerializerState::Goto(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtActionXTypeContentSerializerState::Done__,
                    },
                    CtActionXTypeContentSerializerState::Uri(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtActionXTypeContentSerializerState::Done__,
                    },
                    CtActionXTypeContentSerializerState::GotoA(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtActionXTypeContentSerializerState::Done__,
                    },
                    CtActionXTypeContentSerializerState::Sound(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtActionXTypeContentSerializerState::Done__,
                    },
                    CtActionXTypeContentSerializerState::Movie(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtActionXTypeContentSerializerState::Done__,
                    },
                    CtActionXTypeContentSerializerState::Done__ => return Ok(None),
                    CtActionXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtActionXTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtActionXTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtAttachmentXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtAttachmentXType,
        pub(super) state: Box<CtAttachmentXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtAttachmentXTypeSerializerState<'ser> {
        Init__,
        FileLoc(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtAttachmentXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtAttachmentXTypeSerializerState::Init__ => {
                        *self.state =
                            CtAttachmentXTypeSerializerState::FileLoc(WithSerializer::serializer(
                                &self.value.file_loc,
                                Some("FileLoc"),
                                false,
                            )?);
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        write_attrib(&mut bytes, "Name", &self.value.name)?;
                        write_attrib_opt(&mut bytes, "Format", &self.value.format)?;
                        write_attrib_opt(&mut bytes, "CreationDate", &self.value.creation_date)?;
                        write_attrib_opt(&mut bytes, "ModDate", &self.value.mod_date)?;
                        write_attrib_opt(&mut bytes, "Size", &self.value.size)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib(&mut bytes, "Usage", &self.value.usage)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtAttachmentXTypeSerializerState::FileLoc(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtAttachmentXTypeSerializerState::End__,
                    },
                    CtAttachmentXTypeSerializerState::End__ => {
                        *self.state = CtAttachmentXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtAttachmentXTypeSerializerState::Done__ => return Ok(None),
                    CtAttachmentXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtAttachmentXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtAttachmentXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtAxialShdXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtAxialShdXType,
        pub(super) state: Box<CtAxialShdXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtAxialShdXTypeSerializerState<'ser> {
        Init__,
        Segment(
            IterSerializer<
                'ser,
                &'ser [super::CtAxialShdSegmentXElementType],
                super::CtAxialShdSegmentXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtAxialShdXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtAxialShdXTypeSerializerState::Init__ => {
                        *self.state = CtAxialShdXTypeSerializerState::Segment(IterSerializer::new(
                            &self.value.segment[..],
                            Some("Segment"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "MapType", &self.value.map_type)?;
                        write_attrib_opt(&mut bytes, "MapUnit", &self.value.map_unit)?;
                        write_attrib(&mut bytes, "Extend", &self.value.extend)?;
                        write_attrib(&mut bytes, "StartPoint", &self.value.start_point)?;
                        write_attrib(&mut bytes, "EndPoint", &self.value.end_point)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtAxialShdXTypeSerializerState::Segment(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtAxialShdXTypeSerializerState::End__,
                    },
                    CtAxialShdXTypeSerializerState::End__ => {
                        *self.state = CtAxialShdXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtAxialShdXTypeSerializerState::Done__ => return Ok(None),
                    CtAxialShdXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtAxialShdXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtAxialShdXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtBookmarkXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtBookmarkXType,
        pub(super) state: Box<CtBookmarkXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtBookmarkXTypeSerializerState<'ser> {
        Init__,
        Dest(<super::CtDestXType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtBookmarkXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtBookmarkXTypeSerializerState::Init__ => {
                        *self.state = CtBookmarkXTypeSerializerState::Dest(
                            WithSerializer::serializer(&self.value.dest, Some("Dest"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Name", &self.value.name)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtBookmarkXTypeSerializerState::Dest(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtBookmarkXTypeSerializerState::End__,
                    },
                    CtBookmarkXTypeSerializerState::End__ => {
                        *self.state = CtBookmarkXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtBookmarkXTypeSerializerState::Done__ => return Ok(None),
                    CtBookmarkXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtBookmarkXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtBookmarkXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtCgTransformXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtCgTransformXType,
        pub(super) state: Box<CtCgTransformXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtCgTransformXTypeSerializerState<'ser> {
        Init__,
        Glyphs(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtCgTransformXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtCgTransformXTypeSerializerState::Init__ => {
                        *self.state = CtCgTransformXTypeSerializerState::Glyphs(
                            IterSerializer::new(self.value.glyphs.as_ref(), Some("Glyphs"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "CodePosition", &self.value.code_position)?;
                        write_attrib(&mut bytes, "CodeCount", &self.value.code_count)?;
                        write_attrib(&mut bytes, "GlyphCount", &self.value.glyph_count)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtCgTransformXTypeSerializerState::Glyphs(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtCgTransformXTypeSerializerState::End__,
                    },
                    CtCgTransformXTypeSerializerState::End__ => {
                        *self.state = CtCgTransformXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtCgTransformXTypeSerializerState::Done__ => return Ok(None),
                    CtCgTransformXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtCgTransformXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtCgTransformXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtClipXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtClipXType,
        pub(super) state: Box<CtClipXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtClipXTypeSerializerState<'ser> {
        Init__,
        Area(
            IterSerializer<
                'ser,
                &'ser [super::CtClipAreaXElementType],
                super::CtClipAreaXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtClipXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtClipXTypeSerializerState::Init__ => {
                        *self.state = CtClipXTypeSerializerState::Area(IterSerializer::new(
                            &self.value.area[..],
                            Some("Area"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtClipXTypeSerializerState::Area(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtClipXTypeSerializerState::End__,
                    },
                    CtClipXTypeSerializerState::End__ => {
                        *self.state = CtClipXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtClipXTypeSerializerState::Done__ => return Ok(None),
                    CtClipXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtClipXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtClipXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtColorXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtColorXType,
        pub(super) state: Box<CtColorXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtColorXTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                Option<&'ser super::CtColorXTypeContent>,
                super::CtColorXTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtColorXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtColorXTypeSerializerState::Init__ => {
                        *self.state = CtColorXTypeSerializerState::Content__(IterSerializer::new(
                            self.value.content.as_ref(),
                            None,
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "Value", &self.value.value)?;
                        write_attrib_opt(&mut bytes, "Index", &self.value.index)?;
                        write_attrib_opt(&mut bytes, "ColorSpace", &self.value.color_space)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtColorXTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtColorXTypeSerializerState::End__,
                    },
                    CtColorXTypeSerializerState::End__ => {
                        *self.state = CtColorXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtColorXTypeSerializerState::Done__ => return Ok(None),
                    CtColorXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtColorXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtColorXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtColorXTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtColorXTypeContent,
        pub(super) state: Box<CtColorXTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtColorXTypeContentSerializerState<'ser> {
        Init__,
        Pattern(<super::CtPatternXType as WithSerializer>::Serializer<'ser>),
        AxialShd(<super::CtAxialShdXType as WithSerializer>::Serializer<'ser>),
        RadialShd(<super::CtRadialShdXType as WithSerializer>::Serializer<'ser>),
        GouraudShd(<super::CtGouraudShdXType as WithSerializer>::Serializer<'ser>),
        LaGourandShd(<super::CtLaGouraudShdXType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtColorXTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtColorXTypeContentSerializerState::Init__ => match self.value {
                        super::CtColorXTypeContent::Pattern(x) => {
                            *self.state = CtColorXTypeContentSerializerState::Pattern(
                                WithSerializer::serializer(x, Some("Pattern"), false)?,
                            )
                        }
                        super::CtColorXTypeContent::AxialShd(x) => {
                            *self.state = CtColorXTypeContentSerializerState::AxialShd(
                                WithSerializer::serializer(x, Some("AxialShd"), false)?,
                            )
                        }
                        super::CtColorXTypeContent::RadialShd(x) => {
                            *self.state = CtColorXTypeContentSerializerState::RadialShd(
                                WithSerializer::serializer(x, Some("RadialShd"), false)?,
                            )
                        }
                        super::CtColorXTypeContent::GouraudShd(x) => {
                            *self.state = CtColorXTypeContentSerializerState::GouraudShd(
                                WithSerializer::serializer(&**x, Some("GouraudShd"), false)?,
                            )
                        }
                        super::CtColorXTypeContent::LaGourandShd(x) => {
                            *self.state = CtColorXTypeContentSerializerState::LaGourandShd(
                                WithSerializer::serializer(&**x, Some("LaGourandShd"), false)?,
                            )
                        }
                    },
                    CtColorXTypeContentSerializerState::Pattern(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtColorXTypeContentSerializerState::Done__,
                        }
                    }
                    CtColorXTypeContentSerializerState::AxialShd(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtColorXTypeContentSerializerState::Done__,
                        }
                    }
                    CtColorXTypeContentSerializerState::RadialShd(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtColorXTypeContentSerializerState::Done__,
                        }
                    }
                    CtColorXTypeContentSerializerState::GouraudShd(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtColorXTypeContentSerializerState::Done__,
                        }
                    }
                    CtColorXTypeContentSerializerState::LaGourandShd(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtColorXTypeContentSerializerState::Done__,
                        }
                    }
                    CtColorXTypeContentSerializerState::Done__ => return Ok(None),
                    CtColorXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtColorXTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtColorXTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtColorSpaceXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtColorSpaceXType,
        pub(super) state: Box<CtColorSpaceXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtColorSpaceXTypeSerializerState<'ser> {
        Init__,
        Palette(
            IterSerializer<
                'ser,
                Option<&'ser super::CtColorSpacePaletteXElementType>,
                super::CtColorSpacePaletteXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtColorSpaceXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtColorSpaceXTypeSerializerState::Init__ => {
                        *self.state =
                            CtColorSpaceXTypeSerializerState::Palette(IterSerializer::new(
                                self.value.palette.as_ref(),
                                Some("Palette"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib(
                            &mut bytes,
                            "BitsPerComponent",
                            &self.value.bits_per_component,
                        )?;
                        write_attrib_opt(&mut bytes, "Profile", &self.value.profile)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtColorSpaceXTypeSerializerState::Palette(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtColorSpaceXTypeSerializerState::End__,
                    },
                    CtColorSpaceXTypeSerializerState::End__ => {
                        *self.state = CtColorSpaceXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtColorSpaceXTypeSerializerState::Done__ => return Ok(None),
                    CtColorSpaceXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtColorSpaceXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtColorSpaceXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtCompositeXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtCompositeXType,
        pub(super) state: Box<CtCompositeXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtCompositeXTypeSerializerState<'ser> {
        Init__,
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        Clips(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitClipsXElementType>,
                super::CtGraphicUnitClipsXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtCompositeXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtCompositeXTypeSerializerState::Init__ => {
                        *self.state =
                            CtCompositeXTypeSerializerState::Actions(IterSerializer::new(
                                self.value.actions.as_ref(),
                                Some("Actions"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        write_attrib(&mut bytes, "ResourceID", &self.value.resource_id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtCompositeXTypeSerializerState::Actions(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtCompositeXTypeSerializerState::Clips(IterSerializer::new(
                                    self.value.clips.as_ref(),
                                    Some("Clips"),
                                    false,
                                ))
                        }
                    },
                    CtCompositeXTypeSerializerState::Clips(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtCompositeXTypeSerializerState::End__,
                    },
                    CtCompositeXTypeSerializerState::End__ => {
                        *self.state = CtCompositeXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtCompositeXTypeSerializerState::Done__ => return Ok(None),
                    CtCompositeXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtCompositeXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtCompositeXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtDestXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtDestXType,
        pub(super) state: Box<CtDestXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtDestXTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtDestXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtDestXTypeSerializerState::Init__ => {
                        *self.state = CtDestXTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib(&mut bytes, "PageID", &self.value.page_id)?;
                        write_attrib_opt(&mut bytes, "Left", &self.value.left)?;
                        write_attrib_opt(&mut bytes, "Top", &self.value.top)?;
                        write_attrib_opt(&mut bytes, "Right", &self.value.right)?;
                        write_attrib_opt(&mut bytes, "Bottom", &self.value.bottom)?;
                        write_attrib_opt(&mut bytes, "Zoom", &self.value.zoom)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtDestXTypeSerializerState::Done__ => return Ok(None),
                    CtDestXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtDestXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtDestXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtDocInfoXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtDocInfoXType,
        pub(super) state: Box<CtDocInfoXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtDocInfoXTypeSerializerState<'ser> {
        Init__,
        DocId(<String as WithSerializer>::Serializer<'ser>),
        Title(IterSerializer<'ser, Option<&'ser String>, String>),
        Author(IterSerializer<'ser, Option<&'ser String>, String>),
        Subject(IterSerializer<'ser, Option<&'ser String>, String>),
        Abstract(IterSerializer<'ser, Option<&'ser String>, String>),
        CreationDate(IterSerializer<'ser, Option<&'ser String>, String>),
        ModDate(IterSerializer<'ser, Option<&'ser String>, String>),
        DocUsage(IterSerializer<'ser, Option<&'ser String>, String>),
        Cover(IterSerializer<'ser, Option<&'ser String>, String>),
        Keywords(
            IterSerializer<
                'ser,
                Option<&'ser super::CtDocInfoKeywordsXElementType>,
                super::CtDocInfoKeywordsXElementType,
            >,
        ),
        Creator(IterSerializer<'ser, Option<&'ser String>, String>),
        CreatorVersion(IterSerializer<'ser, Option<&'ser String>, String>),
        CustomDatas(
            IterSerializer<
                'ser,
                Option<&'ser super::CtDocInfoCustomDatasXElementType>,
                super::CtDocInfoCustomDatasXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtDocInfoXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtDocInfoXTypeSerializerState::Init__ => {
                        *self.state = CtDocInfoXTypeSerializerState::DocId(
                            WithSerializer::serializer(&self.value.doc_id, Some("DocID"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtDocInfoXTypeSerializerState::DocId(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CtDocInfoXTypeSerializerState::Title(IterSerializer::new(
                                self.value.title.as_ref(),
                                Some("Title"),
                                false,
                            ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::Title(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::Author(IterSerializer::new(
                                    self.value.author.as_ref(),
                                    Some("Author"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::Author(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::Subject(IterSerializer::new(
                                    self.value.subject.as_ref(),
                                    Some("Subject"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::Subject(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::Abstract(IterSerializer::new(
                                    self.value.abstract_.as_ref(),
                                    Some("Abstract"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::Abstract(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::CreationDate(IterSerializer::new(
                                    self.value.creation_date.as_ref(),
                                    Some("CreationDate"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::CreationDate(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::ModDate(IterSerializer::new(
                                    self.value.mod_date.as_ref(),
                                    Some("ModDate"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::ModDate(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::DocUsage(IterSerializer::new(
                                    self.value.doc_usage.as_ref(),
                                    Some("DocUsage"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::DocUsage(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CtDocInfoXTypeSerializerState::Cover(IterSerializer::new(
                                self.value.cover.as_ref(),
                                Some("Cover"),
                                false,
                            ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::Cover(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::Keywords(IterSerializer::new(
                                    self.value.keywords.as_ref(),
                                    Some("Keywords"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::Keywords(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::Creator(IterSerializer::new(
                                    self.value.creator.as_ref(),
                                    Some("Creator"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::Creator(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::CreatorVersion(IterSerializer::new(
                                    self.value.creator_version.as_ref(),
                                    Some("CreatorVersion"),
                                    false,
                                ))
                        }
                    },
                    CtDocInfoXTypeSerializerState::CreatorVersion(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtDocInfoXTypeSerializerState::CustomDatas(IterSerializer::new(
                                        self.value.custom_datas.as_ref(),
                                        Some("CustomDatas"),
                                        false,
                                    ))
                            }
                        }
                    }
                    CtDocInfoXTypeSerializerState::CustomDatas(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtDocInfoXTypeSerializerState::End__,
                    },
                    CtDocInfoXTypeSerializerState::End__ => {
                        *self.state = CtDocInfoXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtDocInfoXTypeSerializerState::Done__ => return Ok(None),
                    CtDocInfoXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtDocInfoXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtDocInfoXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtDrawParamXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtDrawParamXType,
        pub(super) state: Box<CtDrawParamXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtDrawParamXTypeSerializerState<'ser> {
        Init__,
        FillColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        StrokeColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtDrawParamXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtDrawParamXTypeSerializerState::Init__ => {
                        *self.state =
                            CtDrawParamXTypeSerializerState::FillColor(IterSerializer::new(
                                self.value.fill_color.as_ref(),
                                Some("FillColor"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "Relative", &self.value.relative)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtDrawParamXTypeSerializerState::FillColor(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtDrawParamXTypeSerializerState::StrokeColor(IterSerializer::new(
                                    self.value.stroke_color.as_ref(),
                                    Some("StrokeColor"),
                                    false,
                                ))
                        }
                    },
                    CtDrawParamXTypeSerializerState::StrokeColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtDrawParamXTypeSerializerState::End__,
                        }
                    }
                    CtDrawParamXTypeSerializerState::End__ => {
                        *self.state = CtDrawParamXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtDrawParamXTypeSerializerState::Done__ => return Ok(None),
                    CtDrawParamXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtDrawParamXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtDrawParamXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtExtensionXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtExtensionXType,
        pub(super) state: Box<CtExtensionXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtExtensionXTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::CtExtensionXTypeContent],
                super::CtExtensionXTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtExtensionXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtExtensionXTypeSerializerState::Init__ => {
                        *self.state = CtExtensionXTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "AppName", &self.value.app_name)?;
                        write_attrib_opt(&mut bytes, "Company", &self.value.company)?;
                        write_attrib_opt(&mut bytes, "AppVersion", &self.value.app_version)?;
                        write_attrib_opt(&mut bytes, "Date", &self.value.date)?;
                        write_attrib(&mut bytes, "RefId", &self.value.ref_id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtExtensionXTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtExtensionXTypeSerializerState::End__,
                    },
                    CtExtensionXTypeSerializerState::End__ => {
                        *self.state = CtExtensionXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtExtensionXTypeSerializerState::Done__ => return Ok(None),
                    CtExtensionXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtExtensionXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtExtensionXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtExtensionXTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtExtensionXTypeContent,
        pub(super) state: Box<CtExtensionXTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtExtensionXTypeContentSerializerState<'ser> {
        Init__,
        Property(<super::CtExtensionPropertyXElementType as WithSerializer>::Serializer<'ser>),
        Data(<super::xs::AnyTypeXType as WithSerializer>::Serializer<'ser>),
        ExtendData(<String as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtExtensionXTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtExtensionXTypeContentSerializerState::Init__ => match self.value {
                        super::CtExtensionXTypeContent::Property(x) => {
                            *self.state = CtExtensionXTypeContentSerializerState::Property(
                                WithSerializer::serializer(x, Some("Property"), false)?,
                            )
                        }
                        super::CtExtensionXTypeContent::Data(x) => {
                            *self.state = CtExtensionXTypeContentSerializerState::Data(
                                WithSerializer::serializer(x, Some("Data"), false)?,
                            )
                        }
                        super::CtExtensionXTypeContent::ExtendData(x) => {
                            *self.state = CtExtensionXTypeContentSerializerState::ExtendData(
                                WithSerializer::serializer(x, Some("ExtendData"), false)?,
                            )
                        }
                    },
                    CtExtensionXTypeContentSerializerState::Property(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtExtensionXTypeContentSerializerState::Done__,
                        }
                    }
                    CtExtensionXTypeContentSerializerState::Data(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtExtensionXTypeContentSerializerState::Done__,
                        }
                    }
                    CtExtensionXTypeContentSerializerState::ExtendData(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtExtensionXTypeContentSerializerState::Done__,
                        }
                    }
                    CtExtensionXTypeContentSerializerState::Done__ => return Ok(None),
                    CtExtensionXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtExtensionXTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtExtensionXTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtFontXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtFontXType,
        pub(super) state: Box<CtFontXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtFontXTypeSerializerState<'ser> {
        Init__,
        FontFile(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtFontXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtFontXTypeSerializerState::Init__ => {
                        *self.state = CtFontXTypeSerializerState::FontFile(IterSerializer::new(
                            self.value.font_file.as_ref(),
                            Some("FontFile"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "FontName", &self.value.font_name)?;
                        write_attrib_opt(&mut bytes, "FamilyName", &self.value.family_name)?;
                        write_attrib(&mut bytes, "Charset", &self.value.charset)?;
                        write_attrib(&mut bytes, "Italic", &self.value.italic)?;
                        write_attrib(&mut bytes, "Bold", &self.value.bold)?;
                        write_attrib(&mut bytes, "Serif", &self.value.serif)?;
                        write_attrib(&mut bytes, "FixedWidth", &self.value.fixed_width)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtFontXTypeSerializerState::FontFile(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtFontXTypeSerializerState::End__,
                    },
                    CtFontXTypeSerializerState::End__ => {
                        *self.state = CtFontXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtFontXTypeSerializerState::Done__ => return Ok(None),
                    CtFontXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtFontXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtFontXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtGouraudShdXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtGouraudShdXType,
        pub(super) state: Box<CtGouraudShdXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtGouraudShdXTypeSerializerState<'ser> {
        Init__,
        Point(
            IterSerializer<
                'ser,
                &'ser [super::CtGouraudShdPointXElementType],
                super::CtGouraudShdPointXElementType,
            >,
        ),
        BackColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtGouraudShdXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtGouraudShdXTypeSerializerState::Init__ => {
                        *self.state = CtGouraudShdXTypeSerializerState::Point(IterSerializer::new(
                            &self.value.point[..],
                            Some("Point"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "Extend", &self.value.extend)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtGouraudShdXTypeSerializerState::Point(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtGouraudShdXTypeSerializerState::BackColor(IterSerializer::new(
                                    self.value.back_color.as_ref().map(|x| &**x),
                                    Some("BackColor"),
                                    false,
                                ))
                        }
                    },
                    CtGouraudShdXTypeSerializerState::BackColor(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtGouraudShdXTypeSerializerState::End__,
                    },
                    CtGouraudShdXTypeSerializerState::End__ => {
                        *self.state = CtGouraudShdXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtGouraudShdXTypeSerializerState::Done__ => return Ok(None),
                    CtGouraudShdXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtGouraudShdXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtGouraudShdXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtGraphicUnitXType,
        pub(super) state: Box<CtGraphicUnitXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtGraphicUnitXTypeSerializerState<'ser> {
        Init__,
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        Clips(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitClipsXElementType>,
                super::CtGraphicUnitClipsXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtGraphicUnitXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtGraphicUnitXTypeSerializerState::Init__ => {
                        *self.state =
                            CtGraphicUnitXTypeSerializerState::Actions(IterSerializer::new(
                                self.value.actions.as_ref(),
                                Some("Actions"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtGraphicUnitXTypeSerializerState::Actions(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtGraphicUnitXTypeSerializerState::Clips(IterSerializer::new(
                                    self.value.clips.as_ref(),
                                    Some("Clips"),
                                    false,
                                ))
                        }
                    },
                    CtGraphicUnitXTypeSerializerState::Clips(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtGraphicUnitXTypeSerializerState::End__,
                    },
                    CtGraphicUnitXTypeSerializerState::End__ => {
                        *self.state = CtGraphicUnitXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtGraphicUnitXTypeSerializerState::Done__ => return Ok(None),
                    CtGraphicUnitXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtGraphicUnitXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtGraphicUnitXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtImageXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtImageXType,
        pub(super) state: Box<CtImageXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtImageXTypeSerializerState<'ser> {
        Init__,
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        Clips(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitClipsXElementType>,
                super::CtGraphicUnitClipsXElementType,
            >,
        ),
        Border(
            IterSerializer<
                'ser,
                Option<&'ser super::CtImageBorderXElementType>,
                super::CtImageBorderXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtImageXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtImageXTypeSerializerState::Init__ => {
                        *self.state = CtImageXTypeSerializerState::Actions(IterSerializer::new(
                            self.value.actions.as_ref(),
                            Some("Actions"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        write_attrib(&mut bytes, "ResourceID", &self.value.resource_id)?;
                        write_attrib_opt(&mut bytes, "Substitution", &self.value.substitution)?;
                        write_attrib_opt(&mut bytes, "ImageMask", &self.value.image_mask)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtImageXTypeSerializerState::Actions(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CtImageXTypeSerializerState::Clips(IterSerializer::new(
                                self.value.clips.as_ref(),
                                Some("Clips"),
                                false,
                            ))
                        }
                    },
                    CtImageXTypeSerializerState::Clips(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CtImageXTypeSerializerState::Border(IterSerializer::new(
                                self.value.border.as_ref(),
                                Some("Border"),
                                false,
                            ))
                        }
                    },
                    CtImageXTypeSerializerState::Border(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtImageXTypeSerializerState::End__,
                    },
                    CtImageXTypeSerializerState::End__ => {
                        *self.state = CtImageXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtImageXTypeSerializerState::Done__ => return Ok(None),
                    CtImageXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtImageXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtImageXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtLaGouraudShdXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtLaGouraudShdXType,
        pub(super) state: Box<CtLaGouraudShdXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtLaGouraudShdXTypeSerializerState<'ser> {
        Init__,
        Point(
            IterSerializer<
                'ser,
                &'ser [super::CtLaGouraudShdPointXElementType],
                super::CtLaGouraudShdPointXElementType,
            >,
        ),
        BackColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtLaGouraudShdXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtLaGouraudShdXTypeSerializerState::Init__ => {
                        *self.state = CtLaGouraudShdXTypeSerializerState::Point(
                            IterSerializer::new(&self.value.point[..], Some("Point"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "VerticesPerRow", &self.value.vertices_per_row)?;
                        write_attrib_opt(&mut bytes, "Extend", &self.value.extend)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtLaGouraudShdXTypeSerializerState::Point(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtLaGouraudShdXTypeSerializerState::BackColor(IterSerializer::new(
                                    self.value.back_color.as_ref().map(|x| &**x),
                                    Some("BackColor"),
                                    false,
                                ))
                        }
                    },
                    CtLaGouraudShdXTypeSerializerState::BackColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtLaGouraudShdXTypeSerializerState::End__,
                        }
                    }
                    CtLaGouraudShdXTypeSerializerState::End__ => {
                        *self.state = CtLaGouraudShdXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtLaGouraudShdXTypeSerializerState::Done__ => return Ok(None),
                    CtLaGouraudShdXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtLaGouraudShdXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtLaGouraudShdXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtLayerXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtLayerXType,
        pub(super) state: Box<CtLayerXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtLayerXTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<'ser, &'ser [super::CtLayerXTypeContent], super::CtLayerXTypeContent>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtLayerXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtLayerXTypeSerializerState::Init__ => {
                        *self.state = CtLayerXTypeSerializerState::Content__(IterSerializer::new(
                            &self.value.content[..],
                            None,
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtLayerXTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtLayerXTypeSerializerState::End__,
                    },
                    CtLayerXTypeSerializerState::End__ => {
                        *self.state = CtLayerXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtLayerXTypeSerializerState::Done__ => return Ok(None),
                    CtLayerXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtLayerXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtLayerXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtLayerXTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtLayerXTypeContent,
        pub(super) state: Box<CtLayerXTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtLayerXTypeContentSerializerState<'ser> {
        Init__,
        TextObject(<super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>),
        PathObject(<super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>),
        ImageObject(
            <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        CompositeObject(
            <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        PageBlock(<super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtLayerXTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtLayerXTypeContentSerializerState::Init__ => match self.value {
                        super::CtLayerXTypeContent::TextObject(x) => {
                            *self.state = CtLayerXTypeContentSerializerState::TextObject(
                                WithSerializer::serializer(x, Some("TextObject"), false)?,
                            )
                        }
                        super::CtLayerXTypeContent::PathObject(x) => {
                            *self.state = CtLayerXTypeContentSerializerState::PathObject(
                                WithSerializer::serializer(x, Some("PathObject"), false)?,
                            )
                        }
                        super::CtLayerXTypeContent::ImageObject(x) => {
                            *self.state = CtLayerXTypeContentSerializerState::ImageObject(
                                WithSerializer::serializer(x, Some("ImageObject"), false)?,
                            )
                        }
                        super::CtLayerXTypeContent::CompositeObject(x) => {
                            *self.state = CtLayerXTypeContentSerializerState::CompositeObject(
                                WithSerializer::serializer(x, Some("CompositeObject"), false)?,
                            )
                        }
                        super::CtLayerXTypeContent::PageBlock(x) => {
                            *self.state = CtLayerXTypeContentSerializerState::PageBlock(
                                WithSerializer::serializer(x, Some("PageBlock"), false)?,
                            )
                        }
                    },
                    CtLayerXTypeContentSerializerState::TextObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                        }
                    }
                    CtLayerXTypeContentSerializerState::PathObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                        }
                    }
                    CtLayerXTypeContentSerializerState::ImageObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                        }
                    }
                    CtLayerXTypeContentSerializerState::CompositeObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                        }
                    }
                    CtLayerXTypeContentSerializerState::PageBlock(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                        }
                    }
                    CtLayerXTypeContentSerializerState::Done__ => return Ok(None),
                    CtLayerXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtLayerXTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtLayerXTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtMultiMediaXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtMultiMediaXType,
        pub(super) state: Box<CtMultiMediaXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtMultiMediaXTypeSerializerState<'ser> {
        Init__,
        MediaFile(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtMultiMediaXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtMultiMediaXTypeSerializerState::Init__ => {
                        *self.state = CtMultiMediaXTypeSerializerState::MediaFile(
                            WithSerializer::serializer(
                                &self.value.media_file,
                                Some("MediaFile"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib_opt(&mut bytes, "Format", &self.value.format)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtMultiMediaXTypeSerializerState::MediaFile(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtMultiMediaXTypeSerializerState::End__,
                    },
                    CtMultiMediaXTypeSerializerState::End__ => {
                        *self.state = CtMultiMediaXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtMultiMediaXTypeSerializerState::Done__ => return Ok(None),
                    CtMultiMediaXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtMultiMediaXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtMultiMediaXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtOutlineElemXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtOutlineElemXType,
        pub(super) state: Box<CtOutlineElemXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtOutlineElemXTypeSerializerState<'ser> {
        Init__,
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        OutlineElem(
            IterSerializer<'ser, &'ser [super::CtOutlineElemXType], super::CtOutlineElemXType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtOutlineElemXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtOutlineElemXTypeSerializerState::Init__ => {
                        *self.state =
                            CtOutlineElemXTypeSerializerState::Actions(IterSerializer::new(
                                self.value.actions.as_ref(),
                                Some("Actions"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Title", &self.value.title)?;
                        write_attrib_opt(&mut bytes, "Count", &self.value.count)?;
                        write_attrib(&mut bytes, "Expanded", &self.value.expanded)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtOutlineElemXTypeSerializerState::Actions(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtOutlineElemXTypeSerializerState::OutlineElem(IterSerializer::new(
                                    &self.value.outline_elem[..],
                                    Some("OutlineElem"),
                                    false,
                                ))
                        }
                    },
                    CtOutlineElemXTypeSerializerState::OutlineElem(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtOutlineElemXTypeSerializerState::End__,
                        }
                    }
                    CtOutlineElemXTypeSerializerState::End__ => {
                        *self.state = CtOutlineElemXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtOutlineElemXTypeSerializerState::Done__ => return Ok(None),
                    CtOutlineElemXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtOutlineElemXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtOutlineElemXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageAreaXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPageAreaXType,
        pub(super) state: Box<CtPageAreaXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPageAreaXTypeSerializerState<'ser> {
        Init__,
        PhysicalBox(<String as WithSerializer>::Serializer<'ser>),
        ApplicationBox(IterSerializer<'ser, Option<&'ser String>, String>),
        ContentBox(IterSerializer<'ser, Option<&'ser String>, String>),
        BleedBox(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageAreaXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageAreaXTypeSerializerState::Init__ => {
                        *self.state = CtPageAreaXTypeSerializerState::PhysicalBox(
                            WithSerializer::serializer(
                                &self.value.physical_box,
                                Some("PhysicalBox"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPageAreaXTypeSerializerState::PhysicalBox(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPageAreaXTypeSerializerState::ApplicationBox(IterSerializer::new(
                                    self.value.application_box.as_ref(),
                                    Some("ApplicationBox"),
                                    false,
                                ))
                        }
                    },
                    CtPageAreaXTypeSerializerState::ApplicationBox(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageAreaXTypeSerializerState::ContentBox(IterSerializer::new(
                                        self.value.content_box.as_ref(),
                                        Some("ContentBox"),
                                        false,
                                    ))
                            }
                        }
                    }
                    CtPageAreaXTypeSerializerState::ContentBox(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPageAreaXTypeSerializerState::BleedBox(IterSerializer::new(
                                    self.value.bleed_box.as_ref(),
                                    Some("BleedBox"),
                                    false,
                                ))
                        }
                    },
                    CtPageAreaXTypeSerializerState::BleedBox(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtPageAreaXTypeSerializerState::End__,
                    },
                    CtPageAreaXTypeSerializerState::End__ => {
                        *self.state = CtPageAreaXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPageAreaXTypeSerializerState::Done__ => return Ok(None),
                    CtPageAreaXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageAreaXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageAreaXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockXType,
        pub(super) state: Box<CtPageBlockXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockXTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::CtPageBlockXTypeContent],
                super::CtPageBlockXTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockXTypeSerializerState::Init__ => {
                        *self.state = CtPageBlockXTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPageBlockXTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtPageBlockXTypeSerializerState::End__,
                    },
                    CtPageBlockXTypeSerializerState::End__ => {
                        *self.state = CtPageBlockXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPageBlockXTypeSerializerState::Done__ => return Ok(None),
                    CtPageBlockXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockXTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockXTypeContent,
        pub(super) state: Box<CtPageBlockXTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockXTypeContentSerializerState<'ser> {
        Init__,
        TextObject(<super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>),
        PathObject(<super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>),
        ImageObject(
            <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        CompositeObject(
            <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        PageBlock(<super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockXTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockXTypeContentSerializerState::Init__ => match self.value {
                        super::CtPageBlockXTypeContent::TextObject(x) => {
                            *self.state = CtPageBlockXTypeContentSerializerState::TextObject(
                                WithSerializer::serializer(x, Some("TextObject"), false)?,
                            )
                        }
                        super::CtPageBlockXTypeContent::PathObject(x) => {
                            *self.state = CtPageBlockXTypeContentSerializerState::PathObject(
                                WithSerializer::serializer(x, Some("PathObject"), false)?,
                            )
                        }
                        super::CtPageBlockXTypeContent::ImageObject(x) => {
                            *self.state = CtPageBlockXTypeContentSerializerState::ImageObject(
                                WithSerializer::serializer(x, Some("ImageObject"), false)?,
                            )
                        }
                        super::CtPageBlockXTypeContent::CompositeObject(x) => {
                            *self.state = CtPageBlockXTypeContentSerializerState::CompositeObject(
                                WithSerializer::serializer(x, Some("CompositeObject"), false)?,
                            )
                        }
                        super::CtPageBlockXTypeContent::PageBlock(x) => {
                            *self.state = CtPageBlockXTypeContentSerializerState::PageBlock(
                                WithSerializer::serializer(x, Some("PageBlock"), false)?,
                            )
                        }
                    },
                    CtPageBlockXTypeContentSerializerState::TextObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtPageBlockXTypeContentSerializerState::Done__,
                        }
                    }
                    CtPageBlockXTypeContentSerializerState::PathObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtPageBlockXTypeContentSerializerState::Done__,
                        }
                    }
                    CtPageBlockXTypeContentSerializerState::ImageObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtPageBlockXTypeContentSerializerState::Done__,
                        }
                    }
                    CtPageBlockXTypeContentSerializerState::CompositeObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtPageBlockXTypeContentSerializerState::Done__,
                        }
                    }
                    CtPageBlockXTypeContentSerializerState::PageBlock(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtPageBlockXTypeContentSerializerState::Done__,
                        }
                    }
                    CtPageBlockXTypeContentSerializerState::Done__ => return Ok(None),
                    CtPageBlockXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockXTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockXTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPathXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPathXType,
        pub(super) state: Box<CtPathXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPathXTypeSerializerState<'ser> {
        Init__,
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        Clips(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitClipsXElementType>,
                super::CtGraphicUnitClipsXElementType,
            >,
        ),
        StrokeColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        FillColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        AbbreviatedData(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPathXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPathXTypeSerializerState::Init__ => {
                        *self.state = CtPathXTypeSerializerState::Actions(IterSerializer::new(
                            self.value.actions.as_ref(),
                            Some("Actions"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        write_attrib(&mut bytes, "Stroke", &self.value.stroke)?;
                        write_attrib(&mut bytes, "Fill", &self.value.fill)?;
                        write_attrib(&mut bytes, "Rule", &self.value.rule)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPathXTypeSerializerState::Actions(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CtPathXTypeSerializerState::Clips(IterSerializer::new(
                                self.value.clips.as_ref(),
                                Some("Clips"),
                                false,
                            ))
                        }
                    },
                    CtPathXTypeSerializerState::Clips(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPathXTypeSerializerState::StrokeColor(IterSerializer::new(
                                    self.value.stroke_color.as_ref(),
                                    Some("StrokeColor"),
                                    false,
                                ))
                        }
                    },
                    CtPathXTypeSerializerState::StrokeColor(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPathXTypeSerializerState::FillColor(IterSerializer::new(
                                    self.value.fill_color.as_ref(),
                                    Some("FillColor"),
                                    false,
                                ))
                        }
                    },
                    CtPathXTypeSerializerState::FillColor(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CtPathXTypeSerializerState::AbbreviatedData(
                                WithSerializer::serializer(
                                    &self.value.abbreviated_data,
                                    Some("AbbreviatedData"),
                                    false,
                                )?,
                            )
                        }
                    },
                    CtPathXTypeSerializerState::AbbreviatedData(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtPathXTypeSerializerState::End__,
                    },
                    CtPathXTypeSerializerState::End__ => {
                        *self.state = CtPathXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPathXTypeSerializerState::Done__ => return Ok(None),
                    CtPathXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPathXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPathXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPatternXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPatternXType,
        pub(super) state: Box<CtPatternXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPatternXTypeSerializerState<'ser> {
        Init__,
        CellContent(<super::CtPatternCellContentXElementType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPatternXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPatternXTypeSerializerState::Init__ => {
                        *self.state =
                            CtPatternXTypeSerializerState::CellContent(WithSerializer::serializer(
                                &self.value.cell_content,
                                Some("CellContent"),
                                false,
                            )?);
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Width", &self.value.width)?;
                        write_attrib(&mut bytes, "Height", &self.value.height)?;
                        write_attrib_opt(&mut bytes, "XStep", &self.value.x_step)?;
                        write_attrib_opt(&mut bytes, "YStep", &self.value.y_step)?;
                        write_attrib(&mut bytes, "ReflectMethod", &self.value.reflect_method)?;
                        write_attrib(&mut bytes, "RelativeTo", &self.value.relative_to)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPatternXTypeSerializerState::CellContent(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtPatternXTypeSerializerState::End__,
                    },
                    CtPatternXTypeSerializerState::End__ => {
                        *self.state = CtPatternXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPatternXTypeSerializerState::Done__ => return Ok(None),
                    CtPatternXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPatternXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPatternXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPermissionXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPermissionXType,
        pub(super) state: Box<CtPermissionXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPermissionXTypeSerializerState<'ser> {
        Init__,
        Edit(IterSerializer<'ser, Option<&'ser bool>, bool>),
        Annot(IterSerializer<'ser, Option<&'ser bool>, bool>),
        Export(IterSerializer<'ser, Option<&'ser bool>, bool>),
        Signature(IterSerializer<'ser, Option<&'ser bool>, bool>),
        Watermark(IterSerializer<'ser, Option<&'ser bool>, bool>),
        PrintScreen(IterSerializer<'ser, Option<&'ser bool>, bool>),
        Print(
            IterSerializer<
                'ser,
                Option<&'ser super::CtPermissionPrintXElementType>,
                super::CtPermissionPrintXElementType,
            >,
        ),
        ValidPeriod(
            IterSerializer<
                'ser,
                Option<&'ser super::CtPermissionValidPeriodXElementType>,
                super::CtPermissionValidPeriodXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPermissionXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPermissionXTypeSerializerState::Init__ => {
                        *self.state = CtPermissionXTypeSerializerState::Edit(IterSerializer::new(
                            self.value.edit.as_ref(),
                            Some("Edit"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPermissionXTypeSerializerState::Edit(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPermissionXTypeSerializerState::Annot(IterSerializer::new(
                                    self.value.annot.as_ref(),
                                    Some("Annot"),
                                    false,
                                ))
                        }
                    },
                    CtPermissionXTypeSerializerState::Annot(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPermissionXTypeSerializerState::Export(IterSerializer::new(
                                    self.value.export.as_ref(),
                                    Some("Export"),
                                    false,
                                ))
                        }
                    },
                    CtPermissionXTypeSerializerState::Export(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPermissionXTypeSerializerState::Signature(IterSerializer::new(
                                    self.value.signature.as_ref(),
                                    Some("Signature"),
                                    false,
                                ))
                        }
                    },
                    CtPermissionXTypeSerializerState::Signature(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPermissionXTypeSerializerState::Watermark(IterSerializer::new(
                                    self.value.watermark.as_ref(),
                                    Some("Watermark"),
                                    false,
                                ))
                        }
                    },
                    CtPermissionXTypeSerializerState::Watermark(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPermissionXTypeSerializerState::PrintScreen(IterSerializer::new(
                                    self.value.print_screen.as_ref(),
                                    Some("PrintScreen"),
                                    false,
                                ))
                        }
                    },
                    CtPermissionXTypeSerializerState::PrintScreen(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPermissionXTypeSerializerState::Print(IterSerializer::new(
                                        self.value.print.as_ref(),
                                        Some("Print"),
                                        false,
                                    ))
                            }
                        }
                    }
                    CtPermissionXTypeSerializerState::Print(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtPermissionXTypeSerializerState::ValidPeriod(IterSerializer::new(
                                    self.value.valid_period.as_ref(),
                                    Some("ValidPeriod"),
                                    false,
                                ))
                        }
                    },
                    CtPermissionXTypeSerializerState::ValidPeriod(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtPermissionXTypeSerializerState::End__,
                        }
                    }
                    CtPermissionXTypeSerializerState::End__ => {
                        *self.state = CtPermissionXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPermissionXTypeSerializerState::Done__ => return Ok(None),
                    CtPermissionXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPermissionXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPermissionXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRadialShdXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtRadialShdXType,
        pub(super) state: Box<CtRadialShdXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtRadialShdXTypeSerializerState<'ser> {
        Init__,
        Seqment(
            IterSerializer<
                'ser,
                &'ser [super::CtAxialShdSegmentXElementType],
                super::CtAxialShdSegmentXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtRadialShdXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtRadialShdXTypeSerializerState::Init__ => {
                        *self.state = CtRadialShdXTypeSerializerState::Seqment(
                            IterSerializer::new(&self.value.seqment[..], Some("Seqment"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "MapType", &self.value.map_type)?;
                        write_attrib_opt(&mut bytes, "MapUnit", &self.value.map_unit)?;
                        write_attrib(&mut bytes, "Eccentricity", &self.value.eccentricity)?;
                        write_attrib(&mut bytes, "Angle", &self.value.angle)?;
                        write_attrib(&mut bytes, "StartPoint", &self.value.start_point)?;
                        write_attrib(&mut bytes, "StartRadius", &self.value.start_radius)?;
                        write_attrib(&mut bytes, "EndPoint", &self.value.end_point)?;
                        write_attrib(&mut bytes, "EndRadius", &self.value.end_radius)?;
                        write_attrib(&mut bytes, "Extend", &self.value.extend)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtRadialShdXTypeSerializerState::Seqment(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtRadialShdXTypeSerializerState::End__,
                    },
                    CtRadialShdXTypeSerializerState::End__ => {
                        *self.state = CtRadialShdXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtRadialShdXTypeSerializerState::Done__ => return Ok(None),
                    CtRadialShdXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtRadialShdXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtRadialShdXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtRegionXType,
        pub(super) state: Box<CtRegionXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtRegionXTypeSerializerState<'ser> {
        Init__,
        Area(
            IterSerializer<
                'ser,
                &'ser [super::CtRegionAreaXElementType],
                super::CtRegionAreaXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtRegionXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtRegionXTypeSerializerState::Init__ => {
                        *self.state = CtRegionXTypeSerializerState::Area(IterSerializer::new(
                            &self.value.area[..],
                            Some("Area"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtRegionXTypeSerializerState::Area(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtRegionXTypeSerializerState::End__,
                    },
                    CtRegionXTypeSerializerState::End__ => {
                        *self.state = CtRegionXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtRegionXTypeSerializerState::Done__ => return Ok(None),
                    CtRegionXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtRegionXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtRegionXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtTextXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtTextXType,
        pub(super) state: Box<CtTextXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtTextXTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<'ser, &'ser [super::CtTextXTypeContent], super::CtTextXTypeContent>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtTextXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtTextXTypeSerializerState::Init__ => {
                        *self.state = CtTextXTypeSerializerState::Content__(IterSerializer::new(
                            &self.value.content[..],
                            None,
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        write_attrib(&mut bytes, "Font", &self.value.font)?;
                        write_attrib(&mut bytes, "Size", &self.value.size)?;
                        write_attrib(&mut bytes, "Stroke", &self.value.stroke)?;
                        write_attrib(&mut bytes, "Fill", &self.value.fill)?;
                        write_attrib(&mut bytes, "HScale", &self.value.h_scale)?;
                        write_attrib(&mut bytes, "ReadDirection", &self.value.read_direction)?;
                        write_attrib(&mut bytes, "CharDirection", &self.value.char_direction)?;
                        write_attrib(&mut bytes, "Weight", &self.value.weight)?;
                        write_attrib(&mut bytes, "Italic", &self.value.italic)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtTextXTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtTextXTypeSerializerState::End__,
                    },
                    CtTextXTypeSerializerState::End__ => {
                        *self.state = CtTextXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtTextXTypeSerializerState::Done__ => return Ok(None),
                    CtTextXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtTextXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtTextXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtTextXTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtTextXTypeContent,
        pub(super) state: Box<CtTextXTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtTextXTypeContentSerializerState<'ser> {
        Init__,
        Actions(<super::CtGraphicUnitActionsXElementType as WithSerializer>::Serializer<'ser>),
        Clips(<super::CtGraphicUnitClipsXElementType as WithSerializer>::Serializer<'ser>),
        FillColor(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
        StrokeColor(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
        CgTransform(<super::CtCgTransformXType as WithSerializer>::Serializer<'ser>),
        TextCode(<super::CtTextTextCodeXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtTextXTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtTextXTypeContentSerializerState::Init__ => match self.value {
                        super::CtTextXTypeContent::Actions(x) => {
                            *self.state = CtTextXTypeContentSerializerState::Actions(
                                WithSerializer::serializer(x, Some("Actions"), false)?,
                            )
                        }
                        super::CtTextXTypeContent::Clips(x) => {
                            *self.state = CtTextXTypeContentSerializerState::Clips(
                                WithSerializer::serializer(x, Some("Clips"), false)?,
                            )
                        }
                        super::CtTextXTypeContent::FillColor(x) => {
                            *self.state = CtTextXTypeContentSerializerState::FillColor(
                                WithSerializer::serializer(x, Some("FillColor"), false)?,
                            )
                        }
                        super::CtTextXTypeContent::StrokeColor(x) => {
                            *self.state = CtTextXTypeContentSerializerState::StrokeColor(
                                WithSerializer::serializer(x, Some("StrokeColor"), false)?,
                            )
                        }
                        super::CtTextXTypeContent::CgTransform(x) => {
                            *self.state = CtTextXTypeContentSerializerState::CgTransform(
                                WithSerializer::serializer(x, Some("CGTransform"), false)?,
                            )
                        }
                        super::CtTextXTypeContent::TextCode(x) => {
                            *self.state = CtTextXTypeContentSerializerState::TextCode(
                                WithSerializer::serializer(x, Some("TextCode"), false)?,
                            )
                        }
                    },
                    CtTextXTypeContentSerializerState::Actions(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtTextXTypeContentSerializerState::Done__,
                    },
                    CtTextXTypeContentSerializerState::Clips(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtTextXTypeContentSerializerState::Done__,
                    },
                    CtTextXTypeContentSerializerState::FillColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtTextXTypeContentSerializerState::Done__,
                        }
                    }
                    CtTextXTypeContentSerializerState::StrokeColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtTextXTypeContentSerializerState::Done__,
                        }
                    }
                    CtTextXTypeContentSerializerState::CgTransform(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtTextXTypeContentSerializerState::Done__,
                        }
                    }
                    CtTextXTypeContentSerializerState::TextCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtTextXTypeContentSerializerState::Done__,
                        }
                    }
                    CtTextXTypeContentSerializerState::Done__ => return Ok(None),
                    CtTextXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtTextXTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtTextXTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtVPreferencesXTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtVPreferencesXType,
        pub(super) state: Box<CtVPreferencesXTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtVPreferencesXTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::CtVPreferencesXTypeContent],
                super::CtVPreferencesXTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtVPreferencesXTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtVPreferencesXTypeSerializerState::Init__ => {
                        *self.state = CtVPreferencesXTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtVPreferencesXTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeSerializerState::End__,
                        }
                    }
                    CtVPreferencesXTypeSerializerState::End__ => {
                        *self.state = CtVPreferencesXTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtVPreferencesXTypeSerializerState::Done__ => return Ok(None),
                    CtVPreferencesXTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtVPreferencesXTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtVPreferencesXTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtVPreferencesXTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtVPreferencesXTypeContent,
        pub(super) state: Box<CtVPreferencesXTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtVPreferencesXTypeContentSerializerState<'ser> {
        Init__,
        PageMode(<super::CtVPreferencesPageModeXElementType as WithSerializer>::Serializer<'ser>),
        PageLayout(
            <super::CtVPreferencesPageLayoutXElementType as WithSerializer>::Serializer<'ser>,
        ),
        TabDisplay(
            <super::CtVPreferencesTabDisplayXElementType as WithSerializer>::Serializer<'ser>,
        ),
        HideToolbar(<bool as WithSerializer>::Serializer<'ser>),
        HideMenubar(<bool as WithSerializer>::Serializer<'ser>),
        HideWindowUi(<bool as WithSerializer>::Serializer<'ser>),
        ZoomMode(<super::CtVPreferencesZoomModeXElementType as WithSerializer>::Serializer<'ser>),
        Zoom(<f64 as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtVPreferencesXTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtVPreferencesXTypeContentSerializerState::Init__ => match self.value {
                        super::CtVPreferencesXTypeContent::PageMode(x) => {
                            *self.state = CtVPreferencesXTypeContentSerializerState::PageMode(
                                WithSerializer::serializer(x, Some("PageMode"), false)?,
                            )
                        }
                        super::CtVPreferencesXTypeContent::PageLayout(x) => {
                            *self.state = CtVPreferencesXTypeContentSerializerState::PageLayout(
                                WithSerializer::serializer(x, Some("PageLayout"), false)?,
                            )
                        }
                        super::CtVPreferencesXTypeContent::TabDisplay(x) => {
                            *self.state = CtVPreferencesXTypeContentSerializerState::TabDisplay(
                                WithSerializer::serializer(x, Some("TabDisplay"), false)?,
                            )
                        }
                        super::CtVPreferencesXTypeContent::HideToolbar(x) => {
                            *self.state = CtVPreferencesXTypeContentSerializerState::HideToolbar(
                                WithSerializer::serializer(x, Some("HideToolbar"), false)?,
                            )
                        }
                        super::CtVPreferencesXTypeContent::HideMenubar(x) => {
                            *self.state = CtVPreferencesXTypeContentSerializerState::HideMenubar(
                                WithSerializer::serializer(x, Some("HideMenubar"), false)?,
                            )
                        }
                        super::CtVPreferencesXTypeContent::HideWindowUi(x) => {
                            *self.state = CtVPreferencesXTypeContentSerializerState::HideWindowUi(
                                WithSerializer::serializer(x, Some("HideWindowUI"), false)?,
                            )
                        }
                        super::CtVPreferencesXTypeContent::ZoomMode(x) => {
                            *self.state = CtVPreferencesXTypeContentSerializerState::ZoomMode(
                                WithSerializer::serializer(x, Some("ZoomMode"), false)?,
                            )
                        }
                        super::CtVPreferencesXTypeContent::Zoom(x) => {
                            *self.state = CtVPreferencesXTypeContentSerializerState::Zoom(
                                WithSerializer::serializer(x, Some("Zoom"), false)?,
                            )
                        }
                    },
                    CtVPreferencesXTypeContentSerializerState::PageMode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeContentSerializerState::Done__,
                        }
                    }
                    CtVPreferencesXTypeContentSerializerState::PageLayout(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeContentSerializerState::Done__,
                        }
                    }
                    CtVPreferencesXTypeContentSerializerState::TabDisplay(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeContentSerializerState::Done__,
                        }
                    }
                    CtVPreferencesXTypeContentSerializerState::HideToolbar(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeContentSerializerState::Done__,
                        }
                    }
                    CtVPreferencesXTypeContentSerializerState::HideMenubar(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeContentSerializerState::Done__,
                        }
                    }
                    CtVPreferencesXTypeContentSerializerState::HideWindowUi(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeContentSerializerState::Done__,
                        }
                    }
                    CtVPreferencesXTypeContentSerializerState::ZoomMode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeContentSerializerState::Done__,
                        }
                    }
                    CtVPreferencesXTypeContentSerializerState::Zoom(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtVPreferencesXTypeContentSerializerState::Done__,
                        }
                    }
                    CtVPreferencesXTypeContentSerializerState::Done__ => return Ok(None),
                    CtVPreferencesXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtVPreferencesXTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtVectorGxTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtVectorGxType,
        pub(super) state: Box<CtVectorGxTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtVectorGxTypeSerializerState<'ser> {
        Init__,
        Thumbnail(IterSerializer<'ser, Option<&'ser u32>, u32>),
        Substitution(IterSerializer<'ser, Option<&'ser u32>, u32>),
        Content(<super::CtPageBlockXType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtVectorGxTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtVectorGxTypeSerializerState::Init__ => {
                        *self.state =
                            CtVectorGxTypeSerializerState::Thumbnail(IterSerializer::new(
                                self.value.thumbnail.as_ref(),
                                Some("Thumbnail"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Width", &self.value.width)?;
                        write_attrib(&mut bytes, "Height", &self.value.height)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtVectorGxTypeSerializerState::Thumbnail(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtVectorGxTypeSerializerState::Substitution(IterSerializer::new(
                                    self.value.substitution.as_ref(),
                                    Some("Substitution"),
                                    false,
                                ))
                        }
                    },
                    CtVectorGxTypeSerializerState::Substitution(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CtVectorGxTypeSerializerState::Content(WithSerializer::serializer(
                                    &self.value.content,
                                    Some("Content"),
                                    false,
                                )?)
                        }
                    },
                    CtVectorGxTypeSerializerState::Content(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtVectorGxTypeSerializerState::End__,
                    },
                    CtVectorGxTypeSerializerState::End__ => {
                        *self.state = CtVectorGxTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtVectorGxTypeSerializerState::Done__ => return Ok(None),
                    CtVectorGxTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtVectorGxTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtVectorGxTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CustomTagsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CustomTagsXElementType,
        pub(super) state: Box<CustomTagsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CustomTagsXElementTypeSerializerState<'ser> {
        Init__,
        CustomTag(
            IterSerializer<
                'ser,
                &'ser [super::CustomTagsCustomTagXElementType],
                super::CustomTagsCustomTagXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CustomTagsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CustomTagsXElementTypeSerializerState::Init__ => {
                        *self.state =
                            CustomTagsXElementTypeSerializerState::CustomTag(IterSerializer::new(
                                &self.value.custom_tag[..],
                                Some("CustomTag"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CustomTagsXElementTypeSerializerState::CustomTag(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CustomTagsXElementTypeSerializerState::End__,
                        }
                    }
                    CustomTagsXElementTypeSerializerState::End__ => {
                        *self.state = CustomTagsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CustomTagsXElementTypeSerializerState::Done__ => return Ok(None),
                    CustomTagsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CustomTagsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CustomTagsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocVersionXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocVersionXElementType,
        pub(super) state: Box<DocVersionXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocVersionXElementTypeSerializerState<'ser> {
        Init__,
        FileList(<super::DocVersionFileListXElementType as WithSerializer>::Serializer<'ser>),
        DocRoot(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocVersionXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocVersionXElementTypeSerializerState::Init__ => {
                        *self.state = DocVersionXElementTypeSerializerState::FileList(
                            WithSerializer::serializer(
                                &self.value.file_list,
                                Some("FileList"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        write_attrib_opt(&mut bytes, "Version", &self.value.version)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib_opt(&mut bytes, "CreationDate", &self.value.creation_date)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocVersionXElementTypeSerializerState::FileList(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocVersionXElementTypeSerializerState::DocRoot(
                                    WithSerializer::serializer(
                                        &self.value.doc_root,
                                        Some("DocRoot"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    DocVersionXElementTypeSerializerState::DocRoot(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DocVersionXElementTypeSerializerState::End__,
                        }
                    }
                    DocVersionXElementTypeSerializerState::End__ => {
                        *self.state = DocVersionXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocVersionXElementTypeSerializerState::Done__ => return Ok(None),
                    DocVersionXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocVersionXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocVersionXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentXElementType,
        pub(super) state: Box<DocumentXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentXElementTypeSerializerState<'ser> {
        Init__,
        CommonData(<super::DocumentCommonDataXElementType as WithSerializer>::Serializer<'ser>),
        Pages(<super::DocumentPagesXElementType as WithSerializer>::Serializer<'ser>),
        Outlines(
            IterSerializer<
                'ser,
                Option<&'ser super::DocumentOutlinesXElementType>,
                super::DocumentOutlinesXElementType,
            >,
        ),
        Permissions(
            IterSerializer<'ser, Option<&'ser super::CtPermissionXType>, super::CtPermissionXType>,
        ),
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        VPreferences(
            IterSerializer<
                'ser,
                Option<&'ser super::CtVPreferencesXType>,
                super::CtVPreferencesXType,
            >,
        ),
        Bookmarks(
            IterSerializer<
                'ser,
                Option<&'ser super::DocumentBookmarksXElementType>,
                super::DocumentBookmarksXElementType,
            >,
        ),
        Annotations(IterSerializer<'ser, Option<&'ser String>, String>),
        CustomTags(IterSerializer<'ser, Option<&'ser String>, String>),
        Attachments(IterSerializer<'ser, Option<&'ser String>, String>),
        Extensions(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentXElementTypeSerializerState::Init__ => {
                        *self.state = DocumentXElementTypeSerializerState::CommonData(
                            WithSerializer::serializer(
                                &self.value.common_data,
                                Some("CommonData"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocumentXElementTypeSerializerState::CommonData(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::Pages(
                                    WithSerializer::serializer(
                                        &self.value.pages,
                                        Some("Pages"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::Pages(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                DocumentXElementTypeSerializerState::Outlines(IterSerializer::new(
                                    self.value.outlines.as_ref(),
                                    Some("Outlines"),
                                    false,
                                ))
                        }
                    },
                    DocumentXElementTypeSerializerState::Outlines(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::Permissions(
                                    IterSerializer::new(
                                        self.value.permissions.as_ref(),
                                        Some("Permissions"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::Permissions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::Actions(
                                    IterSerializer::new(
                                        self.value.actions.as_ref(),
                                        Some("Actions"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::Actions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::VPreferences(
                                    IterSerializer::new(
                                        self.value.v_preferences.as_ref(),
                                        Some("VPreferences"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::VPreferences(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::Bookmarks(
                                    IterSerializer::new(
                                        self.value.bookmarks.as_ref(),
                                        Some("Bookmarks"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::Bookmarks(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::Annotations(
                                    IterSerializer::new(
                                        self.value.annotations.as_ref(),
                                        Some("Annotations"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::Annotations(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::CustomTags(
                                    IterSerializer::new(
                                        self.value.custom_tags.as_ref(),
                                        Some("CustomTags"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::CustomTags(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::Attachments(
                                    IterSerializer::new(
                                        self.value.attachments.as_ref(),
                                        Some("Attachments"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::Attachments(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = DocumentXElementTypeSerializerState::Extensions(
                                    IterSerializer::new(
                                        self.value.extensions.as_ref(),
                                        Some("Extensions"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    DocumentXElementTypeSerializerState::Extensions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DocumentXElementTypeSerializerState::End__,
                        }
                    }
                    DocumentXElementTypeSerializerState::End__ => {
                        *self.state = DocumentXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocumentXElementTypeSerializerState::Done__ => return Ok(None),
                    DocumentXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ExtensionsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ExtensionsXElementType,
        pub(super) state: Box<ExtensionsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ExtensionsXElementTypeSerializerState<'ser> {
        Init__,
        Extension(IterSerializer<'ser, &'ser [super::CtExtensionXType], super::CtExtensionXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ExtensionsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ExtensionsXElementTypeSerializerState::Init__ => {
                        *self.state =
                            ExtensionsXElementTypeSerializerState::Extension(IterSerializer::new(
                                &self.value.extension[..],
                                Some("Extension"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ExtensionsXElementTypeSerializerState::Extension(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ExtensionsXElementTypeSerializerState::End__,
                        }
                    }
                    ExtensionsXElementTypeSerializerState::End__ => {
                        *self.state = ExtensionsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ExtensionsXElementTypeSerializerState::Done__ => return Ok(None),
                    ExtensionsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ExtensionsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ExtensionsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct OfdXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::OfdXElementType,
        pub(super) state: Box<OfdXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum OfdXElementTypeSerializerState<'ser> {
        Init__,
        DocBody(
            IterSerializer<
                'ser,
                &'ser [super::OfdDocBodyXElementType],
                super::OfdDocBodyXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> OfdXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    OfdXElementTypeSerializerState::Init__ => {
                        *self.state = OfdXElementTypeSerializerState::DocBody(IterSerializer::new(
                            &self.value.doc_body[..],
                            Some("DocBody"),
                            false,
                        ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Version", &self.value.version)?;
                        write_attrib(&mut bytes, "DocType", &self.value.doc_type)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    OfdXElementTypeSerializerState::DocBody(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = OfdXElementTypeSerializerState::End__,
                    },
                    OfdXElementTypeSerializerState::End__ => {
                        *self.state = OfdXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    OfdXElementTypeSerializerState::Done__ => return Ok(None),
                    OfdXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for OfdXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = OfdXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PageXElementType,
        pub(super) state: Box<PageXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PageXElementTypeSerializerState<'ser> {
        Init__,
        Template(
            IterSerializer<
                'ser,
                &'ser [super::PageTemplateXElementType],
                super::PageTemplateXElementType,
            >,
        ),
        PageRes(IterSerializer<'ser, &'ser [String], String>),
        Area(IterSerializer<'ser, Option<&'ser super::CtPageAreaXType>, super::CtPageAreaXType>),
        Content(
            IterSerializer<
                'ser,
                Option<&'ser super::PageContentXElementType>,
                super::PageContentXElementType,
            >,
        ),
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageXElementTypeSerializerState::Init__ => {
                        *self.state = PageXElementTypeSerializerState::Template(
                            IterSerializer::new(&self.value.template[..], Some("Template"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PageXElementTypeSerializerState::Template(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                PageXElementTypeSerializerState::PageRes(IterSerializer::new(
                                    &self.value.page_res[..],
                                    Some("PageRes"),
                                    false,
                                ))
                        }
                    },
                    PageXElementTypeSerializerState::PageRes(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = PageXElementTypeSerializerState::Area(
                                IterSerializer::new(self.value.area.as_ref(), Some("Area"), false),
                            )
                        }
                    },
                    PageXElementTypeSerializerState::Area(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                PageXElementTypeSerializerState::Content(IterSerializer::new(
                                    self.value.content.as_ref(),
                                    Some("Content"),
                                    false,
                                ))
                        }
                    },
                    PageXElementTypeSerializerState::Content(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                PageXElementTypeSerializerState::Actions(IterSerializer::new(
                                    self.value.actions.as_ref(),
                                    Some("Actions"),
                                    false,
                                ))
                        }
                    },
                    PageXElementTypeSerializerState::Actions(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = PageXElementTypeSerializerState::End__,
                    },
                    PageXElementTypeSerializerState::End__ => {
                        *self.state = PageXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PageXElementTypeSerializerState::Done__ => return Ok(None),
                    PageXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PageXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PageAnnotXElementType,
        pub(super) state: Box<PageAnnotXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PageAnnotXElementTypeSerializerState<'ser> {
        Init__,
        Annot(
            IterSerializer<
                'ser,
                &'ser [super::PageAnnotAnnotXElementType],
                super::PageAnnotAnnotXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageAnnotXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageAnnotXElementTypeSerializerState::Init__ => {
                        *self.state = PageAnnotXElementTypeSerializerState::Annot(
                            IterSerializer::new(&self.value.annot[..], Some("Annot"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PageAnnotXElementTypeSerializerState::Annot(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = PageAnnotXElementTypeSerializerState::End__,
                    },
                    PageAnnotXElementTypeSerializerState::End__ => {
                        *self.state = PageAnnotXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PageAnnotXElementTypeSerializerState::Done__ => return Ok(None),
                    PageAnnotXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PageAnnotXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageAnnotXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResXElementType,
        pub(super) state: Box<ResXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResXElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::ResXElementTypeContent],
                super::ResXElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResXElementTypeSerializerState::Init__ => {
                        *self.state = ResXElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResXElementTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = ResXElementTypeSerializerState::End__,
                    },
                    ResXElementTypeSerializerState::End__ => {
                        *self.state = ResXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResXElementTypeSerializerState::Done__ => return Ok(None),
                    ResXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ResXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResXElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::ResXElementTypeContent,
        pub(super) state: Box<ResXElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum ResXElementTypeContentSerializerState<'ser> {
        Init__,
        ColorSpaces(<super::ResColorSpacesXElementType as WithSerializer>::Serializer<'ser>),
        DrawParams(<super::ResDrawParamsXElementType as WithSerializer>::Serializer<'ser>),
        Fonts(<super::ResFontsXElementType as WithSerializer>::Serializer<'ser>),
        MultiMedias(<super::ResMultiMediasXElementType as WithSerializer>::Serializer<'ser>),
        CompositeGraphicUnits(
            <super::ResCompositeGraphicUnitsXElementType as WithSerializer>::Serializer<'ser>,
        ),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResXElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResXElementTypeContentSerializerState::Init__ => match self.value {
                        super::ResXElementTypeContent::ColorSpaces(x) => {
                            *self.state = ResXElementTypeContentSerializerState::ColorSpaces(
                                WithSerializer::serializer(x, Some("ColorSpaces"), false)?,
                            )
                        }
                        super::ResXElementTypeContent::DrawParams(x) => {
                            *self.state = ResXElementTypeContentSerializerState::DrawParams(
                                WithSerializer::serializer(x, Some("DrawParams"), false)?,
                            )
                        }
                        super::ResXElementTypeContent::Fonts(x) => {
                            *self.state = ResXElementTypeContentSerializerState::Fonts(
                                WithSerializer::serializer(x, Some("Fonts"), false)?,
                            )
                        }
                        super::ResXElementTypeContent::MultiMedias(x) => {
                            *self.state = ResXElementTypeContentSerializerState::MultiMedias(
                                WithSerializer::serializer(x, Some("MultiMedias"), false)?,
                            )
                        }
                        super::ResXElementTypeContent::CompositeGraphicUnits(x) => {
                            *self.state =
                                ResXElementTypeContentSerializerState::CompositeGraphicUnits(
                                    WithSerializer::serializer(
                                        x,
                                        Some("CompositeGraphicUnits"),
                                        false,
                                    )?,
                                )
                        }
                    },
                    ResXElementTypeContentSerializerState::ColorSpaces(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResXElementTypeContentSerializerState::Done__,
                        }
                    }
                    ResXElementTypeContentSerializerState::DrawParams(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResXElementTypeContentSerializerState::Done__,
                        }
                    }
                    ResXElementTypeContentSerializerState::Fonts(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResXElementTypeContentSerializerState::Done__,
                        }
                    }
                    ResXElementTypeContentSerializerState::MultiMedias(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResXElementTypeContentSerializerState::Done__,
                        }
                    }
                    ResXElementTypeContentSerializerState::CompositeGraphicUnits(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResXElementTypeContentSerializerState::Done__,
                        }
                    }
                    ResXElementTypeContentSerializerState::Done__ => return Ok(None),
                    ResXElementTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ResXElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResXElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SianatureXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SianatureXElementType,
        pub(super) state: Box<SianatureXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SianatureXElementTypeSerializerState<'ser> {
        Init__,
        SiqnedInfo(<super::SianatureSiqnedInfoXElementType as WithSerializer>::Serializer<'ser>),
        SignedValue(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SianatureXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SianatureXElementTypeSerializerState::Init__ => {
                        *self.state = SianatureXElementTypeSerializerState::SiqnedInfo(
                            WithSerializer::serializer(
                                &self.value.siqned_info,
                                Some("SiqnedInfo"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SianatureXElementTypeSerializerState::SiqnedInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SianatureXElementTypeSerializerState::SignedValue(
                                    WithSerializer::serializer(
                                        &self.value.signed_value,
                                        Some("SignedValue"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    SianatureXElementTypeSerializerState::SignedValue(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SianatureXElementTypeSerializerState::End__,
                        }
                    }
                    SianatureXElementTypeSerializerState::End__ => {
                        *self.state = SianatureXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SianatureXElementTypeSerializerState::Done__ => return Ok(None),
                    SianatureXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SianatureXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SianatureXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SiqnaturesXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SiqnaturesXElementType,
        pub(super) state: Box<SiqnaturesXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SiqnaturesXElementTypeSerializerState<'ser> {
        Init__,
        MaxSignId(IterSerializer<'ser, Option<&'ser String>, String>),
        Signature(
            IterSerializer<
                'ser,
                &'ser [super::SiqnaturesSignatureXElementType],
                super::SiqnaturesSignatureXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SiqnaturesXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SiqnaturesXElementTypeSerializerState::Init__ => {
                        *self.state =
                            SiqnaturesXElementTypeSerializerState::MaxSignId(IterSerializer::new(
                                self.value.max_sign_id.as_ref(),
                                Some("MaxSignId"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SiqnaturesXElementTypeSerializerState::MaxSignId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SiqnaturesXElementTypeSerializerState::Signature(
                                    IterSerializer::new(
                                        &self.value.signature[..],
                                        Some("Signature"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SiqnaturesXElementTypeSerializerState::Signature(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SiqnaturesXElementTypeSerializerState::End__,
                        }
                    }
                    SiqnaturesXElementTypeSerializerState::End__ => {
                        *self.state = SiqnaturesXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SiqnaturesXElementTypeSerializerState::Done__ => return Ok(None),
                    SiqnaturesXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SiqnaturesXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SiqnaturesXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct AnnotationsPageXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::AnnotationsPageXElementType,
        pub(super) state: Box<AnnotationsPageXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum AnnotationsPageXElementTypeSerializerState<'ser> {
        Init__,
        FileLoc(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> AnnotationsPageXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    AnnotationsPageXElementTypeSerializerState::Init__ => {
                        *self.state = AnnotationsPageXElementTypeSerializerState::FileLoc(
                            WithSerializer::serializer(
                                &self.value.file_loc,
                                Some("FileLoc"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "PageID", &self.value.page_id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    AnnotationsPageXElementTypeSerializerState::FileLoc(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = AnnotationsPageXElementTypeSerializerState::End__,
                        }
                    }
                    AnnotationsPageXElementTypeSerializerState::End__ => {
                        *self.state = AnnotationsPageXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    AnnotationsPageXElementTypeSerializerState::Done__ => return Ok(None),
                    AnnotationsPageXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for AnnotationsPageXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = AnnotationsPageXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtActionGotoXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtActionGotoXElementType,
        pub(super) state: Box<CtActionGotoXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtActionGotoXElementTypeSerializerState<'ser> {
        Init__,
        Dest(<super::CtDestXType as WithSerializer>::Serializer<'ser>),
        Bookmark(<super::CtActionGotoBookmarkXElementType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtActionGotoXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtActionGotoXElementTypeSerializerState::Init__ => {
                        match self.value {
                            super::CtActionGotoXElementType::Dest(x) => {
                                *self.state = CtActionGotoXElementTypeSerializerState::Dest(
                                    WithSerializer::serializer(x, Some("Dest"), self.is_root)?,
                                )
                            }
                            super::CtActionGotoXElementType::Bookmark(x) => {
                                *self.state = CtActionGotoXElementTypeSerializerState::Bookmark(
                                    WithSerializer::serializer(x, Some("Bookmark"), self.is_root)?,
                                )
                            }
                        }
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtActionGotoXElementTypeSerializerState::Dest(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtActionGotoXElementTypeSerializerState::End__,
                        }
                    }
                    CtActionGotoXElementTypeSerializerState::Bookmark(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtActionGotoXElementTypeSerializerState::End__,
                        }
                    }
                    CtActionGotoXElementTypeSerializerState::End__ => {
                        *self.state = CtActionGotoXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtActionGotoXElementTypeSerializerState::Done__ => return Ok(None),
                    CtActionGotoXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtActionGotoXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtActionGotoXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtActionUriXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtActionUriXElementType,
        pub(super) state: Box<CtActionUriXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtActionUriXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtActionUriXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtActionUriXElementTypeSerializerState::Init__ => {
                        *self.state = CtActionUriXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "URI", &self.value.uri)?;
                        write_attrib_opt(&mut bytes, "Base", &self.value.base)?;
                        write_attrib_opt(&mut bytes, "Target", &self.value.target)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtActionUriXElementTypeSerializerState::Done__ => return Ok(None),
                    CtActionUriXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtActionUriXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtActionUriXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtActionGotoAxElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtActionGotoAxElementType,
        pub(super) state: Box<CtActionGotoAxElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtActionGotoAxElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtActionGotoAxElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtActionGotoAxElementTypeSerializerState::Init__ => {
                        *self.state = CtActionGotoAxElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "AttachID", &self.value.attach_id)?;
                        write_attrib(&mut bytes, "NewWindow", &self.value.new_window)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtActionGotoAxElementTypeSerializerState::Done__ => return Ok(None),
                    CtActionGotoAxElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtActionGotoAxElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtActionGotoAxElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtActionSoundXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtActionSoundXElementType,
        pub(super) state: Box<CtActionSoundXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtActionSoundXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtActionSoundXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtActionSoundXElementTypeSerializerState::Init__ => {
                        *self.state = CtActionSoundXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ResourceID", &self.value.resource_id)?;
                        write_attrib_opt(&mut bytes, "Volume", &self.value.volume)?;
                        write_attrib_opt(&mut bytes, "Repeat", &self.value.repeat)?;
                        write_attrib_opt(&mut bytes, "Synchronous", &self.value.synchronous)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtActionSoundXElementTypeSerializerState::Done__ => return Ok(None),
                    CtActionSoundXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtActionSoundXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtActionSoundXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtActionMovieXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtActionMovieXElementType,
        pub(super) state: Box<CtActionMovieXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtActionMovieXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtActionMovieXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtActionMovieXElementTypeSerializerState::Init__ => {
                        *self.state = CtActionMovieXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ResourceID", &self.value.resource_id)?;
                        write_attrib(&mut bytes, "Operator", &self.value.operator)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtActionMovieXElementTypeSerializerState::Done__ => return Ok(None),
                    CtActionMovieXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtActionMovieXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtActionMovieXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtAxialShdSegmentXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtAxialShdSegmentXElementType,
        pub(super) state: Box<CtAxialShdSegmentXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtAxialShdSegmentXElementTypeSerializerState<'ser> {
        Init__,
        Color(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtAxialShdSegmentXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtAxialShdSegmentXElementTypeSerializerState::Init__ => {
                        *self.state = CtAxialShdSegmentXElementTypeSerializerState::Color(
                            WithSerializer::serializer(&self.value.color, Some("Color"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "Position", &self.value.position)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtAxialShdSegmentXElementTypeSerializerState::Color(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtAxialShdSegmentXElementTypeSerializerState::End__,
                    },
                    CtAxialShdSegmentXElementTypeSerializerState::End__ => {
                        *self.state = CtAxialShdSegmentXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtAxialShdSegmentXElementTypeSerializerState::Done__ => return Ok(None),
                    CtAxialShdSegmentXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtAxialShdSegmentXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtAxialShdSegmentXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtClipAreaXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtClipAreaXElementType,
        pub(super) state: Box<CtClipAreaXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtClipAreaXElementTypeSerializerState<'ser> {
        Init__,
        Content__(<super::CtClipAreaXElementTypeContent as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtClipAreaXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtClipAreaXElementTypeSerializerState::Init__ => {
                        *self.state = CtClipAreaXElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtClipAreaXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtClipAreaXElementTypeSerializerState::End__,
                        }
                    }
                    CtClipAreaXElementTypeSerializerState::End__ => {
                        *self.state = CtClipAreaXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtClipAreaXElementTypeSerializerState::Done__ => return Ok(None),
                    CtClipAreaXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtClipAreaXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtClipAreaXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtClipAreaXElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtClipAreaXElementTypeContent,
        pub(super) state: Box<CtClipAreaXElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtClipAreaXElementTypeContentSerializerState<'ser> {
        Init__,
        Path(<super::CtPathXType as WithSerializer>::Serializer<'ser>),
        Text(<super::CtTextXType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtClipAreaXElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtClipAreaXElementTypeContentSerializerState::Init__ => match self.value {
                        super::CtClipAreaXElementTypeContent::Path(x) => {
                            *self.state = CtClipAreaXElementTypeContentSerializerState::Path(
                                WithSerializer::serializer(x, Some("Path"), false)?,
                            )
                        }
                        super::CtClipAreaXElementTypeContent::Text(x) => {
                            *self.state = CtClipAreaXElementTypeContentSerializerState::Text(
                                WithSerializer::serializer(x, Some("Text"), false)?,
                            )
                        }
                    },
                    CtClipAreaXElementTypeContentSerializerState::Path(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtClipAreaXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtClipAreaXElementTypeContentSerializerState::Text(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtClipAreaXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtClipAreaXElementTypeContentSerializerState::Done__ => return Ok(None),
                    CtClipAreaXElementTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtClipAreaXElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtClipAreaXElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtColorSpacePaletteXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtColorSpacePaletteXElementType,
        pub(super) state: Box<CtColorSpacePaletteXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtColorSpacePaletteXElementTypeSerializerState<'ser> {
        Init__,
        Cv(IterSerializer<'ser, &'ser [String], String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtColorSpacePaletteXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtColorSpacePaletteXElementTypeSerializerState::Init__ => {
                        *self.state = CtColorSpacePaletteXElementTypeSerializerState::Cv(
                            IterSerializer::new(&self.value.cv[..], Some("CV"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtColorSpacePaletteXElementTypeSerializerState::Cv(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtColorSpacePaletteXElementTypeSerializerState::End__,
                    },
                    CtColorSpacePaletteXElementTypeSerializerState::End__ => {
                        *self.state = CtColorSpacePaletteXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtColorSpacePaletteXElementTypeSerializerState::Done__ => return Ok(None),
                    CtColorSpacePaletteXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtColorSpacePaletteXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtColorSpacePaletteXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitActionsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtGraphicUnitActionsXElementType,
        pub(super) state: Box<CtGraphicUnitActionsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtGraphicUnitActionsXElementTypeSerializerState<'ser> {
        Init__,
        Action(IterSerializer<'ser, &'ser [super::CtActionXType], super::CtActionXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtGraphicUnitActionsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtGraphicUnitActionsXElementTypeSerializerState::Init__ => {
                        *self.state = CtGraphicUnitActionsXElementTypeSerializerState::Action(
                            IterSerializer::new(&self.value.action[..], Some("Action"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtGraphicUnitActionsXElementTypeSerializerState::Action(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtGraphicUnitActionsXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtGraphicUnitActionsXElementTypeSerializerState::End__ => {
                        *self.state = CtGraphicUnitActionsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtGraphicUnitActionsXElementTypeSerializerState::Done__ => return Ok(None),
                    CtGraphicUnitActionsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtGraphicUnitActionsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtGraphicUnitActionsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitClipsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtGraphicUnitClipsXElementType,
        pub(super) state: Box<CtGraphicUnitClipsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtGraphicUnitClipsXElementTypeSerializerState<'ser> {
        Init__,
        Clip(IterSerializer<'ser, &'ser [super::CtClipXType], super::CtClipXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtGraphicUnitClipsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtGraphicUnitClipsXElementTypeSerializerState::Init__ => {
                        *self.state = CtGraphicUnitClipsXElementTypeSerializerState::Clip(
                            IterSerializer::new(&self.value.clip[..], Some("Clip"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtGraphicUnitClipsXElementTypeSerializerState::Clip(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtGraphicUnitClipsXElementTypeSerializerState::End__,
                    },
                    CtGraphicUnitClipsXElementTypeSerializerState::End__ => {
                        *self.state = CtGraphicUnitClipsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtGraphicUnitClipsXElementTypeSerializerState::Done__ => return Ok(None),
                    CtGraphicUnitClipsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtGraphicUnitClipsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtGraphicUnitClipsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtDocInfoKeywordsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtDocInfoKeywordsXElementType,
        pub(super) state: Box<CtDocInfoKeywordsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtDocInfoKeywordsXElementTypeSerializerState<'ser> {
        Init__,
        Keyword(IterSerializer<'ser, &'ser [String], String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtDocInfoKeywordsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtDocInfoKeywordsXElementTypeSerializerState::Init__ => {
                        *self.state = CtDocInfoKeywordsXElementTypeSerializerState::Keyword(
                            IterSerializer::new(&self.value.keyword[..], Some("Keyword"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtDocInfoKeywordsXElementTypeSerializerState::Keyword(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtDocInfoKeywordsXElementTypeSerializerState::End__,
                    },
                    CtDocInfoKeywordsXElementTypeSerializerState::End__ => {
                        *self.state = CtDocInfoKeywordsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtDocInfoKeywordsXElementTypeSerializerState::Done__ => return Ok(None),
                    CtDocInfoKeywordsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtDocInfoKeywordsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtDocInfoKeywordsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtDocInfoCustomDatasXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtDocInfoCustomDatasXElementType,
        pub(super) state: Box<CtDocInfoCustomDatasXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtDocInfoCustomDatasXElementTypeSerializerState<'ser> {
        Init__,
        CustomData(
            IterSerializer<
                'ser,
                &'ser [super::CtDocInfoCustomDatasCustomDataXElementType],
                super::CtDocInfoCustomDatasCustomDataXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtDocInfoCustomDatasXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtDocInfoCustomDatasXElementTypeSerializerState::Init__ => {
                        *self.state = CtDocInfoCustomDatasXElementTypeSerializerState::CustomData(
                            IterSerializer::new(
                                &self.value.custom_data[..],
                                Some("CustomData"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtDocInfoCustomDatasXElementTypeSerializerState::CustomData(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtDocInfoCustomDatasXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtDocInfoCustomDatasXElementTypeSerializerState::End__ => {
                        *self.state = CtDocInfoCustomDatasXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtDocInfoCustomDatasXElementTypeSerializerState::Done__ => return Ok(None),
                    CtDocInfoCustomDatasXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtDocInfoCustomDatasXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtDocInfoCustomDatasXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtExtensionPropertyXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtExtensionPropertyXElementType,
        pub(super) state: Box<CtExtensionPropertyXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtExtensionPropertyXElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtExtensionPropertyXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtExtensionPropertyXElementTypeSerializerState::Init__ => {
                        *self.state = CtExtensionPropertyXElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Name", &self.value.name)?;
                        write_attrib_opt(&mut bytes, "Type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtExtensionPropertyXElementTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose(
                    )? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtExtensionPropertyXElementTypeSerializerState::End__,
                    },
                    CtExtensionPropertyXElementTypeSerializerState::End__ => {
                        *self.state = CtExtensionPropertyXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtExtensionPropertyXElementTypeSerializerState::Done__ => return Ok(None),
                    CtExtensionPropertyXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtExtensionPropertyXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtExtensionPropertyXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtGouraudShdPointXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtGouraudShdPointXElementType,
        pub(super) state: Box<CtGouraudShdPointXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtGouraudShdPointXElementTypeSerializerState<'ser> {
        Init__,
        Color(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtGouraudShdPointXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtGouraudShdPointXElementTypeSerializerState::Init__ => {
                        *self.state = CtGouraudShdPointXElementTypeSerializerState::Color(
                            WithSerializer::serializer(&self.value.color, Some("Color"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "X", &self.value.x)?;
                        write_attrib(&mut bytes, "y", &self.value.y)?;
                        write_attrib_opt(&mut bytes, "EdgeFlag", &self.value.edge_flag)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtGouraudShdPointXElementTypeSerializerState::Color(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtGouraudShdPointXElementTypeSerializerState::End__,
                    },
                    CtGouraudShdPointXElementTypeSerializerState::End__ => {
                        *self.state = CtGouraudShdPointXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtGouraudShdPointXElementTypeSerializerState::Done__ => return Ok(None),
                    CtGouraudShdPointXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtGouraudShdPointXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtGouraudShdPointXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtImageBorderXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtImageBorderXElementType,
        pub(super) state: Box<CtImageBorderXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtImageBorderXElementTypeSerializerState<'ser> {
        Init__,
        BorderColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtImageBorderXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtImageBorderXElementTypeSerializerState::Init__ => {
                        *self.state = CtImageBorderXElementTypeSerializerState::BorderColor(
                            IterSerializer::new(
                                self.value.border_color.as_ref(),
                                Some("BorderColor"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(
                            &mut bytes,
                            "HorizonalCornerRadius",
                            &self.value.horizonal_corner_radius,
                        )?;
                        write_attrib(
                            &mut bytes,
                            "VerticalCornerRadius",
                            &self.value.vertical_corner_radius,
                        )?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtImageBorderXElementTypeSerializerState::BorderColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtImageBorderXElementTypeSerializerState::End__,
                        }
                    }
                    CtImageBorderXElementTypeSerializerState::End__ => {
                        *self.state = CtImageBorderXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtImageBorderXElementTypeSerializerState::Done__ => return Ok(None),
                    CtImageBorderXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtImageBorderXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtImageBorderXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtLaGouraudShdPointXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtLaGouraudShdPointXElementType,
        pub(super) state: Box<CtLaGouraudShdPointXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtLaGouraudShdPointXElementTypeSerializerState<'ser> {
        Init__,
        Color(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtLaGouraudShdPointXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtLaGouraudShdPointXElementTypeSerializerState::Init__ => {
                        *self.state = CtLaGouraudShdPointXElementTypeSerializerState::Color(
                            WithSerializer::serializer(&self.value.color, Some("Color"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "X", &self.value.x)?;
                        write_attrib_opt(&mut bytes, "y", &self.value.y)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtLaGouraudShdPointXElementTypeSerializerState::Color(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CtLaGouraudShdPointXElementTypeSerializerState::End__,
                    },
                    CtLaGouraudShdPointXElementTypeSerializerState::End__ => {
                        *self.state = CtLaGouraudShdPointXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtLaGouraudShdPointXElementTypeSerializerState::Done__ => return Ok(None),
                    CtLaGouraudShdPointXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtLaGouraudShdPointXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtLaGouraudShdPointXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockTextObjectXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockTextObjectXElementType,
        pub(super) state: Box<CtPageBlockTextObjectXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockTextObjectXElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::CtPageBlockTextObjectXElementTypeContent],
                super::CtPageBlockTextObjectXElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockTextObjectXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockTextObjectXElementTypeSerializerState::Init__ => {
                        *self.state = CtPageBlockTextObjectXElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        write_attrib(&mut bytes, "Font", &self.value.font)?;
                        write_attrib(&mut bytes, "Size", &self.value.size)?;
                        write_attrib(&mut bytes, "Stroke", &self.value.stroke)?;
                        write_attrib(&mut bytes, "Fill", &self.value.fill)?;
                        write_attrib(&mut bytes, "HScale", &self.value.h_scale)?;
                        write_attrib(&mut bytes, "ReadDirection", &self.value.read_direction)?;
                        write_attrib(&mut bytes, "CharDirection", &self.value.char_direction)?;
                        write_attrib(&mut bytes, "Weight", &self.value.weight)?;
                        write_attrib(&mut bytes, "Italic", &self.value.italic)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPageBlockTextObjectXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockTextObjectXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtPageBlockTextObjectXElementTypeSerializerState::End__ => {
                        *self.state = CtPageBlockTextObjectXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPageBlockTextObjectXElementTypeSerializerState::Done__ => return Ok(None),
                    CtPageBlockTextObjectXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockTextObjectXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockTextObjectXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockTextObjectXElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockTextObjectXElementTypeContent,
        pub(super) state: Box<CtPageBlockTextObjectXElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockTextObjectXElementTypeContentSerializerState<'ser> {
        Init__,
        Actions(<super::CtGraphicUnitActionsXElementType as WithSerializer>::Serializer<'ser>),
        Clips(<super::CtGraphicUnitClipsXElementType as WithSerializer>::Serializer<'ser>),
        FillColor(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
        StrokeColor(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
        CgTransform(<super::CtCgTransformXType as WithSerializer>::Serializer<'ser>),
        TextCode(<super::CtTextTextCodeXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockTextObjectXElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockTextObjectXElementTypeContentSerializerState::Init__ => {
                        match self . value { super :: CtPageBlockTextObjectXElementTypeContent :: Actions (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Actions (WithSerializer :: serializer (x , Some ("Actions") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: Clips (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Clips (WithSerializer :: serializer (x , Some ("Clips") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: FillColor (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: FillColor (WithSerializer :: serializer (x , Some ("FillColor") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: StrokeColor (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: StrokeColor (WithSerializer :: serializer (x , Some ("StrokeColor") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: CgTransform (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: CgTransform (WithSerializer :: serializer (x , Some ("CGTransform") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: TextCode (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: TextCode (WithSerializer :: serializer (x , Some ("TextCode") , false) ?) , }
                    }
                    CtPageBlockTextObjectXElementTypeContentSerializerState::Actions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockTextObjectXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockTextObjectXElementTypeContentSerializerState::Clips(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockTextObjectXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockTextObjectXElementTypeContentSerializerState::FillColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockTextObjectXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockTextObjectXElementTypeContentSerializerState::StrokeColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockTextObjectXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockTextObjectXElementTypeContentSerializerState::CgTransform(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockTextObjectXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockTextObjectXElementTypeContentSerializerState::TextCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockTextObjectXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockTextObjectXElementTypeContentSerializerState::Done__ => {
                        return Ok(None)
                    }
                    CtPageBlockTextObjectXElementTypeContentSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockTextObjectXElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockTextObjectXElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockPathObjectXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockPathObjectXElementType,
        pub(super) state: Box<CtPageBlockPathObjectXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockPathObjectXElementTypeSerializerState<'ser> {
        Init__,
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        Clips(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitClipsXElementType>,
                super::CtGraphicUnitClipsXElementType,
            >,
        ),
        StrokeColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        FillColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        AbbreviatedData(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockPathObjectXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockPathObjectXElementTypeSerializerState::Init__ => {
                        *self.state = CtPageBlockPathObjectXElementTypeSerializerState::Actions(
                            IterSerializer::new(
                                self.value.actions.as_ref(),
                                Some("Actions"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        write_attrib(&mut bytes, "Stroke", &self.value.stroke)?;
                        write_attrib(&mut bytes, "Fill", &self.value.fill)?;
                        write_attrib(&mut bytes, "Rule", &self.value.rule)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPageBlockPathObjectXElementTypeSerializerState::Actions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPathObjectXElementTypeSerializerState::Clips(
                                        IterSerializer::new(
                                            self.value.clips.as_ref(),
                                            Some("Clips"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    CtPageBlockPathObjectXElementTypeSerializerState::Clips(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPathObjectXElementTypeSerializerState::StrokeColor(
                                        IterSerializer::new(
                                            self.value.stroke_color.as_ref(),
                                            Some("StrokeColor"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    CtPageBlockPathObjectXElementTypeSerializerState::StrokeColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPathObjectXElementTypeSerializerState::FillColor(
                                        IterSerializer::new(
                                            self.value.fill_color.as_ref(),
                                            Some("FillColor"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    CtPageBlockPathObjectXElementTypeSerializerState::FillColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                CtPageBlockPathObjectXElementTypeSerializerState::AbbreviatedData(
                                    WithSerializer::serializer(
                                        &self.value.abbreviated_data,
                                        Some("AbbreviatedData"),
                                        false,
                                    )?,
                                ),
                        }
                    }
                    CtPageBlockPathObjectXElementTypeSerializerState::AbbreviatedData(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPathObjectXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtPageBlockPathObjectXElementTypeSerializerState::End__ => {
                        *self.state = CtPageBlockPathObjectXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPageBlockPathObjectXElementTypeSerializerState::Done__ => return Ok(None),
                    CtPageBlockPathObjectXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockPathObjectXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockPathObjectXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockImageObjectXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockImageObjectXElementType,
        pub(super) state: Box<CtPageBlockImageObjectXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockImageObjectXElementTypeSerializerState<'ser> {
        Init__,
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        Clips(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitClipsXElementType>,
                super::CtGraphicUnitClipsXElementType,
            >,
        ),
        Border(
            IterSerializer<
                'ser,
                Option<&'ser super::CtImageBorderXElementType>,
                super::CtImageBorderXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockImageObjectXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockImageObjectXElementTypeSerializerState::Init__ => {
                        *self.state = CtPageBlockImageObjectXElementTypeSerializerState::Actions(
                            IterSerializer::new(
                                self.value.actions.as_ref(),
                                Some("Actions"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        write_attrib(&mut bytes, "ResourceID", &self.value.resource_id)?;
                        write_attrib_opt(&mut bytes, "Substitution", &self.value.substitution)?;
                        write_attrib_opt(&mut bytes, "ImageMask", &self.value.image_mask)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPageBlockImageObjectXElementTypeSerializerState::Actions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockImageObjectXElementTypeSerializerState::Clips(
                                        IterSerializer::new(
                                            self.value.clips.as_ref(),
                                            Some("Clips"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    CtPageBlockImageObjectXElementTypeSerializerState::Clips(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockImageObjectXElementTypeSerializerState::Border(
                                        IterSerializer::new(
                                            self.value.border.as_ref(),
                                            Some("Border"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    CtPageBlockImageObjectXElementTypeSerializerState::Border(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockImageObjectXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtPageBlockImageObjectXElementTypeSerializerState::End__ => {
                        *self.state = CtPageBlockImageObjectXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPageBlockImageObjectXElementTypeSerializerState::Done__ => return Ok(None),
                    CtPageBlockImageObjectXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockImageObjectXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockImageObjectXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockCompositeObjectXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockCompositeObjectXElementType,
        pub(super) state: Box<CtPageBlockCompositeObjectXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockCompositeObjectXElementTypeSerializerState<'ser> {
        Init__,
        Actions(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitActionsXElementType>,
                super::CtGraphicUnitActionsXElementType,
            >,
        ),
        Clips(
            IterSerializer<
                'ser,
                Option<&'ser super::CtGraphicUnitClipsXElementType>,
                super::CtGraphicUnitClipsXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockCompositeObjectXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockCompositeObjectXElementTypeSerializerState::Init__ => {
                        *self.state =
                            CtPageBlockCompositeObjectXElementTypeSerializerState::Actions(
                                IterSerializer::new(
                                    self.value.actions.as_ref(),
                                    Some("Actions"),
                                    false,
                                ),
                            );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                        write_attrib(&mut bytes, "ResourceID", &self.value.resource_id)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPageBlockCompositeObjectXElementTypeSerializerState::Actions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockCompositeObjectXElementTypeSerializerState::Clips(
                                        IterSerializer::new(
                                            self.value.clips.as_ref(),
                                            Some("Clips"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    CtPageBlockCompositeObjectXElementTypeSerializerState::Clips(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockCompositeObjectXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtPageBlockCompositeObjectXElementTypeSerializerState::End__ => {
                        *self.state = CtPageBlockCompositeObjectXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPageBlockCompositeObjectXElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    CtPageBlockCompositeObjectXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockCompositeObjectXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockCompositeObjectXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockPageBlockXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockPageBlockXElementType,
        pub(super) state: Box<CtPageBlockPageBlockXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockPageBlockXElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::CtPageBlockPageBlockXElementTypeContent],
                super::CtPageBlockPageBlockXElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockPageBlockXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockPageBlockXElementTypeSerializerState::Init__ => {
                        *self.state = CtPageBlockPageBlockXElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPageBlockPageBlockXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtPageBlockPageBlockXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtPageBlockPageBlockXElementTypeSerializerState::End__ => {
                        *self.state = CtPageBlockPageBlockXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPageBlockPageBlockXElementTypeSerializerState::Done__ => return Ok(None),
                    CtPageBlockPageBlockXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockPageBlockXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockPageBlockXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockPageBlockXElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtPageBlockPageBlockXElementTypeContent,
        pub(super) state: Box<CtPageBlockPageBlockXElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtPageBlockPageBlockXElementTypeContentSerializerState<'ser> {
        Init__,
        TextObject(<super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>),
        PathObject(<super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>),
        ImageObject(
            <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        CompositeObject(
            <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        PageBlock(<super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPageBlockPageBlockXElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPageBlockPageBlockXElementTypeContentSerializerState::Init__ => {
                        match self . value { super :: CtPageBlockPageBlockXElementTypeContent :: TextObject (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: TextObject (WithSerializer :: serializer (x , Some ("TextObject") , false) ?) , super :: CtPageBlockPageBlockXElementTypeContent :: PathObject (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: PathObject (WithSerializer :: serializer (x , Some ("PathObject") , false) ?) , super :: CtPageBlockPageBlockXElementTypeContent :: ImageObject (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: ImageObject (WithSerializer :: serializer (x , Some ("ImageObject") , false) ?) , super :: CtPageBlockPageBlockXElementTypeContent :: CompositeObject (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: CompositeObject (WithSerializer :: serializer (x , Some ("CompositeObject") , false) ?) , super :: CtPageBlockPageBlockXElementTypeContent :: PageBlock (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: PageBlock (WithSerializer :: serializer (x , Some ("PageBlock") , false) ?) , }
                    }
                    CtPageBlockPageBlockXElementTypeContentSerializerState::TextObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPageBlockXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockPageBlockXElementTypeContentSerializerState::PathObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPageBlockXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockPageBlockXElementTypeContentSerializerState::ImageObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPageBlockXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockPageBlockXElementTypeContentSerializerState::CompositeObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPageBlockXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockPageBlockXElementTypeContentSerializerState::PageBlock(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPageBlockPageBlockXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPageBlockPageBlockXElementTypeContentSerializerState::Done__ => {
                        return Ok(None)
                    }
                    CtPageBlockPageBlockXElementTypeContentSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtPageBlockPageBlockXElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPageBlockPageBlockXElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPatternCellContentXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPatternCellContentXElementType,
        pub(super) state: Box<CtPatternCellContentXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPatternCellContentXElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::CtPatternCellContentXElementTypeContent],
                super::CtPatternCellContentXElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPatternCellContentXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPatternCellContentXElementTypeSerializerState::Init__ => {
                        *self.state = CtPatternCellContentXElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "Thumbnail", &self.value.thumbnail)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtPatternCellContentXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtPatternCellContentXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtPatternCellContentXElementTypeSerializerState::End__ => {
                        *self.state = CtPatternCellContentXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtPatternCellContentXElementTypeSerializerState::Done__ => return Ok(None),
                    CtPatternCellContentXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPatternCellContentXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPatternCellContentXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPatternCellContentXElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtPatternCellContentXElementTypeContent,
        pub(super) state: Box<CtPatternCellContentXElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtPatternCellContentXElementTypeContentSerializerState<'ser> {
        Init__,
        TextObject(<super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>),
        PathObject(<super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>),
        ImageObject(
            <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        CompositeObject(
            <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        PageBlock(<super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPatternCellContentXElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPatternCellContentXElementTypeContentSerializerState::Init__ => {
                        match self . value { super :: CtPatternCellContentXElementTypeContent :: TextObject (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: TextObject (WithSerializer :: serializer (x , Some ("TextObject") , false) ?) , super :: CtPatternCellContentXElementTypeContent :: PathObject (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: PathObject (WithSerializer :: serializer (x , Some ("PathObject") , false) ?) , super :: CtPatternCellContentXElementTypeContent :: ImageObject (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: ImageObject (WithSerializer :: serializer (x , Some ("ImageObject") , false) ?) , super :: CtPatternCellContentXElementTypeContent :: CompositeObject (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: CompositeObject (WithSerializer :: serializer (x , Some ("CompositeObject") , false) ?) , super :: CtPatternCellContentXElementTypeContent :: PageBlock (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: PageBlock (WithSerializer :: serializer (x , Some ("PageBlock") , false) ?) , }
                    }
                    CtPatternCellContentXElementTypeContentSerializerState::TextObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPatternCellContentXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPatternCellContentXElementTypeContentSerializerState::PathObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPatternCellContentXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPatternCellContentXElementTypeContentSerializerState::ImageObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPatternCellContentXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPatternCellContentXElementTypeContentSerializerState::CompositeObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPatternCellContentXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPatternCellContentXElementTypeContentSerializerState::PageBlock(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPatternCellContentXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtPatternCellContentXElementTypeContentSerializerState::Done__ => {
                        return Ok(None)
                    }
                    CtPatternCellContentXElementTypeContentSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtPatternCellContentXElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPatternCellContentXElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPermissionPrintXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPermissionPrintXElementType,
        pub(super) state: Box<CtPermissionPrintXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPermissionPrintXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPermissionPrintXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPermissionPrintXElementTypeSerializerState::Init__ => {
                        *self.state = CtPermissionPrintXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Printable", &self.value.printable)?;
                        write_attrib(&mut bytes, "Copies", &self.value.copies)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtPermissionPrintXElementTypeSerializerState::Done__ => return Ok(None),
                    CtPermissionPrintXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtPermissionPrintXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPermissionPrintXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPermissionValidPeriodXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtPermissionValidPeriodXElementType,
        pub(super) state: Box<CtPermissionValidPeriodXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtPermissionValidPeriodXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtPermissionValidPeriodXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtPermissionValidPeriodXElementTypeSerializerState::Init__ => {
                        *self.state = CtPermissionValidPeriodXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "StartDate", &self.value.start_date)?;
                        write_attrib_opt(&mut bytes, "EndDate", &self.value.end_date)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtPermissionValidPeriodXElementTypeSerializerState::Done__ => return Ok(None),
                    CtPermissionValidPeriodXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtPermissionValidPeriodXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtPermissionValidPeriodXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtRegionAreaXElementType,
        pub(super) state: Box<CtRegionAreaXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtRegionAreaXElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::CtRegionAreaXElementTypeContent],
                super::CtRegionAreaXElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtRegionAreaXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtRegionAreaXElementTypeSerializerState::Init__ => {
                        *self.state = CtRegionAreaXElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Start", &self.value.start)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtRegionAreaXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtRegionAreaXElementTypeSerializerState::End__,
                        }
                    }
                    CtRegionAreaXElementTypeSerializerState::End__ => {
                        *self.state = CtRegionAreaXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtRegionAreaXElementTypeSerializerState::Done__ => return Ok(None),
                    CtRegionAreaXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtRegionAreaXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtRegionAreaXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaXElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::CtRegionAreaXElementTypeContent,
        pub(super) state: Box<CtRegionAreaXElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum CtRegionAreaXElementTypeContentSerializerState<'ser> {
        Init__,
        Move(<super::CtRegionAreaLineXElementType as WithSerializer>::Serializer<'ser>),
        Line(<super::CtRegionAreaLineXElementType as WithSerializer>::Serializer<'ser>),
        OuadraticBezier(
            <super::CtRegionAreaOuadraticBezierXElementType as WithSerializer>::Serializer<'ser>,
        ),
        CubicBezier(
            <super::CtRegionAreaCubicBezierXElementType as WithSerializer>::Serializer<'ser>,
        ),
        Arc(<super::CtRegionAreaArcXElementType as WithSerializer>::Serializer<'ser>),
        Close(<super::xs::AnyTypeXType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtRegionAreaXElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtRegionAreaXElementTypeContentSerializerState::Init__ => match self.value {
                        super::CtRegionAreaXElementTypeContent::Move(x) => {
                            *self.state = CtRegionAreaXElementTypeContentSerializerState::Move(
                                WithSerializer::serializer(x, Some("Move"), false)?,
                            )
                        }
                        super::CtRegionAreaXElementTypeContent::Line(x) => {
                            *self.state = CtRegionAreaXElementTypeContentSerializerState::Line(
                                WithSerializer::serializer(x, Some("Line"), false)?,
                            )
                        }
                        super::CtRegionAreaXElementTypeContent::OuadraticBezier(x) => {
                            *self.state =
                                CtRegionAreaXElementTypeContentSerializerState::OuadraticBezier(
                                    WithSerializer::serializer(x, Some("OuadraticBezier"), false)?,
                                )
                        }
                        super::CtRegionAreaXElementTypeContent::CubicBezier(x) => {
                            *self.state =
                                CtRegionAreaXElementTypeContentSerializerState::CubicBezier(
                                    WithSerializer::serializer(x, Some("CubicBezier"), false)?,
                                )
                        }
                        super::CtRegionAreaXElementTypeContent::Arc(x) => {
                            *self.state = CtRegionAreaXElementTypeContentSerializerState::Arc(
                                WithSerializer::serializer(x, Some("Arc"), false)?,
                            )
                        }
                        super::CtRegionAreaXElementTypeContent::Close(x) => {
                            *self.state = CtRegionAreaXElementTypeContentSerializerState::Close(
                                WithSerializer::serializer(x, Some("Close"), false)?,
                            )
                        }
                    },
                    CtRegionAreaXElementTypeContentSerializerState::Move(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtRegionAreaXElementTypeContentSerializerState::Line(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtRegionAreaXElementTypeContentSerializerState::OuadraticBezier(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtRegionAreaXElementTypeContentSerializerState::CubicBezier(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtRegionAreaXElementTypeContentSerializerState::Arc(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtRegionAreaXElementTypeContentSerializerState::Close(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    CtRegionAreaXElementTypeContentSerializerState::Done__ => return Ok(None),
                    CtRegionAreaXElementTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtRegionAreaXElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtRegionAreaXElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtTextTextCodeXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtTextTextCodeXElementType,
        pub(super) state: Box<CtTextTextCodeXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtTextTextCodeXElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtTextTextCodeXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtTextTextCodeXElementTypeSerializerState::Init__ => {
                        *self.state = CtTextTextCodeXElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "X", &self.value.x)?;
                        write_attrib_opt(&mut bytes, "y", &self.value.y)?;
                        write_attrib_opt(&mut bytes, "DeltaX", &self.value.delta_x)?;
                        write_attrib_opt(&mut bytes, "Deltay", &self.value.deltay)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtTextTextCodeXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtTextTextCodeXElementTypeSerializerState::End__,
                        }
                    }
                    CtTextTextCodeXElementTypeSerializerState::End__ => {
                        *self.state = CtTextTextCodeXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtTextTextCodeXElementTypeSerializerState::Done__ => return Ok(None),
                    CtTextTextCodeXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtTextTextCodeXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtTextTextCodeXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CustomTagsCustomTagXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CustomTagsCustomTagXElementType,
        pub(super) state: Box<CustomTagsCustomTagXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CustomTagsCustomTagXElementTypeSerializerState<'ser> {
        Init__,
        SchemaLoc(IterSerializer<'ser, Option<&'ser String>, String>),
        FileLoc(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CustomTagsCustomTagXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CustomTagsCustomTagXElementTypeSerializerState::Init__ => {
                        *self.state = CustomTagsCustomTagXElementTypeSerializerState::SchemaLoc(
                            IterSerializer::new(
                                self.value.schema_loc.as_ref(),
                                Some("SchemaLoc"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "NameSpace", &self.value.name_space)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CustomTagsCustomTagXElementTypeSerializerState::SchemaLoc(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CustomTagsCustomTagXElementTypeSerializerState::FileLoc(
                                        WithSerializer::serializer(
                                            &self.value.file_loc,
                                            Some("FileLoc"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    CustomTagsCustomTagXElementTypeSerializerState::FileLoc(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CustomTagsCustomTagXElementTypeSerializerState::End__,
                    },
                    CustomTagsCustomTagXElementTypeSerializerState::End__ => {
                        *self.state = CustomTagsCustomTagXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CustomTagsCustomTagXElementTypeSerializerState::Done__ => return Ok(None),
                    CustomTagsCustomTagXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CustomTagsCustomTagXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CustomTagsCustomTagXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocVersionFileListXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocVersionFileListXElementType,
        pub(super) state: Box<DocVersionFileListXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocVersionFileListXElementTypeSerializerState<'ser> {
        Init__,
        File(
            IterSerializer<
                'ser,
                &'ser [super::DocVersionFileListFileXElementType],
                super::DocVersionFileListFileXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocVersionFileListXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocVersionFileListXElementTypeSerializerState::Init__ => {
                        *self.state = DocVersionFileListXElementTypeSerializerState::File(
                            IterSerializer::new(&self.value.file[..], Some("File"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocVersionFileListXElementTypeSerializerState::File(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DocVersionFileListXElementTypeSerializerState::End__,
                    },
                    DocVersionFileListXElementTypeSerializerState::End__ => {
                        *self.state = DocVersionFileListXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocVersionFileListXElementTypeSerializerState::Done__ => return Ok(None),
                    DocVersionFileListXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocVersionFileListXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocVersionFileListXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentCommonDataXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentCommonDataXElementType,
        pub(super) state: Box<DocumentCommonDataXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentCommonDataXElementTypeSerializerState<'ser> {
        Init__,
        MaxUnitId(<u32 as WithSerializer>::Serializer<'ser>),
        PageArea(<super::CtPageAreaXType as WithSerializer>::Serializer<'ser>),
        PublicRes(IterSerializer<'ser, &'ser [String], String>),
        DocumentRes(IterSerializer<'ser, &'ser [String], String>),
        TemplatePage(
            IterSerializer<
                'ser,
                &'ser [super::DocumentCommonDataTemplatePageXElementType],
                super::DocumentCommonDataTemplatePageXElementType,
            >,
        ),
        DefaultCs(IterSerializer<'ser, Option<&'ser u32>, u32>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentCommonDataXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentCommonDataXElementTypeSerializerState::Init__ => {
                        *self.state = DocumentCommonDataXElementTypeSerializerState::MaxUnitId(
                            WithSerializer::serializer(
                                &self.value.max_unit_id,
                                Some("MaxUnitID"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocumentCommonDataXElementTypeSerializerState::MaxUnitId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    DocumentCommonDataXElementTypeSerializerState::PageArea(
                                        WithSerializer::serializer(
                                            &self.value.page_area,
                                            Some("PageArea"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    DocumentCommonDataXElementTypeSerializerState::PageArea(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    DocumentCommonDataXElementTypeSerializerState::PublicRes(
                                        IterSerializer::new(
                                            &self.value.public_res[..],
                                            Some("PublicRes"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    DocumentCommonDataXElementTypeSerializerState::PublicRes(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    DocumentCommonDataXElementTypeSerializerState::DocumentRes(
                                        IterSerializer::new(
                                            &self.value.document_res[..],
                                            Some("DocumentRes"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    DocumentCommonDataXElementTypeSerializerState::DocumentRes(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    DocumentCommonDataXElementTypeSerializerState::TemplatePage(
                                        IterSerializer::new(
                                            &self.value.template_page[..],
                                            Some("TemplatePage"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    DocumentCommonDataXElementTypeSerializerState::TemplatePage(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    DocumentCommonDataXElementTypeSerializerState::DefaultCs(
                                        IterSerializer::new(
                                            self.value.default_cs.as_ref(),
                                            Some("DefaultCs"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    DocumentCommonDataXElementTypeSerializerState::DefaultCs(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DocumentCommonDataXElementTypeSerializerState::End__,
                    },
                    DocumentCommonDataXElementTypeSerializerState::End__ => {
                        *self.state = DocumentCommonDataXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocumentCommonDataXElementTypeSerializerState::Done__ => return Ok(None),
                    DocumentCommonDataXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentCommonDataXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentCommonDataXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentPagesXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentPagesXElementType,
        pub(super) state: Box<DocumentPagesXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentPagesXElementTypeSerializerState<'ser> {
        Init__,
        Page(
            IterSerializer<
                'ser,
                &'ser [super::DocumentPagesPageXElementType],
                super::DocumentPagesPageXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentPagesXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentPagesXElementTypeSerializerState::Init__ => {
                        *self.state = DocumentPagesXElementTypeSerializerState::Page(
                            IterSerializer::new(&self.value.page[..], Some("Page"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocumentPagesXElementTypeSerializerState::Page(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DocumentPagesXElementTypeSerializerState::End__,
                        }
                    }
                    DocumentPagesXElementTypeSerializerState::End__ => {
                        *self.state = DocumentPagesXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocumentPagesXElementTypeSerializerState::Done__ => return Ok(None),
                    DocumentPagesXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentPagesXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentPagesXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentOutlinesXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentOutlinesXElementType,
        pub(super) state: Box<DocumentOutlinesXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentOutlinesXElementTypeSerializerState<'ser> {
        Init__,
        OutlineElem(
            IterSerializer<'ser, &'ser [super::CtOutlineElemXType], super::CtOutlineElemXType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentOutlinesXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentOutlinesXElementTypeSerializerState::Init__ => {
                        *self.state = DocumentOutlinesXElementTypeSerializerState::OutlineElem(
                            IterSerializer::new(
                                &self.value.outline_elem[..],
                                Some("OutlineElem"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocumentOutlinesXElementTypeSerializerState::OutlineElem(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DocumentOutlinesXElementTypeSerializerState::End__,
                    },
                    DocumentOutlinesXElementTypeSerializerState::End__ => {
                        *self.state = DocumentOutlinesXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocumentOutlinesXElementTypeSerializerState::Done__ => return Ok(None),
                    DocumentOutlinesXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentOutlinesXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentOutlinesXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentBookmarksXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentBookmarksXElementType,
        pub(super) state: Box<DocumentBookmarksXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentBookmarksXElementTypeSerializerState<'ser> {
        Init__,
        Bookmark(IterSerializer<'ser, &'ser [super::CtBookmarkXType], super::CtBookmarkXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentBookmarksXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentBookmarksXElementTypeSerializerState::Init__ => {
                        *self.state = DocumentBookmarksXElementTypeSerializerState::Bookmark(
                            IterSerializer::new(&self.value.bookmark[..], Some("Bookmark"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocumentBookmarksXElementTypeSerializerState::Bookmark(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DocumentBookmarksXElementTypeSerializerState::End__,
                    },
                    DocumentBookmarksXElementTypeSerializerState::End__ => {
                        *self.state = DocumentBookmarksXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocumentBookmarksXElementTypeSerializerState::Done__ => return Ok(None),
                    DocumentBookmarksXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentBookmarksXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentBookmarksXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct OfdDocBodyXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::OfdDocBodyXElementType,
        pub(super) state: Box<OfdDocBodyXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum OfdDocBodyXElementTypeSerializerState<'ser> {
        Init__,
        DocInfo(<super::CtDocInfoXType as WithSerializer>::Serializer<'ser>),
        DocRoot(<String as WithSerializer>::Serializer<'ser>),
        Versions(
            IterSerializer<
                'ser,
                Option<&'ser super::OfdDocBodyVersionsXElementType>,
                super::OfdDocBodyVersionsXElementType,
            >,
        ),
        Signatures(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> OfdDocBodyXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    OfdDocBodyXElementTypeSerializerState::Init__ => {
                        *self.state = OfdDocBodyXElementTypeSerializerState::DocInfo(
                            WithSerializer::serializer(
                                &self.value.doc_info,
                                Some("DocInfo"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    OfdDocBodyXElementTypeSerializerState::DocInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = OfdDocBodyXElementTypeSerializerState::DocRoot(
                                    WithSerializer::serializer(
                                        &self.value.doc_root,
                                        Some("DocRoot"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    OfdDocBodyXElementTypeSerializerState::DocRoot(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = OfdDocBodyXElementTypeSerializerState::Versions(
                                    IterSerializer::new(
                                        self.value.versions.as_ref(),
                                        Some("Versions"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    OfdDocBodyXElementTypeSerializerState::Versions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = OfdDocBodyXElementTypeSerializerState::Signatures(
                                    IterSerializer::new(
                                        self.value.signatures.as_ref(),
                                        Some("Signatures"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    OfdDocBodyXElementTypeSerializerState::Signatures(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = OfdDocBodyXElementTypeSerializerState::End__,
                        }
                    }
                    OfdDocBodyXElementTypeSerializerState::End__ => {
                        *self.state = OfdDocBodyXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    OfdDocBodyXElementTypeSerializerState::Done__ => return Ok(None),
                    OfdDocBodyXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for OfdDocBodyXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = OfdDocBodyXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageTemplateXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PageTemplateXElementType,
        pub(super) state: Box<PageTemplateXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PageTemplateXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageTemplateXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageTemplateXElementTypeSerializerState::Init__ => {
                        *self.state = PageTemplateXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "TemplateID", &self.value.template_id)?;
                        write_attrib(&mut bytes, "ZOrder", &self.value.z_order)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    PageTemplateXElementTypeSerializerState::Done__ => return Ok(None),
                    PageTemplateXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PageTemplateXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageTemplateXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageContentXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PageContentXElementType,
        pub(super) state: Box<PageContentXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PageContentXElementTypeSerializerState<'ser> {
        Init__,
        Layer(
            IterSerializer<
                'ser,
                &'ser [super::PageContentLayerXElementType],
                super::PageContentLayerXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageContentXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageContentXElementTypeSerializerState::Init__ => {
                        *self.state = PageContentXElementTypeSerializerState::Layer(
                            IterSerializer::new(&self.value.layer[..], Some("Layer"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PageContentXElementTypeSerializerState::Layer(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = PageContentXElementTypeSerializerState::End__,
                        }
                    }
                    PageContentXElementTypeSerializerState::End__ => {
                        *self.state = PageContentXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PageContentXElementTypeSerializerState::Done__ => return Ok(None),
                    PageContentXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PageContentXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageContentXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PageAnnotAnnotXElementType,
        pub(super) state: Box<PageAnnotAnnotXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PageAnnotAnnotXElementTypeSerializerState<'ser> {
        Init__,
        Remark(IterSerializer<'ser, Option<&'ser String>, String>),
        Parameters(
            IterSerializer<
                'ser,
                Option<&'ser super::PageAnnotAnnotParametersXElementType>,
                super::PageAnnotAnnotParametersXElementType,
            >,
        ),
        Appearance(
            <super::PageAnnotAnnotAppearanceXElementType as WithSerializer>::Serializer<'ser>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageAnnotAnnotXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageAnnotAnnotXElementTypeSerializerState::Init__ => {
                        *self.state = PageAnnotAnnotXElementTypeSerializerState::Remark(
                            IterSerializer::new(self.value.remark.as_ref(), Some("Remark"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib(&mut bytes, "Creator", &self.value.creator)?;
                        write_attrib(&mut bytes, "LastModDate", &self.value.last_mod_date)?;
                        write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                        write_attrib_opt(&mut bytes, "Subtype", &self.value.subtype)?;
                        write_attrib(&mut bytes, "Print", &self.value.print)?;
                        write_attrib(&mut bytes, "NoZoom", &self.value.no_zoom)?;
                        write_attrib(&mut bytes, "NoRotate", &self.value.no_rotate)?;
                        write_attrib(&mut bytes, "ReadOnly", &self.value.read_only)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PageAnnotAnnotXElementTypeSerializerState::Remark(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = PageAnnotAnnotXElementTypeSerializerState::Parameters(
                                    IterSerializer::new(
                                        self.value.parameters.as_ref(),
                                        Some("Parameters"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    PageAnnotAnnotXElementTypeSerializerState::Parameters(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = PageAnnotAnnotXElementTypeSerializerState::Appearance(
                                    WithSerializer::serializer(
                                        &self.value.appearance,
                                        Some("Appearance"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    PageAnnotAnnotXElementTypeSerializerState::Appearance(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = PageAnnotAnnotXElementTypeSerializerState::End__,
                        }
                    }
                    PageAnnotAnnotXElementTypeSerializerState::End__ => {
                        *self.state = PageAnnotAnnotXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PageAnnotAnnotXElementTypeSerializerState::Done__ => return Ok(None),
                    PageAnnotAnnotXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PageAnnotAnnotXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageAnnotAnnotXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResColorSpacesXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResColorSpacesXElementType,
        pub(super) state: Box<ResColorSpacesXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResColorSpacesXElementTypeSerializerState<'ser> {
        Init__,
        ColorSpace(
            IterSerializer<
                'ser,
                &'ser [super::ResColorSpacesColorSpaceXElementType],
                super::ResColorSpacesColorSpaceXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResColorSpacesXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResColorSpacesXElementTypeSerializerState::Init__ => {
                        *self.state = ResColorSpacesXElementTypeSerializerState::ColorSpace(
                            IterSerializer::new(
                                &self.value.color_space[..],
                                Some("ColorSpace"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResColorSpacesXElementTypeSerializerState::ColorSpace(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResColorSpacesXElementTypeSerializerState::End__,
                        }
                    }
                    ResColorSpacesXElementTypeSerializerState::End__ => {
                        *self.state = ResColorSpacesXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResColorSpacesXElementTypeSerializerState::Done__ => return Ok(None),
                    ResColorSpacesXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ResColorSpacesXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResColorSpacesXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResDrawParamsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResDrawParamsXElementType,
        pub(super) state: Box<ResDrawParamsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResDrawParamsXElementTypeSerializerState<'ser> {
        Init__,
        DrawParam(
            IterSerializer<
                'ser,
                &'ser [super::ResDrawParamsDrawParamXElementType],
                super::ResDrawParamsDrawParamXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResDrawParamsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResDrawParamsXElementTypeSerializerState::Init__ => {
                        *self.state = ResDrawParamsXElementTypeSerializerState::DrawParam(
                            IterSerializer::new(
                                &self.value.draw_param[..],
                                Some("DrawParam"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResDrawParamsXElementTypeSerializerState::DrawParam(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResDrawParamsXElementTypeSerializerState::End__,
                        }
                    }
                    ResDrawParamsXElementTypeSerializerState::End__ => {
                        *self.state = ResDrawParamsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResDrawParamsXElementTypeSerializerState::Done__ => return Ok(None),
                    ResDrawParamsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ResDrawParamsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResDrawParamsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResFontsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResFontsXElementType,
        pub(super) state: Box<ResFontsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResFontsXElementTypeSerializerState<'ser> {
        Init__,
        Font(
            IterSerializer<
                'ser,
                &'ser [super::ResFontsFontXElementType],
                super::ResFontsFontXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResFontsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResFontsXElementTypeSerializerState::Init__ => {
                        *self.state = ResFontsXElementTypeSerializerState::Font(
                            IterSerializer::new(&self.value.font[..], Some("Font"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResFontsXElementTypeSerializerState::Font(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = ResFontsXElementTypeSerializerState::End__,
                    },
                    ResFontsXElementTypeSerializerState::End__ => {
                        *self.state = ResFontsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResFontsXElementTypeSerializerState::Done__ => return Ok(None),
                    ResFontsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ResFontsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResFontsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResMultiMediasXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResMultiMediasXElementType,
        pub(super) state: Box<ResMultiMediasXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResMultiMediasXElementTypeSerializerState<'ser> {
        Init__,
        MultiMedia(
            IterSerializer<
                'ser,
                &'ser [super::ResMultiMediasMultiMediaXElementType],
                super::ResMultiMediasMultiMediaXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResMultiMediasXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResMultiMediasXElementTypeSerializerState::Init__ => {
                        *self.state = ResMultiMediasXElementTypeSerializerState::MultiMedia(
                            IterSerializer::new(
                                &self.value.multi_media[..],
                                Some("MultiMedia"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResMultiMediasXElementTypeSerializerState::MultiMedia(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResMultiMediasXElementTypeSerializerState::End__,
                        }
                    }
                    ResMultiMediasXElementTypeSerializerState::End__ => {
                        *self.state = ResMultiMediasXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResMultiMediasXElementTypeSerializerState::Done__ => return Ok(None),
                    ResMultiMediasXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ResMultiMediasXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResMultiMediasXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResCompositeGraphicUnitsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResCompositeGraphicUnitsXElementType,
        pub(super) state: Box<ResCompositeGraphicUnitsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResCompositeGraphicUnitsXElementTypeSerializerState<'ser> {
        Init__,
        CompositeGraphicUnit(
            IterSerializer<
                'ser,
                &'ser [super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType],
                super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResCompositeGraphicUnitsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResCompositeGraphicUnitsXElementTypeSerializerState::Init__ => {
                        * self . state = ResCompositeGraphicUnitsXElementTypeSerializerState :: CompositeGraphicUnit (IterSerializer :: new (& self . value . composite_graphic_unit [..] , Some ("CompositeGraphicUnit") , false)) ;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResCompositeGraphicUnitsXElementTypeSerializerState::CompositeGraphicUnit(
                        x,
                    ) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = ResCompositeGraphicUnitsXElementTypeSerializerState::End__
                        }
                    },
                    ResCompositeGraphicUnitsXElementTypeSerializerState::End__ => {
                        *self.state = ResCompositeGraphicUnitsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResCompositeGraphicUnitsXElementTypeSerializerState::Done__ => return Ok(None),
                    ResCompositeGraphicUnitsXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for ResCompositeGraphicUnitsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResCompositeGraphicUnitsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SianatureSiqnedInfoXElementType,
        pub(super) state: Box<SianatureSiqnedInfoXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SianatureSiqnedInfoXElementTypeSerializerState<'ser> {
        Init__,
        Provider(
            <super::SianatureSiqnedInfoProviderXElementType as WithSerializer>::Serializer<'ser>,
        ),
        SignatureMethod(IterSerializer<'ser, Option<&'ser String>, String>),
        SianatureDateTime(IterSerializer<'ser, Option<&'ser String>, String>),
        References(
            <super::SianatureSiqnedInfoReferencesXElementType as WithSerializer>::Serializer<'ser>,
        ),
        StampAnnot(
            IterSerializer<
                'ser,
                &'ser [super::SianatureSiqnedInfoStampAnnotXElementType],
                super::SianatureSiqnedInfoStampAnnotXElementType,
            >,
        ),
        Seal(
            IterSerializer<
                'ser,
                Option<&'ser super::SianatureSiqnedInfoSealXElementType>,
                super::SianatureSiqnedInfoSealXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SianatureSiqnedInfoXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SianatureSiqnedInfoXElementTypeSerializerState::Init__ => {
                        *self.state = SianatureSiqnedInfoXElementTypeSerializerState::Provider(
                            WithSerializer::serializer(
                                &self.value.provider,
                                Some("Provider"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SianatureSiqnedInfoXElementTypeSerializerState::Provider(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    SianatureSiqnedInfoXElementTypeSerializerState::SignatureMethod(
                                        IterSerializer::new(
                                            self.value.signature_method.as_ref(),
                                            Some("SignatureMethod"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    SianatureSiqnedInfoXElementTypeSerializerState::SignatureMethod(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                SianatureSiqnedInfoXElementTypeSerializerState::SianatureDateTime(
                                    IterSerializer::new(
                                        self.value.sianature_date_time.as_ref(),
                                        Some("SianatureDateTime"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    SianatureSiqnedInfoXElementTypeSerializerState::SianatureDateTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    SianatureSiqnedInfoXElementTypeSerializerState::References(
                                        WithSerializer::serializer(
                                            &self.value.references,
                                            Some("References"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    SianatureSiqnedInfoXElementTypeSerializerState::References(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    SianatureSiqnedInfoXElementTypeSerializerState::StampAnnot(
                                        IterSerializer::new(
                                            &self.value.stamp_annot[..],
                                            Some("StampAnnot"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    SianatureSiqnedInfoXElementTypeSerializerState::StampAnnot(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = SianatureSiqnedInfoXElementTypeSerializerState::Seal(
                                IterSerializer::new(self.value.seal.as_ref(), Some("Seal"), false),
                            )
                        }
                    },
                    SianatureSiqnedInfoXElementTypeSerializerState::Seal(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = SianatureSiqnedInfoXElementTypeSerializerState::End__,
                    },
                    SianatureSiqnedInfoXElementTypeSerializerState::End__ => {
                        *self.state = SianatureSiqnedInfoXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SianatureSiqnedInfoXElementTypeSerializerState::Done__ => return Ok(None),
                    SianatureSiqnedInfoXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SianatureSiqnedInfoXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SianatureSiqnedInfoXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SiqnaturesSignatureXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SiqnaturesSignatureXElementType,
        pub(super) state: Box<SiqnaturesSignatureXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SiqnaturesSignatureXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SiqnaturesSignatureXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SiqnaturesSignatureXElementTypeSerializerState::Init__ => {
                        *self.state = SiqnaturesSignatureXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    SiqnaturesSignatureXElementTypeSerializerState::Done__ => return Ok(None),
                    SiqnaturesSignatureXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SiqnaturesSignatureXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SiqnaturesSignatureXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtActionGotoBookmarkXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtActionGotoBookmarkXElementType,
        pub(super) state: Box<CtActionGotoBookmarkXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtActionGotoBookmarkXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtActionGotoBookmarkXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtActionGotoBookmarkXElementTypeSerializerState::Init__ => {
                        *self.state = CtActionGotoBookmarkXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Name", &self.value.name)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtActionGotoBookmarkXElementTypeSerializerState::Done__ => return Ok(None),
                    CtActionGotoBookmarkXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtActionGotoBookmarkXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtActionGotoBookmarkXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtDocInfoCustomDatasCustomDataXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtDocInfoCustomDatasCustomDataXElementType,
        pub(super) state: Box<CtDocInfoCustomDatasCustomDataXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtDocInfoCustomDatasCustomDataXElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtDocInfoCustomDatasCustomDataXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::Init__ => {
                        *self.state =
                            CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Name", &self.value.name)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::End__
                            }
                        }
                    }
                    CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::End__ => {
                        *self.state =
                            CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtDocInfoCustomDatasCustomDataXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaLineXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtRegionAreaLineXElementType,
        pub(super) state: Box<CtRegionAreaLineXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtRegionAreaLineXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtRegionAreaLineXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtRegionAreaLineXElementTypeSerializerState::Init__ => {
                        *self.state = CtRegionAreaLineXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Point1", &self.value.point_1)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtRegionAreaLineXElementTypeSerializerState::Done__ => return Ok(None),
                    CtRegionAreaLineXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtRegionAreaLineXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtRegionAreaLineXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaOuadraticBezierXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtRegionAreaOuadraticBezierXElementType,
        pub(super) state: Box<CtRegionAreaOuadraticBezierXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtRegionAreaOuadraticBezierXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtRegionAreaOuadraticBezierXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtRegionAreaOuadraticBezierXElementTypeSerializerState::Init__ => {
                        *self.state =
                            CtRegionAreaOuadraticBezierXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Pointl", &self.value.pointl)?;
                        write_attrib(&mut bytes, "Point2", &self.value.point_2)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtRegionAreaOuadraticBezierXElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    CtRegionAreaOuadraticBezierXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtRegionAreaOuadraticBezierXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtRegionAreaOuadraticBezierXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaCubicBezierXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtRegionAreaCubicBezierXElementType,
        pub(super) state: Box<CtRegionAreaCubicBezierXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtRegionAreaCubicBezierXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtRegionAreaCubicBezierXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtRegionAreaCubicBezierXElementTypeSerializerState::Init__ => {
                        *self.state = CtRegionAreaCubicBezierXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "Point1", &self.value.point_1)?;
                        write_attrib_opt(&mut bytes, "Point2", &self.value.point_2)?;
                        write_attrib(&mut bytes, "Point3", &self.value.point_3)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtRegionAreaCubicBezierXElementTypeSerializerState::Done__ => return Ok(None),
                    CtRegionAreaCubicBezierXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for CtRegionAreaCubicBezierXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtRegionAreaCubicBezierXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaArcXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CtRegionAreaArcXElementType,
        pub(super) state: Box<CtRegionAreaArcXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CtRegionAreaArcXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CtRegionAreaArcXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CtRegionAreaArcXElementTypeSerializerState::Init__ => {
                        *self.state = CtRegionAreaArcXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "SweepDirection", &self.value.sweep_direction)?;
                        write_attrib(&mut bytes, "LargeArc", &self.value.large_arc)?;
                        write_attrib(&mut bytes, "RotationAnglet", &self.value.rotation_anglet)?;
                        write_attrib(&mut bytes, "EllipseSize", &self.value.ellipse_size)?;
                        write_attrib(&mut bytes, "EndPoint", &self.value.end_point)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    CtRegionAreaArcXElementTypeSerializerState::Done__ => return Ok(None),
                    CtRegionAreaArcXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CtRegionAreaArcXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CtRegionAreaArcXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocVersionFileListFileXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocVersionFileListFileXElementType,
        pub(super) state: Box<DocVersionFileListFileXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocVersionFileListFileXElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocVersionFileListFileXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocVersionFileListFileXElementTypeSerializerState::Init__ => {
                        *self.state = DocVersionFileListFileXElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DocVersionFileListFileXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    DocVersionFileListFileXElementTypeSerializerState::End__
                            }
                        }
                    }
                    DocVersionFileListFileXElementTypeSerializerState::End__ => {
                        *self.state = DocVersionFileListFileXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DocVersionFileListFileXElementTypeSerializerState::Done__ => return Ok(None),
                    DocVersionFileListFileXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for DocVersionFileListFileXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocVersionFileListFileXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentCommonDataTemplatePageXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentCommonDataTemplatePageXElementType,
        pub(super) state: Box<DocumentCommonDataTemplatePageXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentCommonDataTemplatePageXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentCommonDataTemplatePageXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentCommonDataTemplatePageXElementTypeSerializerState::Init__ => {
                        *self.state =
                            DocumentCommonDataTemplatePageXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                        write_attrib_opt(&mut bytes, "ZOrder", &self.value.z_order)?;
                        write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    DocumentCommonDataTemplatePageXElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    DocumentCommonDataTemplatePageXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentCommonDataTemplatePageXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentCommonDataTemplatePageXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentPagesPageXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::DocumentPagesPageXElementType,
        pub(super) state: Box<DocumentPagesPageXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DocumentPagesPageXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DocumentPagesPageXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DocumentPagesPageXElementTypeSerializerState::Init__ => {
                        *self.state = DocumentPagesPageXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    DocumentPagesPageXElementTypeSerializerState::Done__ => return Ok(None),
                    DocumentPagesPageXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DocumentPagesPageXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DocumentPagesPageXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct OfdDocBodyVersionsXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::OfdDocBodyVersionsXElementType,
        pub(super) state: Box<OfdDocBodyVersionsXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum OfdDocBodyVersionsXElementTypeSerializerState<'ser> {
        Init__,
        Version(
            IterSerializer<
                'ser,
                &'ser [super::OfdDocBodyVersionsVersionXElementType],
                super::OfdDocBodyVersionsVersionXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> OfdDocBodyVersionsXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    OfdDocBodyVersionsXElementTypeSerializerState::Init__ => {
                        *self.state = OfdDocBodyVersionsXElementTypeSerializerState::Version(
                            IterSerializer::new(&self.value.version[..], Some("Version"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    OfdDocBodyVersionsXElementTypeSerializerState::Version(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = OfdDocBodyVersionsXElementTypeSerializerState::End__,
                    },
                    OfdDocBodyVersionsXElementTypeSerializerState::End__ => {
                        *self.state = OfdDocBodyVersionsXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    OfdDocBodyVersionsXElementTypeSerializerState::Done__ => return Ok(None),
                    OfdDocBodyVersionsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for OfdDocBodyVersionsXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = OfdDocBodyVersionsXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageContentLayerXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PageContentLayerXElementType,
        pub(super) state: Box<PageContentLayerXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PageContentLayerXElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::PageContentLayerXElementTypeContent],
                super::PageContentLayerXElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageContentLayerXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageContentLayerXElementTypeSerializerState::Init__ => {
                        *self.state = PageContentLayerXElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib_opt(&mut bytes, "DrawParam", &self.value.draw_param)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PageContentLayerXElementTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = PageContentLayerXElementTypeSerializerState::End__,
                    },
                    PageContentLayerXElementTypeSerializerState::End__ => {
                        *self.state = PageContentLayerXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PageContentLayerXElementTypeSerializerState::Done__ => return Ok(None),
                    PageContentLayerXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PageContentLayerXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageContentLayerXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageContentLayerXElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::PageContentLayerXElementTypeContent,
        pub(super) state: Box<PageContentLayerXElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum PageContentLayerXElementTypeContentSerializerState<'ser> {
        Init__,
        TextObject(<super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>),
        PathObject(<super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>),
        ImageObject(
            <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        CompositeObject(
            <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        PageBlock(<super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageContentLayerXElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageContentLayerXElementTypeContentSerializerState::Init__ => match self.value {
                        super::PageContentLayerXElementTypeContent::TextObject(x) => {
                            *self.state =
                                PageContentLayerXElementTypeContentSerializerState::TextObject(
                                    WithSerializer::serializer(x, Some("TextObject"), false)?,
                                )
                        }
                        super::PageContentLayerXElementTypeContent::PathObject(x) => {
                            *self.state =
                                PageContentLayerXElementTypeContentSerializerState::PathObject(
                                    WithSerializer::serializer(x, Some("PathObject"), false)?,
                                )
                        }
                        super::PageContentLayerXElementTypeContent::ImageObject(x) => {
                            *self.state =
                                PageContentLayerXElementTypeContentSerializerState::ImageObject(
                                    WithSerializer::serializer(x, Some("ImageObject"), false)?,
                                )
                        }
                        super::PageContentLayerXElementTypeContent::CompositeObject(x) => {
                            *self.state =
                                PageContentLayerXElementTypeContentSerializerState::CompositeObject(
                                    WithSerializer::serializer(x, Some("CompositeObject"), false)?,
                                )
                        }
                        super::PageContentLayerXElementTypeContent::PageBlock(x) => {
                            *self.state =
                                PageContentLayerXElementTypeContentSerializerState::PageBlock(
                                    WithSerializer::serializer(x, Some("PageBlock"), false)?,
                                )
                        }
                    },
                    PageContentLayerXElementTypeContentSerializerState::TextObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    PageContentLayerXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    PageContentLayerXElementTypeContentSerializerState::PathObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    PageContentLayerXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    PageContentLayerXElementTypeContentSerializerState::ImageObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    PageContentLayerXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    PageContentLayerXElementTypeContentSerializerState::CompositeObject(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    PageContentLayerXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    PageContentLayerXElementTypeContentSerializerState::PageBlock(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    PageContentLayerXElementTypeContentSerializerState::Done__
                            }
                        }
                    }
                    PageContentLayerXElementTypeContentSerializerState::Done__ => return Ok(None),
                    PageContentLayerXElementTypeContentSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for PageContentLayerXElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageContentLayerXElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotParametersXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PageAnnotAnnotParametersXElementType,
        pub(super) state: Box<PageAnnotAnnotParametersXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PageAnnotAnnotParametersXElementTypeSerializerState<'ser> {
        Init__,
        Parameter(
            IterSerializer<
                'ser,
                &'ser [super::CtDocInfoCustomDatasCustomDataXElementType],
                super::CtDocInfoCustomDatasCustomDataXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageAnnotAnnotParametersXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageAnnotAnnotParametersXElementTypeSerializerState::Init__ => {
                        *self.state =
                            PageAnnotAnnotParametersXElementTypeSerializerState::Parameter(
                                IterSerializer::new(
                                    &self.value.parameter[..],
                                    Some("Parameter"),
                                    false,
                                ),
                            );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PageAnnotAnnotParametersXElementTypeSerializerState::Parameter(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    PageAnnotAnnotParametersXElementTypeSerializerState::End__
                            }
                        }
                    }
                    PageAnnotAnnotParametersXElementTypeSerializerState::End__ => {
                        *self.state = PageAnnotAnnotParametersXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PageAnnotAnnotParametersXElementTypeSerializerState::Done__ => return Ok(None),
                    PageAnnotAnnotParametersXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for PageAnnotAnnotParametersXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageAnnotAnnotParametersXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotAppearanceXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PageAnnotAnnotAppearanceXElementType,
        pub(super) state: Box<PageAnnotAnnotAppearanceXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PageAnnotAnnotAppearanceXElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::PageAnnotAnnotAppearanceXElementTypeContent],
                super::PageAnnotAnnotAppearanceXElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageAnnotAnnotAppearanceXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PageAnnotAnnotAppearanceXElementTypeSerializerState::Init__ => {
                        *self.state =
                            PageAnnotAnnotAppearanceXElementTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "Boundary", &self.value.boundary)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PageAnnotAnnotAppearanceXElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    PageAnnotAnnotAppearanceXElementTypeSerializerState::End__
                            }
                        }
                    }
                    PageAnnotAnnotAppearanceXElementTypeSerializerState::End__ => {
                        *self.state = PageAnnotAnnotAppearanceXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PageAnnotAnnotAppearanceXElementTypeSerializerState::Done__ => return Ok(None),
                    PageAnnotAnnotAppearanceXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for PageAnnotAnnotAppearanceXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PageAnnotAnnotAppearanceXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotAppearanceXElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::PageAnnotAnnotAppearanceXElementTypeContent,
        pub(super) state: Box<PageAnnotAnnotAppearanceXElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum PageAnnotAnnotAppearanceXElementTypeContentSerializerState<'ser> {
        Init__,
        TextObject(<super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>),
        PathObject(<super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>),
        ImageObject(
            <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        CompositeObject(
            <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
        ),
        PageBlock(<super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PageAnnotAnnotAppearanceXElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Init__ => { match self . value { super :: PageAnnotAnnotAppearanceXElementTypeContent :: TextObject (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: TextObject (WithSerializer :: serializer (x , Some ("TextObject") , false) ?) , super :: PageAnnotAnnotAppearanceXElementTypeContent :: PathObject (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: PathObject (WithSerializer :: serializer (x , Some ("PathObject") , false) ?) , super :: PageAnnotAnnotAppearanceXElementTypeContent :: ImageObject (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: ImageObject (WithSerializer :: serializer (x , Some ("ImageObject") , false) ?) , super :: PageAnnotAnnotAppearanceXElementTypeContent :: CompositeObject (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: CompositeObject (WithSerializer :: serializer (x , Some ("CompositeObject") , false) ?) , super :: PageAnnotAnnotAppearanceXElementTypeContent :: PageBlock (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: PageBlock (WithSerializer :: serializer (x , Some ("PageBlock") , false) ?) , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: TextObject (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: PathObject (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: ImageObject (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: CompositeObject (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: PageBlock (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ => return Ok (None) , PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for PageAnnotAnnotAppearanceXElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state =
                        PageAnnotAnnotAppearanceXElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResColorSpacesColorSpaceXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResColorSpacesColorSpaceXElementType,
        pub(super) state: Box<ResColorSpacesColorSpaceXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResColorSpacesColorSpaceXElementTypeSerializerState<'ser> {
        Init__,
        Palette(
            IterSerializer<
                'ser,
                Option<&'ser super::CtColorSpacePaletteXElementType>,
                super::CtColorSpacePaletteXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResColorSpacesColorSpaceXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResColorSpacesColorSpaceXElementTypeSerializerState::Init__ => {
                        *self.state = ResColorSpacesColorSpaceXElementTypeSerializerState::Palette(
                            IterSerializer::new(
                                self.value.palette.as_ref(),
                                Some("Palette"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib(
                            &mut bytes,
                            "BitsPerComponent",
                            &self.value.bits_per_component,
                        )?;
                        write_attrib_opt(&mut bytes, "Profile", &self.value.profile)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResColorSpacesColorSpaceXElementTypeSerializerState::Palette(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ResColorSpacesColorSpaceXElementTypeSerializerState::End__
                            }
                        }
                    }
                    ResColorSpacesColorSpaceXElementTypeSerializerState::End__ => {
                        *self.state = ResColorSpacesColorSpaceXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResColorSpacesColorSpaceXElementTypeSerializerState::Done__ => return Ok(None),
                    ResColorSpacesColorSpaceXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for ResColorSpacesColorSpaceXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResColorSpacesColorSpaceXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResDrawParamsDrawParamXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResDrawParamsDrawParamXElementType,
        pub(super) state: Box<ResDrawParamsDrawParamXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResDrawParamsDrawParamXElementTypeSerializerState<'ser> {
        Init__,
        FillColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        StrokeColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResDrawParamsDrawParamXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResDrawParamsDrawParamXElementTypeSerializerState::Init__ => {
                        *self.state = ResDrawParamsDrawParamXElementTypeSerializerState::FillColor(
                            IterSerializer::new(
                                self.value.fill_color.as_ref(),
                                Some("FillColor"),
                                false,
                            ),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib_opt(&mut bytes, "Relative", &self.value.relative)?;
                        write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                        write_attrib(&mut bytes, "Join", &self.value.join)?;
                        write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                        write_attrib(&mut bytes, "DashOffset", &self.value.dash_offset)?;
                        write_attrib_opt(&mut bytes, "DashPattern", &self.value.dash_pattern)?;
                        write_attrib(&mut bytes, "MiterLimit", &self.value.miter_limit)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResDrawParamsDrawParamXElementTypeSerializerState::FillColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ResDrawParamsDrawParamXElementTypeSerializerState::StrokeColor(
                                        IterSerializer::new(
                                            self.value.stroke_color.as_ref(),
                                            Some("StrokeColor"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ResDrawParamsDrawParamXElementTypeSerializerState::StrokeColor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ResDrawParamsDrawParamXElementTypeSerializerState::End__
                            }
                        }
                    }
                    ResDrawParamsDrawParamXElementTypeSerializerState::End__ => {
                        *self.state = ResDrawParamsDrawParamXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResDrawParamsDrawParamXElementTypeSerializerState::Done__ => return Ok(None),
                    ResDrawParamsDrawParamXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for ResDrawParamsDrawParamXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResDrawParamsDrawParamXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResFontsFontXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResFontsFontXElementType,
        pub(super) state: Box<ResFontsFontXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResFontsFontXElementTypeSerializerState<'ser> {
        Init__,
        FontFile(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResFontsFontXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResFontsFontXElementTypeSerializerState::Init__ => {
                        *self.state =
                            ResFontsFontXElementTypeSerializerState::FontFile(IterSerializer::new(
                                self.value.font_file.as_ref(),
                                Some("FontFile"),
                                false,
                            ));
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "FontName", &self.value.font_name)?;
                        write_attrib_opt(&mut bytes, "FamilyName", &self.value.family_name)?;
                        write_attrib(&mut bytes, "Charset", &self.value.charset)?;
                        write_attrib(&mut bytes, "Italic", &self.value.italic)?;
                        write_attrib(&mut bytes, "Bold", &self.value.bold)?;
                        write_attrib(&mut bytes, "Serif", &self.value.serif)?;
                        write_attrib(&mut bytes, "FixedWidth", &self.value.fixed_width)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResFontsFontXElementTypeSerializerState::FontFile(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResFontsFontXElementTypeSerializerState::End__,
                        }
                    }
                    ResFontsFontXElementTypeSerializerState::End__ => {
                        *self.state = ResFontsFontXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResFontsFontXElementTypeSerializerState::Done__ => return Ok(None),
                    ResFontsFontXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ResFontsFontXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResFontsFontXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResMultiMediasMultiMediaXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResMultiMediasMultiMediaXElementType,
        pub(super) state: Box<ResMultiMediasMultiMediaXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResMultiMediasMultiMediaXElementTypeSerializerState<'ser> {
        Init__,
        MediaFile(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResMultiMediasMultiMediaXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ResMultiMediasMultiMediaXElementTypeSerializerState::Init__ => {
                        *self.state =
                            ResMultiMediasMultiMediaXElementTypeSerializerState::MediaFile(
                                WithSerializer::serializer(
                                    &self.value.media_file,
                                    Some("MediaFile"),
                                    false,
                                )?,
                            );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "Type", &self.value.type_)?;
                        write_attrib_opt(&mut bytes, "Format", &self.value.format)?;
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ResMultiMediasMultiMediaXElementTypeSerializerState::MediaFile(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ResMultiMediasMultiMediaXElementTypeSerializerState::End__
                            }
                        }
                    }
                    ResMultiMediasMultiMediaXElementTypeSerializerState::End__ => {
                        *self.state = ResMultiMediasMultiMediaXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ResMultiMediasMultiMediaXElementTypeSerializerState::Done__ => return Ok(None),
                    ResMultiMediasMultiMediaXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for ResMultiMediasMultiMediaXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ResMultiMediasMultiMediaXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
        pub(super) state:
            Box<ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState<'ser> {
        Init__,
        Thumbnail(IterSerializer<'ser, Option<&'ser u32>, u32>),
        Substitution(IterSerializer<'ser, Option<&'ser u32>, u32>),
        Content(<super::CtPageBlockXType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Init__ => { * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Thumbnail (IterSerializer :: new (self . value . thumbnail . as_ref () , Some ("Thumbnail") , false)) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns" [..] , & super :: NS_DEFAULT [..])) ; } write_attrib (& mut bytes , "Width" , & self . value . width) ? ; write_attrib (& mut bytes , "Height" , & self . value . height) ? ; write_attrib (& mut bytes , "ID" , & self . value . id) ? ; return Ok (Some (Event :: Start (bytes))) } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Thumbnail (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Substitution (IterSerializer :: new (self . value . substitution . as_ref () , Some ("Substitution") , false)) , } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Substitution (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Content (WithSerializer :: serializer (& self . value . content , Some ("Content") , false) ?) , } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Content (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: End__ , } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: End__ => { * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Done__ => return Ok (None) , ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Done__ ;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoProviderXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SianatureSiqnedInfoProviderXElementType,
        pub(super) state: Box<SianatureSiqnedInfoProviderXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SianatureSiqnedInfoProviderXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SianatureSiqnedInfoProviderXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SianatureSiqnedInfoProviderXElementTypeSerializerState::Init__ => {
                        *self.state =
                            SianatureSiqnedInfoProviderXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ProviderName", &self.value.provider_name)?;
                        write_attrib_opt(&mut bytes, "Version", &self.value.version)?;
                        write_attrib_opt(&mut bytes, "Company", &self.value.company)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    SianatureSiqnedInfoProviderXElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    SianatureSiqnedInfoProviderXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for SianatureSiqnedInfoProviderXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SianatureSiqnedInfoProviderXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoReferencesXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SianatureSiqnedInfoReferencesXElementType,
        pub(super) state: Box<SianatureSiqnedInfoReferencesXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SianatureSiqnedInfoReferencesXElementTypeSerializerState<'ser> {
        Init__,
        Reference(
            IterSerializer<
                'ser,
                &'ser [super::SianatureSiqnedInfoReferencesReferenceXElementType],
                super::SianatureSiqnedInfoReferencesReferenceXElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SianatureSiqnedInfoReferencesXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SianatureSiqnedInfoReferencesXElementTypeSerializerState::Init__ => {
                        *self.state =
                            SianatureSiqnedInfoReferencesXElementTypeSerializerState::Reference(
                                IterSerializer::new(
                                    &self.value.reference[..],
                                    Some("Reference"),
                                    false,
                                ),
                            );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "CheckMethod", &self.value.check_method)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SianatureSiqnedInfoReferencesXElementTypeSerializerState::Reference(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    SianatureSiqnedInfoReferencesXElementTypeSerializerState::End__
                            }
                        }
                    }
                    SianatureSiqnedInfoReferencesXElementTypeSerializerState::End__ => {
                        *self.state =
                            SianatureSiqnedInfoReferencesXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SianatureSiqnedInfoReferencesXElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    SianatureSiqnedInfoReferencesXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for SianatureSiqnedInfoReferencesXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SianatureSiqnedInfoReferencesXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoStampAnnotXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SianatureSiqnedInfoStampAnnotXElementType,
        pub(super) state: Box<SianatureSiqnedInfoStampAnnotXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SianatureSiqnedInfoStampAnnotXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SianatureSiqnedInfoStampAnnotXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Init__ => {
                        *self.state =
                            SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        write_attrib(&mut bytes, "PageRef", &self.value.page_ref)?;
                        write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                        write_attrib_opt(&mut bytes, "Clip", &self.value.clip)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for SianatureSiqnedInfoStampAnnotXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoSealXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SianatureSiqnedInfoSealXElementType,
        pub(super) state: Box<SianatureSiqnedInfoSealXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SianatureSiqnedInfoSealXElementTypeSerializerState<'ser> {
        Init__,
        BaseLoc(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SianatureSiqnedInfoSealXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SianatureSiqnedInfoSealXElementTypeSerializerState::Init__ => {
                        *self.state = SianatureSiqnedInfoSealXElementTypeSerializerState::BaseLoc(
                            WithSerializer::serializer(
                                &self.value.base_loc,
                                Some("BaseLoc"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SianatureSiqnedInfoSealXElementTypeSerializerState::BaseLoc(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    SianatureSiqnedInfoSealXElementTypeSerializerState::End__
                            }
                        }
                    }
                    SianatureSiqnedInfoSealXElementTypeSerializerState::End__ => {
                        *self.state = SianatureSiqnedInfoSealXElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SianatureSiqnedInfoSealXElementTypeSerializerState::Done__ => return Ok(None),
                    SianatureSiqnedInfoSealXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for SianatureSiqnedInfoSealXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SianatureSiqnedInfoSealXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct OfdDocBodyVersionsVersionXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::OfdDocBodyVersionsVersionXElementType,
        pub(super) state: Box<OfdDocBodyVersionsVersionXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum OfdDocBodyVersionsVersionXElementTypeSerializerState<'ser> {
        Init__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> OfdDocBodyVersionsVersionXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    OfdDocBodyVersionsVersionXElementTypeSerializerState::Init__ => {
                        *self.state = OfdDocBodyVersionsVersionXElementTypeSerializerState::Done__;
                        let mut bytes = BytesStart::new(self.name);
                        if self.is_root {
                            bytes.push_attribute((&b"xmlns"[..], &super::NS_DEFAULT[..]));
                        }
                        write_attrib(&mut bytes, "ID", &self.value.id)?;
                        write_attrib(&mut bytes, "Index", &self.value.index)?;
                        write_attrib(&mut bytes, "Current", &self.value.current)?;
                        write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                        return Ok(Some(Event::Empty(bytes)));
                    }
                    OfdDocBodyVersionsVersionXElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    OfdDocBodyVersionsVersionXElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for OfdDocBodyVersionsVersionXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = OfdDocBodyVersionsVersionXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SianatureSiqnedInfoReferencesReferenceXElementType,
        pub(super) state:
            Box<SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState<'ser> {
        Init__,
        CheckValue(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Init__ => { * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: CheckValue (WithSerializer :: serializer (& self . value . check_value , Some ("CheckValue") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; if self . is_root { bytes . push_attribute ((& b"xmlns" [..] , & super :: NS_DEFAULT [..])) ; } write_attrib (& mut bytes , "FileRef" , & self . value . file_ref) ? ; return Ok (Some (Event :: Start (bytes))) } SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: CheckValue (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: End__ , } SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: End__ => { * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Done__ => return Ok (None) , SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state =
                        SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
}
pub mod xs {
    use num::{BigInt, BigUint};
    use std::borrow::Cow;
    use xsd_parser::quick_xml::{
        DeserializeBytes, DeserializeReader, Error, SerializeBytes, WithDeserializer,
        WithSerializer,
    };
    #[derive(Debug, Default)]
    pub struct EntitiesXType(pub Vec<String>);
    impl SerializeBytes for EntitiesXType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            if self.0.is_empty() {
                return Ok(None);
            }
            let mut data = String::new();
            for item in &self.0 {
                if let Some(bytes) = item.serialize_bytes()? {
                    if !data.is_empty() {
                        data.push(' ');
                    }
                    data.push_str(&bytes);
                }
            }
            Ok(Some(Cow::Owned(data)))
        }
    }
    impl DeserializeBytes for EntitiesXType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            Ok(Self(
                bytes
                    .split(|b| *b == b' ' || *b == b'|' || *b == b',' || *b == b';')
                    .map(|bytes| String::deserialize_bytes(reader, bytes))
                    .collect::<Result<Vec<_>, _>>()?,
            ))
        }
    }
    pub type EntityXType = EntitiesXType;
    pub type IdXType = String;
    pub type IdrefXType = String;
    pub type IdrefsXType = EntitiesXType;
    pub type NcNameXType = String;
    pub type NmtokenXType = String;
    pub type NmtokensXType = EntitiesXType;
    pub type NotationXType = String;
    pub type NameXType = String;
    pub type QNameXType = String;
    pub type AnySimpleTypeXType = String;
    #[derive(Debug)]
    pub struct AnyTypeXType;
    impl WithSerializer for AnyTypeXType {
        type Serializer<'x> = quick_xml_serialize::AnyTypeXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::AnyTypeXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::AnyTypeXTypeSerializerState::Init__),
                name: name.unwrap_or("anyType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for AnyTypeXType {
        type Deserializer = quick_xml_deserialize::AnyTypeXTypeDeserializer;
    }
    pub type AnyUriXType = String;
    pub type Base64BinaryXType = String;
    pub type BooleanXType = bool;
    pub type ByteXType = i8;
    pub type DateXType = String;
    pub type DateTimeXType = String;
    pub type DecimalXType = f64;
    pub type DoubleXType = f64;
    pub type DurationXType = String;
    pub type FloatXType = f32;
    pub type GDayXType = String;
    pub type GMonthXType = String;
    pub type GMonthDayXType = String;
    pub type GYearXType = String;
    pub type GYearMonthXType = String;
    pub type HexBinaryXType = String;
    pub type IntXType = i32;
    pub type IntegerXType = BigInt;
    pub type LanguageXType = String;
    pub type LongXType = i64;
    pub type NegativeIntegerXType = BigInt;
    pub type NonNegativeIntegerXType = BigUint;
    pub type NonPositiveIntegerXType = BigInt;
    pub type NormalizedStringXType = String;
    pub type PositiveIntegerXType = BigUint;
    pub type ShortXType = i16;
    pub type StringXType = String;
    pub type TimeXType = String;
    pub type TokenXType = String;
    pub type UnsignedByteXType = u8;
    pub type UnsignedIntXType = u32;
    pub type UnsignedLongXType = u64;
    pub type UnsignedShortXType = u16;
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser::quick_xml::{
            BytesStart, DeserializeReader, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, Error, Event,
        };
        #[derive(Debug)]
        pub struct AnyTypeXTypeDeserializer {
            state: Box<AnyTypeXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum AnyTypeXTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl AnyTypeXTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                Ok(Self {
                    state: Box::new(AnyTypeXTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: AnyTypeXTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::AnyTypeXType> for AnyTypeXTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::AnyTypeXType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::AnyTypeXType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: true,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::AnyTypeXType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, AnyTypeXTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::AnyTypeXType {})
            }
        }
    }
    pub mod quick_xml_serialize {
        use core::iter::Iterator;
        use xsd_parser::quick_xml::{BytesStart, Error, Event};
        #[derive(Debug)]
        pub struct AnyTypeXTypeSerializer<'ser> {
            pub(super) value: &'ser super::AnyTypeXType,
            pub(super) state: Box<AnyTypeXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum AnyTypeXTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> AnyTypeXTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        AnyTypeXTypeSerializerState::Init__ => {
                            *self.state = AnyTypeXTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns"[..], &super::super::NS_DEFAULT[..]));
                            }
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        AnyTypeXTypeSerializerState::Done__ => return Ok(None),
                        AnyTypeXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for AnyTypeXTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = AnyTypeXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
