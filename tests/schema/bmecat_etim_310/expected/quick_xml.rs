use std::borrow::Cow;
use xsd_parser::{
    quick_xml::{
        DeserializeBytes, DeserializeReader, Error, ErrorKind, RawByteStr, SerializeBytes,
        WithDeserializer, WithSerializer,
    },
    schema::Namespace,
};
pub const NS_XS: Namespace = Namespace::new_const(b"http://www.w3.org/2001/XMLSchema");
pub const NS_XML: Namespace = Namespace::new_const(b"http://www.w3.org/XML/1998/namespace");
pub const NS_DEFAULT: Namespace =
    Namespace::new_const(b"http://www.etim-international.com/bmecat/31");
pub type Bmecat = BmecatElementType;
#[derive(Debug)]
pub struct BmecatElementType {
    pub version: TypeBmEcatVersionType,
    pub content: Vec<BmecatElementTypeContent>,
}
#[derive(Debug)]
pub enum BmecatElementTypeContent {
    Header(HeaderElementType),
    TNewCatalog(TNewCatalogElementType),
    TUpdateProducts(TUpdateProductsElementType),
    TUpdatePrices(TUpdatePricesElementType),
}
impl WithSerializer for BmecatElementType {
    type Serializer<'x> = quick_xml_serialize::BmecatElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::BmecatElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BmecatElementTypeSerializerState::Init__),
            name: name.unwrap_or("BMECAT"),
            is_root,
        })
    }
}
impl WithSerializer for BmecatElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::BmecatElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::BmecatElementTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BmecatElementTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for BmecatElementType {
    type Deserializer = quick_xml_deserialize::BmecatElementTypeDeserializer;
}
impl WithDeserializer for BmecatElementTypeContent {
    type Deserializer = quick_xml_deserialize::BmecatElementTypeContentDeserializer;
}
#[derive(Debug)]
pub enum TypeBmEcatVersionType {
    _12,
    _2005,
}
impl SerializeBytes for TypeBmEcatVersionType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_12 => Ok(Some(Cow::Borrowed("1.2"))),
            Self::_2005 => Ok(Some(Cow::Borrowed("2005"))),
        }
    }
}
impl DeserializeBytes for TypeBmEcatVersionType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"1.2" => Ok(Self::_12),
            b"2005" => Ok(Self::_2005),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct HeaderElementType {
    pub generator_info: Option<String>,
    pub catalog: CatalogElementType,
    pub buyer: BuyerElementType,
    pub supplier: SupplierElementType,
    pub user_defined_extensions: UdxHeaderType,
}
impl WithSerializer for HeaderElementType {
    type Serializer<'x> = quick_xml_serialize::HeaderElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::HeaderElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::HeaderElementTypeSerializerState::Init__),
            name: name.unwrap_or("HEADER"),
            is_root,
        })
    }
}
impl WithDeserializer for HeaderElementType {
    type Deserializer = quick_xml_deserialize::HeaderElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TNewCatalogElementType {
    pub product: Vec<TNewCatalogProductElementType>,
}
impl WithSerializer for TNewCatalogElementType {
    type Serializer<'x> = quick_xml_serialize::TNewCatalogElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TNewCatalogElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TNewCatalogElementTypeSerializerState::Init__),
            name: name.unwrap_or("T_NEW_CATALOG"),
            is_root,
        })
    }
}
impl WithDeserializer for TNewCatalogElementType {
    type Deserializer = quick_xml_deserialize::TNewCatalogElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TUpdateProductsElementType {
    pub prev_version: i32,
    pub product: Vec<TUpdateProductsProductElementType>,
}
impl WithSerializer for TUpdateProductsElementType {
    type Serializer<'x> = quick_xml_serialize::TUpdateProductsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TUpdateProductsElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TUpdateProductsElementTypeSerializerState::Init__),
            name: name.unwrap_or("T_UPDATE_PRODUCTS"),
            is_root,
        })
    }
}
impl WithDeserializer for TUpdateProductsElementType {
    type Deserializer = quick_xml_deserialize::TUpdateProductsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TUpdatePricesElementType {
    pub prev_version: i32,
    pub product: Vec<TUpdatePricesProductElementType>,
}
impl WithSerializer for TUpdatePricesElementType {
    type Serializer<'x> = quick_xml_serialize::TUpdatePricesElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TUpdatePricesElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TUpdatePricesElementTypeSerializerState::Init__),
            name: name.unwrap_or("T_UPDATE_PRICES"),
            is_root,
        })
    }
}
impl WithDeserializer for TUpdatePricesElementType {
    type Deserializer = quick_xml_deserialize::TUpdatePricesElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CatalogElementType {
    pub language: Vec<LanguageElementType>,
    pub catalog_id: String,
    pub catalog_version: String,
    pub catalog_name: Vec<DtMlstringType>,
    pub datetime: CatalogDatetimeElementType,
    pub territory: Vec<String>,
    pub currency: Option<DtCurrenciesType>,
    pub mime_root: Vec<DtMlstringType>,
}
impl WithSerializer for CatalogElementType {
    type Serializer<'x> = quick_xml_serialize::CatalogElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CatalogElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CatalogElementTypeSerializerState::Init__),
            name: name.unwrap_or("CATALOG"),
            is_root,
        })
    }
}
impl WithDeserializer for CatalogElementType {
    type Deserializer = quick_xml_deserialize::CatalogElementTypeDeserializer;
}
#[derive(Debug)]
pub struct BuyerElementType {
    pub buyer_id: Option<TypePartyIdType>,
    pub buyer_name: String,
}
impl WithSerializer for BuyerElementType {
    type Serializer<'x> = quick_xml_serialize::BuyerElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::BuyerElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BuyerElementTypeSerializerState::Init__),
            name: name.unwrap_or("BUYER"),
            is_root,
        })
    }
}
impl WithDeserializer for BuyerElementType {
    type Deserializer = quick_xml_deserialize::BuyerElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SupplierElementType {
    pub supplier_id: Vec<TypePartyIdType>,
    pub supplier_name: String,
    pub address: Option<SupplierAddressElementType>,
    pub mime_info: Option<MimeInfoElementType>,
}
impl WithSerializer for SupplierElementType {
    type Serializer<'x> = quick_xml_serialize::SupplierElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SupplierElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SupplierElementTypeSerializerState::Init__),
            name: name.unwrap_or("SUPPLIER"),
            is_root,
        })
    }
}
impl WithDeserializer for SupplierElementType {
    type Deserializer = quick_xml_deserialize::SupplierElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxHeaderType {
    pub udx_edxf_version: String,
}
impl WithSerializer for UdxHeaderType {
    type Serializer<'x> = quick_xml_serialize::UdxHeaderTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxHeaderTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxHeaderTypeSerializerState::Init__),
            name: name.unwrap_or("udxHEADER"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxHeaderType {
    type Deserializer = quick_xml_deserialize::UdxHeaderTypeDeserializer;
}
#[derive(Debug)]
pub struct TNewCatalogProductElementType {
    pub mode: TNewCatalogProductmodeType,
    pub supplier_pid: SupplierPidElementType,
    pub product_details: ProductDetailsElementType,
    pub product_features: Vec<ProductFeaturesElementType>,
    pub product_order_details: ProductOrderDetailsElementType,
    pub product_price_details: Vec<ProductPriceDetailsElementType>,
    pub mime_info: Option<MimeInfoElementType>,
    pub user_defined_extensions: UdxProductType,
    pub product_reference: Vec<ProductReferenceElementType>,
    pub product_logistic_details: Option<ProductLogisticDetailsElementType>,
}
impl TNewCatalogProductElementType {
    #[must_use]
    pub fn default_mode() -> TNewCatalogProductmodeType {
        TNewCatalogProductmodeType::New
    }
}
impl WithSerializer for TNewCatalogProductElementType {
    type Serializer<'x> = quick_xml_serialize::TNewCatalogProductElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TNewCatalogProductElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TNewCatalogProductElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("TNewCatalogProduct"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TNewCatalogProductElementType {
    type Deserializer = quick_xml_deserialize::TNewCatalogProductElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TUpdateProductsProductElementType {
    pub mode: TUpdateProductsProductmodeType,
    pub supplier_pid: SupplierPidElementType,
    pub product_details: ProductDetailsElementType,
    pub product_features: Vec<ProductFeaturesElementType>,
    pub product_order_details: ProductOrderDetailsElementType,
    pub product_price_details: Vec<ProductPriceDetailsElementType>,
    pub mime_info: Option<MimeInfoElementType>,
    pub user_defined_extensions: Option<UdxProductType>,
    pub product_reference: Vec<ProductReferenceElementType>,
    pub product_logistic_details: Option<ProductLogisticDetailsElementType>,
}
impl WithSerializer for TUpdateProductsProductElementType {
    type Serializer<'x> = quick_xml_serialize::TUpdateProductsProductElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TUpdateProductsProductElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TUpdateProductsProductElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("TUpdateProductsProduct"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TUpdateProductsProductElementType {
    type Deserializer = quick_xml_deserialize::TUpdateProductsProductElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TUpdatePricesProductElementType {
    pub mode: TUpdatePricesProductmodeType,
    pub supplier_pid: SupplierPidElementType,
    pub product_price_details: Vec<ProductPriceDetailsElementType>,
    pub user_defined_extensions: Option<UdxProductType>,
}
impl TUpdatePricesProductElementType {
    #[must_use]
    pub fn default_mode() -> TUpdatePricesProductmodeType {
        TUpdatePricesProductmodeType::Update
    }
}
impl WithSerializer for TUpdatePricesProductElementType {
    type Serializer<'x> = quick_xml_serialize::TUpdatePricesProductElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TUpdatePricesProductElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TUpdatePricesProductElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("TUpdatePricesProduct"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TUpdatePricesProductElementType {
    type Deserializer = quick_xml_deserialize::TUpdatePricesProductElementTypeDeserializer;
}
#[derive(Debug)]
pub struct LanguageElementType {
    pub default: Option<String>,
    pub content: DtLangType,
}
impl WithSerializer for LanguageElementType {
    type Serializer<'x> = quick_xml_serialize::LanguageElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::LanguageElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::LanguageElementTypeSerializerState::Init__),
            name: name.unwrap_or("LANGUAGE"),
            is_root,
        })
    }
}
impl WithDeserializer for LanguageElementType {
    type Deserializer = quick_xml_deserialize::LanguageElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DtMlstringType {
    pub lang: Option<DtLangType>,
    pub content: String,
}
impl WithSerializer for DtMlstringType {
    type Serializer<'x> = quick_xml_serialize::DtMlstringTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DtMlstringTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DtMlstringTypeSerializerState::Init__),
            name: name.unwrap_or("dtMLSTRING"),
            is_root,
        })
    }
}
impl WithDeserializer for DtMlstringType {
    type Deserializer = quick_xml_deserialize::DtMlstringTypeDeserializer;
}
#[derive(Debug)]
pub struct CatalogDatetimeElementType {
    pub type_: CatalogDatetimetypeType,
    pub date: String,
    pub time: Option<String>,
    pub timezone: Option<String>,
}
impl WithSerializer for CatalogDatetimeElementType {
    type Serializer<'x> = quick_xml_serialize::CatalogDatetimeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CatalogDatetimeElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CatalogDatetimeElementTypeSerializerState::Init__),
            name: name.unwrap_or("CatalogDatetime"),
            is_root,
        })
    }
}
impl WithDeserializer for CatalogDatetimeElementType {
    type Deserializer = quick_xml_deserialize::CatalogDatetimeElementTypeDeserializer;
}
#[derive(Debug)]
pub enum DtCurrenciesType {
    Adp,
    Aed,
    Afa,
    All,
    Ang,
    Aok,
    Ara,
    Ats,
    Aud,
    Awg,
    Bbd,
    Bdt,
    Bef,
    Bgl,
    Bhd,
    Bif,
    Bmd,
    Bnd,
    Bob,
    Brc,
    Bsd,
    Btn,
    Buk,
    Bwp,
    Bzd,
    Cad,
    Chf,
    Clf,
    Clp,
    Cny,
    Cop,
    Crc,
    Csk,
    Cup,
    Cve,
    Cyp,
    Ddm,
    Dem,
    Djf,
    Dkk,
    Dop,
    Dzd,
    Ecs,
    Egp,
    Esp,
    Etb,
    Eur,
    Fim,
    Fjd,
    Fkp,
    Frf,
    Gbp,
    Ghc,
    Gip,
    Gmd,
    Gnf,
    Grd,
    Gtq,
    Gwp,
    Gyd,
    Hkd,
    Hnl,
    Htg,
    Huf,
    Idr,
    Iep,
    Ils,
    Inr,
    Iqd,
    Irr,
    Isk,
    Itl,
    Jmd,
    Jod,
    Jpy,
    Kes,
    Khr,
    Kmf,
    Kpw,
    Krw,
    Kwd,
    Kyd,
    Lak,
    Lbp,
    Lkr,
    Lrd,
    Lsl,
    Luf,
    Lyd,
    Mad,
    Mgf,
    Mnt,
    Mop,
    Mro,
    Mtl,
    Mur,
    Mvr,
    Mwk,
    Mxp,
    Myr,
    Mzm,
    Ngn,
    Nic,
    Nlg,
    Nok,
    Npr,
    Nzd,
    Omr,
    Pab,
    Pei,
    Pgk,
    Php,
    Pkr,
    Plz,
    Pln,
    Pte,
    Pyg,
    Qar,
    Rol,
    Rwf,
    Sar,
    Sbd,
    Scr,
    Sdp,
    Sek,
    Sgd,
    Shp,
    Sll,
    Skk,
    Sos,
    Srg,
    Std,
    Sur,
    Svc,
    Syp,
    Szl,
    Thb,
    Tnd,
    Top,
    Tpe,
    Trl,
    Ttd,
    Twd,
    Tzs,
    Ugs,
    Usd,
    Uyp,
    Veb,
    Vnd,
    Vuv,
    Wst,
    Ydd,
    Yer,
    Yud,
    Zar,
    Zmk,
    Zrz,
    Zwd,
}
impl SerializeBytes for DtCurrenciesType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Adp => Ok(Some(Cow::Borrowed("ADP"))),
            Self::Aed => Ok(Some(Cow::Borrowed("AED"))),
            Self::Afa => Ok(Some(Cow::Borrowed("AFA"))),
            Self::All => Ok(Some(Cow::Borrowed("ALL"))),
            Self::Ang => Ok(Some(Cow::Borrowed("ANG"))),
            Self::Aok => Ok(Some(Cow::Borrowed("AOK"))),
            Self::Ara => Ok(Some(Cow::Borrowed("ARA"))),
            Self::Ats => Ok(Some(Cow::Borrowed("ATS"))),
            Self::Aud => Ok(Some(Cow::Borrowed("AUD"))),
            Self::Awg => Ok(Some(Cow::Borrowed("AWG"))),
            Self::Bbd => Ok(Some(Cow::Borrowed("BBD"))),
            Self::Bdt => Ok(Some(Cow::Borrowed("BDT"))),
            Self::Bef => Ok(Some(Cow::Borrowed("BEF"))),
            Self::Bgl => Ok(Some(Cow::Borrowed("BGL"))),
            Self::Bhd => Ok(Some(Cow::Borrowed("BHD"))),
            Self::Bif => Ok(Some(Cow::Borrowed("BIF"))),
            Self::Bmd => Ok(Some(Cow::Borrowed("BMD"))),
            Self::Bnd => Ok(Some(Cow::Borrowed("BND"))),
            Self::Bob => Ok(Some(Cow::Borrowed("BOB"))),
            Self::Brc => Ok(Some(Cow::Borrowed("BRC"))),
            Self::Bsd => Ok(Some(Cow::Borrowed("BSD"))),
            Self::Btn => Ok(Some(Cow::Borrowed("BTN"))),
            Self::Buk => Ok(Some(Cow::Borrowed("BUK"))),
            Self::Bwp => Ok(Some(Cow::Borrowed("BWP"))),
            Self::Bzd => Ok(Some(Cow::Borrowed("BZD"))),
            Self::Cad => Ok(Some(Cow::Borrowed("CAD"))),
            Self::Chf => Ok(Some(Cow::Borrowed("CHF"))),
            Self::Clf => Ok(Some(Cow::Borrowed("CLF"))),
            Self::Clp => Ok(Some(Cow::Borrowed("CLP"))),
            Self::Cny => Ok(Some(Cow::Borrowed("CNY"))),
            Self::Cop => Ok(Some(Cow::Borrowed("COP"))),
            Self::Crc => Ok(Some(Cow::Borrowed("CRC"))),
            Self::Csk => Ok(Some(Cow::Borrowed("CSK"))),
            Self::Cup => Ok(Some(Cow::Borrowed("CUP"))),
            Self::Cve => Ok(Some(Cow::Borrowed("CVE"))),
            Self::Cyp => Ok(Some(Cow::Borrowed("CYP"))),
            Self::Ddm => Ok(Some(Cow::Borrowed("DDM"))),
            Self::Dem => Ok(Some(Cow::Borrowed("DEM"))),
            Self::Djf => Ok(Some(Cow::Borrowed("DJF"))),
            Self::Dkk => Ok(Some(Cow::Borrowed("DKK"))),
            Self::Dop => Ok(Some(Cow::Borrowed("DOP"))),
            Self::Dzd => Ok(Some(Cow::Borrowed("DZD"))),
            Self::Ecs => Ok(Some(Cow::Borrowed("ECS"))),
            Self::Egp => Ok(Some(Cow::Borrowed("EGP"))),
            Self::Esp => Ok(Some(Cow::Borrowed("ESP"))),
            Self::Etb => Ok(Some(Cow::Borrowed("ETB"))),
            Self::Eur => Ok(Some(Cow::Borrowed("EUR"))),
            Self::Fim => Ok(Some(Cow::Borrowed("FIM"))),
            Self::Fjd => Ok(Some(Cow::Borrowed("FJD"))),
            Self::Fkp => Ok(Some(Cow::Borrowed("FKP"))),
            Self::Frf => Ok(Some(Cow::Borrowed("FRF"))),
            Self::Gbp => Ok(Some(Cow::Borrowed("GBP"))),
            Self::Ghc => Ok(Some(Cow::Borrowed("GHC"))),
            Self::Gip => Ok(Some(Cow::Borrowed("GIP"))),
            Self::Gmd => Ok(Some(Cow::Borrowed("GMD"))),
            Self::Gnf => Ok(Some(Cow::Borrowed("GNF"))),
            Self::Grd => Ok(Some(Cow::Borrowed("GRD"))),
            Self::Gtq => Ok(Some(Cow::Borrowed("GTQ"))),
            Self::Gwp => Ok(Some(Cow::Borrowed("GWP"))),
            Self::Gyd => Ok(Some(Cow::Borrowed("GYD"))),
            Self::Hkd => Ok(Some(Cow::Borrowed("HKD"))),
            Self::Hnl => Ok(Some(Cow::Borrowed("HNL"))),
            Self::Htg => Ok(Some(Cow::Borrowed("HTG"))),
            Self::Huf => Ok(Some(Cow::Borrowed("HUF"))),
            Self::Idr => Ok(Some(Cow::Borrowed("IDR"))),
            Self::Iep => Ok(Some(Cow::Borrowed("IEP"))),
            Self::Ils => Ok(Some(Cow::Borrowed("ILS"))),
            Self::Inr => Ok(Some(Cow::Borrowed("INR"))),
            Self::Iqd => Ok(Some(Cow::Borrowed("IQD"))),
            Self::Irr => Ok(Some(Cow::Borrowed("IRR"))),
            Self::Isk => Ok(Some(Cow::Borrowed("ISK"))),
            Self::Itl => Ok(Some(Cow::Borrowed("ITL"))),
            Self::Jmd => Ok(Some(Cow::Borrowed("JMD"))),
            Self::Jod => Ok(Some(Cow::Borrowed("JOD"))),
            Self::Jpy => Ok(Some(Cow::Borrowed("JPY"))),
            Self::Kes => Ok(Some(Cow::Borrowed("KES"))),
            Self::Khr => Ok(Some(Cow::Borrowed("KHR"))),
            Self::Kmf => Ok(Some(Cow::Borrowed("KMF"))),
            Self::Kpw => Ok(Some(Cow::Borrowed("KPW"))),
            Self::Krw => Ok(Some(Cow::Borrowed("KRW"))),
            Self::Kwd => Ok(Some(Cow::Borrowed("KWD"))),
            Self::Kyd => Ok(Some(Cow::Borrowed("KYD"))),
            Self::Lak => Ok(Some(Cow::Borrowed("LAK"))),
            Self::Lbp => Ok(Some(Cow::Borrowed("LBP"))),
            Self::Lkr => Ok(Some(Cow::Borrowed("LKR"))),
            Self::Lrd => Ok(Some(Cow::Borrowed("LRD"))),
            Self::Lsl => Ok(Some(Cow::Borrowed("LSL"))),
            Self::Luf => Ok(Some(Cow::Borrowed("LUF"))),
            Self::Lyd => Ok(Some(Cow::Borrowed("LYD"))),
            Self::Mad => Ok(Some(Cow::Borrowed("MAD"))),
            Self::Mgf => Ok(Some(Cow::Borrowed("MGF"))),
            Self::Mnt => Ok(Some(Cow::Borrowed("MNT"))),
            Self::Mop => Ok(Some(Cow::Borrowed("MOP"))),
            Self::Mro => Ok(Some(Cow::Borrowed("MRO"))),
            Self::Mtl => Ok(Some(Cow::Borrowed("MTL"))),
            Self::Mur => Ok(Some(Cow::Borrowed("MUR"))),
            Self::Mvr => Ok(Some(Cow::Borrowed("MVR"))),
            Self::Mwk => Ok(Some(Cow::Borrowed("MWK"))),
            Self::Mxp => Ok(Some(Cow::Borrowed("MXP"))),
            Self::Myr => Ok(Some(Cow::Borrowed("MYR"))),
            Self::Mzm => Ok(Some(Cow::Borrowed("MZM"))),
            Self::Ngn => Ok(Some(Cow::Borrowed("NGN"))),
            Self::Nic => Ok(Some(Cow::Borrowed("NIC"))),
            Self::Nlg => Ok(Some(Cow::Borrowed("NLG"))),
            Self::Nok => Ok(Some(Cow::Borrowed("NOK"))),
            Self::Npr => Ok(Some(Cow::Borrowed("NPR"))),
            Self::Nzd => Ok(Some(Cow::Borrowed("NZD"))),
            Self::Omr => Ok(Some(Cow::Borrowed("OMR"))),
            Self::Pab => Ok(Some(Cow::Borrowed("PAB"))),
            Self::Pei => Ok(Some(Cow::Borrowed("PEI"))),
            Self::Pgk => Ok(Some(Cow::Borrowed("PGK"))),
            Self::Php => Ok(Some(Cow::Borrowed("PHP"))),
            Self::Pkr => Ok(Some(Cow::Borrowed("PKR"))),
            Self::Plz => Ok(Some(Cow::Borrowed("PLZ"))),
            Self::Pln => Ok(Some(Cow::Borrowed("PLN"))),
            Self::Pte => Ok(Some(Cow::Borrowed("PTE"))),
            Self::Pyg => Ok(Some(Cow::Borrowed("PYG"))),
            Self::Qar => Ok(Some(Cow::Borrowed("QAR"))),
            Self::Rol => Ok(Some(Cow::Borrowed("ROL"))),
            Self::Rwf => Ok(Some(Cow::Borrowed("RWF"))),
            Self::Sar => Ok(Some(Cow::Borrowed("SAR"))),
            Self::Sbd => Ok(Some(Cow::Borrowed("SBD"))),
            Self::Scr => Ok(Some(Cow::Borrowed("SCR"))),
            Self::Sdp => Ok(Some(Cow::Borrowed("SDP"))),
            Self::Sek => Ok(Some(Cow::Borrowed("SEK"))),
            Self::Sgd => Ok(Some(Cow::Borrowed("SGD"))),
            Self::Shp => Ok(Some(Cow::Borrowed("SHP"))),
            Self::Sll => Ok(Some(Cow::Borrowed("SLL"))),
            Self::Skk => Ok(Some(Cow::Borrowed("SKK"))),
            Self::Sos => Ok(Some(Cow::Borrowed("SOS"))),
            Self::Srg => Ok(Some(Cow::Borrowed("SRG"))),
            Self::Std => Ok(Some(Cow::Borrowed("STD"))),
            Self::Sur => Ok(Some(Cow::Borrowed("SUR"))),
            Self::Svc => Ok(Some(Cow::Borrowed("SVC"))),
            Self::Syp => Ok(Some(Cow::Borrowed("SYP"))),
            Self::Szl => Ok(Some(Cow::Borrowed("SZL"))),
            Self::Thb => Ok(Some(Cow::Borrowed("THB"))),
            Self::Tnd => Ok(Some(Cow::Borrowed("TND"))),
            Self::Top => Ok(Some(Cow::Borrowed("TOP"))),
            Self::Tpe => Ok(Some(Cow::Borrowed("TPE"))),
            Self::Trl => Ok(Some(Cow::Borrowed("TRL"))),
            Self::Ttd => Ok(Some(Cow::Borrowed("TTD"))),
            Self::Twd => Ok(Some(Cow::Borrowed("TWD"))),
            Self::Tzs => Ok(Some(Cow::Borrowed("TZS"))),
            Self::Ugs => Ok(Some(Cow::Borrowed("UGS"))),
            Self::Usd => Ok(Some(Cow::Borrowed("USD"))),
            Self::Uyp => Ok(Some(Cow::Borrowed("UYP"))),
            Self::Veb => Ok(Some(Cow::Borrowed("VEB"))),
            Self::Vnd => Ok(Some(Cow::Borrowed("VND"))),
            Self::Vuv => Ok(Some(Cow::Borrowed("VUV"))),
            Self::Wst => Ok(Some(Cow::Borrowed("WST"))),
            Self::Ydd => Ok(Some(Cow::Borrowed("YDD"))),
            Self::Yer => Ok(Some(Cow::Borrowed("YER"))),
            Self::Yud => Ok(Some(Cow::Borrowed("YUD"))),
            Self::Zar => Ok(Some(Cow::Borrowed("ZAR"))),
            Self::Zmk => Ok(Some(Cow::Borrowed("ZMK"))),
            Self::Zrz => Ok(Some(Cow::Borrowed("ZRZ"))),
            Self::Zwd => Ok(Some(Cow::Borrowed("ZWD"))),
        }
    }
}
impl DeserializeBytes for DtCurrenciesType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"ADP" => Ok(Self::Adp),
            b"AED" => Ok(Self::Aed),
            b"AFA" => Ok(Self::Afa),
            b"ALL" => Ok(Self::All),
            b"ANG" => Ok(Self::Ang),
            b"AOK" => Ok(Self::Aok),
            b"ARA" => Ok(Self::Ara),
            b"ATS" => Ok(Self::Ats),
            b"AUD" => Ok(Self::Aud),
            b"AWG" => Ok(Self::Awg),
            b"BBD" => Ok(Self::Bbd),
            b"BDT" => Ok(Self::Bdt),
            b"BEF" => Ok(Self::Bef),
            b"BGL" => Ok(Self::Bgl),
            b"BHD" => Ok(Self::Bhd),
            b"BIF" => Ok(Self::Bif),
            b"BMD" => Ok(Self::Bmd),
            b"BND" => Ok(Self::Bnd),
            b"BOB" => Ok(Self::Bob),
            b"BRC" => Ok(Self::Brc),
            b"BSD" => Ok(Self::Bsd),
            b"BTN" => Ok(Self::Btn),
            b"BUK" => Ok(Self::Buk),
            b"BWP" => Ok(Self::Bwp),
            b"BZD" => Ok(Self::Bzd),
            b"CAD" => Ok(Self::Cad),
            b"CHF" => Ok(Self::Chf),
            b"CLF" => Ok(Self::Clf),
            b"CLP" => Ok(Self::Clp),
            b"CNY" => Ok(Self::Cny),
            b"COP" => Ok(Self::Cop),
            b"CRC" => Ok(Self::Crc),
            b"CSK" => Ok(Self::Csk),
            b"CUP" => Ok(Self::Cup),
            b"CVE" => Ok(Self::Cve),
            b"CYP" => Ok(Self::Cyp),
            b"DDM" => Ok(Self::Ddm),
            b"DEM" => Ok(Self::Dem),
            b"DJF" => Ok(Self::Djf),
            b"DKK" => Ok(Self::Dkk),
            b"DOP" => Ok(Self::Dop),
            b"DZD" => Ok(Self::Dzd),
            b"ECS" => Ok(Self::Ecs),
            b"EGP" => Ok(Self::Egp),
            b"ESP" => Ok(Self::Esp),
            b"ETB" => Ok(Self::Etb),
            b"EUR" => Ok(Self::Eur),
            b"FIM" => Ok(Self::Fim),
            b"FJD" => Ok(Self::Fjd),
            b"FKP" => Ok(Self::Fkp),
            b"FRF" => Ok(Self::Frf),
            b"GBP" => Ok(Self::Gbp),
            b"GHC" => Ok(Self::Ghc),
            b"GIP" => Ok(Self::Gip),
            b"GMD" => Ok(Self::Gmd),
            b"GNF" => Ok(Self::Gnf),
            b"GRD" => Ok(Self::Grd),
            b"GTQ" => Ok(Self::Gtq),
            b"GWP" => Ok(Self::Gwp),
            b"GYD" => Ok(Self::Gyd),
            b"HKD" => Ok(Self::Hkd),
            b"HNL" => Ok(Self::Hnl),
            b"HTG" => Ok(Self::Htg),
            b"HUF" => Ok(Self::Huf),
            b"IDR" => Ok(Self::Idr),
            b"IEP" => Ok(Self::Iep),
            b"ILS" => Ok(Self::Ils),
            b"INR" => Ok(Self::Inr),
            b"IQD" => Ok(Self::Iqd),
            b"IRR" => Ok(Self::Irr),
            b"ISK" => Ok(Self::Isk),
            b"ITL" => Ok(Self::Itl),
            b"JMD" => Ok(Self::Jmd),
            b"JOD" => Ok(Self::Jod),
            b"JPY" => Ok(Self::Jpy),
            b"KES" => Ok(Self::Kes),
            b"KHR" => Ok(Self::Khr),
            b"KMF" => Ok(Self::Kmf),
            b"KPW" => Ok(Self::Kpw),
            b"KRW" => Ok(Self::Krw),
            b"KWD" => Ok(Self::Kwd),
            b"KYD" => Ok(Self::Kyd),
            b"LAK" => Ok(Self::Lak),
            b"LBP" => Ok(Self::Lbp),
            b"LKR" => Ok(Self::Lkr),
            b"LRD" => Ok(Self::Lrd),
            b"LSL" => Ok(Self::Lsl),
            b"LUF" => Ok(Self::Luf),
            b"LYD" => Ok(Self::Lyd),
            b"MAD" => Ok(Self::Mad),
            b"MGF" => Ok(Self::Mgf),
            b"MNT" => Ok(Self::Mnt),
            b"MOP" => Ok(Self::Mop),
            b"MRO" => Ok(Self::Mro),
            b"MTL" => Ok(Self::Mtl),
            b"MUR" => Ok(Self::Mur),
            b"MVR" => Ok(Self::Mvr),
            b"MWK" => Ok(Self::Mwk),
            b"MXP" => Ok(Self::Mxp),
            b"MYR" => Ok(Self::Myr),
            b"MZM" => Ok(Self::Mzm),
            b"NGN" => Ok(Self::Ngn),
            b"NIC" => Ok(Self::Nic),
            b"NLG" => Ok(Self::Nlg),
            b"NOK" => Ok(Self::Nok),
            b"NPR" => Ok(Self::Npr),
            b"NZD" => Ok(Self::Nzd),
            b"OMR" => Ok(Self::Omr),
            b"PAB" => Ok(Self::Pab),
            b"PEI" => Ok(Self::Pei),
            b"PGK" => Ok(Self::Pgk),
            b"PHP" => Ok(Self::Php),
            b"PKR" => Ok(Self::Pkr),
            b"PLZ" => Ok(Self::Plz),
            b"PLN" => Ok(Self::Pln),
            b"PTE" => Ok(Self::Pte),
            b"PYG" => Ok(Self::Pyg),
            b"QAR" => Ok(Self::Qar),
            b"ROL" => Ok(Self::Rol),
            b"RWF" => Ok(Self::Rwf),
            b"SAR" => Ok(Self::Sar),
            b"SBD" => Ok(Self::Sbd),
            b"SCR" => Ok(Self::Scr),
            b"SDP" => Ok(Self::Sdp),
            b"SEK" => Ok(Self::Sek),
            b"SGD" => Ok(Self::Sgd),
            b"SHP" => Ok(Self::Shp),
            b"SLL" => Ok(Self::Sll),
            b"SKK" => Ok(Self::Skk),
            b"SOS" => Ok(Self::Sos),
            b"SRG" => Ok(Self::Srg),
            b"STD" => Ok(Self::Std),
            b"SUR" => Ok(Self::Sur),
            b"SVC" => Ok(Self::Svc),
            b"SYP" => Ok(Self::Syp),
            b"SZL" => Ok(Self::Szl),
            b"THB" => Ok(Self::Thb),
            b"TND" => Ok(Self::Tnd),
            b"TOP" => Ok(Self::Top),
            b"TPE" => Ok(Self::Tpe),
            b"TRL" => Ok(Self::Trl),
            b"TTD" => Ok(Self::Ttd),
            b"TWD" => Ok(Self::Twd),
            b"TZS" => Ok(Self::Tzs),
            b"UGS" => Ok(Self::Ugs),
            b"USD" => Ok(Self::Usd),
            b"UYP" => Ok(Self::Uyp),
            b"VEB" => Ok(Self::Veb),
            b"VND" => Ok(Self::Vnd),
            b"VUV" => Ok(Self::Vuv),
            b"WST" => Ok(Self::Wst),
            b"YDD" => Ok(Self::Ydd),
            b"YER" => Ok(Self::Yer),
            b"YUD" => Ok(Self::Yud),
            b"ZAR" => Ok(Self::Zar),
            b"ZMK" => Ok(Self::Zmk),
            b"ZRZ" => Ok(Self::Zrz),
            b"ZWD" => Ok(Self::Zwd),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct TypePartyIdType {
    pub type_: Option<String>,
    pub content: String,
}
impl WithSerializer for TypePartyIdType {
    type Serializer<'x> = quick_xml_serialize::TypePartyIdTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TypePartyIdTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TypePartyIdTypeSerializerState::Init__),
            name: name.unwrap_or("typePARTY_ID"),
            is_root,
        })
    }
}
impl WithDeserializer for TypePartyIdType {
    type Deserializer = quick_xml_deserialize::TypePartyIdTypeDeserializer;
}
#[derive(Debug)]
pub struct SupplierAddressElementType {
    pub type_: SupplierAddresstypeType,
    pub contact: Vec<DtMlstringType>,
    pub street: Vec<DtMlstringType>,
    pub zip: Vec<DtMlstringType>,
    pub city: Vec<DtMlstringType>,
    pub country: Vec<DtMlstringType>,
    pub vat_id: Option<String>,
    pub email: String,
    pub url: Option<String>,
}
impl WithSerializer for SupplierAddressElementType {
    type Serializer<'x> = quick_xml_serialize::SupplierAddressElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SupplierAddressElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SupplierAddressElementTypeSerializerState::Init__),
            name: name.unwrap_or("SupplierAddress"),
            is_root,
        })
    }
}
impl WithDeserializer for SupplierAddressElementType {
    type Deserializer = quick_xml_deserialize::SupplierAddressElementTypeDeserializer;
}
#[derive(Debug)]
pub struct MimeInfoElementType {
    pub mime: Vec<MimeElementType>,
}
impl WithSerializer for MimeInfoElementType {
    type Serializer<'x> = quick_xml_serialize::MimeInfoElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::MimeInfoElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::MimeInfoElementTypeSerializerState::Init__),
            name: name.unwrap_or("MIME_INFO"),
            is_root,
        })
    }
}
impl WithDeserializer for MimeInfoElementType {
    type Deserializer = quick_xml_deserialize::MimeInfoElementTypeDeserializer;
}
#[derive(Debug)]
pub enum TNewCatalogProductmodeType {
    New,
}
impl SerializeBytes for TNewCatalogProductmodeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::New => Ok(Some(Cow::Borrowed("new"))),
        }
    }
}
impl DeserializeBytes for TNewCatalogProductmodeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"new" => Ok(Self::New),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct SupplierPidElementType {
    pub type_: Option<String>,
    pub content: String,
}
impl WithSerializer for SupplierPidElementType {
    type Serializer<'x> = quick_xml_serialize::SupplierPidElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SupplierPidElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SupplierPidElementTypeSerializerState::Init__),
            name: name.unwrap_or("SUPPLIER_PID"),
            is_root,
        })
    }
}
impl WithDeserializer for SupplierPidElementType {
    type Deserializer = quick_xml_deserialize::SupplierPidElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductDetailsElementType {
    pub description_short: Vec<DtMlstringType>,
    pub description_long: Vec<DtMlstringType>,
    pub international_pid: Vec<InternationalPidElementType>,
    pub supplier_alt_pid: Option<String>,
    pub buyer_pid: Vec<BuyerPidElementType>,
    pub manufacturer_pid: Option<String>,
    pub manufacturer_name: Option<String>,
    pub manufacturer_type_descr: Vec<DtMlstringType>,
    pub special_treatment_class: Vec<SpecialTreatmentClassElementType>,
    pub keyword: Vec<DtMlstringType>,
    pub remarks: Vec<RemarksElementType>,
    pub product_status: Vec<ProductStatusElementType>,
}
impl WithSerializer for ProductDetailsElementType {
    type Serializer<'x> = quick_xml_serialize::ProductDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductDetailsElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductDetailsElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRODUCT_DETAILS"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductDetailsElementType {
    type Deserializer = quick_xml_deserialize::ProductDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductFeaturesElementType {
    pub reference_feature_system_name: String,
    pub reference_feature_group_id: TypeClassificationGroupIdType,
    pub feature: Vec<FeatureElementType>,
}
impl WithSerializer for ProductFeaturesElementType {
    type Serializer<'x> = quick_xml_serialize::ProductFeaturesElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductFeaturesElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductFeaturesElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRODUCT_FEATURES"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductFeaturesElementType {
    type Deserializer = quick_xml_deserialize::ProductFeaturesElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductOrderDetailsElementType {
    pub order_unit: DtPunitType,
    pub content_unit: DtPunitType,
    pub no_cu_per_ou: Option<f64>,
    pub price_quantity: Option<f64>,
    pub quantity_min: Option<f32>,
    pub quantity_interval: Option<f32>,
}
impl WithSerializer for ProductOrderDetailsElementType {
    type Serializer<'x> = quick_xml_serialize::ProductOrderDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::ProductOrderDetailsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ProductOrderDetailsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PRODUCT_ORDER_DETAILS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for ProductOrderDetailsElementType {
    type Deserializer = quick_xml_deserialize::ProductOrderDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductPriceDetailsElementType {
    pub datetime: Vec<ProductPriceDetailsDatetimeElementType>,
    pub daily_price: Option<String>,
    pub product_price: Vec<ProductPriceElementType>,
}
impl WithSerializer for ProductPriceDetailsElementType {
    type Serializer<'x> = quick_xml_serialize::ProductPriceDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::ProductPriceDetailsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ProductPriceDetailsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PRODUCT_PRICE_DETAILS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for ProductPriceDetailsElementType {
    type Deserializer = quick_xml_deserialize::ProductPriceDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxProductType {
    pub udx_edxf_manufacturer_acronym: Option<String>,
    pub udx_edxf_description_very_short: Vec<DtMlstringType>,
    pub udx_edxf_brand_name: Option<String>,
    pub udx_edxf_tender_text: Vec<DtMlstringType>,
    pub udx_edxf_valid_from: Option<String>,
    pub udx_edxf_expiration_date: Option<String>,
    pub udx_edxf_discount_group: Option<UdxEdxfDiscountGroupElementType>,
    pub udx_edxf_bonus_group_supplier: Option<String>,
    pub udx_edxf_pkwiu: Option<String>,
    pub udx_edxf_declaration: Vec<UdxEdxfDeclarationElementType>,
    pub udx_edxf_additional_factors: Option<UdxEdxfAdditionalFactorsElementType>,
    pub udx_edxf_product_to_stock: Option<String>,
    pub udx_edxf_product_series: Vec<DtMlstringType>,
    pub udx_edxf_product_variation: Vec<DtMlstringType>,
    pub udx_edxf_at_reverse_charge_info: Option<String>,
    pub udx_edxf_country_branch_numbers: Option<UdxEdxfCountryBranchNumbersElementType>,
    pub udx_edxf_country_branch_supplier_ids: Option<UdxEdxfCountryBranchSupplierIdsElementType>,
    pub udx_edxf_packing_units: Option<UdxEdxfPackingUnitsElementType>,
    pub udx_edxf_product_logistic_details: Option<UdxEdxfProductLogisticDetailsElementType>,
    pub udx_edxf_reach: Option<UdxEdxfReachElementType>,
    pub udx_edxf_surcharge_list: Option<UdxEdxfSurchargeListElementType>,
}
impl WithSerializer for UdxProductType {
    type Serializer<'x> = quick_xml_serialize::UdxProductTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxProductTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxProductTypeSerializerState::Init__),
            name: name.unwrap_or("udxPRODUCT"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxProductType {
    type Deserializer = quick_xml_deserialize::UdxProductTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductReferenceElementType {
    pub type_: ProductReferencetypeType,
    pub quantity: Option<i32>,
    pub prod_id_to: String,
    pub catalog_id: Option<String>,
    pub catalog_version: Option<String>,
}
impl WithSerializer for ProductReferenceElementType {
    type Serializer<'x> = quick_xml_serialize::ProductReferenceElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductReferenceElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::ProductReferenceElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("PRODUCT_REFERENCE"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductReferenceElementType {
    type Deserializer = quick_xml_deserialize::ProductReferenceElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductLogisticDetailsElementType {
    pub customs_tariff_number: Vec<CustomsTariffNumberElementType>,
    pub statistics_factor: Option<f64>,
    pub country_of_origin: Vec<String>,
}
impl WithSerializer for ProductLogisticDetailsElementType {
    type Serializer<'x> = quick_xml_serialize::ProductLogisticDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::ProductLogisticDetailsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ProductLogisticDetailsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PRODUCT_LOGISTIC_DETAILS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for ProductLogisticDetailsElementType {
    type Deserializer = quick_xml_deserialize::ProductLogisticDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub enum TUpdateProductsProductmodeType {
    Delete,
    New,
    Update,
}
impl SerializeBytes for TUpdateProductsProductmodeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Delete => Ok(Some(Cow::Borrowed("delete"))),
            Self::New => Ok(Some(Cow::Borrowed("new"))),
            Self::Update => Ok(Some(Cow::Borrowed("update"))),
        }
    }
}
impl DeserializeBytes for TUpdateProductsProductmodeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"delete" => Ok(Self::Delete),
            b"new" => Ok(Self::New),
            b"update" => Ok(Self::Update),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum TUpdatePricesProductmodeType {
    Update,
}
impl SerializeBytes for TUpdatePricesProductmodeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Update => Ok(Some(Cow::Borrowed("update"))),
        }
    }
}
impl DeserializeBytes for TUpdatePricesProductmodeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"update" => Ok(Self::Update),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum DtLangType {
    Aar,
    Abk,
    Ace,
    Ach,
    Ada,
    Afa,
    Afh,
    Afr,
    Aka,
    Akk,
    Alb,
    Ale,
    Alg,
    Amh,
    Ang,
    Apa,
    Ara,
    Arc,
    Arm,
    Arn,
    Arp,
    Art,
    Arw,
    Asm,
    Ath,
    Aus,
    Ava,
    Ave,
    Awa,
    Aym,
    Aze,
    Bad,
    Bai,
    Bak,
    Bal,
    Bam,
    Ban,
    Baq,
    Bas,
    Bat,
    Bej,
    Bel,
    Bem,
    Ben,
    Ber,
    Bho,
    Bih,
    Bik,
    Bin,
    Bis,
    Bla,
    Bnt,
    Bod,
    Bos,
    Bra,
    Bre,
    Btk,
    Bua,
    Bug,
    Bul,
    Bur,
    Cad,
    Cai,
    Car,
    Cat,
    Cau,
    Ceb,
    Cel,
    Ces,
    Cha,
    Chb,
    Che,
    Chg,
    Chi,
    Chk,
    Chm,
    Chn,
    Cho,
    Chp,
    Chr,
    Chu,
    Chv,
    Chy,
    Cmc,
    Cop,
    Cor,
    Cos,
    Cpe,
    Cpf,
    Cpp,
    Cre,
    Crp,
    Cus,
    Cym,
    Cze,
    Dak,
    Dan,
    Day,
    Del,
    Den,
    Deu,
    Dgr,
    Din,
    Div,
    Doi,
    Dra,
    Dua,
    Dum,
    Dut,
    Dyu,
    Dzo,
    Efi,
    Egy,
    Eka,
    Ell,
    Elx,
    Eng,
    Enm,
    Epo,
    Est,
    Eus,
    Ewe,
    Ewo,
    Fan,
    Fao,
    Fas,
    Fat,
    Fij,
    Fin,
    Fiu,
    Fon,
    Fra,
    Fre,
    Frm,
    Fro,
    Fry,
    Ful,
    Fur,
    Gaa,
    Gay,
    Gba,
    Gem,
    Geo,
    Ger,
    Gez,
    Gil,
    Gla,
    Gle,
    Glg,
    Glv,
    Gmh,
    Goh,
    Gon,
    Gor,
    Got,
    Grb,
    Grc,
    Gre,
    Grn,
    Guj,
    Gwi,
    Hai,
    Hau,
    Haw,
    Heb,
    Her,
    Hil,
    Him,
    Hin,
    Hit,
    Hmn,
    Hmo,
    Hrv,
    Hun,
    Hup,
    Hye,
    Iba,
    Ibo,
    Ice,
    Ijo,
    Iku,
    Ile,
    Ilo,
    Ina,
    Inc,
    Ind,
    Ine,
    Ipk,
    Ira,
    Iro,
    Isl,
    Ita,
    Jav,
    Jpn,
    Jpr,
    Jrb,
    Kaa,
    Kab,
    Kac,
    Kal,
    Kam,
    Kan,
    Kar,
    Kas,
    Kat,
    Kau,
    Kaw,
    Kaz,
    Kha,
    Khi,
    Khm,
    Kho,
    Kik,
    Kin,
    Kir,
    Kmb,
    Kok,
    Kom,
    Kon,
    Kor,
    Kos,
    Kpe,
    Kro,
    Kru,
    Kua,
    Kum,
    Kur,
    Kut,
    Lad,
    Lah,
    Lam,
    Lao,
    Lat,
    Lav,
    Lez,
    Lin,
    Lit,
    Lol,
    Loz,
    Ltz,
    Lua,
    Lub,
    Lug,
    Lui,
    Lun,
    Luo,
    Lus,
    Mac,
    Mad,
    Mag,
    Mah,
    Mai,
    Mak,
    Mal,
    Man,
    Mao,
    Map,
    Mar,
    Mas,
    May,
    Mdr,
    Men,
    Mga,
    Mic,
    Min,
    Mis,
    Mkd,
    Mkh,
    Mlg,
    Mlt,
    Mnc,
    Mni,
    Mno,
    Moh,
    Mol,
    Mon,
    Mos,
    Mri,
    Msa,
    Mul,
    Mun,
    Mus,
    Mwr,
    Mya,
    Myn,
    Nah,
    Nai,
    Nau,
    Nav,
    Nbl,
    Nde,
    Ndo,
    Nds,
    Nep,
    New,
    Nia,
    Nic,
    Niu,
    Nld,
    Nno,
    Nob,
    Non,
    Nor,
    Nso,
    Nub,
    Nya,
    Nym,
    Nyn,
    Nyo,
    Nzi,
    Oci,
    Oji,
    Ori,
    Orm,
    Osa,
    Oss,
    Ota,
    Oto,
    Paa,
    Pag,
    Pal,
    Pam,
    Pan,
    Pap,
    Pau,
    Peo,
    Per,
    Phi,
    Phn,
    Pli,
    Pol,
    Pon,
    Por,
    Pra,
    Pro,
    Pus,
    Qaa,
    Que,
    Raj,
    Rap,
    Rar,
    Roa,
    Roh,
    Rom,
    Ron,
    Rum,
    Run,
    Rus,
    Sad,
    Sag,
    Sah,
    Sai,
    Sal,
    Sam,
    San,
    Sas,
    Sat,
    Scc,
    Sco,
    Scr,
    Sel,
    Sem,
    Sga,
    Sgn,
    Shn,
    Sid,
    Sin,
    Sio,
    Sit,
    Sla,
    Slk,
    Slo,
    Slv,
    Sme,
    Smi,
    Smo,
    Sna,
    Snd,
    Snk,
    Sog,
    Som,
    Son,
    Sot,
    Spa,
    Sqi,
    Srd,
    Srp,
    Srr,
    Ssa,
    Ssw,
    Suk,
    Sun,
    Sus,
    Sux,
    Swa,
    Swe,
    Syr,
    Tah,
    Tai,
    Tam,
    Tat,
    Tel,
    Tem,
    Ter,
    Tet,
    Tgk,
    Tgl,
    Tha,
    Tib,
    Tig,
    Tir,
    Tiv,
    Tkl,
    Tli,
    Tmh,
    Tog,
    Ton,
    Tpi,
    Tsi,
    Tsn,
    Tso,
    Tuk,
    Tum,
    Tur,
    Tut,
    Tvl,
    Twi,
    Tyv,
    Uga,
    Uig,
    Ukr,
    Umb,
    Und,
    Urd,
    Uzb,
    Vai,
    Ven,
    Vie,
    Vol,
    Vot,
    Wak,
    Wal,
    War,
    Was,
    Wel,
    Wen,
    Wol,
    Xho,
    Yao,
    Yap,
    Yid,
    Yor,
    Ypk,
    Zap,
    Zen,
    Zha,
    Zho,
    Znd,
    Zul,
}
impl SerializeBytes for DtLangType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Aar => Ok(Some(Cow::Borrowed("aar"))),
            Self::Abk => Ok(Some(Cow::Borrowed("abk"))),
            Self::Ace => Ok(Some(Cow::Borrowed("ace"))),
            Self::Ach => Ok(Some(Cow::Borrowed("ach"))),
            Self::Ada => Ok(Some(Cow::Borrowed("ada"))),
            Self::Afa => Ok(Some(Cow::Borrowed("afa"))),
            Self::Afh => Ok(Some(Cow::Borrowed("afh"))),
            Self::Afr => Ok(Some(Cow::Borrowed("afr"))),
            Self::Aka => Ok(Some(Cow::Borrowed("aka"))),
            Self::Akk => Ok(Some(Cow::Borrowed("akk"))),
            Self::Alb => Ok(Some(Cow::Borrowed("alb"))),
            Self::Ale => Ok(Some(Cow::Borrowed("ale"))),
            Self::Alg => Ok(Some(Cow::Borrowed("alg"))),
            Self::Amh => Ok(Some(Cow::Borrowed("amh"))),
            Self::Ang => Ok(Some(Cow::Borrowed("ang"))),
            Self::Apa => Ok(Some(Cow::Borrowed("apa"))),
            Self::Ara => Ok(Some(Cow::Borrowed("ara"))),
            Self::Arc => Ok(Some(Cow::Borrowed("arc"))),
            Self::Arm => Ok(Some(Cow::Borrowed("arm"))),
            Self::Arn => Ok(Some(Cow::Borrowed("arn"))),
            Self::Arp => Ok(Some(Cow::Borrowed("arp"))),
            Self::Art => Ok(Some(Cow::Borrowed("art"))),
            Self::Arw => Ok(Some(Cow::Borrowed("arw"))),
            Self::Asm => Ok(Some(Cow::Borrowed("asm"))),
            Self::Ath => Ok(Some(Cow::Borrowed("ath"))),
            Self::Aus => Ok(Some(Cow::Borrowed("aus"))),
            Self::Ava => Ok(Some(Cow::Borrowed("ava"))),
            Self::Ave => Ok(Some(Cow::Borrowed("ave"))),
            Self::Awa => Ok(Some(Cow::Borrowed("awa"))),
            Self::Aym => Ok(Some(Cow::Borrowed("aym"))),
            Self::Aze => Ok(Some(Cow::Borrowed("aze"))),
            Self::Bad => Ok(Some(Cow::Borrowed("bad"))),
            Self::Bai => Ok(Some(Cow::Borrowed("bai"))),
            Self::Bak => Ok(Some(Cow::Borrowed("bak"))),
            Self::Bal => Ok(Some(Cow::Borrowed("bal"))),
            Self::Bam => Ok(Some(Cow::Borrowed("bam"))),
            Self::Ban => Ok(Some(Cow::Borrowed("ban"))),
            Self::Baq => Ok(Some(Cow::Borrowed("baq"))),
            Self::Bas => Ok(Some(Cow::Borrowed("bas"))),
            Self::Bat => Ok(Some(Cow::Borrowed("bat"))),
            Self::Bej => Ok(Some(Cow::Borrowed("bej"))),
            Self::Bel => Ok(Some(Cow::Borrowed("bel"))),
            Self::Bem => Ok(Some(Cow::Borrowed("bem"))),
            Self::Ben => Ok(Some(Cow::Borrowed("ben"))),
            Self::Ber => Ok(Some(Cow::Borrowed("ber"))),
            Self::Bho => Ok(Some(Cow::Borrowed("bho"))),
            Self::Bih => Ok(Some(Cow::Borrowed("bih"))),
            Self::Bik => Ok(Some(Cow::Borrowed("bik"))),
            Self::Bin => Ok(Some(Cow::Borrowed("bin"))),
            Self::Bis => Ok(Some(Cow::Borrowed("bis"))),
            Self::Bla => Ok(Some(Cow::Borrowed("bla"))),
            Self::Bnt => Ok(Some(Cow::Borrowed("bnt"))),
            Self::Bod => Ok(Some(Cow::Borrowed("bod"))),
            Self::Bos => Ok(Some(Cow::Borrowed("bos"))),
            Self::Bra => Ok(Some(Cow::Borrowed("bra"))),
            Self::Bre => Ok(Some(Cow::Borrowed("bre"))),
            Self::Btk => Ok(Some(Cow::Borrowed("btk"))),
            Self::Bua => Ok(Some(Cow::Borrowed("bua"))),
            Self::Bug => Ok(Some(Cow::Borrowed("bug"))),
            Self::Bul => Ok(Some(Cow::Borrowed("bul"))),
            Self::Bur => Ok(Some(Cow::Borrowed("bur"))),
            Self::Cad => Ok(Some(Cow::Borrowed("cad"))),
            Self::Cai => Ok(Some(Cow::Borrowed("cai"))),
            Self::Car => Ok(Some(Cow::Borrowed("car"))),
            Self::Cat => Ok(Some(Cow::Borrowed("cat"))),
            Self::Cau => Ok(Some(Cow::Borrowed("cau"))),
            Self::Ceb => Ok(Some(Cow::Borrowed("ceb"))),
            Self::Cel => Ok(Some(Cow::Borrowed("cel"))),
            Self::Ces => Ok(Some(Cow::Borrowed("ces"))),
            Self::Cha => Ok(Some(Cow::Borrowed("cha"))),
            Self::Chb => Ok(Some(Cow::Borrowed("chb"))),
            Self::Che => Ok(Some(Cow::Borrowed("che"))),
            Self::Chg => Ok(Some(Cow::Borrowed("chg"))),
            Self::Chi => Ok(Some(Cow::Borrowed("chi"))),
            Self::Chk => Ok(Some(Cow::Borrowed("chk"))),
            Self::Chm => Ok(Some(Cow::Borrowed("chm"))),
            Self::Chn => Ok(Some(Cow::Borrowed("chn"))),
            Self::Cho => Ok(Some(Cow::Borrowed("cho"))),
            Self::Chp => Ok(Some(Cow::Borrowed("chp"))),
            Self::Chr => Ok(Some(Cow::Borrowed("chr"))),
            Self::Chu => Ok(Some(Cow::Borrowed("chu"))),
            Self::Chv => Ok(Some(Cow::Borrowed("chv"))),
            Self::Chy => Ok(Some(Cow::Borrowed("chy"))),
            Self::Cmc => Ok(Some(Cow::Borrowed("cmc"))),
            Self::Cop => Ok(Some(Cow::Borrowed("cop"))),
            Self::Cor => Ok(Some(Cow::Borrowed("cor"))),
            Self::Cos => Ok(Some(Cow::Borrowed("cos"))),
            Self::Cpe => Ok(Some(Cow::Borrowed("cpe"))),
            Self::Cpf => Ok(Some(Cow::Borrowed("cpf"))),
            Self::Cpp => Ok(Some(Cow::Borrowed("cpp"))),
            Self::Cre => Ok(Some(Cow::Borrowed("cre"))),
            Self::Crp => Ok(Some(Cow::Borrowed("crp"))),
            Self::Cus => Ok(Some(Cow::Borrowed("cus"))),
            Self::Cym => Ok(Some(Cow::Borrowed("cym"))),
            Self::Cze => Ok(Some(Cow::Borrowed("cze"))),
            Self::Dak => Ok(Some(Cow::Borrowed("dak"))),
            Self::Dan => Ok(Some(Cow::Borrowed("dan"))),
            Self::Day => Ok(Some(Cow::Borrowed("day"))),
            Self::Del => Ok(Some(Cow::Borrowed("del"))),
            Self::Den => Ok(Some(Cow::Borrowed("den"))),
            Self::Deu => Ok(Some(Cow::Borrowed("deu"))),
            Self::Dgr => Ok(Some(Cow::Borrowed("dgr"))),
            Self::Din => Ok(Some(Cow::Borrowed("din"))),
            Self::Div => Ok(Some(Cow::Borrowed("div"))),
            Self::Doi => Ok(Some(Cow::Borrowed("doi"))),
            Self::Dra => Ok(Some(Cow::Borrowed("dra"))),
            Self::Dua => Ok(Some(Cow::Borrowed("dua"))),
            Self::Dum => Ok(Some(Cow::Borrowed("dum"))),
            Self::Dut => Ok(Some(Cow::Borrowed("dut"))),
            Self::Dyu => Ok(Some(Cow::Borrowed("dyu"))),
            Self::Dzo => Ok(Some(Cow::Borrowed("dzo"))),
            Self::Efi => Ok(Some(Cow::Borrowed("efi"))),
            Self::Egy => Ok(Some(Cow::Borrowed("egy"))),
            Self::Eka => Ok(Some(Cow::Borrowed("eka"))),
            Self::Ell => Ok(Some(Cow::Borrowed("ell"))),
            Self::Elx => Ok(Some(Cow::Borrowed("elx"))),
            Self::Eng => Ok(Some(Cow::Borrowed("eng"))),
            Self::Enm => Ok(Some(Cow::Borrowed("enm"))),
            Self::Epo => Ok(Some(Cow::Borrowed("epo"))),
            Self::Est => Ok(Some(Cow::Borrowed("est"))),
            Self::Eus => Ok(Some(Cow::Borrowed("eus"))),
            Self::Ewe => Ok(Some(Cow::Borrowed("ewe"))),
            Self::Ewo => Ok(Some(Cow::Borrowed("ewo"))),
            Self::Fan => Ok(Some(Cow::Borrowed("fan"))),
            Self::Fao => Ok(Some(Cow::Borrowed("fao"))),
            Self::Fas => Ok(Some(Cow::Borrowed("fas"))),
            Self::Fat => Ok(Some(Cow::Borrowed("fat"))),
            Self::Fij => Ok(Some(Cow::Borrowed("fij"))),
            Self::Fin => Ok(Some(Cow::Borrowed("fin"))),
            Self::Fiu => Ok(Some(Cow::Borrowed("fiu"))),
            Self::Fon => Ok(Some(Cow::Borrowed("fon"))),
            Self::Fra => Ok(Some(Cow::Borrowed("fra"))),
            Self::Fre => Ok(Some(Cow::Borrowed("fre"))),
            Self::Frm => Ok(Some(Cow::Borrowed("frm"))),
            Self::Fro => Ok(Some(Cow::Borrowed("fro"))),
            Self::Fry => Ok(Some(Cow::Borrowed("fry"))),
            Self::Ful => Ok(Some(Cow::Borrowed("ful"))),
            Self::Fur => Ok(Some(Cow::Borrowed("fur"))),
            Self::Gaa => Ok(Some(Cow::Borrowed("gaa"))),
            Self::Gay => Ok(Some(Cow::Borrowed("gay"))),
            Self::Gba => Ok(Some(Cow::Borrowed("gba"))),
            Self::Gem => Ok(Some(Cow::Borrowed("gem"))),
            Self::Geo => Ok(Some(Cow::Borrowed("geo"))),
            Self::Ger => Ok(Some(Cow::Borrowed("ger"))),
            Self::Gez => Ok(Some(Cow::Borrowed("gez"))),
            Self::Gil => Ok(Some(Cow::Borrowed("gil"))),
            Self::Gla => Ok(Some(Cow::Borrowed("gla"))),
            Self::Gle => Ok(Some(Cow::Borrowed("gle"))),
            Self::Glg => Ok(Some(Cow::Borrowed("glg"))),
            Self::Glv => Ok(Some(Cow::Borrowed("glv"))),
            Self::Gmh => Ok(Some(Cow::Borrowed("gmh"))),
            Self::Goh => Ok(Some(Cow::Borrowed("goh"))),
            Self::Gon => Ok(Some(Cow::Borrowed("gon"))),
            Self::Gor => Ok(Some(Cow::Borrowed("gor"))),
            Self::Got => Ok(Some(Cow::Borrowed("got"))),
            Self::Grb => Ok(Some(Cow::Borrowed("grb"))),
            Self::Grc => Ok(Some(Cow::Borrowed("grc"))),
            Self::Gre => Ok(Some(Cow::Borrowed("gre"))),
            Self::Grn => Ok(Some(Cow::Borrowed("grn"))),
            Self::Guj => Ok(Some(Cow::Borrowed("guj"))),
            Self::Gwi => Ok(Some(Cow::Borrowed("gwi"))),
            Self::Hai => Ok(Some(Cow::Borrowed("hai"))),
            Self::Hau => Ok(Some(Cow::Borrowed("hau"))),
            Self::Haw => Ok(Some(Cow::Borrowed("haw"))),
            Self::Heb => Ok(Some(Cow::Borrowed("heb"))),
            Self::Her => Ok(Some(Cow::Borrowed("her"))),
            Self::Hil => Ok(Some(Cow::Borrowed("hil"))),
            Self::Him => Ok(Some(Cow::Borrowed("him"))),
            Self::Hin => Ok(Some(Cow::Borrowed("hin"))),
            Self::Hit => Ok(Some(Cow::Borrowed("hit"))),
            Self::Hmn => Ok(Some(Cow::Borrowed("hmn"))),
            Self::Hmo => Ok(Some(Cow::Borrowed("hmo"))),
            Self::Hrv => Ok(Some(Cow::Borrowed("hrv"))),
            Self::Hun => Ok(Some(Cow::Borrowed("hun"))),
            Self::Hup => Ok(Some(Cow::Borrowed("hup"))),
            Self::Hye => Ok(Some(Cow::Borrowed("hye"))),
            Self::Iba => Ok(Some(Cow::Borrowed("iba"))),
            Self::Ibo => Ok(Some(Cow::Borrowed("ibo"))),
            Self::Ice => Ok(Some(Cow::Borrowed("ice"))),
            Self::Ijo => Ok(Some(Cow::Borrowed("ijo"))),
            Self::Iku => Ok(Some(Cow::Borrowed("iku"))),
            Self::Ile => Ok(Some(Cow::Borrowed("ile"))),
            Self::Ilo => Ok(Some(Cow::Borrowed("ilo"))),
            Self::Ina => Ok(Some(Cow::Borrowed("ina"))),
            Self::Inc => Ok(Some(Cow::Borrowed("inc"))),
            Self::Ind => Ok(Some(Cow::Borrowed("ind"))),
            Self::Ine => Ok(Some(Cow::Borrowed("ine"))),
            Self::Ipk => Ok(Some(Cow::Borrowed("ipk"))),
            Self::Ira => Ok(Some(Cow::Borrowed("ira"))),
            Self::Iro => Ok(Some(Cow::Borrowed("iro"))),
            Self::Isl => Ok(Some(Cow::Borrowed("isl"))),
            Self::Ita => Ok(Some(Cow::Borrowed("ita"))),
            Self::Jav => Ok(Some(Cow::Borrowed("jav"))),
            Self::Jpn => Ok(Some(Cow::Borrowed("jpn"))),
            Self::Jpr => Ok(Some(Cow::Borrowed("jpr"))),
            Self::Jrb => Ok(Some(Cow::Borrowed("jrb"))),
            Self::Kaa => Ok(Some(Cow::Borrowed("kaa"))),
            Self::Kab => Ok(Some(Cow::Borrowed("kab"))),
            Self::Kac => Ok(Some(Cow::Borrowed("kac"))),
            Self::Kal => Ok(Some(Cow::Borrowed("kal"))),
            Self::Kam => Ok(Some(Cow::Borrowed("kam"))),
            Self::Kan => Ok(Some(Cow::Borrowed("kan"))),
            Self::Kar => Ok(Some(Cow::Borrowed("kar"))),
            Self::Kas => Ok(Some(Cow::Borrowed("kas"))),
            Self::Kat => Ok(Some(Cow::Borrowed("kat"))),
            Self::Kau => Ok(Some(Cow::Borrowed("kau"))),
            Self::Kaw => Ok(Some(Cow::Borrowed("kaw"))),
            Self::Kaz => Ok(Some(Cow::Borrowed("kaz"))),
            Self::Kha => Ok(Some(Cow::Borrowed("kha"))),
            Self::Khi => Ok(Some(Cow::Borrowed("khi"))),
            Self::Khm => Ok(Some(Cow::Borrowed("khm"))),
            Self::Kho => Ok(Some(Cow::Borrowed("kho"))),
            Self::Kik => Ok(Some(Cow::Borrowed("kik"))),
            Self::Kin => Ok(Some(Cow::Borrowed("kin"))),
            Self::Kir => Ok(Some(Cow::Borrowed("kir"))),
            Self::Kmb => Ok(Some(Cow::Borrowed("kmb"))),
            Self::Kok => Ok(Some(Cow::Borrowed("kok"))),
            Self::Kom => Ok(Some(Cow::Borrowed("kom"))),
            Self::Kon => Ok(Some(Cow::Borrowed("kon"))),
            Self::Kor => Ok(Some(Cow::Borrowed("kor"))),
            Self::Kos => Ok(Some(Cow::Borrowed("kos"))),
            Self::Kpe => Ok(Some(Cow::Borrowed("kpe"))),
            Self::Kro => Ok(Some(Cow::Borrowed("kro"))),
            Self::Kru => Ok(Some(Cow::Borrowed("kru"))),
            Self::Kua => Ok(Some(Cow::Borrowed("kua"))),
            Self::Kum => Ok(Some(Cow::Borrowed("kum"))),
            Self::Kur => Ok(Some(Cow::Borrowed("kur"))),
            Self::Kut => Ok(Some(Cow::Borrowed("kut"))),
            Self::Lad => Ok(Some(Cow::Borrowed("lad"))),
            Self::Lah => Ok(Some(Cow::Borrowed("lah"))),
            Self::Lam => Ok(Some(Cow::Borrowed("lam"))),
            Self::Lao => Ok(Some(Cow::Borrowed("lao"))),
            Self::Lat => Ok(Some(Cow::Borrowed("lat"))),
            Self::Lav => Ok(Some(Cow::Borrowed("lav"))),
            Self::Lez => Ok(Some(Cow::Borrowed("lez"))),
            Self::Lin => Ok(Some(Cow::Borrowed("lin"))),
            Self::Lit => Ok(Some(Cow::Borrowed("lit"))),
            Self::Lol => Ok(Some(Cow::Borrowed("lol"))),
            Self::Loz => Ok(Some(Cow::Borrowed("loz"))),
            Self::Ltz => Ok(Some(Cow::Borrowed("ltz"))),
            Self::Lua => Ok(Some(Cow::Borrowed("lua"))),
            Self::Lub => Ok(Some(Cow::Borrowed("lub"))),
            Self::Lug => Ok(Some(Cow::Borrowed("lug"))),
            Self::Lui => Ok(Some(Cow::Borrowed("lui"))),
            Self::Lun => Ok(Some(Cow::Borrowed("lun"))),
            Self::Luo => Ok(Some(Cow::Borrowed("luo"))),
            Self::Lus => Ok(Some(Cow::Borrowed("lus"))),
            Self::Mac => Ok(Some(Cow::Borrowed("mac"))),
            Self::Mad => Ok(Some(Cow::Borrowed("mad"))),
            Self::Mag => Ok(Some(Cow::Borrowed("mag"))),
            Self::Mah => Ok(Some(Cow::Borrowed("mah"))),
            Self::Mai => Ok(Some(Cow::Borrowed("mai"))),
            Self::Mak => Ok(Some(Cow::Borrowed("mak"))),
            Self::Mal => Ok(Some(Cow::Borrowed("mal"))),
            Self::Man => Ok(Some(Cow::Borrowed("man"))),
            Self::Mao => Ok(Some(Cow::Borrowed("mao"))),
            Self::Map => Ok(Some(Cow::Borrowed("map"))),
            Self::Mar => Ok(Some(Cow::Borrowed("mar"))),
            Self::Mas => Ok(Some(Cow::Borrowed("mas"))),
            Self::May => Ok(Some(Cow::Borrowed("may"))),
            Self::Mdr => Ok(Some(Cow::Borrowed("mdr"))),
            Self::Men => Ok(Some(Cow::Borrowed("men"))),
            Self::Mga => Ok(Some(Cow::Borrowed("mga"))),
            Self::Mic => Ok(Some(Cow::Borrowed("mic"))),
            Self::Min => Ok(Some(Cow::Borrowed("min"))),
            Self::Mis => Ok(Some(Cow::Borrowed("mis"))),
            Self::Mkd => Ok(Some(Cow::Borrowed("mkd"))),
            Self::Mkh => Ok(Some(Cow::Borrowed("mkh"))),
            Self::Mlg => Ok(Some(Cow::Borrowed("mlg"))),
            Self::Mlt => Ok(Some(Cow::Borrowed("mlt"))),
            Self::Mnc => Ok(Some(Cow::Borrowed("mnc"))),
            Self::Mni => Ok(Some(Cow::Borrowed("mni"))),
            Self::Mno => Ok(Some(Cow::Borrowed("mno"))),
            Self::Moh => Ok(Some(Cow::Borrowed("moh"))),
            Self::Mol => Ok(Some(Cow::Borrowed("mol"))),
            Self::Mon => Ok(Some(Cow::Borrowed("mon"))),
            Self::Mos => Ok(Some(Cow::Borrowed("mos"))),
            Self::Mri => Ok(Some(Cow::Borrowed("mri"))),
            Self::Msa => Ok(Some(Cow::Borrowed("msa"))),
            Self::Mul => Ok(Some(Cow::Borrowed("mul"))),
            Self::Mun => Ok(Some(Cow::Borrowed("mun"))),
            Self::Mus => Ok(Some(Cow::Borrowed("mus"))),
            Self::Mwr => Ok(Some(Cow::Borrowed("mwr"))),
            Self::Mya => Ok(Some(Cow::Borrowed("mya"))),
            Self::Myn => Ok(Some(Cow::Borrowed("myn"))),
            Self::Nah => Ok(Some(Cow::Borrowed("nah"))),
            Self::Nai => Ok(Some(Cow::Borrowed("nai"))),
            Self::Nau => Ok(Some(Cow::Borrowed("nau"))),
            Self::Nav => Ok(Some(Cow::Borrowed("nav"))),
            Self::Nbl => Ok(Some(Cow::Borrowed("nbl"))),
            Self::Nde => Ok(Some(Cow::Borrowed("nde"))),
            Self::Ndo => Ok(Some(Cow::Borrowed("ndo"))),
            Self::Nds => Ok(Some(Cow::Borrowed("nds"))),
            Self::Nep => Ok(Some(Cow::Borrowed("nep"))),
            Self::New => Ok(Some(Cow::Borrowed("new"))),
            Self::Nia => Ok(Some(Cow::Borrowed("nia"))),
            Self::Nic => Ok(Some(Cow::Borrowed("nic"))),
            Self::Niu => Ok(Some(Cow::Borrowed("niu"))),
            Self::Nld => Ok(Some(Cow::Borrowed("nld"))),
            Self::Nno => Ok(Some(Cow::Borrowed("nno"))),
            Self::Nob => Ok(Some(Cow::Borrowed("nob"))),
            Self::Non => Ok(Some(Cow::Borrowed("non"))),
            Self::Nor => Ok(Some(Cow::Borrowed("nor"))),
            Self::Nso => Ok(Some(Cow::Borrowed("nso"))),
            Self::Nub => Ok(Some(Cow::Borrowed("nub"))),
            Self::Nya => Ok(Some(Cow::Borrowed("nya"))),
            Self::Nym => Ok(Some(Cow::Borrowed("nym"))),
            Self::Nyn => Ok(Some(Cow::Borrowed("nyn"))),
            Self::Nyo => Ok(Some(Cow::Borrowed("nyo"))),
            Self::Nzi => Ok(Some(Cow::Borrowed("nzi"))),
            Self::Oci => Ok(Some(Cow::Borrowed("oci"))),
            Self::Oji => Ok(Some(Cow::Borrowed("oji"))),
            Self::Ori => Ok(Some(Cow::Borrowed("ori"))),
            Self::Orm => Ok(Some(Cow::Borrowed("orm"))),
            Self::Osa => Ok(Some(Cow::Borrowed("osa"))),
            Self::Oss => Ok(Some(Cow::Borrowed("oss"))),
            Self::Ota => Ok(Some(Cow::Borrowed("ota"))),
            Self::Oto => Ok(Some(Cow::Borrowed("oto"))),
            Self::Paa => Ok(Some(Cow::Borrowed("paa"))),
            Self::Pag => Ok(Some(Cow::Borrowed("pag"))),
            Self::Pal => Ok(Some(Cow::Borrowed("pal"))),
            Self::Pam => Ok(Some(Cow::Borrowed("pam"))),
            Self::Pan => Ok(Some(Cow::Borrowed("pan"))),
            Self::Pap => Ok(Some(Cow::Borrowed("pap"))),
            Self::Pau => Ok(Some(Cow::Borrowed("pau"))),
            Self::Peo => Ok(Some(Cow::Borrowed("peo"))),
            Self::Per => Ok(Some(Cow::Borrowed("per"))),
            Self::Phi => Ok(Some(Cow::Borrowed("phi"))),
            Self::Phn => Ok(Some(Cow::Borrowed("phn"))),
            Self::Pli => Ok(Some(Cow::Borrowed("pli"))),
            Self::Pol => Ok(Some(Cow::Borrowed("pol"))),
            Self::Pon => Ok(Some(Cow::Borrowed("pon"))),
            Self::Por => Ok(Some(Cow::Borrowed("por"))),
            Self::Pra => Ok(Some(Cow::Borrowed("pra"))),
            Self::Pro => Ok(Some(Cow::Borrowed("pro"))),
            Self::Pus => Ok(Some(Cow::Borrowed("pus"))),
            Self::Qaa => Ok(Some(Cow::Borrowed("qaa"))),
            Self::Que => Ok(Some(Cow::Borrowed("que"))),
            Self::Raj => Ok(Some(Cow::Borrowed("raj"))),
            Self::Rap => Ok(Some(Cow::Borrowed("rap"))),
            Self::Rar => Ok(Some(Cow::Borrowed("rar"))),
            Self::Roa => Ok(Some(Cow::Borrowed("roa"))),
            Self::Roh => Ok(Some(Cow::Borrowed("roh"))),
            Self::Rom => Ok(Some(Cow::Borrowed("rom"))),
            Self::Ron => Ok(Some(Cow::Borrowed("ron"))),
            Self::Rum => Ok(Some(Cow::Borrowed("rum"))),
            Self::Run => Ok(Some(Cow::Borrowed("run"))),
            Self::Rus => Ok(Some(Cow::Borrowed("rus"))),
            Self::Sad => Ok(Some(Cow::Borrowed("sad"))),
            Self::Sag => Ok(Some(Cow::Borrowed("sag"))),
            Self::Sah => Ok(Some(Cow::Borrowed("sah"))),
            Self::Sai => Ok(Some(Cow::Borrowed("sai"))),
            Self::Sal => Ok(Some(Cow::Borrowed("sal"))),
            Self::Sam => Ok(Some(Cow::Borrowed("sam"))),
            Self::San => Ok(Some(Cow::Borrowed("san"))),
            Self::Sas => Ok(Some(Cow::Borrowed("sas"))),
            Self::Sat => Ok(Some(Cow::Borrowed("sat"))),
            Self::Scc => Ok(Some(Cow::Borrowed("scc"))),
            Self::Sco => Ok(Some(Cow::Borrowed("sco"))),
            Self::Scr => Ok(Some(Cow::Borrowed("scr"))),
            Self::Sel => Ok(Some(Cow::Borrowed("sel"))),
            Self::Sem => Ok(Some(Cow::Borrowed("sem"))),
            Self::Sga => Ok(Some(Cow::Borrowed("sga"))),
            Self::Sgn => Ok(Some(Cow::Borrowed("sgn"))),
            Self::Shn => Ok(Some(Cow::Borrowed("shn"))),
            Self::Sid => Ok(Some(Cow::Borrowed("sid"))),
            Self::Sin => Ok(Some(Cow::Borrowed("sin"))),
            Self::Sio => Ok(Some(Cow::Borrowed("sio"))),
            Self::Sit => Ok(Some(Cow::Borrowed("sit"))),
            Self::Sla => Ok(Some(Cow::Borrowed("sla"))),
            Self::Slk => Ok(Some(Cow::Borrowed("slk"))),
            Self::Slo => Ok(Some(Cow::Borrowed("slo"))),
            Self::Slv => Ok(Some(Cow::Borrowed("slv"))),
            Self::Sme => Ok(Some(Cow::Borrowed("sme"))),
            Self::Smi => Ok(Some(Cow::Borrowed("smi"))),
            Self::Smo => Ok(Some(Cow::Borrowed("smo"))),
            Self::Sna => Ok(Some(Cow::Borrowed("sna"))),
            Self::Snd => Ok(Some(Cow::Borrowed("snd"))),
            Self::Snk => Ok(Some(Cow::Borrowed("snk"))),
            Self::Sog => Ok(Some(Cow::Borrowed("sog"))),
            Self::Som => Ok(Some(Cow::Borrowed("som"))),
            Self::Son => Ok(Some(Cow::Borrowed("son"))),
            Self::Sot => Ok(Some(Cow::Borrowed("sot"))),
            Self::Spa => Ok(Some(Cow::Borrowed("spa"))),
            Self::Sqi => Ok(Some(Cow::Borrowed("sqi"))),
            Self::Srd => Ok(Some(Cow::Borrowed("srd"))),
            Self::Srp => Ok(Some(Cow::Borrowed("srp"))),
            Self::Srr => Ok(Some(Cow::Borrowed("srr"))),
            Self::Ssa => Ok(Some(Cow::Borrowed("ssa"))),
            Self::Ssw => Ok(Some(Cow::Borrowed("ssw"))),
            Self::Suk => Ok(Some(Cow::Borrowed("suk"))),
            Self::Sun => Ok(Some(Cow::Borrowed("sun"))),
            Self::Sus => Ok(Some(Cow::Borrowed("sus"))),
            Self::Sux => Ok(Some(Cow::Borrowed("sux"))),
            Self::Swa => Ok(Some(Cow::Borrowed("swa"))),
            Self::Swe => Ok(Some(Cow::Borrowed("swe"))),
            Self::Syr => Ok(Some(Cow::Borrowed("syr"))),
            Self::Tah => Ok(Some(Cow::Borrowed("tah"))),
            Self::Tai => Ok(Some(Cow::Borrowed("tai"))),
            Self::Tam => Ok(Some(Cow::Borrowed("tam"))),
            Self::Tat => Ok(Some(Cow::Borrowed("tat"))),
            Self::Tel => Ok(Some(Cow::Borrowed("tel"))),
            Self::Tem => Ok(Some(Cow::Borrowed("tem"))),
            Self::Ter => Ok(Some(Cow::Borrowed("ter"))),
            Self::Tet => Ok(Some(Cow::Borrowed("tet"))),
            Self::Tgk => Ok(Some(Cow::Borrowed("tgk"))),
            Self::Tgl => Ok(Some(Cow::Borrowed("tgl"))),
            Self::Tha => Ok(Some(Cow::Borrowed("tha"))),
            Self::Tib => Ok(Some(Cow::Borrowed("tib"))),
            Self::Tig => Ok(Some(Cow::Borrowed("tig"))),
            Self::Tir => Ok(Some(Cow::Borrowed("tir"))),
            Self::Tiv => Ok(Some(Cow::Borrowed("tiv"))),
            Self::Tkl => Ok(Some(Cow::Borrowed("tkl"))),
            Self::Tli => Ok(Some(Cow::Borrowed("tli"))),
            Self::Tmh => Ok(Some(Cow::Borrowed("tmh"))),
            Self::Tog => Ok(Some(Cow::Borrowed("tog"))),
            Self::Ton => Ok(Some(Cow::Borrowed("ton"))),
            Self::Tpi => Ok(Some(Cow::Borrowed("tpi"))),
            Self::Tsi => Ok(Some(Cow::Borrowed("tsi"))),
            Self::Tsn => Ok(Some(Cow::Borrowed("tsn"))),
            Self::Tso => Ok(Some(Cow::Borrowed("tso"))),
            Self::Tuk => Ok(Some(Cow::Borrowed("tuk"))),
            Self::Tum => Ok(Some(Cow::Borrowed("tum"))),
            Self::Tur => Ok(Some(Cow::Borrowed("tur"))),
            Self::Tut => Ok(Some(Cow::Borrowed("tut"))),
            Self::Tvl => Ok(Some(Cow::Borrowed("tvl"))),
            Self::Twi => Ok(Some(Cow::Borrowed("twi"))),
            Self::Tyv => Ok(Some(Cow::Borrowed("tyv"))),
            Self::Uga => Ok(Some(Cow::Borrowed("uga"))),
            Self::Uig => Ok(Some(Cow::Borrowed("uig"))),
            Self::Ukr => Ok(Some(Cow::Borrowed("ukr"))),
            Self::Umb => Ok(Some(Cow::Borrowed("umb"))),
            Self::Und => Ok(Some(Cow::Borrowed("und"))),
            Self::Urd => Ok(Some(Cow::Borrowed("urd"))),
            Self::Uzb => Ok(Some(Cow::Borrowed("uzb"))),
            Self::Vai => Ok(Some(Cow::Borrowed("vai"))),
            Self::Ven => Ok(Some(Cow::Borrowed("ven"))),
            Self::Vie => Ok(Some(Cow::Borrowed("vie"))),
            Self::Vol => Ok(Some(Cow::Borrowed("vol"))),
            Self::Vot => Ok(Some(Cow::Borrowed("vot"))),
            Self::Wak => Ok(Some(Cow::Borrowed("wak"))),
            Self::Wal => Ok(Some(Cow::Borrowed("wal"))),
            Self::War => Ok(Some(Cow::Borrowed("war"))),
            Self::Was => Ok(Some(Cow::Borrowed("was"))),
            Self::Wel => Ok(Some(Cow::Borrowed("wel"))),
            Self::Wen => Ok(Some(Cow::Borrowed("wen"))),
            Self::Wol => Ok(Some(Cow::Borrowed("wol"))),
            Self::Xho => Ok(Some(Cow::Borrowed("xho"))),
            Self::Yao => Ok(Some(Cow::Borrowed("yao"))),
            Self::Yap => Ok(Some(Cow::Borrowed("yap"))),
            Self::Yid => Ok(Some(Cow::Borrowed("yid"))),
            Self::Yor => Ok(Some(Cow::Borrowed("yor"))),
            Self::Ypk => Ok(Some(Cow::Borrowed("ypk"))),
            Self::Zap => Ok(Some(Cow::Borrowed("zap"))),
            Self::Zen => Ok(Some(Cow::Borrowed("zen"))),
            Self::Zha => Ok(Some(Cow::Borrowed("zha"))),
            Self::Zho => Ok(Some(Cow::Borrowed("zho"))),
            Self::Znd => Ok(Some(Cow::Borrowed("znd"))),
            Self::Zul => Ok(Some(Cow::Borrowed("zul"))),
        }
    }
}
impl DeserializeBytes for DtLangType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"aar" => Ok(Self::Aar),
            b"abk" => Ok(Self::Abk),
            b"ace" => Ok(Self::Ace),
            b"ach" => Ok(Self::Ach),
            b"ada" => Ok(Self::Ada),
            b"afa" => Ok(Self::Afa),
            b"afh" => Ok(Self::Afh),
            b"afr" => Ok(Self::Afr),
            b"aka" => Ok(Self::Aka),
            b"akk" => Ok(Self::Akk),
            b"alb" => Ok(Self::Alb),
            b"ale" => Ok(Self::Ale),
            b"alg" => Ok(Self::Alg),
            b"amh" => Ok(Self::Amh),
            b"ang" => Ok(Self::Ang),
            b"apa" => Ok(Self::Apa),
            b"ara" => Ok(Self::Ara),
            b"arc" => Ok(Self::Arc),
            b"arm" => Ok(Self::Arm),
            b"arn" => Ok(Self::Arn),
            b"arp" => Ok(Self::Arp),
            b"art" => Ok(Self::Art),
            b"arw" => Ok(Self::Arw),
            b"asm" => Ok(Self::Asm),
            b"ath" => Ok(Self::Ath),
            b"aus" => Ok(Self::Aus),
            b"ava" => Ok(Self::Ava),
            b"ave" => Ok(Self::Ave),
            b"awa" => Ok(Self::Awa),
            b"aym" => Ok(Self::Aym),
            b"aze" => Ok(Self::Aze),
            b"bad" => Ok(Self::Bad),
            b"bai" => Ok(Self::Bai),
            b"bak" => Ok(Self::Bak),
            b"bal" => Ok(Self::Bal),
            b"bam" => Ok(Self::Bam),
            b"ban" => Ok(Self::Ban),
            b"baq" => Ok(Self::Baq),
            b"bas" => Ok(Self::Bas),
            b"bat" => Ok(Self::Bat),
            b"bej" => Ok(Self::Bej),
            b"bel" => Ok(Self::Bel),
            b"bem" => Ok(Self::Bem),
            b"ben" => Ok(Self::Ben),
            b"ber" => Ok(Self::Ber),
            b"bho" => Ok(Self::Bho),
            b"bih" => Ok(Self::Bih),
            b"bik" => Ok(Self::Bik),
            b"bin" => Ok(Self::Bin),
            b"bis" => Ok(Self::Bis),
            b"bla" => Ok(Self::Bla),
            b"bnt" => Ok(Self::Bnt),
            b"bod" => Ok(Self::Bod),
            b"bos" => Ok(Self::Bos),
            b"bra" => Ok(Self::Bra),
            b"bre" => Ok(Self::Bre),
            b"btk" => Ok(Self::Btk),
            b"bua" => Ok(Self::Bua),
            b"bug" => Ok(Self::Bug),
            b"bul" => Ok(Self::Bul),
            b"bur" => Ok(Self::Bur),
            b"cad" => Ok(Self::Cad),
            b"cai" => Ok(Self::Cai),
            b"car" => Ok(Self::Car),
            b"cat" => Ok(Self::Cat),
            b"cau" => Ok(Self::Cau),
            b"ceb" => Ok(Self::Ceb),
            b"cel" => Ok(Self::Cel),
            b"ces" => Ok(Self::Ces),
            b"cha" => Ok(Self::Cha),
            b"chb" => Ok(Self::Chb),
            b"che" => Ok(Self::Che),
            b"chg" => Ok(Self::Chg),
            b"chi" => Ok(Self::Chi),
            b"chk" => Ok(Self::Chk),
            b"chm" => Ok(Self::Chm),
            b"chn" => Ok(Self::Chn),
            b"cho" => Ok(Self::Cho),
            b"chp" => Ok(Self::Chp),
            b"chr" => Ok(Self::Chr),
            b"chu" => Ok(Self::Chu),
            b"chv" => Ok(Self::Chv),
            b"chy" => Ok(Self::Chy),
            b"cmc" => Ok(Self::Cmc),
            b"cop" => Ok(Self::Cop),
            b"cor" => Ok(Self::Cor),
            b"cos" => Ok(Self::Cos),
            b"cpe" => Ok(Self::Cpe),
            b"cpf" => Ok(Self::Cpf),
            b"cpp" => Ok(Self::Cpp),
            b"cre" => Ok(Self::Cre),
            b"crp" => Ok(Self::Crp),
            b"cus" => Ok(Self::Cus),
            b"cym" => Ok(Self::Cym),
            b"cze" => Ok(Self::Cze),
            b"dak" => Ok(Self::Dak),
            b"dan" => Ok(Self::Dan),
            b"day" => Ok(Self::Day),
            b"del" => Ok(Self::Del),
            b"den" => Ok(Self::Den),
            b"deu" => Ok(Self::Deu),
            b"dgr" => Ok(Self::Dgr),
            b"din" => Ok(Self::Din),
            b"div" => Ok(Self::Div),
            b"doi" => Ok(Self::Doi),
            b"dra" => Ok(Self::Dra),
            b"dua" => Ok(Self::Dua),
            b"dum" => Ok(Self::Dum),
            b"dut" => Ok(Self::Dut),
            b"dyu" => Ok(Self::Dyu),
            b"dzo" => Ok(Self::Dzo),
            b"efi" => Ok(Self::Efi),
            b"egy" => Ok(Self::Egy),
            b"eka" => Ok(Self::Eka),
            b"ell" => Ok(Self::Ell),
            b"elx" => Ok(Self::Elx),
            b"eng" => Ok(Self::Eng),
            b"enm" => Ok(Self::Enm),
            b"epo" => Ok(Self::Epo),
            b"est" => Ok(Self::Est),
            b"eus" => Ok(Self::Eus),
            b"ewe" => Ok(Self::Ewe),
            b"ewo" => Ok(Self::Ewo),
            b"fan" => Ok(Self::Fan),
            b"fao" => Ok(Self::Fao),
            b"fas" => Ok(Self::Fas),
            b"fat" => Ok(Self::Fat),
            b"fij" => Ok(Self::Fij),
            b"fin" => Ok(Self::Fin),
            b"fiu" => Ok(Self::Fiu),
            b"fon" => Ok(Self::Fon),
            b"fra" => Ok(Self::Fra),
            b"fre" => Ok(Self::Fre),
            b"frm" => Ok(Self::Frm),
            b"fro" => Ok(Self::Fro),
            b"fry" => Ok(Self::Fry),
            b"ful" => Ok(Self::Ful),
            b"fur" => Ok(Self::Fur),
            b"gaa" => Ok(Self::Gaa),
            b"gay" => Ok(Self::Gay),
            b"gba" => Ok(Self::Gba),
            b"gem" => Ok(Self::Gem),
            b"geo" => Ok(Self::Geo),
            b"ger" => Ok(Self::Ger),
            b"gez" => Ok(Self::Gez),
            b"gil" => Ok(Self::Gil),
            b"gla" => Ok(Self::Gla),
            b"gle" => Ok(Self::Gle),
            b"glg" => Ok(Self::Glg),
            b"glv" => Ok(Self::Glv),
            b"gmh" => Ok(Self::Gmh),
            b"goh" => Ok(Self::Goh),
            b"gon" => Ok(Self::Gon),
            b"gor" => Ok(Self::Gor),
            b"got" => Ok(Self::Got),
            b"grb" => Ok(Self::Grb),
            b"grc" => Ok(Self::Grc),
            b"gre" => Ok(Self::Gre),
            b"grn" => Ok(Self::Grn),
            b"guj" => Ok(Self::Guj),
            b"gwi" => Ok(Self::Gwi),
            b"hai" => Ok(Self::Hai),
            b"hau" => Ok(Self::Hau),
            b"haw" => Ok(Self::Haw),
            b"heb" => Ok(Self::Heb),
            b"her" => Ok(Self::Her),
            b"hil" => Ok(Self::Hil),
            b"him" => Ok(Self::Him),
            b"hin" => Ok(Self::Hin),
            b"hit" => Ok(Self::Hit),
            b"hmn" => Ok(Self::Hmn),
            b"hmo" => Ok(Self::Hmo),
            b"hrv" => Ok(Self::Hrv),
            b"hun" => Ok(Self::Hun),
            b"hup" => Ok(Self::Hup),
            b"hye" => Ok(Self::Hye),
            b"iba" => Ok(Self::Iba),
            b"ibo" => Ok(Self::Ibo),
            b"ice" => Ok(Self::Ice),
            b"ijo" => Ok(Self::Ijo),
            b"iku" => Ok(Self::Iku),
            b"ile" => Ok(Self::Ile),
            b"ilo" => Ok(Self::Ilo),
            b"ina" => Ok(Self::Ina),
            b"inc" => Ok(Self::Inc),
            b"ind" => Ok(Self::Ind),
            b"ine" => Ok(Self::Ine),
            b"ipk" => Ok(Self::Ipk),
            b"ira" => Ok(Self::Ira),
            b"iro" => Ok(Self::Iro),
            b"isl" => Ok(Self::Isl),
            b"ita" => Ok(Self::Ita),
            b"jav" => Ok(Self::Jav),
            b"jpn" => Ok(Self::Jpn),
            b"jpr" => Ok(Self::Jpr),
            b"jrb" => Ok(Self::Jrb),
            b"kaa" => Ok(Self::Kaa),
            b"kab" => Ok(Self::Kab),
            b"kac" => Ok(Self::Kac),
            b"kal" => Ok(Self::Kal),
            b"kam" => Ok(Self::Kam),
            b"kan" => Ok(Self::Kan),
            b"kar" => Ok(Self::Kar),
            b"kas" => Ok(Self::Kas),
            b"kat" => Ok(Self::Kat),
            b"kau" => Ok(Self::Kau),
            b"kaw" => Ok(Self::Kaw),
            b"kaz" => Ok(Self::Kaz),
            b"kha" => Ok(Self::Kha),
            b"khi" => Ok(Self::Khi),
            b"khm" => Ok(Self::Khm),
            b"kho" => Ok(Self::Kho),
            b"kik" => Ok(Self::Kik),
            b"kin" => Ok(Self::Kin),
            b"kir" => Ok(Self::Kir),
            b"kmb" => Ok(Self::Kmb),
            b"kok" => Ok(Self::Kok),
            b"kom" => Ok(Self::Kom),
            b"kon" => Ok(Self::Kon),
            b"kor" => Ok(Self::Kor),
            b"kos" => Ok(Self::Kos),
            b"kpe" => Ok(Self::Kpe),
            b"kro" => Ok(Self::Kro),
            b"kru" => Ok(Self::Kru),
            b"kua" => Ok(Self::Kua),
            b"kum" => Ok(Self::Kum),
            b"kur" => Ok(Self::Kur),
            b"kut" => Ok(Self::Kut),
            b"lad" => Ok(Self::Lad),
            b"lah" => Ok(Self::Lah),
            b"lam" => Ok(Self::Lam),
            b"lao" => Ok(Self::Lao),
            b"lat" => Ok(Self::Lat),
            b"lav" => Ok(Self::Lav),
            b"lez" => Ok(Self::Lez),
            b"lin" => Ok(Self::Lin),
            b"lit" => Ok(Self::Lit),
            b"lol" => Ok(Self::Lol),
            b"loz" => Ok(Self::Loz),
            b"ltz" => Ok(Self::Ltz),
            b"lua" => Ok(Self::Lua),
            b"lub" => Ok(Self::Lub),
            b"lug" => Ok(Self::Lug),
            b"lui" => Ok(Self::Lui),
            b"lun" => Ok(Self::Lun),
            b"luo" => Ok(Self::Luo),
            b"lus" => Ok(Self::Lus),
            b"mac" => Ok(Self::Mac),
            b"mad" => Ok(Self::Mad),
            b"mag" => Ok(Self::Mag),
            b"mah" => Ok(Self::Mah),
            b"mai" => Ok(Self::Mai),
            b"mak" => Ok(Self::Mak),
            b"mal" => Ok(Self::Mal),
            b"man" => Ok(Self::Man),
            b"mao" => Ok(Self::Mao),
            b"map" => Ok(Self::Map),
            b"mar" => Ok(Self::Mar),
            b"mas" => Ok(Self::Mas),
            b"may" => Ok(Self::May),
            b"mdr" => Ok(Self::Mdr),
            b"men" => Ok(Self::Men),
            b"mga" => Ok(Self::Mga),
            b"mic" => Ok(Self::Mic),
            b"min" => Ok(Self::Min),
            b"mis" => Ok(Self::Mis),
            b"mkd" => Ok(Self::Mkd),
            b"mkh" => Ok(Self::Mkh),
            b"mlg" => Ok(Self::Mlg),
            b"mlt" => Ok(Self::Mlt),
            b"mnc" => Ok(Self::Mnc),
            b"mni" => Ok(Self::Mni),
            b"mno" => Ok(Self::Mno),
            b"moh" => Ok(Self::Moh),
            b"mol" => Ok(Self::Mol),
            b"mon" => Ok(Self::Mon),
            b"mos" => Ok(Self::Mos),
            b"mri" => Ok(Self::Mri),
            b"msa" => Ok(Self::Msa),
            b"mul" => Ok(Self::Mul),
            b"mun" => Ok(Self::Mun),
            b"mus" => Ok(Self::Mus),
            b"mwr" => Ok(Self::Mwr),
            b"mya" => Ok(Self::Mya),
            b"myn" => Ok(Self::Myn),
            b"nah" => Ok(Self::Nah),
            b"nai" => Ok(Self::Nai),
            b"nau" => Ok(Self::Nau),
            b"nav" => Ok(Self::Nav),
            b"nbl" => Ok(Self::Nbl),
            b"nde" => Ok(Self::Nde),
            b"ndo" => Ok(Self::Ndo),
            b"nds" => Ok(Self::Nds),
            b"nep" => Ok(Self::Nep),
            b"new" => Ok(Self::New),
            b"nia" => Ok(Self::Nia),
            b"nic" => Ok(Self::Nic),
            b"niu" => Ok(Self::Niu),
            b"nld" => Ok(Self::Nld),
            b"nno" => Ok(Self::Nno),
            b"nob" => Ok(Self::Nob),
            b"non" => Ok(Self::Non),
            b"nor" => Ok(Self::Nor),
            b"nso" => Ok(Self::Nso),
            b"nub" => Ok(Self::Nub),
            b"nya" => Ok(Self::Nya),
            b"nym" => Ok(Self::Nym),
            b"nyn" => Ok(Self::Nyn),
            b"nyo" => Ok(Self::Nyo),
            b"nzi" => Ok(Self::Nzi),
            b"oci" => Ok(Self::Oci),
            b"oji" => Ok(Self::Oji),
            b"ori" => Ok(Self::Ori),
            b"orm" => Ok(Self::Orm),
            b"osa" => Ok(Self::Osa),
            b"oss" => Ok(Self::Oss),
            b"ota" => Ok(Self::Ota),
            b"oto" => Ok(Self::Oto),
            b"paa" => Ok(Self::Paa),
            b"pag" => Ok(Self::Pag),
            b"pal" => Ok(Self::Pal),
            b"pam" => Ok(Self::Pam),
            b"pan" => Ok(Self::Pan),
            b"pap" => Ok(Self::Pap),
            b"pau" => Ok(Self::Pau),
            b"peo" => Ok(Self::Peo),
            b"per" => Ok(Self::Per),
            b"phi" => Ok(Self::Phi),
            b"phn" => Ok(Self::Phn),
            b"pli" => Ok(Self::Pli),
            b"pol" => Ok(Self::Pol),
            b"pon" => Ok(Self::Pon),
            b"por" => Ok(Self::Por),
            b"pra" => Ok(Self::Pra),
            b"pro" => Ok(Self::Pro),
            b"pus" => Ok(Self::Pus),
            b"qaa" => Ok(Self::Qaa),
            b"que" => Ok(Self::Que),
            b"raj" => Ok(Self::Raj),
            b"rap" => Ok(Self::Rap),
            b"rar" => Ok(Self::Rar),
            b"roa" => Ok(Self::Roa),
            b"roh" => Ok(Self::Roh),
            b"rom" => Ok(Self::Rom),
            b"ron" => Ok(Self::Ron),
            b"rum" => Ok(Self::Rum),
            b"run" => Ok(Self::Run),
            b"rus" => Ok(Self::Rus),
            b"sad" => Ok(Self::Sad),
            b"sag" => Ok(Self::Sag),
            b"sah" => Ok(Self::Sah),
            b"sai" => Ok(Self::Sai),
            b"sal" => Ok(Self::Sal),
            b"sam" => Ok(Self::Sam),
            b"san" => Ok(Self::San),
            b"sas" => Ok(Self::Sas),
            b"sat" => Ok(Self::Sat),
            b"scc" => Ok(Self::Scc),
            b"sco" => Ok(Self::Sco),
            b"scr" => Ok(Self::Scr),
            b"sel" => Ok(Self::Sel),
            b"sem" => Ok(Self::Sem),
            b"sga" => Ok(Self::Sga),
            b"sgn" => Ok(Self::Sgn),
            b"shn" => Ok(Self::Shn),
            b"sid" => Ok(Self::Sid),
            b"sin" => Ok(Self::Sin),
            b"sio" => Ok(Self::Sio),
            b"sit" => Ok(Self::Sit),
            b"sla" => Ok(Self::Sla),
            b"slk" => Ok(Self::Slk),
            b"slo" => Ok(Self::Slo),
            b"slv" => Ok(Self::Slv),
            b"sme" => Ok(Self::Sme),
            b"smi" => Ok(Self::Smi),
            b"smo" => Ok(Self::Smo),
            b"sna" => Ok(Self::Sna),
            b"snd" => Ok(Self::Snd),
            b"snk" => Ok(Self::Snk),
            b"sog" => Ok(Self::Sog),
            b"som" => Ok(Self::Som),
            b"son" => Ok(Self::Son),
            b"sot" => Ok(Self::Sot),
            b"spa" => Ok(Self::Spa),
            b"sqi" => Ok(Self::Sqi),
            b"srd" => Ok(Self::Srd),
            b"srp" => Ok(Self::Srp),
            b"srr" => Ok(Self::Srr),
            b"ssa" => Ok(Self::Ssa),
            b"ssw" => Ok(Self::Ssw),
            b"suk" => Ok(Self::Suk),
            b"sun" => Ok(Self::Sun),
            b"sus" => Ok(Self::Sus),
            b"sux" => Ok(Self::Sux),
            b"swa" => Ok(Self::Swa),
            b"swe" => Ok(Self::Swe),
            b"syr" => Ok(Self::Syr),
            b"tah" => Ok(Self::Tah),
            b"tai" => Ok(Self::Tai),
            b"tam" => Ok(Self::Tam),
            b"tat" => Ok(Self::Tat),
            b"tel" => Ok(Self::Tel),
            b"tem" => Ok(Self::Tem),
            b"ter" => Ok(Self::Ter),
            b"tet" => Ok(Self::Tet),
            b"tgk" => Ok(Self::Tgk),
            b"tgl" => Ok(Self::Tgl),
            b"tha" => Ok(Self::Tha),
            b"tib" => Ok(Self::Tib),
            b"tig" => Ok(Self::Tig),
            b"tir" => Ok(Self::Tir),
            b"tiv" => Ok(Self::Tiv),
            b"tkl" => Ok(Self::Tkl),
            b"tli" => Ok(Self::Tli),
            b"tmh" => Ok(Self::Tmh),
            b"tog" => Ok(Self::Tog),
            b"ton" => Ok(Self::Ton),
            b"tpi" => Ok(Self::Tpi),
            b"tsi" => Ok(Self::Tsi),
            b"tsn" => Ok(Self::Tsn),
            b"tso" => Ok(Self::Tso),
            b"tuk" => Ok(Self::Tuk),
            b"tum" => Ok(Self::Tum),
            b"tur" => Ok(Self::Tur),
            b"tut" => Ok(Self::Tut),
            b"tvl" => Ok(Self::Tvl),
            b"twi" => Ok(Self::Twi),
            b"tyv" => Ok(Self::Tyv),
            b"uga" => Ok(Self::Uga),
            b"uig" => Ok(Self::Uig),
            b"ukr" => Ok(Self::Ukr),
            b"umb" => Ok(Self::Umb),
            b"und" => Ok(Self::Und),
            b"urd" => Ok(Self::Urd),
            b"uzb" => Ok(Self::Uzb),
            b"vai" => Ok(Self::Vai),
            b"ven" => Ok(Self::Ven),
            b"vie" => Ok(Self::Vie),
            b"vol" => Ok(Self::Vol),
            b"vot" => Ok(Self::Vot),
            b"wak" => Ok(Self::Wak),
            b"wal" => Ok(Self::Wal),
            b"war" => Ok(Self::War),
            b"was" => Ok(Self::Was),
            b"wel" => Ok(Self::Wel),
            b"wen" => Ok(Self::Wen),
            b"wol" => Ok(Self::Wol),
            b"xho" => Ok(Self::Xho),
            b"yao" => Ok(Self::Yao),
            b"yap" => Ok(Self::Yap),
            b"yid" => Ok(Self::Yid),
            b"yor" => Ok(Self::Yor),
            b"ypk" => Ok(Self::Ypk),
            b"zap" => Ok(Self::Zap),
            b"zen" => Ok(Self::Zen),
            b"zha" => Ok(Self::Zha),
            b"zho" => Ok(Self::Zho),
            b"znd" => Ok(Self::Znd),
            b"zul" => Ok(Self::Zul),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CatalogDatetimetypeType {
    GenerationDate,
}
impl SerializeBytes for CatalogDatetimetypeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::GenerationDate => Ok(Some(Cow::Borrowed("generation_date"))),
        }
    }
}
impl DeserializeBytes for CatalogDatetimetypeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"generation_date" => Ok(Self::GenerationDate),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum SupplierAddresstypeType {
    Supplier,
}
impl SerializeBytes for SupplierAddresstypeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Supplier => Ok(Some(Cow::Borrowed("supplier"))),
        }
    }
}
impl DeserializeBytes for SupplierAddresstypeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"supplier" => Ok(Self::Supplier),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct MimeElementType {
    pub mime_type: String,
    pub mime_source: Vec<DtMlstringType>,
    pub mime_descr: Vec<DtMlstringType>,
    pub mime_alt: Vec<DtMlstringType>,
    pub mime_purpose: MimePurposeElementType,
}
impl WithSerializer for MimeElementType {
    type Serializer<'x> = quick_xml_serialize::MimeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::MimeElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::MimeElementTypeSerializerState::Init__),
            name: name.unwrap_or("MIME"),
            is_root,
        })
    }
}
impl WithDeserializer for MimeElementType {
    type Deserializer = quick_xml_deserialize::MimeElementTypeDeserializer;
}
#[derive(Debug)]
pub struct InternationalPidElementType {
    pub type_: Option<String>,
    pub content: String,
}
impl WithSerializer for InternationalPidElementType {
    type Serializer<'x> = quick_xml_serialize::InternationalPidElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::InternationalPidElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::InternationalPidElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("INTERNATIONAL_PID"),
            is_root,
        })
    }
}
impl WithDeserializer for InternationalPidElementType {
    type Deserializer = quick_xml_deserialize::InternationalPidElementTypeDeserializer;
}
#[derive(Debug)]
pub struct BuyerPidElementType {
    pub type_: Option<String>,
    pub content: String,
}
impl WithSerializer for BuyerPidElementType {
    type Serializer<'x> = quick_xml_serialize::BuyerPidElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::BuyerPidElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BuyerPidElementTypeSerializerState::Init__),
            name: name.unwrap_or("BUYER_PID"),
            is_root,
        })
    }
}
impl WithDeserializer for BuyerPidElementType {
    type Deserializer = quick_xml_deserialize::BuyerPidElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SpecialTreatmentClassElementType {
    pub type_: String,
    pub content: String,
}
impl WithSerializer for SpecialTreatmentClassElementType {
    type Serializer<'x> = quick_xml_serialize::SpecialTreatmentClassElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::SpecialTreatmentClassElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::SpecialTreatmentClassElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("SPECIAL_TREATMENT_CLASS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for SpecialTreatmentClassElementType {
    type Deserializer = quick_xml_deserialize::SpecialTreatmentClassElementTypeDeserializer;
}
#[derive(Debug)]
pub struct RemarksElementType {
    pub lang: Option<DtLangType>,
    pub type_: Option<String>,
    pub content: String,
}
impl WithSerializer for RemarksElementType {
    type Serializer<'x> = quick_xml_serialize::RemarksElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::RemarksElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::RemarksElementTypeSerializerState::Init__),
            name: name.unwrap_or("REMARKS"),
            is_root,
        })
    }
}
impl WithDeserializer for RemarksElementType {
    type Deserializer = quick_xml_deserialize::RemarksElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductStatusElementType {
    pub lang: Option<DtLangType>,
    pub type_: ProductStatustypeType,
    pub content: String,
}
impl WithSerializer for ProductStatusElementType {
    type Serializer<'x> = quick_xml_serialize::ProductStatusElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductStatusElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductStatusElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRODUCT_STATUS"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductStatusElementType {
    type Deserializer = quick_xml_deserialize::ProductStatusElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TypeClassificationGroupIdType {
    pub type_: Option<TypeClassificationGroupIdtypeType>,
    pub content: String,
}
impl WithSerializer for TypeClassificationGroupIdType {
    type Serializer<'x> = quick_xml_serialize::TypeClassificationGroupIdTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TypeClassificationGroupIdTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TypeClassificationGroupIdTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("typeCLASSIFICATION_GROUP_ID"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TypeClassificationGroupIdType {
    type Deserializer = quick_xml_deserialize::TypeClassificationGroupIdTypeDeserializer;
}
#[derive(Debug)]
pub struct FeatureElementType {
    pub fname: Vec<DtMlstringType>,
    pub fvalue: Vec<DtMlstringType>,
    pub funit: Option<String>,
    pub fvalue_details: Vec<DtMlstringType>,
}
impl WithSerializer for FeatureElementType {
    type Serializer<'x> = quick_xml_serialize::FeatureElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::FeatureElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::FeatureElementTypeSerializerState::Init__),
            name: name.unwrap_or("FEATURE"),
            is_root,
        })
    }
}
impl WithDeserializer for FeatureElementType {
    type Deserializer = quick_xml_deserialize::FeatureElementTypeDeserializer;
}
#[derive(Debug)]
pub enum DtPunitType {
    Be,
    Bg,
    Bo,
    Bx,
    C62,
    Ca,
    Cl,
    Cmt,
    Cq,
    Cs,
    Ct,
    Dr,
    Grm,
    Kg,
    Kgm,
    Ltr,
    Mgm,
    Mlt,
    Mmt,
    Mtr,
    Pa,
    Pf,
    Pk,
    Pl,
    Pr,
    Pu,
    Rg,
    Rl,
    Ro,
    Sa,
    Set,
    St,
    Tn,
    Tu,
    Z2,
    Z3,
}
impl SerializeBytes for DtPunitType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Be => Ok(Some(Cow::Borrowed("BE"))),
            Self::Bg => Ok(Some(Cow::Borrowed("BG"))),
            Self::Bo => Ok(Some(Cow::Borrowed("BO"))),
            Self::Bx => Ok(Some(Cow::Borrowed("BX"))),
            Self::C62 => Ok(Some(Cow::Borrowed("C62"))),
            Self::Ca => Ok(Some(Cow::Borrowed("CA"))),
            Self::Cl => Ok(Some(Cow::Borrowed("CL"))),
            Self::Cmt => Ok(Some(Cow::Borrowed("CMT"))),
            Self::Cq => Ok(Some(Cow::Borrowed("CQ"))),
            Self::Cs => Ok(Some(Cow::Borrowed("CS"))),
            Self::Ct => Ok(Some(Cow::Borrowed("CT"))),
            Self::Dr => Ok(Some(Cow::Borrowed("DR"))),
            Self::Grm => Ok(Some(Cow::Borrowed("GRM"))),
            Self::Kg => Ok(Some(Cow::Borrowed("KG"))),
            Self::Kgm => Ok(Some(Cow::Borrowed("KGM"))),
            Self::Ltr => Ok(Some(Cow::Borrowed("LTR"))),
            Self::Mgm => Ok(Some(Cow::Borrowed("MGM"))),
            Self::Mlt => Ok(Some(Cow::Borrowed("MLT"))),
            Self::Mmt => Ok(Some(Cow::Borrowed("MMT"))),
            Self::Mtr => Ok(Some(Cow::Borrowed("MTR"))),
            Self::Pa => Ok(Some(Cow::Borrowed("PA"))),
            Self::Pf => Ok(Some(Cow::Borrowed("PF"))),
            Self::Pk => Ok(Some(Cow::Borrowed("PK"))),
            Self::Pl => Ok(Some(Cow::Borrowed("PL"))),
            Self::Pr => Ok(Some(Cow::Borrowed("PR"))),
            Self::Pu => Ok(Some(Cow::Borrowed("PU"))),
            Self::Rg => Ok(Some(Cow::Borrowed("RG"))),
            Self::Rl => Ok(Some(Cow::Borrowed("RL"))),
            Self::Ro => Ok(Some(Cow::Borrowed("RO"))),
            Self::Sa => Ok(Some(Cow::Borrowed("SA"))),
            Self::Set => Ok(Some(Cow::Borrowed("SET"))),
            Self::St => Ok(Some(Cow::Borrowed("ST"))),
            Self::Tn => Ok(Some(Cow::Borrowed("TN"))),
            Self::Tu => Ok(Some(Cow::Borrowed("TU"))),
            Self::Z2 => Ok(Some(Cow::Borrowed("Z2"))),
            Self::Z3 => Ok(Some(Cow::Borrowed("Z3"))),
        }
    }
}
impl DeserializeBytes for DtPunitType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"BE" => Ok(Self::Be),
            b"BG" => Ok(Self::Bg),
            b"BO" => Ok(Self::Bo),
            b"BX" => Ok(Self::Bx),
            b"C62" => Ok(Self::C62),
            b"CA" => Ok(Self::Ca),
            b"CL" => Ok(Self::Cl),
            b"CMT" => Ok(Self::Cmt),
            b"CQ" => Ok(Self::Cq),
            b"CS" => Ok(Self::Cs),
            b"CT" => Ok(Self::Ct),
            b"DR" => Ok(Self::Dr),
            b"GRM" => Ok(Self::Grm),
            b"KG" => Ok(Self::Kg),
            b"KGM" => Ok(Self::Kgm),
            b"LTR" => Ok(Self::Ltr),
            b"MGM" => Ok(Self::Mgm),
            b"MLT" => Ok(Self::Mlt),
            b"MMT" => Ok(Self::Mmt),
            b"MTR" => Ok(Self::Mtr),
            b"PA" => Ok(Self::Pa),
            b"PF" => Ok(Self::Pf),
            b"PK" => Ok(Self::Pk),
            b"PL" => Ok(Self::Pl),
            b"PR" => Ok(Self::Pr),
            b"PU" => Ok(Self::Pu),
            b"RG" => Ok(Self::Rg),
            b"RL" => Ok(Self::Rl),
            b"RO" => Ok(Self::Ro),
            b"SA" => Ok(Self::Sa),
            b"SET" => Ok(Self::Set),
            b"ST" => Ok(Self::St),
            b"TN" => Ok(Self::Tn),
            b"TU" => Ok(Self::Tu),
            b"Z2" => Ok(Self::Z2),
            b"Z3" => Ok(Self::Z3),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct ProductPriceDetailsDatetimeElementType {
    pub type_: ProductPriceDetailsDatetimetypeType,
    pub date: String,
    pub time: Option<String>,
    pub timezone: Option<String>,
}
impl WithSerializer for ProductPriceDetailsDatetimeElementType {
    type Serializer<'x> = quick_xml_serialize::ProductPriceDetailsDatetimeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: ProductPriceDetailsDatetimeElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ProductPriceDetailsDatetimeElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ProductPriceDetailsDatetime") , is_root , })
    }
}
impl WithDeserializer for ProductPriceDetailsDatetimeElementType {
    type Deserializer = quick_xml_deserialize::ProductPriceDetailsDatetimeElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductPriceElementType {
    pub price_type: String,
    pub price_amount: f64,
    pub price_currency: Option<DtCurrenciesType>,
    pub tax: Option<f64>,
    pub price_factor: Option<f64>,
    pub lower_bound: Option<f64>,
    pub territory: Vec<String>,
}
impl WithSerializer for ProductPriceElementType {
    type Serializer<'x> = quick_xml_serialize::ProductPriceElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductPriceElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductPriceElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRODUCT_PRICE"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductPriceElementType {
    type Deserializer = quick_xml_deserialize::ProductPriceElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfDiscountGroupElementType {
    pub content: Vec<UdxEdxfDiscountGroupElementTypeContent>,
}
#[derive(Debug)]
pub enum UdxEdxfDiscountGroupElementTypeContent {
    UdxEdxfDiscountGroupManufacturer(String),
    UdxEdxfDiscountGroupSupplier(String),
}
impl WithSerializer for UdxEdxfDiscountGroupElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfDiscountGroupElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfDiscountGroupElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfDiscountGroupElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.DISCOUNT_GROUP"),
                is_root,
            },
        )
    }
}
impl WithSerializer for UdxEdxfDiscountGroupElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfDiscountGroupElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok (quick_xml_serialize :: UdxEdxfDiscountGroupElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfDiscountGroupElementTypeContentSerializerState :: Init__) , })
    }
}
impl WithDeserializer for UdxEdxfDiscountGroupElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfDiscountGroupElementTypeDeserializer;
}
impl WithDeserializer for UdxEdxfDiscountGroupElementTypeContent {
    type Deserializer = quick_xml_deserialize::UdxEdxfDiscountGroupElementTypeContentDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfDeclarationElementType {
    pub type_: String,
    pub date: Option<String>,
    pub content: String,
}
impl WithSerializer for UdxEdxfDeclarationElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfDeclarationElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfDeclarationElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfDeclarationElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.DECLARATION"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfDeclarationElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfDeclarationElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfAdditionalFactorsElementType {
    pub udx_edxf_additional_price_factor: f64,
    pub udx_edxf_additional_factor_info: DtMlstringType,
}
impl WithSerializer for UdxEdxfAdditionalFactorsElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfAdditionalFactorsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfAdditionalFactorsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfAdditionalFactorsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.ADDITIONAL_FACTORS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfAdditionalFactorsElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfAdditionalFactorsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfCountryBranchNumbersElementType {
    pub udx_edxf_country_branch_number:
        Vec<UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType>,
}
impl WithSerializer for UdxEdxfCountryBranchNumbersElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfCountryBranchNumbersElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfCountryBranchNumbersElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.COUNTRY_BRANCH_NUMBERS") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfCountryBranchNumbersElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfCountryBranchNumbersElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfCountryBranchSupplierIdsElementType {
    pub udx_edxf_country_branch_supplier_id:
        Vec<UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType>,
}
impl WithSerializer for UdxEdxfCountryBranchSupplierIdsElementType {
    type Serializer<'x> =
        quick_xml_serialize::UdxEdxfCountryBranchSupplierIdsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfCountryBranchSupplierIdsElementType {
    type Deserializer =
        quick_xml_deserialize::UdxEdxfCountryBranchSupplierIdsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfPackingUnitsElementType {
    pub udx_edxf_packing_unit: Vec<UdxEdxfPackingUnitElementType>,
}
impl WithSerializer for UdxEdxfPackingUnitsElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfPackingUnitsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfPackingUnitsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfPackingUnitsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.PACKING_UNITS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfPackingUnitsElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfPackingUnitsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfProductLogisticDetailsElementType {
    pub udx_edxf_netweight: Option<f64>,
    pub udx_edxf_region_of_origin: Option<String>,
}
impl WithSerializer for UdxEdxfProductLogisticDetailsElementType {
    type Serializer<'x> =
        quick_xml_serialize::UdxEdxfProductLogisticDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfProductLogisticDetailsElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.PRODUCT_LOGISTIC_DETAILS") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfProductLogisticDetailsElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfProductLogisticDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfReachElementType {
    pub udx_edxf_reach_listdate: Option<String>,
    pub udx_edxf_reach_info: String,
}
impl WithSerializer for UdxEdxfReachElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfReachElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxEdxfReachElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxEdxfReachElementTypeSerializerState::Init__),
            name: name.unwrap_or("UDX.EDXF.REACH"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxEdxfReachElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfReachElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfSurchargeListElementType {
    pub udx_edxf_surcharge: Vec<UdxEdxfSurchargeElementType>,
}
impl WithSerializer for UdxEdxfSurchargeListElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfSurchargeListElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfSurchargeListElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfSurchargeListElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.SURCHARGE_LIST"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfSurchargeListElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfSurchargeListElementTypeDeserializer;
}
#[derive(Debug)]
pub enum ProductReferencetypeType {
    Accessories,
    BaseProduct,
    ConsistsOf,
    DiffOrderunit,
    Followup,
    Mandatory,
    Similar,
    Select,
    Sparepart,
    Others,
}
impl SerializeBytes for ProductReferencetypeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Accessories => Ok(Some(Cow::Borrowed("accessories"))),
            Self::BaseProduct => Ok(Some(Cow::Borrowed("base_product"))),
            Self::ConsistsOf => Ok(Some(Cow::Borrowed("consists_of"))),
            Self::DiffOrderunit => Ok(Some(Cow::Borrowed("diff_orderunit"))),
            Self::Followup => Ok(Some(Cow::Borrowed("followup"))),
            Self::Mandatory => Ok(Some(Cow::Borrowed("mandatory"))),
            Self::Similar => Ok(Some(Cow::Borrowed("similar"))),
            Self::Select => Ok(Some(Cow::Borrowed("select"))),
            Self::Sparepart => Ok(Some(Cow::Borrowed("sparepart"))),
            Self::Others => Ok(Some(Cow::Borrowed("others"))),
        }
    }
}
impl DeserializeBytes for ProductReferencetypeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"accessories" => Ok(Self::Accessories),
            b"base_product" => Ok(Self::BaseProduct),
            b"consists_of" => Ok(Self::ConsistsOf),
            b"diff_orderunit" => Ok(Self::DiffOrderunit),
            b"followup" => Ok(Self::Followup),
            b"mandatory" => Ok(Self::Mandatory),
            b"similar" => Ok(Self::Similar),
            b"select" => Ok(Self::Select),
            b"sparepart" => Ok(Self::Sparepart),
            b"others" => Ok(Self::Others),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CustomsTariffNumberElementType {
    pub customs_number: String,
}
impl WithSerializer for CustomsTariffNumberElementType {
    type Serializer<'x> = quick_xml_serialize::CustomsTariffNumberElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CustomsTariffNumberElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CustomsTariffNumberElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CUSTOMS_TARIFF_NUMBER"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CustomsTariffNumberElementType {
    type Deserializer = quick_xml_deserialize::CustomsTariffNumberElementTypeDeserializer;
}
#[derive(Debug)]
pub enum MimePurposeElementType {
    DataSheet,
    Detail,
    Icon,
    Logo,
    Normal,
    SafetyDataSheet,
    Thumbnail,
    Others,
}
impl SerializeBytes for MimePurposeElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::DataSheet => Ok(Some(Cow::Borrowed("data_sheet"))),
            Self::Detail => Ok(Some(Cow::Borrowed("detail"))),
            Self::Icon => Ok(Some(Cow::Borrowed("icon"))),
            Self::Logo => Ok(Some(Cow::Borrowed("logo"))),
            Self::Normal => Ok(Some(Cow::Borrowed("normal"))),
            Self::SafetyDataSheet => Ok(Some(Cow::Borrowed("safety_data_sheet"))),
            Self::Thumbnail => Ok(Some(Cow::Borrowed("thumbnail"))),
            Self::Others => Ok(Some(Cow::Borrowed("others"))),
        }
    }
}
impl DeserializeBytes for MimePurposeElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"data_sheet" => Ok(Self::DataSheet),
            b"detail" => Ok(Self::Detail),
            b"icon" => Ok(Self::Icon),
            b"logo" => Ok(Self::Logo),
            b"normal" => Ok(Self::Normal),
            b"safety_data_sheet" => Ok(Self::SafetyDataSheet),
            b"thumbnail" => Ok(Self::Thumbnail),
            b"others" => Ok(Self::Others),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum ProductStatustypeType {
    Bargain,
    CoreProduct,
    New,
    NewProduct,
    OldProduct,
    Refurbished,
    Used,
    Others,
}
impl SerializeBytes for ProductStatustypeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Bargain => Ok(Some(Cow::Borrowed("bargain"))),
            Self::CoreProduct => Ok(Some(Cow::Borrowed("core_product"))),
            Self::New => Ok(Some(Cow::Borrowed("new"))),
            Self::NewProduct => Ok(Some(Cow::Borrowed("new_product"))),
            Self::OldProduct => Ok(Some(Cow::Borrowed("old_product"))),
            Self::Refurbished => Ok(Some(Cow::Borrowed("refurbished"))),
            Self::Used => Ok(Some(Cow::Borrowed("used"))),
            Self::Others => Ok(Some(Cow::Borrowed("others"))),
        }
    }
}
impl DeserializeBytes for ProductStatustypeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"bargain" => Ok(Self::Bargain),
            b"core_product" => Ok(Self::CoreProduct),
            b"new" => Ok(Self::New),
            b"new_product" => Ok(Self::NewProduct),
            b"old_product" => Ok(Self::OldProduct),
            b"refurbished" => Ok(Self::Refurbished),
            b"used" => Ok(Self::Used),
            b"others" => Ok(Self::Others),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum TypeClassificationGroupIdtypeType {
    Flat,
    Hierarchy,
}
impl SerializeBytes for TypeClassificationGroupIdtypeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Flat => Ok(Some(Cow::Borrowed("flat"))),
            Self::Hierarchy => Ok(Some(Cow::Borrowed("hierarchy"))),
        }
    }
}
impl DeserializeBytes for TypeClassificationGroupIdtypeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"flat" => Ok(Self::Flat),
            b"hierarchy" => Ok(Self::Hierarchy),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum ProductPriceDetailsDatetimetypeType {
    ValidStartDate,
    ValidEndDate,
}
impl SerializeBytes for ProductPriceDetailsDatetimetypeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::ValidStartDate => Ok(Some(Cow::Borrowed("valid_start_date"))),
            Self::ValidEndDate => Ok(Some(Cow::Borrowed("valid_end_date"))),
        }
    }
}
impl DeserializeBytes for ProductPriceDetailsDatetimetypeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"valid_start_date" => Ok(Self::ValidStartDate),
            b"valid_end_date" => Ok(Self::ValidEndDate),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType {
    pub type_: String,
    pub country: String,
    pub content: f64,
}
impl WithSerializer for UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType {
    type Serializer < 'x > = quick_xml_serialize :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer < 'x > ;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumber") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType {
    type Deserializer = quick_xml_deserialize :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializer ;
}
#[derive(Debug)]
pub struct UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType {
    pub type_: String,
    pub country: String,
    pub content: f64,
}
impl WithSerializer for UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType {
    type Serializer < 'x > = quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer < 'x > ;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierId") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType {
    type Deserializer = quick_xml_deserialize :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializer ;
}
#[derive(Debug)]
pub struct UdxEdxfPackingUnitElementType {
    pub udx_edxf_quantity_min: f32,
    pub udx_edxf_quantity_max: Option<f32>,
    pub udx_edxf_packing_unit_code: DtPunitType,
    pub udx_edxf_packing_unit_name: Vec<DtMlstringType>,
    pub udx_edxf_package_break: Option<String>,
    pub udx_edxf_volume: Option<f64>,
    pub udx_edxf_weight: Option<f64>,
    pub udx_edxf_length: Option<f64>,
    pub udx_edxf_width: Option<f64>,
    pub udx_edxf_depth: Option<f64>,
    pub udx_edxf_diameter: Option<f64>,
    pub udx_edxf_gtin: Option<String>,
    pub udx_edxf_gs_1128: Option<String>,
}
impl WithSerializer for UdxEdxfPackingUnitElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfPackingUnitElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfPackingUnitElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfPackingUnitElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.PACKING_UNIT"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfPackingUnitElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfPackingUnitElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfSurchargeElementType {
    pub content: Vec<UdxEdxfSurchargeElementTypeContent>,
}
#[derive(Debug)]
pub enum UdxEdxfSurchargeElementTypeContent {
    UdxEdxfSurchargeType(String),
    UdxEdxfSurchargeManner(String),
    UdxEdxfSurchargePercentage(f64),
    UdxEdxfSurchargePriceAmount(f64),
    UdxEdxfSurchargeCalculation(f64),
    UdxEdxfMaterialBasis(f64),
    UdxEdxfMaterialBasisWeight(f64),
    UdxEdxfMaterialBasisSurchargeThreshold(f64),
    UdxEdxfMaterialBasisSurchargeShutter(i32),
    UdxEdxfMaterialBasisSurchargeCredit(i32),
    UdxEdxfMaterialBasisSurchargeTable(DtMlstringType),
}
impl WithSerializer for UdxEdxfSurchargeElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfSurchargeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxEdxfSurchargeElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::UdxEdxfSurchargeElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("UDX.EDXF.SURCHARGE"),
            is_root,
        })
    }
}
impl WithSerializer for UdxEdxfSurchargeElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfSurchargeElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(
            quick_xml_serialize::UdxEdxfSurchargeElementTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfSurchargeElementTypeContentSerializerState::Init__,
                ),
            },
        )
    }
}
impl WithDeserializer for UdxEdxfSurchargeElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfSurchargeElementTypeDeserializer;
}
impl WithDeserializer for UdxEdxfSurchargeElementTypeContent {
    type Deserializer = quick_xml_deserialize::UdxEdxfSurchargeElementTypeContentDeserializer;
}
pub mod quick_xml_deserialize {
    use core::mem::replace;
    use xsd_parser::quick_xml::{
        filter_xmlns_attributes, BytesStart, ContentDeserializer, DeserializeReader, Deserializer,
        DeserializerArtifact, DeserializerEvent, DeserializerOutput, DeserializerResult,
        ElementHandlerOutput, Error, ErrorKind, Event, RawByteStr, WithDeserializer,
    };
    #[derive(Debug)]
    pub struct BmecatElementTypeDeserializer {
        version: super::TypeBmEcatVersionType,
        content: Vec<super::BmecatElementTypeContent>,
        state: Box<BmecatElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum BmecatElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::BmecatElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl BmecatElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut version: Option<super::TypeBmEcatVersionType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"version")
                ) {
                    reader.read_attrib(&mut version, b"version", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                version: version.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("version".into()))
                })?,
                content: Vec::new(),
                state: Box::new(BmecatElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: BmecatElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let BmecatElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::BmecatElementTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::BmecatElementTypeContent>,
            fallback: &mut Option<BmecatElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(BmecatElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = BmecatElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let can_have_more = self.content.len().saturating_add(1) < 4usize;
                    let ret = if can_have_more {
                        ElementHandlerOutput::from_event(event, allow_any)
                    } else {
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    };
                    match (can_have_more, &ret) {
                        (true, ElementHandlerOutput::Continue { .. }) => {
                            fallback.get_or_insert(BmecatElementTypeDeserializerState::Content__(
                                deserializer,
                            ));
                            *self.state = BmecatElementTypeDeserializerState::Next__;
                        }
                        (false, _) | (_, ElementHandlerOutput::Break { .. }) => {
                            *self.state =
                                BmecatElementTypeDeserializerState::Content__(deserializer);
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::BmecatElementType> for BmecatElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BmecatElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BmecatElementType>
        where
            R: DeserializeReader,
        {
            use BmecatElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: BmecatElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::BmecatElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                BmecatElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::BmecatElementType {
                version: self.version,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct BmecatElementTypeContentDeserializer {
        state: Box<BmecatElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum BmecatElementTypeContentDeserializerState {
        Init__,
        Header(
            Option<super::HeaderElementType>,
            Option<<super::HeaderElementType as WithDeserializer>::Deserializer>,
        ),
        TNewCatalog(
            Option<super::TNewCatalogElementType>,
            Option<<super::TNewCatalogElementType as WithDeserializer>::Deserializer>,
        ),
        TUpdateProducts(
            Option<super::TUpdateProductsElementType>,
            Option<<super::TUpdateProductsElementType as WithDeserializer>::Deserializer>,
        ),
        TUpdatePrices(
            Option<super::TUpdatePricesElementType>,
            Option<<super::TUpdatePricesElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::BmecatElementTypeContent),
        Unknown__,
    }
    impl BmecatElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(BmecatElementTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"HEADER")
            ) {
                let output = <super::HeaderElementType as WithDeserializer>::Deserializer::init(
                    reader, event,
                )?;
                return self.handle_header(reader, Default::default(), output, &mut *fallback);
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"T_NEW_CATALOG")
            ) {
                let output =
                    <super::TNewCatalogElementType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                return self.handle_t_new_catalog(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"T_UPDATE_PRODUCTS")
            ) {
                let output =
                    <super::TUpdateProductsElementType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                return self.handle_t_update_products(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"T_UPDATE_PRICES")
            ) {
                let output =
                    <super::TUpdatePricesElementType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                return self.handle_t_update_prices(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(BmecatElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: BmecatElementTypeContentDeserializerState,
        ) -> Result<super::BmecatElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use BmecatElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Header(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_header(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::Header(values.ok_or_else(
                        || ErrorKind::MissingElement("HEADER".into()),
                    )?))
                }
                S::TNewCatalog(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_t_new_catalog(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::TNewCatalog(
                        values.ok_or_else(|| ErrorKind::MissingElement("T_NEW_CATALOG".into()))?,
                    ))
                }
                S::TUpdateProducts(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_t_update_products(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::TUpdateProducts(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("T_UPDATE_PRODUCTS".into()))?,
                    ))
                }
                S::TUpdatePrices(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_t_update_prices(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::TUpdatePrices(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("T_UPDATE_PRICES".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_header(
            values: &mut Option<super::HeaderElementType>,
            value: super::HeaderElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"HEADER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_t_new_catalog(
            values: &mut Option<super::TNewCatalogElementType>,
            value: super::TNewCatalogElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"T_NEW_CATALOG",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_t_update_products(
            values: &mut Option<super::TUpdateProductsElementType>,
            value: super::TUpdateProductsElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"T_UPDATE_PRODUCTS",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_t_update_prices(
            values: &mut Option<super::TUpdatePricesElementType>,
            value: super::TUpdatePricesElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"T_UPDATE_PRICES",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_header<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::HeaderElementType>,
            output: DeserializerOutput<'de, super::HeaderElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => BmecatElementTypeContentDeserializerState::Init__,
                    Some(BmecatElementTypeContentDeserializerState::Header(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::Header(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::Header(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_header(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_header(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::Header(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::Header(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_t_new_catalog<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::TNewCatalogElementType>,
            output: DeserializerOutput<'de, super::TNewCatalogElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => BmecatElementTypeContentDeserializerState::Init__,
                    Some(BmecatElementTypeContentDeserializerState::TNewCatalog(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::TNewCatalog(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::TNewCatalog(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_t_new_catalog(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_t_new_catalog(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::TNewCatalog(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::TNewCatalog(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_t_update_products<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::TUpdateProductsElementType>,
            output: DeserializerOutput<'de, super::TUpdateProductsElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => BmecatElementTypeContentDeserializerState::Init__,
                    Some(BmecatElementTypeContentDeserializerState::TUpdateProducts(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::TUpdateProducts(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::TUpdateProducts(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_t_update_products(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_t_update_products(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::TUpdateProducts(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::TUpdateProducts(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_t_update_prices<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::TUpdatePricesElementType>,
            output: DeserializerOutput<'de, super::TUpdatePricesElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => BmecatElementTypeContentDeserializerState::Init__,
                    Some(BmecatElementTypeContentDeserializerState::TUpdatePrices(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::TUpdatePrices(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::TUpdatePrices(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_t_update_prices(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_t_update_prices(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::TUpdatePrices(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::TUpdatePrices(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::BmecatElementTypeContent>
        for BmecatElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BmecatElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(BmecatElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, BmecatElementTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BmecatElementTypeContent>
        where
            R: DeserializeReader,
        {
            use BmecatElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Header(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_header(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TNewCatalog(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_t_new_catalog(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TUpdateProducts(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_t_update_products(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TUpdatePrices(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_t_update_prices(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Header(values, None), event) => {
                        let output =
                            <super::HeaderElementType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_header(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TNewCatalog(values, None), event) => {
                        let output = < super :: TNewCatalogElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_t_new_catalog(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TUpdateProducts(values, None), event) => {
                        let output = < super :: TUpdateProductsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_t_update_products(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TUpdatePrices(values, None), event) => {
                        let output = < super :: TUpdatePricesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_t_update_prices(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::BmecatElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct HeaderElementTypeDeserializer {
        generator_info: Option<String>,
        catalog: Option<super::CatalogElementType>,
        buyer: Option<super::BuyerElementType>,
        supplier: Option<super::SupplierElementType>,
        user_defined_extensions: Option<super::UdxHeaderType>,
        state: Box<HeaderElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum HeaderElementTypeDeserializerState {
        Init__,
        GeneratorInfo(Option<<String as WithDeserializer>::Deserializer>),
        Catalog(Option<<super::CatalogElementType as WithDeserializer>::Deserializer>),
        Buyer(Option<<super::BuyerElementType as WithDeserializer>::Deserializer>),
        Supplier(Option<<super::SupplierElementType as WithDeserializer>::Deserializer>),
        UserDefinedExtensions(Option<<super::UdxHeaderType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl HeaderElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                generator_info: None,
                catalog: None,
                buyer: None,
                supplier: None,
                user_defined_extensions: None,
                state: Box::new(HeaderElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: HeaderElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use HeaderElementTypeDeserializerState as S;
            match state {
                S::GeneratorInfo(Some(deserializer)) => {
                    self.store_generator_info(deserializer.finish(reader)?)?
                }
                S::Catalog(Some(deserializer)) => {
                    self.store_catalog(deserializer.finish(reader)?)?
                }
                S::Buyer(Some(deserializer)) => self.store_buyer(deserializer.finish(reader)?)?,
                S::Supplier(Some(deserializer)) => {
                    self.store_supplier(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_generator_info(&mut self, value: String) -> Result<(), Error> {
            if self.generator_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GENERATOR_INFO",
                )))?;
            }
            self.generator_info = Some(value);
            Ok(())
        }
        fn store_catalog(&mut self, value: super::CatalogElementType) -> Result<(), Error> {
            if self.catalog.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG",
                )))?;
            }
            self.catalog = Some(value);
            Ok(())
        }
        fn store_buyer(&mut self, value: super::BuyerElementType) -> Result<(), Error> {
            if self.buyer.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BUYER",
                )))?;
            }
            self.buyer = Some(value);
            Ok(())
        }
        fn store_supplier(&mut self, value: super::SupplierElementType) -> Result<(), Error> {
            if self.supplier.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER",
                )))?;
            }
            self.supplier = Some(value);
            Ok(())
        }
        fn store_user_defined_extensions(
            &mut self,
            value: super::UdxHeaderType,
        ) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn handle_generator_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(HeaderElementTypeDeserializerState::GeneratorInfo(None));
                *self.state = HeaderElementTypeDeserializerState::Catalog(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_generator_info(data)?;
                    *self.state = HeaderElementTypeDeserializerState::Catalog(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderElementTypeDeserializerState::GeneratorInfo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = HeaderElementTypeDeserializerState::Catalog(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = HeaderElementTypeDeserializerState::GeneratorInfo(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CatalogElementType>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.catalog.is_some() {
                    fallback.get_or_insert(HeaderElementTypeDeserializerState::Catalog(None));
                    *self.state = HeaderElementTypeDeserializerState::Buyer(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderElementTypeDeserializerState::Catalog(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog(data)?;
                    *self.state = HeaderElementTypeDeserializerState::Buyer(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(HeaderElementTypeDeserializerState::Catalog(
                                Some(deserializer),
                            ));
                            *self.state = HeaderElementTypeDeserializerState::Buyer(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderElementTypeDeserializerState::Catalog(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::BuyerElementType>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.buyer.is_some() {
                    fallback.get_or_insert(HeaderElementTypeDeserializerState::Buyer(None));
                    *self.state = HeaderElementTypeDeserializerState::Supplier(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderElementTypeDeserializerState::Buyer(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer(data)?;
                    *self.state = HeaderElementTypeDeserializerState::Supplier(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(HeaderElementTypeDeserializerState::Buyer(
                                Some(deserializer),
                            ));
                            *self.state = HeaderElementTypeDeserializerState::Supplier(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderElementTypeDeserializerState::Buyer(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_supplier<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplierElementType>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier.is_some() {
                    fallback.get_or_insert(HeaderElementTypeDeserializerState::Supplier(None));
                    *self.state = HeaderElementTypeDeserializerState::UserDefinedExtensions(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderElementTypeDeserializerState::Supplier(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier(data)?;
                    *self.state = HeaderElementTypeDeserializerState::UserDefinedExtensions(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(HeaderElementTypeDeserializerState::Supplier(
                                Some(deserializer),
                            ));
                            *self.state =
                                HeaderElementTypeDeserializerState::UserDefinedExtensions(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderElementTypeDeserializerState::Supplier(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxHeaderType>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.user_defined_extensions.is_some() {
                    fallback.get_or_insert(
                        HeaderElementTypeDeserializerState::UserDefinedExtensions(None),
                    );
                    *self.state = HeaderElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderElementTypeDeserializerState::UserDefinedExtensions(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state = HeaderElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderElementTypeDeserializerState::UserDefinedExtensions(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = HeaderElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = HeaderElementTypeDeserializerState::UserDefinedExtensions(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::HeaderElementType> for HeaderElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderElementType>
        where
            R: DeserializeReader,
        {
            use HeaderElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::GeneratorInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_generator_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Catalog(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Buyer(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Supplier(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = HeaderElementTypeDeserializerState::GeneratorInfo(None);
                        event
                    }
                    (S::GeneratorInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"GENERATOR_INFO",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_generator_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Catalog(None);
                            event
                        }
                    }
                    (S::Catalog(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"CATALOG")
                        {
                            let output = < super :: CatalogElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_catalog(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Buyer(None);
                            event
                        }
                    }
                    (S::Buyer(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"BUYER") {
                            let output =
                                <super::BuyerElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_buyer(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Supplier(None);
                            event
                        }
                    }
                    (S::Supplier(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER",
                        ) {
                            let output = < super :: SupplierElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_supplier(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxHeaderType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::HeaderElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                HeaderElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::HeaderElementType {
                generator_info: self.generator_info,
                catalog: self
                    .catalog
                    .ok_or_else(|| ErrorKind::MissingElement("CATALOG".into()))?,
                buyer: self
                    .buyer
                    .ok_or_else(|| ErrorKind::MissingElement("BUYER".into()))?,
                supplier: self
                    .supplier
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER".into()))?,
                user_defined_extensions: self
                    .user_defined_extensions
                    .ok_or_else(|| ErrorKind::MissingElement("USER_DEFINED_EXTENSIONS".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TNewCatalogElementTypeDeserializer {
        product: Vec<super::TNewCatalogProductElementType>,
        state: Box<TNewCatalogElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TNewCatalogElementTypeDeserializerState {
        Init__,
        Product(Option<<super::TNewCatalogProductElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TNewCatalogElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                product: Vec::new(),
                state: Box::new(TNewCatalogElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TNewCatalogElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TNewCatalogElementTypeDeserializerState as S;
            match state {
                S::Product(Some(deserializer)) => {
                    self.store_product(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_product(
            &mut self,
            value: super::TNewCatalogProductElementType,
        ) -> Result<(), Error> {
            self.product.push(value);
            Ok(())
        }
        fn handle_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TNewCatalogProductElementType>,
            fallback: &mut Option<TNewCatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product.len() < 1usize {
                    *self.state = TNewCatalogElementTypeDeserializerState::Product(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(TNewCatalogElementTypeDeserializerState::Product(None));
                    *self.state = TNewCatalogElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product(data)?;
                    *self.state = TNewCatalogElementTypeDeserializerState::Product(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogElementTypeDeserializerState::Product(Some(
                                    deserializer,
                                )),
                            );
                            if self.product.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TNewCatalogElementTypeDeserializerState::Product(None);
                            } else {
                                *self.state = TNewCatalogElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TNewCatalogElementTypeDeserializerState::Product(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TNewCatalogElementType> for TNewCatalogElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewCatalogElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewCatalogElementType>
        where
            R: DeserializeReader,
        {
            use TNewCatalogElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Product(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TNewCatalogElementTypeDeserializerState::Product(None);
                        event
                    }
                    (S::Product(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"PRODUCT")
                        {
                            let output = < super :: TNewCatalogProductElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TNewCatalogElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TNewCatalogElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TNewCatalogElementType {
                product: self.product,
            })
        }
    }
    #[derive(Debug)]
    pub struct TUpdateProductsElementTypeDeserializer {
        prev_version: i32,
        product: Vec<super::TUpdateProductsProductElementType>,
        state: Box<TUpdateProductsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TUpdateProductsElementTypeDeserializerState {
        Init__,
        Product(
            Option<<super::TUpdateProductsProductElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TUpdateProductsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut prev_version: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"prev_version")
                ) {
                    reader.read_attrib(&mut prev_version, b"prev_version", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                prev_version: prev_version.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("prev_version".into()))
                })?,
                product: Vec::new(),
                state: Box::new(TUpdateProductsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TUpdateProductsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TUpdateProductsElementTypeDeserializerState as S;
            match state {
                S::Product(Some(deserializer)) => {
                    self.store_product(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_product(
            &mut self,
            value: super::TUpdateProductsProductElementType,
        ) -> Result<(), Error> {
            self.product.push(value);
            Ok(())
        }
        fn handle_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TUpdateProductsProductElementType>,
            fallback: &mut Option<TUpdateProductsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product.len() < 1usize {
                    *self.state = TUpdateProductsElementTypeDeserializerState::Product(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(TUpdateProductsElementTypeDeserializerState::Product(None));
                    *self.state = TUpdateProductsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product(data)?;
                    *self.state = TUpdateProductsElementTypeDeserializerState::Product(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsElementTypeDeserializerState::Product(Some(
                                    deserializer,
                                )),
                            );
                            if self.product.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TUpdateProductsElementTypeDeserializerState::Product(None);
                            } else {
                                *self.state = TUpdateProductsElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TUpdateProductsElementTypeDeserializerState::Product(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TUpdateProductsElementType>
        for TUpdateProductsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdateProductsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdateProductsElementType>
        where
            R: DeserializeReader,
        {
            use TUpdateProductsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Product(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TUpdateProductsElementTypeDeserializerState::Product(None);
                        event
                    }
                    (S::Product(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"PRODUCT")
                        {
                            let output = < super :: TUpdateProductsProductElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TUpdateProductsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TUpdateProductsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TUpdateProductsElementType {
                prev_version: self.prev_version,
                product: self.product,
            })
        }
    }
    #[derive(Debug)]
    pub struct TUpdatePricesElementTypeDeserializer {
        prev_version: i32,
        product: Vec<super::TUpdatePricesProductElementType>,
        state: Box<TUpdatePricesElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TUpdatePricesElementTypeDeserializerState {
        Init__,
        Product(Option<<super::TUpdatePricesProductElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TUpdatePricesElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut prev_version: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"prev_version")
                ) {
                    reader.read_attrib(&mut prev_version, b"prev_version", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                prev_version: prev_version.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("prev_version".into()))
                })?,
                product: Vec::new(),
                state: Box::new(TUpdatePricesElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TUpdatePricesElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TUpdatePricesElementTypeDeserializerState as S;
            match state {
                S::Product(Some(deserializer)) => {
                    self.store_product(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_product(
            &mut self,
            value: super::TUpdatePricesProductElementType,
        ) -> Result<(), Error> {
            self.product.push(value);
            Ok(())
        }
        fn handle_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TUpdatePricesProductElementType>,
            fallback: &mut Option<TUpdatePricesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product.len() < 1usize {
                    *self.state = TUpdatePricesElementTypeDeserializerState::Product(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(TUpdatePricesElementTypeDeserializerState::Product(None));
                    *self.state = TUpdatePricesElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product(data)?;
                    *self.state = TUpdatePricesElementTypeDeserializerState::Product(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdatePricesElementTypeDeserializerState::Product(Some(
                                    deserializer,
                                )),
                            );
                            if self.product.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TUpdatePricesElementTypeDeserializerState::Product(None);
                            } else {
                                *self.state = TUpdatePricesElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TUpdatePricesElementTypeDeserializerState::Product(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TUpdatePricesElementType>
        for TUpdatePricesElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdatePricesElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdatePricesElementType>
        where
            R: DeserializeReader,
        {
            use TUpdatePricesElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Product(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TUpdatePricesElementTypeDeserializerState::Product(None);
                        event
                    }
                    (S::Product(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"PRODUCT")
                        {
                            let output = < super :: TUpdatePricesProductElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TUpdatePricesElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TUpdatePricesElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TUpdatePricesElementType {
                prev_version: self.prev_version,
                product: self.product,
            })
        }
    }
    #[derive(Debug)]
    pub struct CatalogElementTypeDeserializer {
        language: Vec<super::LanguageElementType>,
        catalog_id: Option<String>,
        catalog_version: Option<String>,
        catalog_name: Vec<super::DtMlstringType>,
        datetime: Option<super::CatalogDatetimeElementType>,
        territory: Vec<String>,
        currency: Option<super::DtCurrenciesType>,
        mime_root: Vec<super::DtMlstringType>,
        state: Box<CatalogElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CatalogElementTypeDeserializerState {
        Init__,
        Language(Option<<super::LanguageElementType as WithDeserializer>::Deserializer>),
        CatalogId(Option<<String as WithDeserializer>::Deserializer>),
        CatalogVersion(Option<<String as WithDeserializer>::Deserializer>),
        CatalogName(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Datetime(Option<<super::CatalogDatetimeElementType as WithDeserializer>::Deserializer>),
        Territory(Option<<String as WithDeserializer>::Deserializer>),
        Currency(Option<<super::DtCurrenciesType as WithDeserializer>::Deserializer>),
        MimeRoot(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CatalogElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                language: Vec::new(),
                catalog_id: None,
                catalog_version: None,
                catalog_name: Vec::new(),
                datetime: None,
                territory: Vec::new(),
                currency: None,
                mime_root: Vec::new(),
                state: Box::new(CatalogElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CatalogElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CatalogElementTypeDeserializerState as S;
            match state {
                S::Language(Some(deserializer)) => {
                    self.store_language(deserializer.finish(reader)?)?
                }
                S::CatalogId(Some(deserializer)) => {
                    self.store_catalog_id(deserializer.finish(reader)?)?
                }
                S::CatalogVersion(Some(deserializer)) => {
                    self.store_catalog_version(deserializer.finish(reader)?)?
                }
                S::CatalogName(Some(deserializer)) => {
                    self.store_catalog_name(deserializer.finish(reader)?)?
                }
                S::Datetime(Some(deserializer)) => {
                    self.store_datetime(deserializer.finish(reader)?)?
                }
                S::Territory(Some(deserializer)) => {
                    self.store_territory(deserializer.finish(reader)?)?
                }
                S::Currency(Some(deserializer)) => {
                    self.store_currency(deserializer.finish(reader)?)?
                }
                S::MimeRoot(Some(deserializer)) => {
                    self.store_mime_root(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_language(&mut self, value: super::LanguageElementType) -> Result<(), Error> {
            self.language.push(value);
            Ok(())
        }
        fn store_catalog_id(&mut self, value: String) -> Result<(), Error> {
            if self.catalog_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG_ID",
                )))?;
            }
            self.catalog_id = Some(value);
            Ok(())
        }
        fn store_catalog_version(&mut self, value: String) -> Result<(), Error> {
            if self.catalog_version.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG_VERSION",
                )))?;
            }
            self.catalog_version = Some(value);
            Ok(())
        }
        fn store_catalog_name(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.catalog_name.push(value);
            Ok(())
        }
        fn store_datetime(
            &mut self,
            value: super::CatalogDatetimeElementType,
        ) -> Result<(), Error> {
            if self.datetime.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DATETIME",
                )))?;
            }
            self.datetime = Some(value);
            Ok(())
        }
        fn store_territory(&mut self, value: String) -> Result<(), Error> {
            self.territory.push(value);
            Ok(())
        }
        fn store_currency(&mut self, value: super::DtCurrenciesType) -> Result<(), Error> {
            if self.currency.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CURRENCY",
                )))?;
            }
            self.currency = Some(value);
            Ok(())
        }
        fn store_mime_root(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.mime_root.push(value);
            Ok(())
        }
        fn handle_language<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LanguageElementType>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.language.len() < 1usize {
                    *self.state = CatalogElementTypeDeserializerState::Language(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CatalogElementTypeDeserializerState::Language(None));
                    *self.state = CatalogElementTypeDeserializerState::CatalogId(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_language(data)?;
                    *self.state = CatalogElementTypeDeserializerState::Language(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::Language(
                                Some(deserializer),
                            ));
                            if self.language.len().saturating_add(1) < 1usize {
                                *self.state = CatalogElementTypeDeserializerState::Language(None);
                            } else {
                                *self.state = CatalogElementTypeDeserializerState::CatalogId(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::Language(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.catalog_id.is_some() {
                    fallback.get_or_insert(CatalogElementTypeDeserializerState::CatalogId(None));
                    *self.state = CatalogElementTypeDeserializerState::CatalogVersion(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CatalogElementTypeDeserializerState::CatalogId(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_id(data)?;
                    *self.state = CatalogElementTypeDeserializerState::CatalogVersion(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::CatalogId(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::CatalogVersion(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::CatalogId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.catalog_version.is_some() {
                    fallback
                        .get_or_insert(CatalogElementTypeDeserializerState::CatalogVersion(None));
                    *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CatalogElementTypeDeserializerState::CatalogVersion(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_version(data)?;
                    *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CatalogElementTypeDeserializerState::CatalogVersion(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CatalogElementTypeDeserializerState::CatalogVersion(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.catalog_name.len() < 1usize {
                    *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CatalogElementTypeDeserializerState::CatalogName(None));
                    *self.state = CatalogElementTypeDeserializerState::Datetime(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_name(data)?;
                    *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CatalogElementTypeDeserializerState::CatalogName(Some(
                                    deserializer,
                                )),
                            );
                            if self.catalog_name.len().saturating_add(1) < 1usize {
                                *self.state =
                                    CatalogElementTypeDeserializerState::CatalogName(None);
                            } else {
                                *self.state = CatalogElementTypeDeserializerState::Datetime(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CatalogElementTypeDeserializerState::CatalogName(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_datetime<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CatalogDatetimeElementType>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.datetime.is_some() {
                    fallback.get_or_insert(CatalogElementTypeDeserializerState::Datetime(None));
                    *self.state = CatalogElementTypeDeserializerState::Territory(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CatalogElementTypeDeserializerState::Datetime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_datetime(data)?;
                    *self.state = CatalogElementTypeDeserializerState::Territory(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::Datetime(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::Territory(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::Datetime(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_territory<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CatalogElementTypeDeserializerState::Territory(None));
                *self.state = CatalogElementTypeDeserializerState::Currency(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_territory(data)?;
                    *self.state = CatalogElementTypeDeserializerState::Territory(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::Territory(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::Territory(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::Territory(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_currency<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtCurrenciesType>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CatalogElementTypeDeserializerState::Currency(None));
                *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_currency(data)?;
                    *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::Currency(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::Currency(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_root<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CatalogElementTypeDeserializerState::MimeRoot(None));
                *self.state = CatalogElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_root(data)?;
                    *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::MimeRoot(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::MimeRoot(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CatalogElementType> for CatalogElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CatalogElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CatalogElementType>
        where
            R: DeserializeReader,
        {
            use CatalogElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Language(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_language(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogVersion(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Datetime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_datetime(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Territory(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_territory(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Currency(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_currency(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeRoot(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_root(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CatalogElementTypeDeserializerState::Language(None);
                        event
                    }
                    (S::Language(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"LANGUAGE",
                        ) {
                            let output = < super :: LanguageElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_language(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogId(None);
                            event
                        }
                    }
                    (S::CatalogId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_ID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_catalog_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogVersion(None);
                            event
                        }
                    }
                    (S::CatalogVersion(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_VERSION",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_catalog_version(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogName(None);
                            event
                        }
                    }
                    (S::CatalogName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_NAME",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_catalog_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Datetime(None);
                            event
                        }
                    }
                    (S::Datetime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DATETIME",
                        ) {
                            let output = < super :: CatalogDatetimeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_datetime(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Territory(None);
                            event
                        }
                    }
                    (S::Territory(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"TERRITORY",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_territory(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Currency(None);
                            event
                        }
                    }
                    (S::Currency(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CURRENCY",
                        ) {
                            let output =
                                <super::DtCurrenciesType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_currency(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeRoot(None);
                            event
                        }
                    }
                    (S::MimeRoot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_ROOT",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime_root(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CatalogElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CatalogElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CatalogElementType {
                language: self.language,
                catalog_id: self
                    .catalog_id
                    .ok_or_else(|| ErrorKind::MissingElement("CATALOG_ID".into()))?,
                catalog_version: self
                    .catalog_version
                    .ok_or_else(|| ErrorKind::MissingElement("CATALOG_VERSION".into()))?,
                catalog_name: self.catalog_name,
                datetime: self
                    .datetime
                    .ok_or_else(|| ErrorKind::MissingElement("DATETIME".into()))?,
                territory: self.territory,
                currency: self.currency,
                mime_root: self.mime_root,
            })
        }
    }
    #[derive(Debug)]
    pub struct BuyerElementTypeDeserializer {
        buyer_id: Option<super::TypePartyIdType>,
        buyer_name: Option<String>,
        state: Box<BuyerElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum BuyerElementTypeDeserializerState {
        Init__,
        BuyerId(Option<<super::TypePartyIdType as WithDeserializer>::Deserializer>),
        BuyerName(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl BuyerElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                buyer_id: None,
                buyer_name: None,
                state: Box::new(BuyerElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: BuyerElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use BuyerElementTypeDeserializerState as S;
            match state {
                S::BuyerId(Some(deserializer)) => {
                    self.store_buyer_id(deserializer.finish(reader)?)?
                }
                S::BuyerName(Some(deserializer)) => {
                    self.store_buyer_name(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_buyer_id(&mut self, value: super::TypePartyIdType) -> Result<(), Error> {
            if self.buyer_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BUYER_ID",
                )))?;
            }
            self.buyer_id = Some(value);
            Ok(())
        }
        fn store_buyer_name(&mut self, value: String) -> Result<(), Error> {
            if self.buyer_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BUYER_NAME",
                )))?;
            }
            self.buyer_name = Some(value);
            Ok(())
        }
        fn handle_buyer_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TypePartyIdType>,
            fallback: &mut Option<BuyerElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(BuyerElementTypeDeserializerState::BuyerId(None));
                *self.state = BuyerElementTypeDeserializerState::BuyerName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_id(data)?;
                    *self.state = BuyerElementTypeDeserializerState::BuyerName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(BuyerElementTypeDeserializerState::BuyerId(
                                Some(deserializer),
                            ));
                            *self.state = BuyerElementTypeDeserializerState::BuyerName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                BuyerElementTypeDeserializerState::BuyerId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<BuyerElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.buyer_name.is_some() {
                    fallback.get_or_insert(BuyerElementTypeDeserializerState::BuyerName(None));
                    *self.state = BuyerElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = BuyerElementTypeDeserializerState::BuyerName(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_name(data)?;
                    *self.state = BuyerElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(BuyerElementTypeDeserializerState::BuyerName(
                                Some(deserializer),
                            ));
                            *self.state = BuyerElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                BuyerElementTypeDeserializerState::BuyerName(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::BuyerElementType> for BuyerElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BuyerElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BuyerElementType>
        where
            R: DeserializeReader,
        {
            use BuyerElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BuyerId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = BuyerElementTypeDeserializerState::BuyerId(None);
                        event
                    }
                    (S::BuyerId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"BUYER_ID",
                        ) {
                            let output =
                                <super::TypePartyIdType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_buyer_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerName(None);
                            event
                        }
                    }
                    (S::BuyerName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"BUYER_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_buyer_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::BuyerElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                BuyerElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::BuyerElementType {
                buyer_id: self.buyer_id,
                buyer_name: self
                    .buyer_name
                    .ok_or_else(|| ErrorKind::MissingElement("BUYER_NAME".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct SupplierElementTypeDeserializer {
        supplier_id: Vec<super::TypePartyIdType>,
        supplier_name: Option<String>,
        address: Option<super::SupplierAddressElementType>,
        mime_info: Option<super::MimeInfoElementType>,
        state: Box<SupplierElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplierElementTypeDeserializerState {
        Init__,
        SupplierId(Option<<super::TypePartyIdType as WithDeserializer>::Deserializer>),
        SupplierName(Option<<String as WithDeserializer>::Deserializer>),
        Address(Option<<super::SupplierAddressElementType as WithDeserializer>::Deserializer>),
        MimeInfo(Option<<super::MimeInfoElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SupplierElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                supplier_id: Vec::new(),
                supplier_name: None,
                address: None,
                mime_info: None,
                state: Box::new(SupplierElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplierElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SupplierElementTypeDeserializerState as S;
            match state {
                S::SupplierId(Some(deserializer)) => {
                    self.store_supplier_id(deserializer.finish(reader)?)?
                }
                S::SupplierName(Some(deserializer)) => {
                    self.store_supplier_name(deserializer.finish(reader)?)?
                }
                S::Address(Some(deserializer)) => {
                    self.store_address(deserializer.finish(reader)?)?
                }
                S::MimeInfo(Some(deserializer)) => {
                    self.store_mime_info(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_id(&mut self, value: super::TypePartyIdType) -> Result<(), Error> {
            self.supplier_id.push(value);
            Ok(())
        }
        fn store_supplier_name(&mut self, value: String) -> Result<(), Error> {
            if self.supplier_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_NAME",
                )))?;
            }
            self.supplier_name = Some(value);
            Ok(())
        }
        fn store_address(&mut self, value: super::SupplierAddressElementType) -> Result<(), Error> {
            if self.address.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ADDRESS",
                )))?;
            }
            self.address = Some(value);
            Ok(())
        }
        fn store_mime_info(&mut self, value: super::MimeInfoElementType) -> Result<(), Error> {
            if self.mime_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MIME_INFO",
                )))?;
            }
            self.mime_info = Some(value);
            Ok(())
        }
        fn handle_supplier_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TypePartyIdType>,
            fallback: &mut Option<SupplierElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierElementTypeDeserializerState::SupplierId(None));
                *self.state = SupplierElementTypeDeserializerState::SupplierName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_id(data)?;
                    if self.supplier_id.len() < 2usize {
                        *self.state = SupplierElementTypeDeserializerState::SupplierId(None);
                    } else {
                        *self.state = SupplierElementTypeDeserializerState::SupplierName(None);
                    }
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierElementTypeDeserializerState::SupplierId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierElementTypeDeserializerState::SupplierId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierElementTypeDeserializerState::SupplierId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_supplier_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SupplierElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_name.is_some() {
                    fallback
                        .get_or_insert(SupplierElementTypeDeserializerState::SupplierName(None));
                    *self.state = SupplierElementTypeDeserializerState::Address(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = SupplierElementTypeDeserializerState::SupplierName(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_name(data)?;
                    *self.state = SupplierElementTypeDeserializerState::Address(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierElementTypeDeserializerState::SupplierName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierElementTypeDeserializerState::Address(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierElementTypeDeserializerState::SupplierName(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_address<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplierAddressElementType>,
            fallback: &mut Option<SupplierElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierElementTypeDeserializerState::Address(None));
                *self.state = SupplierElementTypeDeserializerState::MimeInfo(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_address(data)?;
                    *self.state = SupplierElementTypeDeserializerState::MimeInfo(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(SupplierElementTypeDeserializerState::Address(
                                Some(deserializer),
                            ));
                            *self.state = SupplierElementTypeDeserializerState::MimeInfo(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SupplierElementTypeDeserializerState::Address(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MimeInfoElementType>,
            fallback: &mut Option<SupplierElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierElementTypeDeserializerState::MimeInfo(None));
                *self.state = SupplierElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_info(data)?;
                    *self.state = SupplierElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(SupplierElementTypeDeserializerState::MimeInfo(
                                Some(deserializer),
                            ));
                            *self.state = SupplierElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SupplierElementTypeDeserializerState::MimeInfo(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SupplierElementType> for SupplierElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierElementType>
        where
            R: DeserializeReader,
        {
            use SupplierElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SupplierName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Address(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_address(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = SupplierElementTypeDeserializerState::SupplierId(None);
                        event
                    }
                    (S::SupplierId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_ID",
                        ) {
                            let output =
                                <super::TypePartyIdType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_supplier_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SupplierName(None);
                            event
                        }
                    }
                    (S::SupplierName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_supplier_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Address(None);
                            event
                        }
                    }
                    (S::Address(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"ADDRESS")
                        {
                            let output = < super :: SupplierAddressElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_address(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeInfo(None);
                            event
                        }
                    }
                    (S::MimeInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_INFO",
                        ) {
                            let output = < super :: MimeInfoElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_mime_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplierElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplierElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplierElementType {
                supplier_id: self.supplier_id,
                supplier_name: self
                    .supplier_name
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_NAME".into()))?,
                address: self.address,
                mime_info: self.mime_info,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxHeaderTypeDeserializer {
        udx_edxf_version: Option<String>,
        state: Box<UdxHeaderTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxHeaderTypeDeserializerState {
        Init__,
        UdxEdxfVersion(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxHeaderTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_version: None,
                state: Box::new(UdxHeaderTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxHeaderTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxHeaderTypeDeserializerState as S;
            match state {
                S::UdxEdxfVersion(Some(deserializer)) => {
                    self.store_udx_edxf_version(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_version(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_version.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.VERSION",
                )))?;
            }
            self.udx_edxf_version = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxHeaderTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_version.is_some() {
                    fallback.get_or_insert(UdxHeaderTypeDeserializerState::UdxEdxfVersion(None));
                    *self.state = UdxHeaderTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = UdxHeaderTypeDeserializerState::UdxEdxfVersion(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_version(data)?;
                    *self.state = UdxHeaderTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxHeaderTypeDeserializerState::UdxEdxfVersion(
                                Some(deserializer),
                            ));
                            *self.state = UdxHeaderTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxHeaderTypeDeserializerState::UdxEdxfVersion(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxHeaderType> for UdxHeaderTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::UdxHeaderType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxHeaderType>
        where
            R: DeserializeReader,
        {
            use UdxHeaderTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfVersion(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = UdxHeaderTypeDeserializerState::UdxEdxfVersion(None);
                        event
                    }
                    (S::UdxEdxfVersion(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.VERSION",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_version(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxHeaderType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, UdxHeaderTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::UdxHeaderType {
                udx_edxf_version: self
                    .udx_edxf_version
                    .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.VERSION".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TNewCatalogProductElementTypeDeserializer {
        mode: super::TNewCatalogProductmodeType,
        supplier_pid: Option<super::SupplierPidElementType>,
        product_details: Option<super::ProductDetailsElementType>,
        product_features: Vec<super::ProductFeaturesElementType>,
        product_order_details: Option<super::ProductOrderDetailsElementType>,
        product_price_details: Vec<super::ProductPriceDetailsElementType>,
        mime_info: Option<super::MimeInfoElementType>,
        user_defined_extensions: Option<super::UdxProductType>,
        product_reference: Vec<super::ProductReferenceElementType>,
        product_logistic_details: Option<super::ProductLogisticDetailsElementType>,
        state: Box<TNewCatalogProductElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TNewCatalogProductElementTypeDeserializerState {
        Init__,
        SupplierPid(Option<<super::SupplierPidElementType as WithDeserializer>::Deserializer>),
        ProductDetails(
            Option<<super::ProductDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductFeatures(
            Option<<super::ProductFeaturesElementType as WithDeserializer>::Deserializer>,
        ),
        ProductOrderDetails(
            Option<<super::ProductOrderDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductPriceDetails(
            Option<<super::ProductPriceDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        MimeInfo(Option<<super::MimeInfoElementType as WithDeserializer>::Deserializer>),
        UserDefinedExtensions(Option<<super::UdxProductType as WithDeserializer>::Deserializer>),
        ProductReference(
            Option<<super::ProductReferenceElementType as WithDeserializer>::Deserializer>,
        ),
        ProductLogisticDetails(
            Option<<super::ProductLogisticDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TNewCatalogProductElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut mode: Option<super::TNewCatalogProductmodeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"mode")
                ) {
                    reader.read_attrib(&mut mode, b"mode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                mode: mode.unwrap_or_else(super::TNewCatalogProductElementType::default_mode),
                supplier_pid: None,
                product_details: None,
                product_features: Vec::new(),
                product_order_details: None,
                product_price_details: Vec::new(),
                mime_info: None,
                user_defined_extensions: None,
                product_reference: Vec::new(),
                product_logistic_details: None,
                state: Box::new(TNewCatalogProductElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TNewCatalogProductElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TNewCatalogProductElementTypeDeserializerState as S;
            match state {
                S::SupplierPid(Some(deserializer)) => {
                    self.store_supplier_pid(deserializer.finish(reader)?)?
                }
                S::ProductDetails(Some(deserializer)) => {
                    self.store_product_details(deserializer.finish(reader)?)?
                }
                S::ProductFeatures(Some(deserializer)) => {
                    self.store_product_features(deserializer.finish(reader)?)?
                }
                S::ProductOrderDetails(Some(deserializer)) => {
                    self.store_product_order_details(deserializer.finish(reader)?)?
                }
                S::ProductPriceDetails(Some(deserializer)) => {
                    self.store_product_price_details(deserializer.finish(reader)?)?
                }
                S::MimeInfo(Some(deserializer)) => {
                    self.store_mime_info(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                S::ProductReference(Some(deserializer)) => {
                    self.store_product_reference(deserializer.finish(reader)?)?
                }
                S::ProductLogisticDetails(Some(deserializer)) => {
                    self.store_product_logistic_details(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_pid(
            &mut self,
            value: super::SupplierPidElementType,
        ) -> Result<(), Error> {
            if self.supplier_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_PID",
                )))?;
            }
            self.supplier_pid = Some(value);
            Ok(())
        }
        fn store_product_details(
            &mut self,
            value: super::ProductDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_DETAILS",
                )))?;
            }
            self.product_details = Some(value);
            Ok(())
        }
        fn store_product_features(
            &mut self,
            value: super::ProductFeaturesElementType,
        ) -> Result<(), Error> {
            self.product_features.push(value);
            Ok(())
        }
        fn store_product_order_details(
            &mut self,
            value: super::ProductOrderDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_order_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_ORDER_DETAILS",
                )))?;
            }
            self.product_order_details = Some(value);
            Ok(())
        }
        fn store_product_price_details(
            &mut self,
            value: super::ProductPriceDetailsElementType,
        ) -> Result<(), Error> {
            self.product_price_details.push(value);
            Ok(())
        }
        fn store_mime_info(&mut self, value: super::MimeInfoElementType) -> Result<(), Error> {
            if self.mime_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MIME_INFO",
                )))?;
            }
            self.mime_info = Some(value);
            Ok(())
        }
        fn store_user_defined_extensions(
            &mut self,
            value: super::UdxProductType,
        ) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn store_product_reference(
            &mut self,
            value: super::ProductReferenceElementType,
        ) -> Result<(), Error> {
            self.product_reference.push(value);
            Ok(())
        }
        fn store_product_logistic_details(
            &mut self,
            value: super::ProductLogisticDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_logistic_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_LOGISTIC_DETAILS",
                )))?;
            }
            self.product_logistic_details = Some(value);
            Ok(())
        }
        fn handle_supplier_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplierPidElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_pid.is_some() {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::SupplierPid(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TNewCatalogProductElementTypeDeserializerState::SupplierPid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_pid(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::SupplierPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::SupplierPid(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductDetailsElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_details.is_some() {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::ProductDetails(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_details(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductFeatures(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_features<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductFeaturesElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_features.len() < 1usize {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_features(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                ),
                            );
                            if self.product_features.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TNewCatalogProductElementTypeDeserializerState::ProductFeatures(
                                        None,
                                    );
                            } else {
                                * self . state = TNewCatalogProductElementTypeDeserializerState :: ProductOrderDetails (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_order_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductOrderDetailsElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_order_details.is_some() {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_order_details(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_price_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceDetailsElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_price_details.len() < 1usize {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None),
                    );
                    *self.state = TNewCatalogProductElementTypeDeserializerState::MimeInfo(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_price_details(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(
                                    Some(deserializer),
                                ),
                            );
                            if self.product_price_details.len().saturating_add(1) < 1usize {
                                * self . state = TNewCatalogProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                            } else {
                                *self.state =
                                    TNewCatalogProductElementTypeDeserializerState::MimeInfo(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MimeInfoElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(TNewCatalogProductElementTypeDeserializerState::MimeInfo(
                    None,
                ));
                *self.state =
                    TNewCatalogProductElementTypeDeserializerState::UserDefinedExtensions(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_info(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::UserDefinedExtensions(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::MimeInfo(Some(
                                    deserializer,
                                )),
                            );
                            * self . state = TNewCatalogProductElementTypeDeserializerState :: UserDefinedExtensions (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TNewCatalogProductElementTypeDeserializerState::MimeInfo(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxProductType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.user_defined_extensions.is_some() {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::UserDefinedExtensions(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductReference(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::UserDefinedExtensions(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TNewCatalogProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer))) ;
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductReference(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TNewCatalogProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductReferenceElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TNewCatalogProductElementTypeDeserializerState::ProductReference(None),
                );
                *self.state =
                    TNewCatalogProductElementTypeDeserializerState::ProductLogisticDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_reference(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductReference(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductReference(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductReference(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_logistic_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductLogisticDetailsElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TNewCatalogProductElementTypeDeserializerState::ProductLogisticDetails(None),
                );
                *self.state = TNewCatalogProductElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_logistic_details(data)?;
                    *self.state = TNewCatalogProductElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TNewCatalogProductElementTypeDeserializerState :: ProductLogisticDetails (Some (deserializer))) ;
                            *self.state = TNewCatalogProductElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TNewCatalogProductElementTypeDeserializerState :: ProductLogisticDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TNewCatalogProductElementType>
        for TNewCatalogProductElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewCatalogProductElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewCatalogProductElementType>
        where
            R: DeserializeReader,
        {
            use TNewCatalogProductElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductFeatures(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_features(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductOrderDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_order_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductPriceDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_price_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductReference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductLogisticDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_logistic_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TNewCatalogProductElementTypeDeserializerState::SupplierPid(None);
                        event
                    }
                    (S::SupplierPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_PID",
                        ) {
                            let output = < super :: SupplierPidElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_supplier_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductDetails(None);
                            event
                        }
                    }
                    (S::ProductDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_DETAILS",
                        ) {
                            let output = < super :: ProductDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_details(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductFeatures(None);
                            event
                        }
                    }
                    (S::ProductFeatures(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_FEATURES",
                        ) {
                            let output = < super :: ProductFeaturesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_features(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductOrderDetails(None);
                            event
                        }
                    }
                    (S::ProductOrderDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_ORDER_DETAILS",
                        ) {
                            let output = < super :: ProductOrderDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_order_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductPriceDetails(None);
                            event
                        }
                    }
                    (S::ProductPriceDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_PRICE_DETAILS",
                        ) {
                            let output = < super :: ProductPriceDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_price_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeInfo(None);
                            event
                        }
                    }
                    (S::MimeInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_INFO",
                        ) {
                            let output = < super :: MimeInfoElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_mime_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxProductType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductReference(None);
                            event
                        }
                    }
                    (S::ProductReference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_REFERENCE",
                        ) {
                            let output = < super :: ProductReferenceElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_reference(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductLogisticDetails(None);
                            event
                        }
                    }
                    (
                        S::ProductLogisticDetails(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_LOGISTIC_DETAILS",
                        ) {
                            let output = < super :: ProductLogisticDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_logistic_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TNewCatalogProductElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TNewCatalogProductElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TNewCatalogProductElementType {
                mode: self.mode,
                supplier_pid: self
                    .supplier_pid
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_PID".into()))?,
                product_details: self
                    .product_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_DETAILS".into()))?,
                product_features: self.product_features,
                product_order_details: self
                    .product_order_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_ORDER_DETAILS".into()))?,
                product_price_details: self.product_price_details,
                mime_info: self.mime_info,
                user_defined_extensions: self
                    .user_defined_extensions
                    .ok_or_else(|| ErrorKind::MissingElement("USER_DEFINED_EXTENSIONS".into()))?,
                product_reference: self.product_reference,
                product_logistic_details: self.product_logistic_details,
            })
        }
    }
    #[derive(Debug)]
    pub struct TUpdateProductsProductElementTypeDeserializer {
        mode: super::TUpdateProductsProductmodeType,
        supplier_pid: Option<super::SupplierPidElementType>,
        product_details: Option<super::ProductDetailsElementType>,
        product_features: Vec<super::ProductFeaturesElementType>,
        product_order_details: Option<super::ProductOrderDetailsElementType>,
        product_price_details: Vec<super::ProductPriceDetailsElementType>,
        mime_info: Option<super::MimeInfoElementType>,
        user_defined_extensions: Option<super::UdxProductType>,
        product_reference: Vec<super::ProductReferenceElementType>,
        product_logistic_details: Option<super::ProductLogisticDetailsElementType>,
        state: Box<TUpdateProductsProductElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TUpdateProductsProductElementTypeDeserializerState {
        Init__,
        SupplierPid(Option<<super::SupplierPidElementType as WithDeserializer>::Deserializer>),
        ProductDetails(
            Option<<super::ProductDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductFeatures(
            Option<<super::ProductFeaturesElementType as WithDeserializer>::Deserializer>,
        ),
        ProductOrderDetails(
            Option<<super::ProductOrderDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductPriceDetails(
            Option<<super::ProductPriceDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        MimeInfo(Option<<super::MimeInfoElementType as WithDeserializer>::Deserializer>),
        UserDefinedExtensions(Option<<super::UdxProductType as WithDeserializer>::Deserializer>),
        ProductReference(
            Option<<super::ProductReferenceElementType as WithDeserializer>::Deserializer>,
        ),
        ProductLogisticDetails(
            Option<<super::ProductLogisticDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TUpdateProductsProductElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut mode: Option<super::TUpdateProductsProductmodeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"mode")
                ) {
                    reader.read_attrib(&mut mode, b"mode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                mode: mode
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("mode".into())))?,
                supplier_pid: None,
                product_details: None,
                product_features: Vec::new(),
                product_order_details: None,
                product_price_details: Vec::new(),
                mime_info: None,
                user_defined_extensions: None,
                product_reference: Vec::new(),
                product_logistic_details: None,
                state: Box::new(TUpdateProductsProductElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TUpdateProductsProductElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TUpdateProductsProductElementTypeDeserializerState as S;
            match state {
                S::SupplierPid(Some(deserializer)) => {
                    self.store_supplier_pid(deserializer.finish(reader)?)?
                }
                S::ProductDetails(Some(deserializer)) => {
                    self.store_product_details(deserializer.finish(reader)?)?
                }
                S::ProductFeatures(Some(deserializer)) => {
                    self.store_product_features(deserializer.finish(reader)?)?
                }
                S::ProductOrderDetails(Some(deserializer)) => {
                    self.store_product_order_details(deserializer.finish(reader)?)?
                }
                S::ProductPriceDetails(Some(deserializer)) => {
                    self.store_product_price_details(deserializer.finish(reader)?)?
                }
                S::MimeInfo(Some(deserializer)) => {
                    self.store_mime_info(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                S::ProductReference(Some(deserializer)) => {
                    self.store_product_reference(deserializer.finish(reader)?)?
                }
                S::ProductLogisticDetails(Some(deserializer)) => {
                    self.store_product_logistic_details(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_pid(
            &mut self,
            value: super::SupplierPidElementType,
        ) -> Result<(), Error> {
            if self.supplier_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_PID",
                )))?;
            }
            self.supplier_pid = Some(value);
            Ok(())
        }
        fn store_product_details(
            &mut self,
            value: super::ProductDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_DETAILS",
                )))?;
            }
            self.product_details = Some(value);
            Ok(())
        }
        fn store_product_features(
            &mut self,
            value: super::ProductFeaturesElementType,
        ) -> Result<(), Error> {
            self.product_features.push(value);
            Ok(())
        }
        fn store_product_order_details(
            &mut self,
            value: super::ProductOrderDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_order_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_ORDER_DETAILS",
                )))?;
            }
            self.product_order_details = Some(value);
            Ok(())
        }
        fn store_product_price_details(
            &mut self,
            value: super::ProductPriceDetailsElementType,
        ) -> Result<(), Error> {
            self.product_price_details.push(value);
            Ok(())
        }
        fn store_mime_info(&mut self, value: super::MimeInfoElementType) -> Result<(), Error> {
            if self.mime_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MIME_INFO",
                )))?;
            }
            self.mime_info = Some(value);
            Ok(())
        }
        fn store_user_defined_extensions(
            &mut self,
            value: super::UdxProductType,
        ) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn store_product_reference(
            &mut self,
            value: super::ProductReferenceElementType,
        ) -> Result<(), Error> {
            self.product_reference.push(value);
            Ok(())
        }
        fn store_product_logistic_details(
            &mut self,
            value: super::ProductLogisticDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_logistic_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_LOGISTIC_DETAILS",
                )))?;
            }
            self.product_logistic_details = Some(value);
            Ok(())
        }
        fn handle_supplier_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplierPidElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_pid.is_some() {
                    fallback.get_or_insert(
                        TUpdateProductsProductElementTypeDeserializerState::SupplierPid(None),
                    );
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::SupplierPid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_pid(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductDetailsElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_details.is_some() {
                    fallback.get_or_insert(
                        TUpdateProductsProductElementTypeDeserializerState::ProductDetails(None),
                    );
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_details(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_features<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductFeaturesElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(None),
                );
                *self.state =
                    TUpdateProductsProductElementTypeDeserializerState::ProductOrderDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_features(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_order_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductOrderDetailsElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_order_details.is_some() {
                    fallback.get_or_insert(
                        TUpdateProductsProductElementTypeDeserializerState::ProductOrderDetails(
                            None,
                        ),
                    );
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductOrderDetails(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_order_details(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: ProductOrderDetails (Some (deserializer))) ;
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductOrderDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_price_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceDetailsElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_price_details.len() < 1usize {
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        ),
                    );
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::MimeInfo(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_price_details(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: ProductPriceDetails (Some (deserializer))) ;
                            if self.product_price_details.len().saturating_add(1) < 1usize {
                                * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                            } else {
                                *self.state =
                                    TUpdateProductsProductElementTypeDeserializerState::MimeInfo(
                                        None,
                                    );
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductPriceDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MimeInfoElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::MimeInfo(None),
                );
                *self.state =
                    TUpdateProductsProductElementTypeDeserializerState::UserDefinedExtensions(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_info(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::UserDefinedExtensions(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsProductElementTypeDeserializerState::MimeInfo(Some(
                                    deserializer,
                                )),
                            );
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: UserDefinedExtensions (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::MimeInfo(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxProductType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::UserDefinedExtensions(None),
                );
                *self.state =
                    TUpdateProductsProductElementTypeDeserializerState::ProductReference(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer))) ;
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductReference (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductReferenceElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::ProductReference(None),
                );
                *self.state =
                    TUpdateProductsProductElementTypeDeserializerState::ProductLogisticDetails(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_reference(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: ProductReference (Some (deserializer))) ;
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductReference (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductReference (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_logistic_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductLogisticDetailsElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::ProductLogisticDetails(
                        None,
                    ),
                );
                *self.state = TUpdateProductsProductElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_logistic_details(data)?;
                    *self.state = TUpdateProductsProductElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: ProductLogisticDetails (Some (deserializer))) ;
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductLogisticDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TUpdateProductsProductElementType>
        for TUpdateProductsProductElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdateProductsProductElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdateProductsProductElementType>
        where
            R: DeserializeReader,
        {
            use TUpdateProductsProductElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductFeatures(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_features(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductOrderDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_order_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductPriceDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_price_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductReference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductLogisticDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_logistic_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TUpdateProductsProductElementTypeDeserializerState::SupplierPid(None);
                        event
                    }
                    (S::SupplierPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_PID",
                        ) {
                            let output = < super :: SupplierPidElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_supplier_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductDetails(None);
                            event
                        }
                    }
                    (S::ProductDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_DETAILS",
                        ) {
                            let output = < super :: ProductDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_details(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductFeatures(None);
                            event
                        }
                    }
                    (S::ProductFeatures(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_FEATURES",
                        ) {
                            let output = < super :: ProductFeaturesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_features(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductOrderDetails(None);
                            event
                        }
                    }
                    (S::ProductOrderDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_ORDER_DETAILS",
                        ) {
                            let output = < super :: ProductOrderDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_order_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductPriceDetails(None);
                            event
                        }
                    }
                    (S::ProductPriceDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_PRICE_DETAILS",
                        ) {
                            let output = < super :: ProductPriceDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_price_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeInfo(None);
                            event
                        }
                    }
                    (S::MimeInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_INFO",
                        ) {
                            let output = < super :: MimeInfoElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_mime_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxProductType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductReference(None);
                            event
                        }
                    }
                    (S::ProductReference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_REFERENCE",
                        ) {
                            let output = < super :: ProductReferenceElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_reference(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductLogisticDetails(None);
                            event
                        }
                    }
                    (
                        S::ProductLogisticDetails(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_LOGISTIC_DETAILS",
                        ) {
                            let output = < super :: ProductLogisticDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_logistic_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::TUpdateProductsProductElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TUpdateProductsProductElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TUpdateProductsProductElementType {
                mode: self.mode,
                supplier_pid: self
                    .supplier_pid
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_PID".into()))?,
                product_details: self
                    .product_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_DETAILS".into()))?,
                product_features: self.product_features,
                product_order_details: self
                    .product_order_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_ORDER_DETAILS".into()))?,
                product_price_details: self.product_price_details,
                mime_info: self.mime_info,
                user_defined_extensions: self.user_defined_extensions,
                product_reference: self.product_reference,
                product_logistic_details: self.product_logistic_details,
            })
        }
    }
    #[derive(Debug)]
    pub struct TUpdatePricesProductElementTypeDeserializer {
        mode: super::TUpdatePricesProductmodeType,
        supplier_pid: Option<super::SupplierPidElementType>,
        product_price_details: Vec<super::ProductPriceDetailsElementType>,
        user_defined_extensions: Option<super::UdxProductType>,
        state: Box<TUpdatePricesProductElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TUpdatePricesProductElementTypeDeserializerState {
        Init__,
        SupplierPid(Option<<super::SupplierPidElementType as WithDeserializer>::Deserializer>),
        ProductPriceDetails(
            Option<<super::ProductPriceDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        UserDefinedExtensions(Option<<super::UdxProductType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TUpdatePricesProductElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut mode: Option<super::TUpdatePricesProductmodeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"mode")
                ) {
                    reader.read_attrib(&mut mode, b"mode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                mode: mode.unwrap_or_else(super::TUpdatePricesProductElementType::default_mode),
                supplier_pid: None,
                product_price_details: Vec::new(),
                user_defined_extensions: None,
                state: Box::new(TUpdatePricesProductElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TUpdatePricesProductElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TUpdatePricesProductElementTypeDeserializerState as S;
            match state {
                S::SupplierPid(Some(deserializer)) => {
                    self.store_supplier_pid(deserializer.finish(reader)?)?
                }
                S::ProductPriceDetails(Some(deserializer)) => {
                    self.store_product_price_details(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_pid(
            &mut self,
            value: super::SupplierPidElementType,
        ) -> Result<(), Error> {
            if self.supplier_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_PID",
                )))?;
            }
            self.supplier_pid = Some(value);
            Ok(())
        }
        fn store_product_price_details(
            &mut self,
            value: super::ProductPriceDetailsElementType,
        ) -> Result<(), Error> {
            self.product_price_details.push(value);
            Ok(())
        }
        fn store_user_defined_extensions(
            &mut self,
            value: super::UdxProductType,
        ) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn handle_supplier_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplierPidElementType>,
            fallback: &mut Option<TUpdatePricesProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_pid.is_some() {
                    fallback.get_or_insert(
                        TUpdatePricesProductElementTypeDeserializerState::SupplierPid(None),
                    );
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::SupplierPid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_pid(data)?;
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdatePricesProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = TUpdatePricesProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdatePricesProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_price_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceDetailsElementType>,
            fallback: &mut Option<TUpdatePricesProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_price_details.len() < 1usize {
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None),
                    );
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::UserDefinedExtensions(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_price_details(data)?;
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdatePricesProductElementTypeDeserializerState :: ProductPriceDetails (Some (deserializer))) ;
                            if self.product_price_details.len().saturating_add(1) < 1usize {
                                * self . state = TUpdatePricesProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                            } else {
                                * self . state = TUpdatePricesProductElementTypeDeserializerState :: UserDefinedExtensions (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdatePricesProductElementTypeDeserializerState :: ProductPriceDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxProductType>,
            fallback: &mut Option<TUpdatePricesProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdatePricesProductElementTypeDeserializerState::UserDefinedExtensions(None),
                );
                *self.state = TUpdatePricesProductElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state = TUpdatePricesProductElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdatePricesProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer))) ;
                            *self.state = TUpdatePricesProductElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdatePricesProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TUpdatePricesProductElementType>
        for TUpdatePricesProductElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdatePricesProductElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdatePricesProductElementType>
        where
            R: DeserializeReader,
        {
            use TUpdatePricesProductElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductPriceDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_price_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TUpdatePricesProductElementTypeDeserializerState::SupplierPid(None);
                        event
                    }
                    (S::SupplierPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_PID",
                        ) {
                            let output = < super :: SupplierPidElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_supplier_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductPriceDetails(None);
                            event
                        }
                    }
                    (S::ProductPriceDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_PRICE_DETAILS",
                        ) {
                            let output = < super :: ProductPriceDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_price_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxProductType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TUpdatePricesProductElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TUpdatePricesProductElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TUpdatePricesProductElementType {
                mode: self.mode,
                supplier_pid: self
                    .supplier_pid
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_PID".into()))?,
                product_price_details: self.product_price_details,
                user_defined_extensions: self.user_defined_extensions,
            })
        }
    }
    #[derive(Debug)]
    pub struct LanguageElementTypeDeserializer {
        default: Option<String>,
        content: Option<super::DtLangType>,
        state: Box<LanguageElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LanguageElementTypeDeserializerState {
        Init__,
        Content__(<super::DtLangType as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl LanguageElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut default: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"default")
                ) {
                    reader.read_attrib(&mut default, b"default", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                default: default,
                content: None,
                state: Box::new(LanguageElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LanguageElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let LanguageElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::DtLangType) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtLangType>,
        ) -> DeserializerResult<'de, super::LanguageElementType>
        where
            R: DeserializeReader,
        {
            use LanguageElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::LanguageElementType> for LanguageElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LanguageElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LanguageElementType>
        where
            R: DeserializeReader,
        {
            use LanguageElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LanguageElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LanguageElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LanguageElementType {
                default: self.default,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DtMlstringTypeDeserializer {
        lang: Option<super::DtLangType>,
        content: Option<String>,
        state: Box<DtMlstringTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum DtMlstringTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DtMlstringTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut lang: Option<super::DtLangType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"lang")
                ) {
                    reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                lang: lang,
                content: None,
                state: Box::new(DtMlstringTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DtMlstringTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DtMlstringTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::DtMlstringType>
        where
            R: DeserializeReader,
        {
            use DtMlstringTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::DtMlstringType> for DtMlstringTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::DtMlstringType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DtMlstringType>
        where
            R: DeserializeReader,
        {
            use DtMlstringTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DtMlstringType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, DtMlstringTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::DtMlstringType {
                lang: self.lang,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CatalogDatetimeElementTypeDeserializer {
        type_: super::CatalogDatetimetypeType,
        date: Option<String>,
        time: Option<String>,
        timezone: Option<String>,
        state: Box<CatalogDatetimeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CatalogDatetimeElementTypeDeserializerState {
        Init__,
        Date(Option<<String as WithDeserializer>::Deserializer>),
        Time(Option<<String as WithDeserializer>::Deserializer>),
        Timezone(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CatalogDatetimeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CatalogDatetimetypeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                date: None,
                time: None,
                timezone: None,
                state: Box::new(CatalogDatetimeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CatalogDatetimeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CatalogDatetimeElementTypeDeserializerState as S;
            match state {
                S::Date(Some(deserializer)) => self.store_date(deserializer.finish(reader)?)?,
                S::Time(Some(deserializer)) => self.store_time(deserializer.finish(reader)?)?,
                S::Timezone(Some(deserializer)) => {
                    self.store_timezone(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_date(&mut self, value: String) -> Result<(), Error> {
            if self.date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"DATE")))?;
            }
            self.date = Some(value);
            Ok(())
        }
        fn store_time(&mut self, value: String) -> Result<(), Error> {
            if self.time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"TIME")))?;
            }
            self.time = Some(value);
            Ok(())
        }
        fn store_timezone(&mut self, value: String) -> Result<(), Error> {
            if self.timezone.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TIMEZONE",
                )))?;
            }
            self.timezone = Some(value);
            Ok(())
        }
        fn handle_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogDatetimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.date.is_some() {
                    fallback.get_or_insert(CatalogDatetimeElementTypeDeserializerState::Date(None));
                    *self.state = CatalogDatetimeElementTypeDeserializerState::Time(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CatalogDatetimeElementTypeDeserializerState::Date(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_date(data)?;
                    *self.state = CatalogDatetimeElementTypeDeserializerState::Time(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CatalogDatetimeElementTypeDeserializerState::Date(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CatalogDatetimeElementTypeDeserializerState::Time(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CatalogDatetimeElementTypeDeserializerState::Date(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogDatetimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CatalogDatetimeElementTypeDeserializerState::Time(None));
                *self.state = CatalogDatetimeElementTypeDeserializerState::Timezone(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_time(data)?;
                    *self.state = CatalogDatetimeElementTypeDeserializerState::Timezone(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CatalogDatetimeElementTypeDeserializerState::Time(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                CatalogDatetimeElementTypeDeserializerState::Timezone(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CatalogDatetimeElementTypeDeserializerState::Time(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_timezone<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogDatetimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CatalogDatetimeElementTypeDeserializerState::Timezone(None));
                *self.state = CatalogDatetimeElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_timezone(data)?;
                    *self.state = CatalogDatetimeElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CatalogDatetimeElementTypeDeserializerState::Timezone(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CatalogDatetimeElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CatalogDatetimeElementTypeDeserializerState::Timezone(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CatalogDatetimeElementType>
        for CatalogDatetimeElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CatalogDatetimeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CatalogDatetimeElementType>
        where
            R: DeserializeReader,
        {
            use CatalogDatetimeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Date(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Time(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Timezone(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_timezone(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CatalogDatetimeElementTypeDeserializerState::Date(None);
                        event
                    }
                    (S::Date(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"DATE") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_date(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Time(None);
                            event
                        }
                    }
                    (S::Time(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"TIME") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Timezone(None);
                            event
                        }
                    }
                    (S::Timezone(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"TIMEZONE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_timezone(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CatalogDatetimeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CatalogDatetimeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CatalogDatetimeElementType {
                type_: self.type_,
                date: self
                    .date
                    .ok_or_else(|| ErrorKind::MissingElement("DATE".into()))?,
                time: self.time,
                timezone: self.timezone,
            })
        }
    }
    #[derive(Debug)]
    pub struct TypePartyIdTypeDeserializer {
        type_: Option<String>,
        content: Option<String>,
        state: Box<TypePartyIdTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TypePartyIdTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl TypePartyIdTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_,
                content: None,
                state: Box::new(TypePartyIdTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TypePartyIdTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let TypePartyIdTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::TypePartyIdType>
        where
            R: DeserializeReader,
        {
            use TypePartyIdTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::TypePartyIdType> for TypePartyIdTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TypePartyIdType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TypePartyIdType>
        where
            R: DeserializeReader,
        {
            use TypePartyIdTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TypePartyIdType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TypePartyIdTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TypePartyIdType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct SupplierAddressElementTypeDeserializer {
        type_: super::SupplierAddresstypeType,
        contact: Vec<super::DtMlstringType>,
        street: Vec<super::DtMlstringType>,
        zip: Vec<super::DtMlstringType>,
        city: Vec<super::DtMlstringType>,
        country: Vec<super::DtMlstringType>,
        vat_id: Option<String>,
        email: Option<String>,
        url: Option<String>,
        state: Box<SupplierAddressElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplierAddressElementTypeDeserializerState {
        Init__,
        Contact(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Street(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Zip(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        City(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Country(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        VatId(Option<<String as WithDeserializer>::Deserializer>),
        Email(Option<<String as WithDeserializer>::Deserializer>),
        Url(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SupplierAddressElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::SupplierAddresstypeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                contact: Vec::new(),
                street: Vec::new(),
                zip: Vec::new(),
                city: Vec::new(),
                country: Vec::new(),
                vat_id: None,
                email: None,
                url: None,
                state: Box::new(SupplierAddressElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplierAddressElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SupplierAddressElementTypeDeserializerState as S;
            match state {
                S::Contact(Some(deserializer)) => {
                    self.store_contact(deserializer.finish(reader)?)?
                }
                S::Street(Some(deserializer)) => self.store_street(deserializer.finish(reader)?)?,
                S::Zip(Some(deserializer)) => self.store_zip(deserializer.finish(reader)?)?,
                S::City(Some(deserializer)) => self.store_city(deserializer.finish(reader)?)?,
                S::Country(Some(deserializer)) => {
                    self.store_country(deserializer.finish(reader)?)?
                }
                S::VatId(Some(deserializer)) => self.store_vat_id(deserializer.finish(reader)?)?,
                S::Email(Some(deserializer)) => self.store_email(deserializer.finish(reader)?)?,
                S::Url(Some(deserializer)) => self.store_url(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_contact(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.contact.push(value);
            Ok(())
        }
        fn store_street(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.street.push(value);
            Ok(())
        }
        fn store_zip(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.zip.push(value);
            Ok(())
        }
        fn store_city(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.city.push(value);
            Ok(())
        }
        fn store_country(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.country.push(value);
            Ok(())
        }
        fn store_vat_id(&mut self, value: String) -> Result<(), Error> {
            if self.vat_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"VAT_ID",
                )))?;
            }
            self.vat_id = Some(value);
            Ok(())
        }
        fn store_email(&mut self, value: String) -> Result<(), Error> {
            if self.email.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"EMAIL",
                )))?;
            }
            self.email = Some(value);
            Ok(())
        }
        fn store_url(&mut self, value: String) -> Result<(), Error> {
            if self.url.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"URL")))?;
            }
            self.url = Some(value);
            Ok(())
        }
        fn handle_contact<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Contact(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Street(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_contact(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Contact(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Contact(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                SupplierAddressElementTypeDeserializerState::Contact(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Contact(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_street<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Street(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Zip(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_street(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Street(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Street(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Street(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Street(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_zip<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Zip(None));
                *self.state = SupplierAddressElementTypeDeserializerState::City(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_zip(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Zip(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Zip(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Zip(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Zip(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_city<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::City(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Country(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_city(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::City(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::City(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::City(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::City(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_country<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Country(None));
                *self.state = SupplierAddressElementTypeDeserializerState::VatId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_country(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Country(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Country(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                SupplierAddressElementTypeDeserializerState::Country(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Country(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_vat_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::VatId(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Email(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_vat_id(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Email(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::VatId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Email(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::VatId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_email<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.email.is_some() {
                    fallback
                        .get_or_insert(SupplierAddressElementTypeDeserializerState::Email(None));
                    *self.state = SupplierAddressElementTypeDeserializerState::Url(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = SupplierAddressElementTypeDeserializerState::Email(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_email(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Url(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Email(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Url(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Email(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_url<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Url(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_url(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Url(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Url(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SupplierAddressElementType>
        for SupplierAddressElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierAddressElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierAddressElementType>
        where
            R: DeserializeReader,
        {
            use SupplierAddressElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Contact(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_contact(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Street(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_street(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Zip(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_zip(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::City(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_city(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Country(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_country(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::VatId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_vat_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Email(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_email(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Url(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_url(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = SupplierAddressElementTypeDeserializerState::Contact(None);
                        event
                    }
                    (S::Contact(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"CONTACT")
                        {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_contact(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Street(None);
                            event
                        }
                    }
                    (S::Street(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"STREET")
                        {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_street(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Zip(None);
                            event
                        }
                    }
                    (S::Zip(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"ZIP") {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_zip(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::City(None);
                            event
                        }
                    }
                    (S::City(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"CITY") {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_city(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Country(None);
                            event
                        }
                    }
                    (S::Country(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"COUNTRY")
                        {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_country(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::VatId(None);
                            event
                        }
                    }
                    (S::VatId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"VAT_ID")
                        {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_vat_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Email(None);
                            event
                        }
                    }
                    (S::Email(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"EMAIL") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_email(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Url(None);
                            event
                        }
                    }
                    (S::Url(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"URL") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_url(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplierAddressElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplierAddressElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplierAddressElementType {
                type_: self.type_,
                contact: self.contact,
                street: self.street,
                zip: self.zip,
                city: self.city,
                country: self.country,
                vat_id: self.vat_id,
                email: self
                    .email
                    .ok_or_else(|| ErrorKind::MissingElement("EMAIL".into()))?,
                url: self.url,
            })
        }
    }
    #[derive(Debug)]
    pub struct MimeInfoElementTypeDeserializer {
        mime: Vec<super::MimeElementType>,
        state: Box<MimeInfoElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum MimeInfoElementTypeDeserializerState {
        Init__,
        Mime(Option<<super::MimeElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl MimeInfoElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                mime: Vec::new(),
                state: Box::new(MimeInfoElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: MimeInfoElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use MimeInfoElementTypeDeserializerState as S;
            match state {
                S::Mime(Some(deserializer)) => self.store_mime(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_mime(&mut self, value: super::MimeElementType) -> Result<(), Error> {
            self.mime.push(value);
            Ok(())
        }
        fn handle_mime<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MimeElementType>,
            fallback: &mut Option<MimeInfoElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.mime.len() < 1usize {
                    *self.state = MimeInfoElementTypeDeserializerState::Mime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(MimeInfoElementTypeDeserializerState::Mime(None));
                    *self.state = MimeInfoElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime(data)?;
                    *self.state = MimeInfoElementTypeDeserializerState::Mime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeInfoElementTypeDeserializerState::Mime(
                                Some(deserializer),
                            ));
                            if self.mime.len().saturating_add(1) < 1usize {
                                *self.state = MimeInfoElementTypeDeserializerState::Mime(None);
                            } else {
                                *self.state = MimeInfoElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeInfoElementTypeDeserializerState::Mime(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::MimeInfoElementType> for MimeInfoElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::MimeInfoElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::MimeInfoElementType>
        where
            R: DeserializeReader,
        {
            use MimeInfoElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Mime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = MimeInfoElementTypeDeserializerState::Mime(None);
                        event
                    }
                    (S::Mime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"MIME") {
                            let output =
                                <super::MimeElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::MimeInfoElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                MimeInfoElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::MimeInfoElementType { mime: self.mime })
        }
    }
    #[derive(Debug)]
    pub struct SupplierPidElementTypeDeserializer {
        type_: Option<String>,
        content: Option<String>,
        state: Box<SupplierPidElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplierPidElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl SupplierPidElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_,
                content: None,
                state: Box::new(SupplierPidElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplierPidElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let SupplierPidElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::SupplierPidElementType>
        where
            R: DeserializeReader,
        {
            use SupplierPidElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::SupplierPidElementType> for SupplierPidElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierPidElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierPidElementType>
        where
            R: DeserializeReader,
        {
            use SupplierPidElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplierPidElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplierPidElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplierPidElementType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductDetailsElementTypeDeserializer {
        description_short: Vec<super::DtMlstringType>,
        description_long: Vec<super::DtMlstringType>,
        international_pid: Vec<super::InternationalPidElementType>,
        supplier_alt_pid: Option<String>,
        buyer_pid: Vec<super::BuyerPidElementType>,
        manufacturer_pid: Option<String>,
        manufacturer_name: Option<String>,
        manufacturer_type_descr: Vec<super::DtMlstringType>,
        special_treatment_class: Vec<super::SpecialTreatmentClassElementType>,
        keyword: Vec<super::DtMlstringType>,
        remarks: Vec<super::RemarksElementType>,
        product_status: Vec<super::ProductStatusElementType>,
        state: Box<ProductDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductDetailsElementTypeDeserializerState {
        Init__,
        DescriptionShort(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        DescriptionLong(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        InternationalPid(
            Option<<super::InternationalPidElementType as WithDeserializer>::Deserializer>,
        ),
        SupplierAltPid(Option<<String as WithDeserializer>::Deserializer>),
        BuyerPid(Option<<super::BuyerPidElementType as WithDeserializer>::Deserializer>),
        ManufacturerPid(Option<<String as WithDeserializer>::Deserializer>),
        ManufacturerName(Option<<String as WithDeserializer>::Deserializer>),
        ManufacturerTypeDescr(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        SpecialTreatmentClass(
            Option<<super::SpecialTreatmentClassElementType as WithDeserializer>::Deserializer>,
        ),
        Keyword(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Remarks(Option<<super::RemarksElementType as WithDeserializer>::Deserializer>),
        ProductStatus(Option<<super::ProductStatusElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                description_short: Vec::new(),
                description_long: Vec::new(),
                international_pid: Vec::new(),
                supplier_alt_pid: None,
                buyer_pid: Vec::new(),
                manufacturer_pid: None,
                manufacturer_name: None,
                manufacturer_type_descr: Vec::new(),
                special_treatment_class: Vec::new(),
                keyword: Vec::new(),
                remarks: Vec::new(),
                product_status: Vec::new(),
                state: Box::new(ProductDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductDetailsElementTypeDeserializerState as S;
            match state {
                S::DescriptionShort(Some(deserializer)) => {
                    self.store_description_short(deserializer.finish(reader)?)?
                }
                S::DescriptionLong(Some(deserializer)) => {
                    self.store_description_long(deserializer.finish(reader)?)?
                }
                S::InternationalPid(Some(deserializer)) => {
                    self.store_international_pid(deserializer.finish(reader)?)?
                }
                S::SupplierAltPid(Some(deserializer)) => {
                    self.store_supplier_alt_pid(deserializer.finish(reader)?)?
                }
                S::BuyerPid(Some(deserializer)) => {
                    self.store_buyer_pid(deserializer.finish(reader)?)?
                }
                S::ManufacturerPid(Some(deserializer)) => {
                    self.store_manufacturer_pid(deserializer.finish(reader)?)?
                }
                S::ManufacturerName(Some(deserializer)) => {
                    self.store_manufacturer_name(deserializer.finish(reader)?)?
                }
                S::ManufacturerTypeDescr(Some(deserializer)) => {
                    self.store_manufacturer_type_descr(deserializer.finish(reader)?)?
                }
                S::SpecialTreatmentClass(Some(deserializer)) => {
                    self.store_special_treatment_class(deserializer.finish(reader)?)?
                }
                S::Keyword(Some(deserializer)) => {
                    self.store_keyword(deserializer.finish(reader)?)?
                }
                S::Remarks(Some(deserializer)) => {
                    self.store_remarks(deserializer.finish(reader)?)?
                }
                S::ProductStatus(Some(deserializer)) => {
                    self.store_product_status(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_description_short(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.description_short.push(value);
            Ok(())
        }
        fn store_description_long(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.description_long.push(value);
            Ok(())
        }
        fn store_international_pid(
            &mut self,
            value: super::InternationalPidElementType,
        ) -> Result<(), Error> {
            self.international_pid.push(value);
            Ok(())
        }
        fn store_supplier_alt_pid(&mut self, value: String) -> Result<(), Error> {
            if self.supplier_alt_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_ALT_PID",
                )))?;
            }
            self.supplier_alt_pid = Some(value);
            Ok(())
        }
        fn store_buyer_pid(&mut self, value: super::BuyerPidElementType) -> Result<(), Error> {
            self.buyer_pid.push(value);
            Ok(())
        }
        fn store_manufacturer_pid(&mut self, value: String) -> Result<(), Error> {
            if self.manufacturer_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MANUFACTURER_PID",
                )))?;
            }
            self.manufacturer_pid = Some(value);
            Ok(())
        }
        fn store_manufacturer_name(&mut self, value: String) -> Result<(), Error> {
            if self.manufacturer_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MANUFACTURER_NAME",
                )))?;
            }
            self.manufacturer_name = Some(value);
            Ok(())
        }
        fn store_manufacturer_type_descr(
            &mut self,
            value: super::DtMlstringType,
        ) -> Result<(), Error> {
            self.manufacturer_type_descr.push(value);
            Ok(())
        }
        fn store_special_treatment_class(
            &mut self,
            value: super::SpecialTreatmentClassElementType,
        ) -> Result<(), Error> {
            self.special_treatment_class.push(value);
            Ok(())
        }
        fn store_keyword(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.keyword.push(value);
            Ok(())
        }
        fn store_remarks(&mut self, value: super::RemarksElementType) -> Result<(), Error> {
            self.remarks.push(value);
            Ok(())
        }
        fn store_product_status(
            &mut self,
            value: super::ProductStatusElementType,
        ) -> Result<(), Error> {
            self.product_status.push(value);
            Ok(())
        }
        fn handle_description_short<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.description_short.len() < 1usize {
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::DescriptionShort(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ProductDetailsElementTypeDeserializerState::DescriptionShort(None),
                    );
                    *self.state = ProductDetailsElementTypeDeserializerState::DescriptionLong(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description_short(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::DescriptionShort(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::DescriptionShort(Some(
                                    deserializer,
                                )),
                            );
                            if self.description_short.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ProductDetailsElementTypeDeserializerState::DescriptionShort(
                                        None,
                                    );
                            } else {
                                *self.state =
                                    ProductDetailsElementTypeDeserializerState::DescriptionLong(
                                        None,
                                    );
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::DescriptionShort(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_description_long<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::DescriptionLong(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::InternationalPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description_long(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::DescriptionLong(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::DescriptionLong(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::DescriptionLong(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::DescriptionLong(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_international_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::InternationalPidElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::InternationalPid(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::SupplierAltPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_international_pid(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::InternationalPid(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::InternationalPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::InternationalPid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::InternationalPid(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_supplier_alt_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::SupplierAltPid(
                    None,
                ));
                *self.state = ProductDetailsElementTypeDeserializerState::BuyerPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_alt_pid(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::BuyerPid(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::SupplierAltPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::BuyerPid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::SupplierAltPid(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::BuyerPidElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::BuyerPid(None));
                *self.state = ProductDetailsElementTypeDeserializerState::ManufacturerPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_pid(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::BuyerPid(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::BuyerPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::BuyerPid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::BuyerPid(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_manufacturer_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::ManufacturerPid(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::ManufacturerName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_manufacturer_pid(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::ManufacturerName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ManufacturerPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerPid(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_manufacturer_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::ManufacturerName(None),
                );
                *self.state =
                    ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_manufacturer_name(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ManufacturerName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerName(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_manufacturer_type_descr<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(None),
                );
                *self.state =
                    ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_manufacturer_type_descr(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_special_treatment_class<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SpecialTreatmentClassElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::Keyword(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_special_treatment_class(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_keyword<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::Keyword(None));
                *self.state = ProductDetailsElementTypeDeserializerState::Remarks(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_keyword(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::Keyword(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::Keyword(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductDetailsElementTypeDeserializerState::Keyword(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::Keyword(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_remarks<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::RemarksElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::Remarks(None));
                *self.state = ProductDetailsElementTypeDeserializerState::ProductStatus(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_remarks(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::Remarks(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::Remarks(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductDetailsElementTypeDeserializerState::Remarks(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::Remarks(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_status<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductStatusElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::ProductStatus(
                    None,
                ));
                *self.state = ProductDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_status(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::ProductStatus(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ProductStatus(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ProductStatus(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::ProductStatus(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductDetailsElementType>
        for ProductDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductDetailsElementType>
        where
            R: DeserializeReader,
        {
            use ProductDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DescriptionShort(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description_short(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DescriptionLong(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description_long(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InternationalPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_international_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SupplierAltPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_alt_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ManufacturerPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_manufacturer_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ManufacturerName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_manufacturer_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ManufacturerTypeDescr(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_manufacturer_type_descr(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecialTreatmentClass(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_special_treatment_class(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Keyword(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_keyword(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Remarks(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_remarks(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductStatus(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_status(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductDetailsElementTypeDeserializerState::DescriptionShort(None);
                        event
                    }
                    (S::DescriptionShort(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DESCRIPTION_SHORT",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_description_short(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DescriptionLong(None);
                            event
                        }
                    }
                    (S::DescriptionLong(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DESCRIPTION_LONG",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_description_long(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InternationalPid(None);
                            event
                        }
                    }
                    (S::InternationalPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"INTERNATIONAL_PID",
                        ) {
                            let output = < super :: InternationalPidElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_international_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SupplierAltPid(None);
                            event
                        }
                    }
                    (S::SupplierAltPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_ALT_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_supplier_alt_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerPid(None);
                            event
                        }
                    }
                    (S::BuyerPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"BUYER_PID",
                        ) {
                            let output = < super :: BuyerPidElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_buyer_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ManufacturerPid(None);
                            event
                        }
                    }
                    (S::ManufacturerPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MANUFACTURER_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_manufacturer_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ManufacturerName(None);
                            event
                        }
                    }
                    (S::ManufacturerName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MANUFACTURER_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_manufacturer_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ManufacturerTypeDescr(None);
                            event
                        }
                    }
                    (
                        S::ManufacturerTypeDescr(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MANUFACTURER_TYPE_DESCR",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_manufacturer_type_descr(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecialTreatmentClass(None);
                            event
                        }
                    }
                    (
                        S::SpecialTreatmentClass(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SPECIAL_TREATMENT_CLASS",
                        ) {
                            let output = < super :: SpecialTreatmentClassElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_special_treatment_class(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Keyword(None);
                            event
                        }
                    }
                    (S::Keyword(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"KEYWORD")
                        {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_keyword(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Remarks(None);
                            event
                        }
                    }
                    (S::Remarks(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"REMARKS")
                        {
                            let output = < super :: RemarksElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_remarks(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductStatus(None);
                            event
                        }
                    }
                    (S::ProductStatus(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_STATUS",
                        ) {
                            let output = < super :: ProductStatusElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_status(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductDetailsElementType {
                description_short: self.description_short,
                description_long: self.description_long,
                international_pid: self.international_pid,
                supplier_alt_pid: self.supplier_alt_pid,
                buyer_pid: self.buyer_pid,
                manufacturer_pid: self.manufacturer_pid,
                manufacturer_name: self.manufacturer_name,
                manufacturer_type_descr: self.manufacturer_type_descr,
                special_treatment_class: self.special_treatment_class,
                keyword: self.keyword,
                remarks: self.remarks,
                product_status: self.product_status,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductFeaturesElementTypeDeserializer {
        reference_feature_system_name: Option<String>,
        reference_feature_group_id: Option<super::TypeClassificationGroupIdType>,
        feature: Vec<super::FeatureElementType>,
        state: Box<ProductFeaturesElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductFeaturesElementTypeDeserializerState {
        Init__,
        ReferenceFeatureSystemName(Option<<String as WithDeserializer>::Deserializer>),
        ReferenceFeatureGroupId(
            Option<<super::TypeClassificationGroupIdType as WithDeserializer>::Deserializer>,
        ),
        Feature(Option<<super::FeatureElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductFeaturesElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                reference_feature_system_name: None,
                reference_feature_group_id: None,
                feature: Vec::new(),
                state: Box::new(ProductFeaturesElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductFeaturesElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductFeaturesElementTypeDeserializerState as S;
            match state {
                S::ReferenceFeatureSystemName(Some(deserializer)) => {
                    self.store_reference_feature_system_name(deserializer.finish(reader)?)?
                }
                S::ReferenceFeatureGroupId(Some(deserializer)) => {
                    self.store_reference_feature_group_id(deserializer.finish(reader)?)?
                }
                S::Feature(Some(deserializer)) => {
                    self.store_feature(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_reference_feature_system_name(&mut self, value: String) -> Result<(), Error> {
            if self.reference_feature_system_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"REFERENCE_FEATURE_SYSTEM_NAME",
                )))?;
            }
            self.reference_feature_system_name = Some(value);
            Ok(())
        }
        fn store_reference_feature_group_id(
            &mut self,
            value: super::TypeClassificationGroupIdType,
        ) -> Result<(), Error> {
            if self.reference_feature_group_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"REFERENCE_FEATURE_GROUP_ID",
                )))?;
            }
            self.reference_feature_group_id = Some(value);
            Ok(())
        }
        fn store_feature(&mut self, value: super::FeatureElementType) -> Result<(), Error> {
            self.feature.push(value);
            Ok(())
        }
        fn handle_reference_feature_system_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductFeaturesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.reference_feature_system_name.is_some() {
                    fallback.get_or_insert(
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureSystemName(
                            None,
                        ),
                    );
                    *self.state =
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureGroupId(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureSystemName(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reference_feature_system_name(data)?;
                    *self.state =
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureGroupId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureSystemName (Some (deserializer))) ;
                            * self . state = ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureGroupId (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureSystemName (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_reference_feature_group_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TypeClassificationGroupIdType>,
            fallback: &mut Option<ProductFeaturesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.reference_feature_group_id.is_some() {
                    fallback.get_or_insert(
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureGroupId(None),
                    );
                    *self.state = ProductFeaturesElementTypeDeserializerState::Feature(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureGroupId(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reference_feature_group_id(data)?;
                    *self.state = ProductFeaturesElementTypeDeserializerState::Feature(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureGroupId (Some (deserializer))) ;
                            *self.state =
                                ProductFeaturesElementTypeDeserializerState::Feature(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureGroupId (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_feature<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::FeatureElementType>,
            fallback: &mut Option<ProductFeaturesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.feature.len() < 1usize {
                    *self.state = ProductFeaturesElementTypeDeserializerState::Feature(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(ProductFeaturesElementTypeDeserializerState::Feature(None));
                    *self.state = ProductFeaturesElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_feature(data)?;
                    *self.state = ProductFeaturesElementTypeDeserializerState::Feature(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductFeaturesElementTypeDeserializerState::Feature(Some(
                                    deserializer,
                                )),
                            );
                            if self.feature.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ProductFeaturesElementTypeDeserializerState::Feature(None);
                            } else {
                                *self.state = ProductFeaturesElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductFeaturesElementTypeDeserializerState::Feature(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductFeaturesElementType>
        for ProductFeaturesElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductFeaturesElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductFeaturesElementType>
        where
            R: DeserializeReader,
        {
            use ProductFeaturesElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ReferenceFeatureSystemName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reference_feature_system_name(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReferenceFeatureGroupId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reference_feature_group_id(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Feature(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_feature(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductFeaturesElementTypeDeserializerState::ReferenceFeatureSystemName(
                                None,
                            );
                        event
                    }
                    (
                        S::ReferenceFeatureSystemName(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"REFERENCE_FEATURE_SYSTEM_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_reference_feature_system_name(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReferenceFeatureGroupId(None);
                            event
                        }
                    }
                    (
                        S::ReferenceFeatureGroupId(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"REFERENCE_FEATURE_GROUP_ID",
                        ) {
                            let output = < super :: TypeClassificationGroupIdType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_reference_feature_group_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Feature(None);
                            event
                        }
                    }
                    (S::Feature(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"FEATURE")
                        {
                            let output = < super :: FeatureElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_feature(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductFeaturesElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductFeaturesElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductFeaturesElementType {
                reference_feature_system_name: self.reference_feature_system_name.ok_or_else(
                    || ErrorKind::MissingElement("REFERENCE_FEATURE_SYSTEM_NAME".into()),
                )?,
                reference_feature_group_id: self.reference_feature_group_id.ok_or_else(|| {
                    ErrorKind::MissingElement("REFERENCE_FEATURE_GROUP_ID".into())
                })?,
                feature: self.feature,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductOrderDetailsElementTypeDeserializer {
        order_unit: Option<super::DtPunitType>,
        content_unit: Option<super::DtPunitType>,
        no_cu_per_ou: Option<f64>,
        price_quantity: Option<f64>,
        quantity_min: Option<f32>,
        quantity_interval: Option<f32>,
        state: Box<ProductOrderDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductOrderDetailsElementTypeDeserializerState {
        Init__,
        OrderUnit(Option<<super::DtPunitType as WithDeserializer>::Deserializer>),
        ContentUnit(Option<<super::DtPunitType as WithDeserializer>::Deserializer>),
        NoCuPerOu(Option<<f64 as WithDeserializer>::Deserializer>),
        PriceQuantity(Option<<f64 as WithDeserializer>::Deserializer>),
        QuantityMin(Option<<f32 as WithDeserializer>::Deserializer>),
        QuantityInterval(Option<<f32 as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductOrderDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                order_unit: None,
                content_unit: None,
                no_cu_per_ou: None,
                price_quantity: None,
                quantity_min: None,
                quantity_interval: None,
                state: Box::new(ProductOrderDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductOrderDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductOrderDetailsElementTypeDeserializerState as S;
            match state {
                S::OrderUnit(Some(deserializer)) => {
                    self.store_order_unit(deserializer.finish(reader)?)?
                }
                S::ContentUnit(Some(deserializer)) => {
                    self.store_content_unit(deserializer.finish(reader)?)?
                }
                S::NoCuPerOu(Some(deserializer)) => {
                    self.store_no_cu_per_ou(deserializer.finish(reader)?)?
                }
                S::PriceQuantity(Some(deserializer)) => {
                    self.store_price_quantity(deserializer.finish(reader)?)?
                }
                S::QuantityMin(Some(deserializer)) => {
                    self.store_quantity_min(deserializer.finish(reader)?)?
                }
                S::QuantityInterval(Some(deserializer)) => {
                    self.store_quantity_interval(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_order_unit(&mut self, value: super::DtPunitType) -> Result<(), Error> {
            if self.order_unit.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ORDER_UNIT",
                )))?;
            }
            self.order_unit = Some(value);
            Ok(())
        }
        fn store_content_unit(&mut self, value: super::DtPunitType) -> Result<(), Error> {
            if self.content_unit.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CONTENT_UNIT",
                )))?;
            }
            self.content_unit = Some(value);
            Ok(())
        }
        fn store_no_cu_per_ou(&mut self, value: f64) -> Result<(), Error> {
            if self.no_cu_per_ou.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"NO_CU_PER_OU",
                )))?;
            }
            self.no_cu_per_ou = Some(value);
            Ok(())
        }
        fn store_price_quantity(&mut self, value: f64) -> Result<(), Error> {
            if self.price_quantity.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_QUANTITY",
                )))?;
            }
            self.price_quantity = Some(value);
            Ok(())
        }
        fn store_quantity_min(&mut self, value: f32) -> Result<(), Error> {
            if self.quantity_min.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"QUANTITY_MIN",
                )))?;
            }
            self.quantity_min = Some(value);
            Ok(())
        }
        fn store_quantity_interval(&mut self, value: f32) -> Result<(), Error> {
            if self.quantity_interval.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"QUANTITY_INTERVAL",
                )))?;
            }
            self.quantity_interval = Some(value);
            Ok(())
        }
        fn handle_order_unit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtPunitType>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.order_unit.is_some() {
                    fallback.get_or_insert(
                        ProductOrderDetailsElementTypeDeserializerState::OrderUnit(None),
                    );
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProductOrderDetailsElementTypeDeserializerState::OrderUnit(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_order_unit(data)?;
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::OrderUnit(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::OrderUnit(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_content_unit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtPunitType>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.content_unit.is_some() {
                    fallback.get_or_insert(
                        ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None),
                    );
                    *self.state = ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content_unit(data)?;
                    *self.state = ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::ContentUnit(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::ContentUnit(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_no_cu_per_ou<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(
                    None,
                ));
                *self.state = ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_no_cu_per_ou(data)?;
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_price_quantity<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(None),
                );
                *self.state = ProductOrderDetailsElementTypeDeserializerState::QuantityMin(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_quantity(data)?;
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::QuantityMin(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::QuantityMin(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_quantity_min<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductOrderDetailsElementTypeDeserializerState::QuantityMin(None),
                );
                *self.state =
                    ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_quantity_min(data)?;
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::QuantityMin(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::QuantityMin(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_quantity_interval<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(None),
                );
                *self.state = ProductOrderDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_quantity_interval(data)?;
                    *self.state = ProductOrderDetailsElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = ProductOrderDetailsElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductOrderDetailsElementType>
        for ProductOrderDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductOrderDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductOrderDetailsElementType>
        where
            R: DeserializeReader,
        {
            use ProductOrderDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::OrderUnit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_order_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ContentUnit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::NoCuPerOu(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_no_cu_per_ou(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PriceQuantity(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_quantity(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::QuantityMin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_quantity_min(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::QuantityInterval(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_quantity_interval(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductOrderDetailsElementTypeDeserializerState::OrderUnit(None);
                        event
                    }
                    (S::OrderUnit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"ORDER_UNIT",
                        ) {
                            let output =
                                <super::DtPunitType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_order_unit(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ContentUnit(None);
                            event
                        }
                    }
                    (S::ContentUnit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CONTENT_UNIT",
                        ) {
                            let output =
                                <super::DtPunitType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_content_unit(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::NoCuPerOu(None);
                            event
                        }
                    }
                    (S::NoCuPerOu(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"NO_CU_PER_OU",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_no_cu_per_ou(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PriceQuantity(None);
                            event
                        }
                    }
                    (S::PriceQuantity(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_QUANTITY",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_price_quantity(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::QuantityMin(None);
                            event
                        }
                    }
                    (S::QuantityMin(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"QUANTITY_MIN",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_quantity_min(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::QuantityInterval(None);
                            event
                        }
                    }
                    (S::QuantityInterval(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"QUANTITY_INTERVAL",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_quantity_interval(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductOrderDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductOrderDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductOrderDetailsElementType {
                order_unit: self
                    .order_unit
                    .ok_or_else(|| ErrorKind::MissingElement("ORDER_UNIT".into()))?,
                content_unit: self
                    .content_unit
                    .ok_or_else(|| ErrorKind::MissingElement("CONTENT_UNIT".into()))?,
                no_cu_per_ou: self.no_cu_per_ou,
                price_quantity: self.price_quantity,
                quantity_min: self.quantity_min,
                quantity_interval: self.quantity_interval,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceDetailsElementTypeDeserializer {
        datetime: Vec<super::ProductPriceDetailsDatetimeElementType>,
        daily_price: Option<String>,
        product_price: Vec<super::ProductPriceElementType>,
        state: Box<ProductPriceDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductPriceDetailsElementTypeDeserializerState {
        Init__,
        Datetime(
            Option<
                <super::ProductPriceDetailsDatetimeElementType as WithDeserializer>::Deserializer,
            >,
        ),
        DailyPrice(Option<<String as WithDeserializer>::Deserializer>),
        ProductPrice(Option<<super::ProductPriceElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductPriceDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                datetime: Vec::new(),
                daily_price: None,
                product_price: Vec::new(),
                state: Box::new(ProductPriceDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductPriceDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductPriceDetailsElementTypeDeserializerState as S;
            match state {
                S::Datetime(Some(deserializer)) => {
                    self.store_datetime(deserializer.finish(reader)?)?
                }
                S::DailyPrice(Some(deserializer)) => {
                    self.store_daily_price(deserializer.finish(reader)?)?
                }
                S::ProductPrice(Some(deserializer)) => {
                    self.store_product_price(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_datetime(
            &mut self,
            value: super::ProductPriceDetailsDatetimeElementType,
        ) -> Result<(), Error> {
            self.datetime.push(value);
            Ok(())
        }
        fn store_daily_price(&mut self, value: String) -> Result<(), Error> {
            if self.daily_price.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DAILY_PRICE",
                )))?;
            }
            self.daily_price = Some(value);
            Ok(())
        }
        fn store_product_price(
            &mut self,
            value: super::ProductPriceElementType,
        ) -> Result<(), Error> {
            self.product_price.push(value);
            Ok(())
        }
        fn handle_datetime<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceDetailsDatetimeElementType>,
            fallback: &mut Option<ProductPriceDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.datetime.len() < 1usize {
                    *self.state = ProductPriceDetailsElementTypeDeserializerState::Datetime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ProductPriceDetailsElementTypeDeserializerState::Datetime(None),
                    );
                    *self.state = ProductPriceDetailsElementTypeDeserializerState::DailyPrice(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_datetime(data)?;
                    if self.datetime.len() < 2usize {
                        *self.state =
                            ProductPriceDetailsElementTypeDeserializerState::Datetime(None);
                    } else {
                        *self.state =
                            ProductPriceDetailsElementTypeDeserializerState::DailyPrice(None);
                    }
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsElementTypeDeserializerState::Datetime(Some(
                                    deserializer,
                                )),
                            );
                            if self.datetime.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ProductPriceDetailsElementTypeDeserializerState::Datetime(None);
                            } else {
                                *self.state =
                                    ProductPriceDetailsElementTypeDeserializerState::DailyPrice(
                                        None,
                                    );
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceDetailsElementTypeDeserializerState::Datetime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_daily_price<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductPriceDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductPriceDetailsElementTypeDeserializerState::DailyPrice(None),
                );
                *self.state = ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_daily_price(data)?;
                    *self.state =
                        ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsElementTypeDeserializerState::DailyPrice(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsElementTypeDeserializerState::DailyPrice(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_price<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceElementType>,
            fallback: &mut Option<ProductPriceDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_price.len() < 1usize {
                    *self.state =
                        ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None),
                    );
                    *self.state = ProductPriceDetailsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_price(data)?;
                    *self.state =
                        ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsElementTypeDeserializerState::ProductPrice(
                                    Some(deserializer),
                                ),
                            );
                            if self.product_price.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ProductPriceDetailsElementTypeDeserializerState::ProductPrice(
                                        None,
                                    );
                            } else {
                                *self.state =
                                    ProductPriceDetailsElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsElementTypeDeserializerState::ProductPrice(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductPriceDetailsElementType>
        for ProductPriceDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceDetailsElementType>
        where
            R: DeserializeReader,
        {
            use ProductPriceDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Datetime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_datetime(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DailyPrice(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_daily_price(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductPrice(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_price(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductPriceDetailsElementTypeDeserializerState::Datetime(None);
                        event
                    }
                    (S::Datetime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DATETIME",
                        ) {
                            let output = < super :: ProductPriceDetailsDatetimeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_datetime(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DailyPrice(None);
                            event
                        }
                    }
                    (S::DailyPrice(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DAILY_PRICE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_daily_price(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductPrice(None);
                            event
                        }
                    }
                    (S::ProductPrice(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_PRICE",
                        ) {
                            let output = < super :: ProductPriceElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_price(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductPriceDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductPriceDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductPriceDetailsElementType {
                datetime: self.datetime,
                daily_price: self.daily_price,
                product_price: self.product_price,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxProductTypeDeserializer {
        udx_edxf_manufacturer_acronym: Option<String>,
        udx_edxf_description_very_short: Vec<super::DtMlstringType>,
        udx_edxf_brand_name: Option<String>,
        udx_edxf_tender_text: Vec<super::DtMlstringType>,
        udx_edxf_valid_from: Option<String>,
        udx_edxf_expiration_date: Option<String>,
        udx_edxf_discount_group: Option<super::UdxEdxfDiscountGroupElementType>,
        udx_edxf_bonus_group_supplier: Option<String>,
        udx_edxf_pkwiu: Option<String>,
        udx_edxf_declaration: Vec<super::UdxEdxfDeclarationElementType>,
        udx_edxf_additional_factors: Option<super::UdxEdxfAdditionalFactorsElementType>,
        udx_edxf_product_to_stock: Option<String>,
        udx_edxf_product_series: Vec<super::DtMlstringType>,
        udx_edxf_product_variation: Vec<super::DtMlstringType>,
        udx_edxf_at_reverse_charge_info: Option<String>,
        udx_edxf_country_branch_numbers: Option<super::UdxEdxfCountryBranchNumbersElementType>,
        udx_edxf_country_branch_supplier_ids:
            Option<super::UdxEdxfCountryBranchSupplierIdsElementType>,
        udx_edxf_packing_units: Option<super::UdxEdxfPackingUnitsElementType>,
        udx_edxf_product_logistic_details: Option<super::UdxEdxfProductLogisticDetailsElementType>,
        udx_edxf_reach: Option<super::UdxEdxfReachElementType>,
        udx_edxf_surcharge_list: Option<super::UdxEdxfSurchargeListElementType>,
        state: Box<UdxProductTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxProductTypeDeserializerState {
        Init__ , UdxEdxfManufacturerAcronym (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfDescriptionVeryShort (Option << super :: DtMlstringType as WithDeserializer > :: Deserializer >) , UdxEdxfBrandName (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfTenderText (Option << super :: DtMlstringType as WithDeserializer > :: Deserializer >) , UdxEdxfValidFrom (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfExpirationDate (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfDiscountGroup (Option << super :: UdxEdxfDiscountGroupElementType as WithDeserializer > :: Deserializer >) , UdxEdxfBonusGroupSupplier (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfPkwiu (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfDeclaration (Option << super :: UdxEdxfDeclarationElementType as WithDeserializer > :: Deserializer >) , UdxEdxfAdditionalFactors (Option << super :: UdxEdxfAdditionalFactorsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductToStock (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfProductSeries (Option << super :: DtMlstringType as WithDeserializer > :: Deserializer >) , UdxEdxfProductVariation (Option << super :: DtMlstringType as WithDeserializer > :: Deserializer >) , UdxEdxfAtReverseChargeInfo (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfCountryBranchNumbers (Option << super :: UdxEdxfCountryBranchNumbersElementType as WithDeserializer > :: Deserializer >) , UdxEdxfCountryBranchSupplierIds (Option << super :: UdxEdxfCountryBranchSupplierIdsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfPackingUnits (Option << super :: UdxEdxfPackingUnitsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductLogisticDetails (Option << super :: UdxEdxfProductLogisticDetailsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfReach (Option << super :: UdxEdxfReachElementType as WithDeserializer > :: Deserializer >) , UdxEdxfSurchargeList (Option << super :: UdxEdxfSurchargeListElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl UdxProductTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_manufacturer_acronym: None,
                udx_edxf_description_very_short: Vec::new(),
                udx_edxf_brand_name: None,
                udx_edxf_tender_text: Vec::new(),
                udx_edxf_valid_from: None,
                udx_edxf_expiration_date: None,
                udx_edxf_discount_group: None,
                udx_edxf_bonus_group_supplier: None,
                udx_edxf_pkwiu: None,
                udx_edxf_declaration: Vec::new(),
                udx_edxf_additional_factors: None,
                udx_edxf_product_to_stock: None,
                udx_edxf_product_series: Vec::new(),
                udx_edxf_product_variation: Vec::new(),
                udx_edxf_at_reverse_charge_info: None,
                udx_edxf_country_branch_numbers: None,
                udx_edxf_country_branch_supplier_ids: None,
                udx_edxf_packing_units: None,
                udx_edxf_product_logistic_details: None,
                udx_edxf_reach: None,
                udx_edxf_surcharge_list: None,
                state: Box::new(UdxProductTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxProductTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxProductTypeDeserializerState as S;
            match state {
                S::UdxEdxfManufacturerAcronym(Some(deserializer)) => {
                    self.store_udx_edxf_manufacturer_acronym(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDescriptionVeryShort(Some(deserializer)) => {
                    self.store_udx_edxf_description_very_short(deserializer.finish(reader)?)?
                }
                S::UdxEdxfBrandName(Some(deserializer)) => {
                    self.store_udx_edxf_brand_name(deserializer.finish(reader)?)?
                }
                S::UdxEdxfTenderText(Some(deserializer)) => {
                    self.store_udx_edxf_tender_text(deserializer.finish(reader)?)?
                }
                S::UdxEdxfValidFrom(Some(deserializer)) => {
                    self.store_udx_edxf_valid_from(deserializer.finish(reader)?)?
                }
                S::UdxEdxfExpirationDate(Some(deserializer)) => {
                    self.store_udx_edxf_expiration_date(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDiscountGroup(Some(deserializer)) => {
                    self.store_udx_edxf_discount_group(deserializer.finish(reader)?)?
                }
                S::UdxEdxfBonusGroupSupplier(Some(deserializer)) => {
                    self.store_udx_edxf_bonus_group_supplier(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPkwiu(Some(deserializer)) => {
                    self.store_udx_edxf_pkwiu(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDeclaration(Some(deserializer)) => {
                    self.store_udx_edxf_declaration(deserializer.finish(reader)?)?
                }
                S::UdxEdxfAdditionalFactors(Some(deserializer)) => {
                    self.store_udx_edxf_additional_factors(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductToStock(Some(deserializer)) => {
                    self.store_udx_edxf_product_to_stock(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductSeries(Some(deserializer)) => {
                    self.store_udx_edxf_product_series(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductVariation(Some(deserializer)) => {
                    self.store_udx_edxf_product_variation(deserializer.finish(reader)?)?
                }
                S::UdxEdxfAtReverseChargeInfo(Some(deserializer)) => {
                    self.store_udx_edxf_at_reverse_charge_info(deserializer.finish(reader)?)?
                }
                S::UdxEdxfCountryBranchNumbers(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_numbers(deserializer.finish(reader)?)?
                }
                S::UdxEdxfCountryBranchSupplierIds(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_supplier_ids(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackingUnits(Some(deserializer)) => {
                    self.store_udx_edxf_packing_units(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductLogisticDetails(Some(deserializer)) => {
                    self.store_udx_edxf_product_logistic_details(deserializer.finish(reader)?)?
                }
                S::UdxEdxfReach(Some(deserializer)) => {
                    self.store_udx_edxf_reach(deserializer.finish(reader)?)?
                }
                S::UdxEdxfSurchargeList(Some(deserializer)) => {
                    self.store_udx_edxf_surcharge_list(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_manufacturer_acronym(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_manufacturer_acronym.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MANUFACTURER_ACRONYM",
                )))?;
            }
            self.udx_edxf_manufacturer_acronym = Some(value);
            Ok(())
        }
        fn store_udx_edxf_description_very_short(
            &mut self,
            value: super::DtMlstringType,
        ) -> Result<(), Error> {
            self.udx_edxf_description_very_short.push(value);
            Ok(())
        }
        fn store_udx_edxf_brand_name(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_brand_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.BRAND_NAME",
                )))?;
            }
            self.udx_edxf_brand_name = Some(value);
            Ok(())
        }
        fn store_udx_edxf_tender_text(
            &mut self,
            value: super::DtMlstringType,
        ) -> Result<(), Error> {
            self.udx_edxf_tender_text.push(value);
            Ok(())
        }
        fn store_udx_edxf_valid_from(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_valid_from.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.VALID_FROM",
                )))?;
            }
            self.udx_edxf_valid_from = Some(value);
            Ok(())
        }
        fn store_udx_edxf_expiration_date(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_expiration_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.EXPIRATION_DATE",
                )))?;
            }
            self.udx_edxf_expiration_date = Some(value);
            Ok(())
        }
        fn store_udx_edxf_discount_group(
            &mut self,
            value: super::UdxEdxfDiscountGroupElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_discount_group.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DISCOUNT_GROUP",
                )))?;
            }
            self.udx_edxf_discount_group = Some(value);
            Ok(())
        }
        fn store_udx_edxf_bonus_group_supplier(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_bonus_group_supplier.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.BONUS_GROUP_SUPPLIER",
                )))?;
            }
            self.udx_edxf_bonus_group_supplier = Some(value);
            Ok(())
        }
        fn store_udx_edxf_pkwiu(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_pkwiu.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PKWIU",
                )))?;
            }
            self.udx_edxf_pkwiu = Some(value);
            Ok(())
        }
        fn store_udx_edxf_declaration(
            &mut self,
            value: super::UdxEdxfDeclarationElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_declaration.push(value);
            Ok(())
        }
        fn store_udx_edxf_additional_factors(
            &mut self,
            value: super::UdxEdxfAdditionalFactorsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_additional_factors.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.ADDITIONAL_FACTORS",
                )))?;
            }
            self.udx_edxf_additional_factors = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_to_stock(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_product_to_stock.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_TO_STOCK",
                )))?;
            }
            self.udx_edxf_product_to_stock = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_series(
            &mut self,
            value: super::DtMlstringType,
        ) -> Result<(), Error> {
            self.udx_edxf_product_series.push(value);
            Ok(())
        }
        fn store_udx_edxf_product_variation(
            &mut self,
            value: super::DtMlstringType,
        ) -> Result<(), Error> {
            self.udx_edxf_product_variation.push(value);
            Ok(())
        }
        fn store_udx_edxf_at_reverse_charge_info(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_at_reverse_charge_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.AT.REVERSE_CHARGE_INFO",
                )))?;
            }
            self.udx_edxf_at_reverse_charge_info = Some(value);
            Ok(())
        }
        fn store_udx_edxf_country_branch_numbers(
            &mut self,
            value: super::UdxEdxfCountryBranchNumbersElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_country_branch_numbers.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COUNTRY_BRANCH_NUMBERS",
                )))?;
            }
            self.udx_edxf_country_branch_numbers = Some(value);
            Ok(())
        }
        fn store_udx_edxf_country_branch_supplier_ids(
            &mut self,
            value: super::UdxEdxfCountryBranchSupplierIdsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_country_branch_supplier_ids.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS",
                )))?;
            }
            self.udx_edxf_country_branch_supplier_ids = Some(value);
            Ok(())
        }
        fn store_udx_edxf_packing_units(
            &mut self,
            value: super::UdxEdxfPackingUnitsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_packing_units.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PACKING_UNITS",
                )))?;
            }
            self.udx_edxf_packing_units = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_logistic_details(
            &mut self,
            value: super::UdxEdxfProductLogisticDetailsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_product_logistic_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_LOGISTIC_DETAILS",
                )))?;
            }
            self.udx_edxf_product_logistic_details = Some(value);
            Ok(())
        }
        fn store_udx_edxf_reach(
            &mut self,
            value: super::UdxEdxfReachElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_reach.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REACH",
                )))?;
            }
            self.udx_edxf_reach = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_list(
            &mut self,
            value: super::UdxEdxfSurchargeListElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_surcharge_list.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_LIST",
                )))?;
            }
            self.udx_edxf_surcharge_list = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_manufacturer_acronym<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductTypeDeserializerState::UdxEdxfManufacturerAcronym(None),
                );
                *self.state = UdxProductTypeDeserializerState::UdxEdxfDescriptionVeryShort(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_manufacturer_acronym(data)?;
                    *self.state =
                        UdxProductTypeDeserializerState::UdxEdxfDescriptionVeryShort(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfManufacturerAcronym(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfDescriptionVeryShort(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfManufacturerAcronym(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_description_very_short<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductTypeDeserializerState::UdxEdxfDescriptionVeryShort(None),
                );
                *self.state = UdxProductTypeDeserializerState::UdxEdxfBrandName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_description_very_short(data)?;
                    *self.state =
                        UdxProductTypeDeserializerState::UdxEdxfDescriptionVeryShort(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfDescriptionVeryShort(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfDescriptionVeryShort(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfDescriptionVeryShort(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_brand_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfBrandName(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfTenderText(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_brand_name(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfTenderText(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfBrandName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfTenderText(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfBrandName(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_tender_text<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfTenderText(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfValidFrom(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_tender_text(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfTenderText(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfTenderText(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfTenderText(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfTenderText(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_valid_from<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfValidFrom(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfExpirationDate(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_valid_from(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfExpirationDate(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfValidFrom(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfExpirationDate(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfValidFrom(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_expiration_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(UdxProductTypeDeserializerState::UdxEdxfExpirationDate(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfDiscountGroup(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_expiration_date(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfDiscountGroup(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfExpirationDate(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfDiscountGroup(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfExpirationDate(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_discount_group<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfDiscountGroupElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfDiscountGroup(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfBonusGroupSupplier(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_discount_group(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfBonusGroupSupplier(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfDiscountGroup(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfBonusGroupSupplier(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfDiscountGroup(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_bonus_group_supplier<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfBonusGroupSupplier(
                    None,
                ));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfPkwiu(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_bonus_group_supplier(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfPkwiu(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfBonusGroupSupplier(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfPkwiu(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfBonusGroupSupplier(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_pkwiu<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfPkwiu(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfDeclaration(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_pkwiu(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfDeclaration(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfPkwiu(
                                Some(deserializer),
                            ));
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfDeclaration(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfPkwiu(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_declaration<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfDeclarationElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfDeclaration(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfAdditionalFactors(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_declaration(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfDeclaration(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfDeclaration(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfDeclaration(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfDeclaration(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_additional_factors<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfAdditionalFactorsElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfAdditionalFactors(
                    None,
                ));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfProductToStock(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_additional_factors(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfProductToStock(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfAdditionalFactors(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfProductToStock(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfAdditionalFactors(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_to_stock<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(UdxProductTypeDeserializerState::UdxEdxfProductToStock(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfProductSeries(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_to_stock(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfProductSeries(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfProductToStock(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfProductSeries(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfProductToStock(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_series<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfProductSeries(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfProductVariation(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_series(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfProductSeries(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfProductSeries(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfProductSeries(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfProductSeries(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_variation<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfProductVariation(
                    None,
                ));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfAtReverseChargeInfo(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_variation(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfProductVariation(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfProductVariation(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfProductVariation(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfProductVariation(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_at_reverse_charge_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductTypeDeserializerState::UdxEdxfAtReverseChargeInfo(None),
                );
                *self.state = UdxProductTypeDeserializerState::UdxEdxfCountryBranchNumbers(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_at_reverse_charge_info(data)?;
                    *self.state =
                        UdxProductTypeDeserializerState::UdxEdxfCountryBranchNumbers(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfAtReverseChargeInfo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfCountryBranchNumbers(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfAtReverseChargeInfo(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_country_branch_numbers<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfCountryBranchNumbersElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductTypeDeserializerState::UdxEdxfCountryBranchNumbers(None),
                );
                *self.state =
                    UdxProductTypeDeserializerState::UdxEdxfCountryBranchSupplierIds(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_numbers(data)?;
                    *self.state =
                        UdxProductTypeDeserializerState::UdxEdxfCountryBranchSupplierIds(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfCountryBranchNumbers(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfCountryBranchSupplierIds(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfCountryBranchNumbers(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_country_branch_supplier_ids<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductTypeDeserializerState::UdxEdxfCountryBranchSupplierIds(None),
                );
                *self.state = UdxProductTypeDeserializerState::UdxEdxfPackingUnits(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_supplier_ids(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfPackingUnits(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfCountryBranchSupplierIds(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfPackingUnits(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfCountryBranchSupplierIds(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_packing_units<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfPackingUnitsElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfPackingUnits(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfProductLogisticDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_units(data)?;
                    *self.state =
                        UdxProductTypeDeserializerState::UdxEdxfProductLogisticDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfPackingUnits(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfProductLogisticDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfPackingUnits(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_logistic_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductLogisticDetailsElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductTypeDeserializerState::UdxEdxfProductLogisticDetails(None),
                );
                *self.state = UdxProductTypeDeserializerState::UdxEdxfReach(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_logistic_details(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfReach(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfProductLogisticDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfReach(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfProductLogisticDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_reach<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfReachElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfReach(None));
                *self.state = UdxProductTypeDeserializerState::UdxEdxfSurchargeList(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_reach(data)?;
                    *self.state = UdxProductTypeDeserializerState::UdxEdxfSurchargeList(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfReach(
                                Some(deserializer),
                            ));
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfSurchargeList(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductTypeDeserializerState::UdxEdxfReach(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_surcharge_list<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfSurchargeListElementType>,
            fallback: &mut Option<UdxProductTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductTypeDeserializerState::UdxEdxfSurchargeList(None));
                *self.state = UdxProductTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_surcharge_list(data)?;
                    *self.state = UdxProductTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductTypeDeserializerState::UdxEdxfSurchargeList(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductTypeDeserializerState::UdxEdxfSurchargeList(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxProductType> for UdxProductTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::UdxProductType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxProductType>
        where
            R: DeserializeReader,
        {
            use UdxProductTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfManufacturerAcronym(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_manufacturer_acronym(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDescriptionVeryShort(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_description_very_short(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfBrandName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_brand_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfTenderText(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_tender_text(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfValidFrom(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_valid_from(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfExpirationDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_expiration_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDiscountGroup(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_discount_group(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfBonusGroupSupplier(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_bonus_group_supplier(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPkwiu(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_pkwiu(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDeclaration(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_declaration(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfAdditionalFactors(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_additional_factors(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductToStock(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_to_stock(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductSeries(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_series(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductVariation(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_variation(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfAtReverseChargeInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_at_reverse_charge_info(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfCountryBranchNumbers(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_numbers(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfCountryBranchSupplierIds(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_supplier_ids(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackingUnits(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_units(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductLogisticDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_logistic_details(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfReach(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_reach(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfSurchargeList(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_list(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxProductTypeDeserializerState::UdxEdxfManufacturerAcronym(None);
                        event
                    }
                    (
                        S::UdxEdxfManufacturerAcronym(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MANUFACTURER_ACRONYM",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_manufacturer_acronym(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDescriptionVeryShort(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfDescriptionVeryShort(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DESCRIPTION_VERY_SHORT",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_description_very_short(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfBrandName(None);
                            event
                        }
                    }
                    (S::UdxEdxfBrandName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.BRAND_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_brand_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfTenderText(None);
                            event
                        }
                    }
                    (S::UdxEdxfTenderText(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.TENDER_TEXT",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_tender_text(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfValidFrom(None);
                            event
                        }
                    }
                    (S::UdxEdxfValidFrom(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.VALID_FROM",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_valid_from(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfExpirationDate(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfExpirationDate(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.EXPIRATION_DATE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_expiration_date(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDiscountGroup(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfDiscountGroup(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DISCOUNT_GROUP",
                        ) {
                            let output = < super :: UdxEdxfDiscountGroupElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_discount_group(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfBonusGroupSupplier(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfBonusGroupSupplier(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.BONUS_GROUP_SUPPLIER",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_bonus_group_supplier(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPkwiu(None);
                            event
                        }
                    }
                    (S::UdxEdxfPkwiu(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PKWIU",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_pkwiu(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDeclaration(None);
                            event
                        }
                    }
                    (S::UdxEdxfDeclaration(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DECLARATION",
                        ) {
                            let output = < super :: UdxEdxfDeclarationElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_declaration(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfAdditionalFactors(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfAdditionalFactors(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.ADDITIONAL_FACTORS",
                        ) {
                            let output = < super :: UdxEdxfAdditionalFactorsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_additional_factors(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductToStock(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductToStock(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_TO_STOCK",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_product_to_stock(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductSeries(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductSeries(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_SERIES",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_product_series(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductVariation(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductVariation(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_VARIATION",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_product_variation(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfAtReverseChargeInfo(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfAtReverseChargeInfo(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.AT.REVERSE_CHARGE_INFO",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_at_reverse_charge_info(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfCountryBranchNumbers(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfCountryBranchNumbers(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_NUMBERS",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchNumbersElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_numbers(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfCountryBranchSupplierIds(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfCountryBranchSupplierIds(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchSupplierIdsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_supplier_ids(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackingUnits(None);
                            event
                        }
                    }
                    (S::UdxEdxfPackingUnits(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_UNITS",
                        ) {
                            let output = < super :: UdxEdxfPackingUnitsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_packing_units(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductLogisticDetails(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductLogisticDetails(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_LOGISTIC_DETAILS",
                        ) {
                            let output = < super :: UdxEdxfProductLogisticDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_logistic_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfReach(None);
                            event
                        }
                    }
                    (S::UdxEdxfReach(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REACH",
                        ) {
                            let output = < super :: UdxEdxfReachElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_reach(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfSurchargeList(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfSurchargeList(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SURCHARGE_LIST",
                        ) {
                            let output = < super :: UdxEdxfSurchargeListElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_surcharge_list(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxProductType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, UdxProductTypeDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::UdxProductType {
                udx_edxf_manufacturer_acronym: self.udx_edxf_manufacturer_acronym,
                udx_edxf_description_very_short: self.udx_edxf_description_very_short,
                udx_edxf_brand_name: self.udx_edxf_brand_name,
                udx_edxf_tender_text: self.udx_edxf_tender_text,
                udx_edxf_valid_from: self.udx_edxf_valid_from,
                udx_edxf_expiration_date: self.udx_edxf_expiration_date,
                udx_edxf_discount_group: self.udx_edxf_discount_group,
                udx_edxf_bonus_group_supplier: self.udx_edxf_bonus_group_supplier,
                udx_edxf_pkwiu: self.udx_edxf_pkwiu,
                udx_edxf_declaration: self.udx_edxf_declaration,
                udx_edxf_additional_factors: self.udx_edxf_additional_factors,
                udx_edxf_product_to_stock: self.udx_edxf_product_to_stock,
                udx_edxf_product_series: self.udx_edxf_product_series,
                udx_edxf_product_variation: self.udx_edxf_product_variation,
                udx_edxf_at_reverse_charge_info: self.udx_edxf_at_reverse_charge_info,
                udx_edxf_country_branch_numbers: self.udx_edxf_country_branch_numbers,
                udx_edxf_country_branch_supplier_ids: self.udx_edxf_country_branch_supplier_ids,
                udx_edxf_packing_units: self.udx_edxf_packing_units,
                udx_edxf_product_logistic_details: self.udx_edxf_product_logistic_details,
                udx_edxf_reach: self.udx_edxf_reach,
                udx_edxf_surcharge_list: self.udx_edxf_surcharge_list,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductReferenceElementTypeDeserializer {
        type_: super::ProductReferencetypeType,
        quantity: Option<i32>,
        prod_id_to: Option<String>,
        catalog_id: Option<String>,
        catalog_version: Option<String>,
        state: Box<ProductReferenceElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductReferenceElementTypeDeserializerState {
        Init__,
        ProdIdTo(Option<<String as WithDeserializer>::Deserializer>),
        CatalogId(Option<<String as WithDeserializer>::Deserializer>),
        CatalogVersion(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductReferenceElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::ProductReferencetypeType> = None;
            let mut quantity: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"quantity")
                ) {
                    reader.read_attrib(&mut quantity, b"quantity", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                quantity: quantity,
                prod_id_to: None,
                catalog_id: None,
                catalog_version: None,
                state: Box::new(ProductReferenceElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductReferenceElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductReferenceElementTypeDeserializerState as S;
            match state {
                S::ProdIdTo(Some(deserializer)) => {
                    self.store_prod_id_to(deserializer.finish(reader)?)?
                }
                S::CatalogId(Some(deserializer)) => {
                    self.store_catalog_id(deserializer.finish(reader)?)?
                }
                S::CatalogVersion(Some(deserializer)) => {
                    self.store_catalog_version(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_prod_id_to(&mut self, value: String) -> Result<(), Error> {
            if self.prod_id_to.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PROD_ID_TO",
                )))?;
            }
            self.prod_id_to = Some(value);
            Ok(())
        }
        fn store_catalog_id(&mut self, value: String) -> Result<(), Error> {
            if self.catalog_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG_ID",
                )))?;
            }
            self.catalog_id = Some(value);
            Ok(())
        }
        fn store_catalog_version(&mut self, value: String) -> Result<(), Error> {
            if self.catalog_version.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG_VERSION",
                )))?;
            }
            self.catalog_version = Some(value);
            Ok(())
        }
        fn handle_prod_id_to<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductReferenceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.prod_id_to.is_some() {
                    fallback.get_or_insert(ProductReferenceElementTypeDeserializerState::ProdIdTo(
                        None,
                    ));
                    *self.state = ProductReferenceElementTypeDeserializerState::CatalogId(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProductReferenceElementTypeDeserializerState::ProdIdTo(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_prod_id_to(data)?;
                    *self.state = ProductReferenceElementTypeDeserializerState::CatalogId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductReferenceElementTypeDeserializerState::ProdIdTo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::CatalogId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductReferenceElementTypeDeserializerState::ProdIdTo(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductReferenceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductReferenceElementTypeDeserializerState::CatalogId(
                    None,
                ));
                *self.state = ProductReferenceElementTypeDeserializerState::CatalogVersion(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_id(data)?;
                    *self.state =
                        ProductReferenceElementTypeDeserializerState::CatalogVersion(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductReferenceElementTypeDeserializerState::CatalogId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::CatalogVersion(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductReferenceElementTypeDeserializerState::CatalogId(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductReferenceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductReferenceElementTypeDeserializerState::CatalogVersion(None),
                );
                *self.state = ProductReferenceElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_version(data)?;
                    *self.state = ProductReferenceElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductReferenceElementTypeDeserializerState::CatalogVersion(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductReferenceElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::CatalogVersion(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductReferenceElementType>
        for ProductReferenceElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductReferenceElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductReferenceElementType>
        where
            R: DeserializeReader,
        {
            use ProductReferenceElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ProdIdTo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_prod_id_to(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogVersion(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ProductReferenceElementTypeDeserializerState::ProdIdTo(None);
                        event
                    }
                    (S::ProdIdTo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PROD_ID_TO",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_prod_id_to(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogId(None);
                            event
                        }
                    }
                    (S::CatalogId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_ID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_catalog_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogVersion(None);
                            event
                        }
                    }
                    (S::CatalogVersion(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_VERSION",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_catalog_version(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductReferenceElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductReferenceElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductReferenceElementType {
                type_: self.type_,
                quantity: self.quantity,
                prod_id_to: self
                    .prod_id_to
                    .ok_or_else(|| ErrorKind::MissingElement("PROD_ID_TO".into()))?,
                catalog_id: self.catalog_id,
                catalog_version: self.catalog_version,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductLogisticDetailsElementTypeDeserializer {
        customs_tariff_number: Vec<super::CustomsTariffNumberElementType>,
        statistics_factor: Option<f64>,
        country_of_origin: Vec<String>,
        state: Box<ProductLogisticDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductLogisticDetailsElementTypeDeserializerState {
        Init__,
        CustomsTariffNumber(
            Option<<super::CustomsTariffNumberElementType as WithDeserializer>::Deserializer>,
        ),
        StatisticsFactor(Option<<f64 as WithDeserializer>::Deserializer>),
        CountryOfOrigin(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductLogisticDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                customs_tariff_number: Vec::new(),
                statistics_factor: None,
                country_of_origin: Vec::new(),
                state: Box::new(ProductLogisticDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductLogisticDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductLogisticDetailsElementTypeDeserializerState as S;
            match state {
                S::CustomsTariffNumber(Some(deserializer)) => {
                    self.store_customs_tariff_number(deserializer.finish(reader)?)?
                }
                S::StatisticsFactor(Some(deserializer)) => {
                    self.store_statistics_factor(deserializer.finish(reader)?)?
                }
                S::CountryOfOrigin(Some(deserializer)) => {
                    self.store_country_of_origin(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_customs_tariff_number(
            &mut self,
            value: super::CustomsTariffNumberElementType,
        ) -> Result<(), Error> {
            self.customs_tariff_number.push(value);
            Ok(())
        }
        fn store_statistics_factor(&mut self, value: f64) -> Result<(), Error> {
            if self.statistics_factor.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"STATISTICS_FACTOR",
                )))?;
            }
            self.statistics_factor = Some(value);
            Ok(())
        }
        fn store_country_of_origin(&mut self, value: String) -> Result<(), Error> {
            self.country_of_origin.push(value);
            Ok(())
        }
        fn handle_customs_tariff_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CustomsTariffNumberElementType>,
            fallback: &mut Option<ProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductLogisticDetailsElementTypeDeserializerState::CustomsTariffNumber(None),
                );
                *self.state =
                    ProductLogisticDetailsElementTypeDeserializerState::StatisticsFactor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_customs_tariff_number(data)?;
                    *self.state =
                        ProductLogisticDetailsElementTypeDeserializerState::CustomsTariffNumber(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ProductLogisticDetailsElementTypeDeserializerState :: CustomsTariffNumber (Some (deserializer))) ;
                            * self . state = ProductLogisticDetailsElementTypeDeserializerState :: CustomsTariffNumber (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ProductLogisticDetailsElementTypeDeserializerState :: CustomsTariffNumber (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_statistics_factor<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductLogisticDetailsElementTypeDeserializerState::StatisticsFactor(None),
                );
                *self.state =
                    ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_statistics_factor(data)?;
                    *self.state =
                        ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ProductLogisticDetailsElementTypeDeserializerState :: StatisticsFactor (Some (deserializer))) ;
                            *self.state =
                                ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ProductLogisticDetailsElementTypeDeserializerState :: StatisticsFactor (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_country_of_origin<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(None),
                );
                *self.state = ProductLogisticDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_country_of_origin(data)?;
                    *self.state =
                        ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductLogisticDetailsElementType>
        for ProductLogisticDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductLogisticDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductLogisticDetailsElementType>
        where
            R: DeserializeReader,
        {
            use ProductLogisticDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CustomsTariffNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_customs_tariff_number(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StatisticsFactor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_statistics_factor(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CountryOfOrigin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_country_of_origin(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductLogisticDetailsElementTypeDeserializerState::CustomsTariffNumber(
                                None,
                            );
                        event
                    }
                    (S::CustomsTariffNumber(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CUSTOMS_TARIFF_NUMBER",
                        ) {
                            let output = < super :: CustomsTariffNumberElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_customs_tariff_number(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::StatisticsFactor(None);
                            event
                        }
                    }
                    (S::StatisticsFactor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"STATISTICS_FACTOR",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_statistics_factor(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CountryOfOrigin(None);
                            event
                        }
                    }
                    (S::CountryOfOrigin(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"COUNTRY_OF_ORIGIN",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_country_of_origin(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ProductLogisticDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductLogisticDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductLogisticDetailsElementType {
                customs_tariff_number: self.customs_tariff_number,
                statistics_factor: self.statistics_factor,
                country_of_origin: self.country_of_origin,
            })
        }
    }
    #[derive(Debug)]
    pub struct MimeElementTypeDeserializer {
        mime_type: Option<String>,
        mime_source: Vec<super::DtMlstringType>,
        mime_descr: Vec<super::DtMlstringType>,
        mime_alt: Vec<super::DtMlstringType>,
        mime_purpose: Option<super::MimePurposeElementType>,
        state: Box<MimeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum MimeElementTypeDeserializerState {
        Init__,
        MimeType(Option<<String as WithDeserializer>::Deserializer>),
        MimeSource(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        MimeDescr(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        MimeAlt(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        MimePurpose(Option<<super::MimePurposeElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl MimeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                mime_type: None,
                mime_source: Vec::new(),
                mime_descr: Vec::new(),
                mime_alt: Vec::new(),
                mime_purpose: None,
                state: Box::new(MimeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: MimeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use MimeElementTypeDeserializerState as S;
            match state {
                S::MimeType(Some(deserializer)) => {
                    self.store_mime_type(deserializer.finish(reader)?)?
                }
                S::MimeSource(Some(deserializer)) => {
                    self.store_mime_source(deserializer.finish(reader)?)?
                }
                S::MimeDescr(Some(deserializer)) => {
                    self.store_mime_descr(deserializer.finish(reader)?)?
                }
                S::MimeAlt(Some(deserializer)) => {
                    self.store_mime_alt(deserializer.finish(reader)?)?
                }
                S::MimePurpose(Some(deserializer)) => {
                    self.store_mime_purpose(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_mime_type(&mut self, value: String) -> Result<(), Error> {
            if self.mime_type.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MIME_TYPE",
                )))?;
            }
            self.mime_type = Some(value);
            Ok(())
        }
        fn store_mime_source(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.mime_source.push(value);
            Ok(())
        }
        fn store_mime_descr(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.mime_descr.push(value);
            Ok(())
        }
        fn store_mime_alt(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.mime_alt.push(value);
            Ok(())
        }
        fn store_mime_purpose(
            &mut self,
            value: super::MimePurposeElementType,
        ) -> Result<(), Error> {
            if self.mime_purpose.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MIME_PURPOSE",
                )))?;
            }
            self.mime_purpose = Some(value);
            Ok(())
        }
        fn handle_mime_type<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<MimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.mime_type.is_some() {
                    fallback.get_or_insert(MimeElementTypeDeserializerState::MimeType(None));
                    *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = MimeElementTypeDeserializerState::MimeType(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_type(data)?;
                    *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeElementTypeDeserializerState::MimeType(
                                Some(deserializer),
                            ));
                            *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeElementTypeDeserializerState::MimeType(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_source<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<MimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.mime_source.len() < 1usize {
                    *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(MimeElementTypeDeserializerState::MimeSource(None));
                    *self.state = MimeElementTypeDeserializerState::MimeDescr(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_source(data)?;
                    *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeElementTypeDeserializerState::MimeSource(
                                Some(deserializer),
                            ));
                            if self.mime_source.len().saturating_add(1) < 1usize {
                                *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                            } else {
                                *self.state = MimeElementTypeDeserializerState::MimeDescr(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeElementTypeDeserializerState::MimeSource(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_descr<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<MimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(MimeElementTypeDeserializerState::MimeDescr(None));
                *self.state = MimeElementTypeDeserializerState::MimeAlt(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_descr(data)?;
                    *self.state = MimeElementTypeDeserializerState::MimeDescr(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeElementTypeDeserializerState::MimeDescr(
                                Some(deserializer),
                            ));
                            *self.state = MimeElementTypeDeserializerState::MimeDescr(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeElementTypeDeserializerState::MimeDescr(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_alt<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<MimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(MimeElementTypeDeserializerState::MimeAlt(None));
                *self.state = MimeElementTypeDeserializerState::MimePurpose(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_alt(data)?;
                    *self.state = MimeElementTypeDeserializerState::MimeAlt(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeElementTypeDeserializerState::MimeAlt(
                                Some(deserializer),
                            ));
                            *self.state = MimeElementTypeDeserializerState::MimeAlt(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeElementTypeDeserializerState::MimeAlt(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_purpose<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MimePurposeElementType>,
            fallback: &mut Option<MimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.mime_purpose.is_some() {
                    fallback.get_or_insert(MimeElementTypeDeserializerState::MimePurpose(None));
                    *self.state = MimeElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = MimeElementTypeDeserializerState::MimePurpose(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_purpose(data)?;
                    *self.state = MimeElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeElementTypeDeserializerState::MimePurpose(
                                Some(deserializer),
                            ));
                            *self.state = MimeElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeElementTypeDeserializerState::MimePurpose(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::MimeElementType> for MimeElementTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::MimeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::MimeElementType>
        where
            R: DeserializeReader,
        {
            use MimeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::MimeType(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_type(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeSource(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_source(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeDescr(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_descr(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeAlt(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_alt(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimePurpose(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_purpose(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = MimeElementTypeDeserializerState::MimeType(None);
                        event
                    }
                    (S::MimeType(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_TYPE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_mime_type(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeSource(None);
                            event
                        }
                    }
                    (S::MimeSource(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_SOURCE",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime_source(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeDescr(None);
                            event
                        }
                    }
                    (S::MimeDescr(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_DESCR",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime_descr(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeAlt(None);
                            event
                        }
                    }
                    (S::MimeAlt(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_ALT",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime_alt(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimePurpose(None);
                            event
                        }
                    }
                    (S::MimePurpose(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_PURPOSE",
                        ) {
                            let output = < super :: MimePurposeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_mime_purpose(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::MimeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                MimeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::MimeElementType {
                mime_type: self
                    .mime_type
                    .ok_or_else(|| ErrorKind::MissingElement("MIME_TYPE".into()))?,
                mime_source: self.mime_source,
                mime_descr: self.mime_descr,
                mime_alt: self.mime_alt,
                mime_purpose: self
                    .mime_purpose
                    .ok_or_else(|| ErrorKind::MissingElement("MIME_PURPOSE".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct InternationalPidElementTypeDeserializer {
        type_: Option<String>,
        content: Option<String>,
        state: Box<InternationalPidElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum InternationalPidElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl InternationalPidElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_,
                content: None,
                state: Box::new(InternationalPidElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: InternationalPidElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let InternationalPidElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::InternationalPidElementType>
        where
            R: DeserializeReader,
        {
            use InternationalPidElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::InternationalPidElementType>
        for InternationalPidElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::InternationalPidElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::InternationalPidElementType>
        where
            R: DeserializeReader,
        {
            use InternationalPidElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::InternationalPidElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                InternationalPidElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::InternationalPidElementType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct BuyerPidElementTypeDeserializer {
        type_: Option<String>,
        content: Option<String>,
        state: Box<BuyerPidElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum BuyerPidElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl BuyerPidElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_,
                content: None,
                state: Box::new(BuyerPidElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: BuyerPidElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let BuyerPidElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::BuyerPidElementType>
        where
            R: DeserializeReader,
        {
            use BuyerPidElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::BuyerPidElementType> for BuyerPidElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BuyerPidElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BuyerPidElementType>
        where
            R: DeserializeReader,
        {
            use BuyerPidElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::BuyerPidElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                BuyerPidElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::BuyerPidElementType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct SpecialTreatmentClassElementTypeDeserializer {
        type_: String,
        content: Option<String>,
        state: Box<SpecialTreatmentClassElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SpecialTreatmentClassElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl SpecialTreatmentClassElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                content: None,
                state: Box::new(SpecialTreatmentClassElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SpecialTreatmentClassElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let SpecialTreatmentClassElementTypeDeserializerState::Content__(deserializer) =
                state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::SpecialTreatmentClassElementType>
        where
            R: DeserializeReader,
        {
            use SpecialTreatmentClassElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::SpecialTreatmentClassElementType>
        for SpecialTreatmentClassElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SpecialTreatmentClassElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SpecialTreatmentClassElementType>
        where
            R: DeserializeReader,
        {
            use SpecialTreatmentClassElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SpecialTreatmentClassElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SpecialTreatmentClassElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SpecialTreatmentClassElementType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct RemarksElementTypeDeserializer {
        lang: Option<super::DtLangType>,
        type_: Option<String>,
        content: Option<String>,
        state: Box<RemarksElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum RemarksElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl RemarksElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut lang: Option<super::DtLangType> = None;
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"lang")
                ) {
                    reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                lang: lang,
                type_: type_,
                content: None,
                state: Box::new(RemarksElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: RemarksElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let RemarksElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::RemarksElementType>
        where
            R: DeserializeReader,
        {
            use RemarksElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::RemarksElementType> for RemarksElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::RemarksElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::RemarksElementType>
        where
            R: DeserializeReader,
        {
            use RemarksElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::RemarksElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                RemarksElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::RemarksElementType {
                lang: self.lang,
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductStatusElementTypeDeserializer {
        lang: Option<super::DtLangType>,
        type_: super::ProductStatustypeType,
        content: Option<String>,
        state: Box<ProductStatusElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductStatusElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl ProductStatusElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut lang: Option<super::DtLangType> = None;
            let mut type_: Option<super::ProductStatustypeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"lang")
                ) {
                    reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                lang: lang,
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                content: None,
                state: Box::new(ProductStatusElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductStatusElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let ProductStatusElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::ProductStatusElementType>
        where
            R: DeserializeReader,
        {
            use ProductStatusElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::ProductStatusElementType>
        for ProductStatusElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductStatusElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductStatusElementType>
        where
            R: DeserializeReader,
        {
            use ProductStatusElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductStatusElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductStatusElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductStatusElementType {
                lang: self.lang,
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TypeClassificationGroupIdTypeDeserializer {
        type_: Option<super::TypeClassificationGroupIdtypeType>,
        content: Option<String>,
        state: Box<TypeClassificationGroupIdTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TypeClassificationGroupIdTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl TypeClassificationGroupIdTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::TypeClassificationGroupIdtypeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_,
                content: None,
                state: Box::new(TypeClassificationGroupIdTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TypeClassificationGroupIdTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let TypeClassificationGroupIdTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::TypeClassificationGroupIdType>
        where
            R: DeserializeReader,
        {
            use TypeClassificationGroupIdTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::TypeClassificationGroupIdType>
        for TypeClassificationGroupIdTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TypeClassificationGroupIdType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TypeClassificationGroupIdType>
        where
            R: DeserializeReader,
        {
            use TypeClassificationGroupIdTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TypeClassificationGroupIdType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TypeClassificationGroupIdTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TypeClassificationGroupIdType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct FeatureElementTypeDeserializer {
        fname: Vec<super::DtMlstringType>,
        fvalue: Vec<super::DtMlstringType>,
        funit: Option<String>,
        fvalue_details: Vec<super::DtMlstringType>,
        state: Box<FeatureElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum FeatureElementTypeDeserializerState {
        Init__,
        Fname(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Fvalue(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Funit(Option<<String as WithDeserializer>::Deserializer>),
        FvalueDetails(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl FeatureElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                fname: Vec::new(),
                fvalue: Vec::new(),
                funit: None,
                fvalue_details: Vec::new(),
                state: Box::new(FeatureElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: FeatureElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use FeatureElementTypeDeserializerState as S;
            match state {
                S::Fname(Some(deserializer)) => self.store_fname(deserializer.finish(reader)?)?,
                S::Fvalue(Some(deserializer)) => self.store_fvalue(deserializer.finish(reader)?)?,
                S::Funit(Some(deserializer)) => self.store_funit(deserializer.finish(reader)?)?,
                S::FvalueDetails(Some(deserializer)) => {
                    self.store_fvalue_details(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_fname(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.fname.push(value);
            Ok(())
        }
        fn store_fvalue(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.fvalue.push(value);
            Ok(())
        }
        fn store_funit(&mut self, value: String) -> Result<(), Error> {
            if self.funit.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FUNIT",
                )))?;
            }
            self.funit = Some(value);
            Ok(())
        }
        fn store_fvalue_details(&mut self, value: super::DtMlstringType) -> Result<(), Error> {
            self.fvalue_details.push(value);
            Ok(())
        }
        fn handle_fname<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<FeatureElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.fname.len() < 1usize {
                    *self.state = FeatureElementTypeDeserializerState::Fname(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(FeatureElementTypeDeserializerState::Fname(None));
                    *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fname(data)?;
                    *self.state = FeatureElementTypeDeserializerState::Fname(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(FeatureElementTypeDeserializerState::Fname(
                                Some(deserializer),
                            ));
                            if self.fname.len().saturating_add(1) < 1usize {
                                *self.state = FeatureElementTypeDeserializerState::Fname(None);
                            } else {
                                *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                FeatureElementTypeDeserializerState::Fname(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_fvalue<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<FeatureElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.fvalue.len() < 1usize {
                    *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(FeatureElementTypeDeserializerState::Fvalue(None));
                    *self.state = FeatureElementTypeDeserializerState::Funit(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fvalue(data)?;
                    *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(FeatureElementTypeDeserializerState::Fvalue(
                                Some(deserializer),
                            ));
                            if self.fvalue.len().saturating_add(1) < 1usize {
                                *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                            } else {
                                *self.state = FeatureElementTypeDeserializerState::Funit(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                FeatureElementTypeDeserializerState::Fvalue(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_funit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<FeatureElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(FeatureElementTypeDeserializerState::Funit(None));
                *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_funit(data)?;
                    *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(FeatureElementTypeDeserializerState::Funit(
                                Some(deserializer),
                            ));
                            *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                FeatureElementTypeDeserializerState::Funit(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_fvalue_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<FeatureElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(FeatureElementTypeDeserializerState::FvalueDetails(None));
                *self.state = FeatureElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fvalue_details(data)?;
                    *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                FeatureElementTypeDeserializerState::FvalueDetails(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = FeatureElementTypeDeserializerState::FvalueDetails(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::FeatureElementType> for FeatureElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::FeatureElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::FeatureElementType>
        where
            R: DeserializeReader,
        {
            use FeatureElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Fname(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fname(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Fvalue(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fvalue(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Funit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_funit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FvalueDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fvalue_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = FeatureElementTypeDeserializerState::Fname(None);
                        event
                    }
                    (S::Fname(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"FNAME") {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_fname(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Fvalue(None);
                            event
                        }
                    }
                    (S::Fvalue(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"FVALUE")
                        {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_fvalue(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Funit(None);
                            event
                        }
                    }
                    (S::Funit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"FUNIT") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_funit(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::FvalueDetails(None);
                            event
                        }
                    }
                    (S::FvalueDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"FVALUE_DETAILS",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_fvalue_details(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::FeatureElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                FeatureElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::FeatureElementType {
                fname: self.fname,
                fvalue: self.fvalue,
                funit: self.funit,
                fvalue_details: self.fvalue_details,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceDetailsDatetimeElementTypeDeserializer {
        type_: super::ProductPriceDetailsDatetimetypeType,
        date: Option<String>,
        time: Option<String>,
        timezone: Option<String>,
        state: Box<ProductPriceDetailsDatetimeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductPriceDetailsDatetimeElementTypeDeserializerState {
        Init__,
        Date(Option<<String as WithDeserializer>::Deserializer>),
        Time(Option<<String as WithDeserializer>::Deserializer>),
        Timezone(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductPriceDetailsDatetimeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::ProductPriceDetailsDatetimetypeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                date: None,
                time: None,
                timezone: None,
                state: Box::new(ProductPriceDetailsDatetimeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductPriceDetailsDatetimeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductPriceDetailsDatetimeElementTypeDeserializerState as S;
            match state {
                S::Date(Some(deserializer)) => self.store_date(deserializer.finish(reader)?)?,
                S::Time(Some(deserializer)) => self.store_time(deserializer.finish(reader)?)?,
                S::Timezone(Some(deserializer)) => {
                    self.store_timezone(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_date(&mut self, value: String) -> Result<(), Error> {
            if self.date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"DATE")))?;
            }
            self.date = Some(value);
            Ok(())
        }
        fn store_time(&mut self, value: String) -> Result<(), Error> {
            if self.time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"TIME")))?;
            }
            self.time = Some(value);
            Ok(())
        }
        fn store_timezone(&mut self, value: String) -> Result<(), Error> {
            if self.timezone.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"TIMEZONE",
                )))?;
            }
            self.timezone = Some(value);
            Ok(())
        }
        fn handle_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductPriceDetailsDatetimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.date.is_some() {
                    fallback.get_or_insert(
                        ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(None),
                    );
                    *self.state =
                        ProductPriceDetailsDatetimeElementTypeDeserializerState::Time(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_date(data)?;
                    *self.state =
                        ProductPriceDetailsDatetimeElementTypeDeserializerState::Time(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Time(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductPriceDetailsDatetimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductPriceDetailsDatetimeElementTypeDeserializerState::Time(None),
                );
                *self.state =
                    ProductPriceDetailsDatetimeElementTypeDeserializerState::Timezone(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_time(data)?;
                    *self.state =
                        ProductPriceDetailsDatetimeElementTypeDeserializerState::Timezone(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Time(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Timezone(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Time(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_timezone<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductPriceDetailsDatetimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductPriceDetailsDatetimeElementTypeDeserializerState::Timezone(None),
                );
                *self.state = ProductPriceDetailsDatetimeElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_timezone(data)?;
                    *self.state = ProductPriceDetailsDatetimeElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Timezone(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Timezone(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductPriceDetailsDatetimeElementType>
        for ProductPriceDetailsDatetimeElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceDetailsDatetimeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceDetailsDatetimeElementType>
        where
            R: DeserializeReader,
        {
            use ProductPriceDetailsDatetimeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Date(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Time(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Timezone(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_timezone(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(None);
                        event
                    }
                    (S::Date(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"DATE") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_date(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Time(None);
                            event
                        }
                    }
                    (S::Time(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"TIME") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Timezone(None);
                            event
                        }
                    }
                    (S::Timezone(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"TIMEZONE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_timezone(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ProductPriceDetailsDatetimeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductPriceDetailsDatetimeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductPriceDetailsDatetimeElementType {
                type_: self.type_,
                date: self
                    .date
                    .ok_or_else(|| ErrorKind::MissingElement("DATE".into()))?,
                time: self.time,
                timezone: self.timezone,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceElementTypeDeserializer {
        price_type: String,
        price_amount: Option<f64>,
        price_currency: Option<super::DtCurrenciesType>,
        tax: Option<f64>,
        price_factor: Option<f64>,
        lower_bound: Option<f64>,
        territory: Vec<String>,
        state: Box<ProductPriceElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductPriceElementTypeDeserializerState {
        Init__,
        PriceAmount(Option<<f64 as WithDeserializer>::Deserializer>),
        PriceCurrency(Option<<super::DtCurrenciesType as WithDeserializer>::Deserializer>),
        Tax(Option<<f64 as WithDeserializer>::Deserializer>),
        PriceFactor(Option<<f64 as WithDeserializer>::Deserializer>),
        LowerBound(Option<<f64 as WithDeserializer>::Deserializer>),
        Territory(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductPriceElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut price_type: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"price_type")
                ) {
                    reader.read_attrib(&mut price_type, b"price_type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                price_type: price_type.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("price_type".into()))
                })?,
                price_amount: None,
                price_currency: None,
                tax: None,
                price_factor: None,
                lower_bound: None,
                territory: Vec::new(),
                state: Box::new(ProductPriceElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductPriceElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductPriceElementTypeDeserializerState as S;
            match state {
                S::PriceAmount(Some(deserializer)) => {
                    self.store_price_amount(deserializer.finish(reader)?)?
                }
                S::PriceCurrency(Some(deserializer)) => {
                    self.store_price_currency(deserializer.finish(reader)?)?
                }
                S::Tax(Some(deserializer)) => self.store_tax(deserializer.finish(reader)?)?,
                S::PriceFactor(Some(deserializer)) => {
                    self.store_price_factor(deserializer.finish(reader)?)?
                }
                S::LowerBound(Some(deserializer)) => {
                    self.store_lower_bound(deserializer.finish(reader)?)?
                }
                S::Territory(Some(deserializer)) => {
                    self.store_territory(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_price_amount(&mut self, value: f64) -> Result<(), Error> {
            if self.price_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_AMOUNT",
                )))?;
            }
            self.price_amount = Some(value);
            Ok(())
        }
        fn store_price_currency(&mut self, value: super::DtCurrenciesType) -> Result<(), Error> {
            if self.price_currency.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_CURRENCY",
                )))?;
            }
            self.price_currency = Some(value);
            Ok(())
        }
        fn store_tax(&mut self, value: f64) -> Result<(), Error> {
            if self.tax.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"TAX")))?;
            }
            self.tax = Some(value);
            Ok(())
        }
        fn store_price_factor(&mut self, value: f64) -> Result<(), Error> {
            if self.price_factor.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_FACTOR",
                )))?;
            }
            self.price_factor = Some(value);
            Ok(())
        }
        fn store_lower_bound(&mut self, value: f64) -> Result<(), Error> {
            if self.lower_bound.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LOWER_BOUND",
                )))?;
            }
            self.lower_bound = Some(value);
            Ok(())
        }
        fn store_territory(&mut self, value: String) -> Result<(), Error> {
            self.territory.push(value);
            Ok(())
        }
        fn handle_price_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.price_amount.is_some() {
                    fallback
                        .get_or_insert(ProductPriceElementTypeDeserializerState::PriceAmount(None));
                    *self.state = ProductPriceElementTypeDeserializerState::PriceCurrency(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProductPriceElementTypeDeserializerState::PriceAmount(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_amount(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::PriceCurrency(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::PriceAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductPriceElementTypeDeserializerState::PriceCurrency(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::PriceAmount(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_price_currency<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtCurrenciesType>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::PriceCurrency(
                    None,
                ));
                *self.state = ProductPriceElementTypeDeserializerState::Tax(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_currency(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::Tax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::PriceCurrency(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductPriceElementTypeDeserializerState::Tax(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::PriceCurrency(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_tax<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::Tax(None));
                *self.state = ProductPriceElementTypeDeserializerState::PriceFactor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_tax(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::PriceFactor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ProductPriceElementTypeDeserializerState::Tax(
                                Some(deserializer),
                            ));
                            *self.state =
                                ProductPriceElementTypeDeserializerState::PriceFactor(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceElementTypeDeserializerState::Tax(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_price_factor<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::PriceFactor(None));
                *self.state = ProductPriceElementTypeDeserializerState::LowerBound(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_factor(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::LowerBound(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::PriceFactor(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductPriceElementTypeDeserializerState::LowerBound(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::PriceFactor(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_lower_bound<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::LowerBound(None));
                *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_lower_bound(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::LowerBound(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::LowerBound(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_territory<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::Territory(None));
                *self.state = ProductPriceElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_territory(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::Territory(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::Territory(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductPriceElementType>
        for ProductPriceElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceElementType>
        where
            R: DeserializeReader,
        {
            use ProductPriceElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::PriceAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PriceCurrency(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_currency(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Tax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tax(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PriceFactor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_factor(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LowerBound(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_lower_bound(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Territory(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_territory(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ProductPriceElementTypeDeserializerState::PriceAmount(None);
                        event
                    }
                    (S::PriceAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_AMOUNT",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_price_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PriceCurrency(None);
                            event
                        }
                    }
                    (S::PriceCurrency(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_CURRENCY",
                        ) {
                            let output =
                                <super::DtCurrenciesType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_price_currency(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Tax(None);
                            event
                        }
                    }
                    (S::Tax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"TAX") {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_tax(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PriceFactor(None);
                            event
                        }
                    }
                    (S::PriceFactor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_FACTOR",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_price_factor(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LowerBound(None);
                            event
                        }
                    }
                    (S::LowerBound(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"LOWER_BOUND",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_lower_bound(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Territory(None);
                            event
                        }
                    }
                    (S::Territory(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"TERRITORY",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_territory(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductPriceElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductPriceElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductPriceElementType {
                price_type: self.price_type,
                price_amount: self
                    .price_amount
                    .ok_or_else(|| ErrorKind::MissingElement("PRICE_AMOUNT".into()))?,
                price_currency: self.price_currency,
                tax: self.tax,
                price_factor: self.price_factor,
                lower_bound: self.lower_bound,
                territory: self.territory,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDiscountGroupElementTypeDeserializer {
        content: Vec<super::UdxEdxfDiscountGroupElementTypeContent>,
        state: Box<UdxEdxfDiscountGroupElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfDiscountGroupElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(
            <super::UdxEdxfDiscountGroupElementTypeContent as WithDeserializer>::Deserializer,
        ),
        Unknown__,
    }
    impl UdxEdxfDiscountGroupElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                content: Vec::new(),
                state: Box::new(UdxEdxfDiscountGroupElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfDiscountGroupElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfDiscountGroupElementTypeDeserializerState::Content__(deserializer) = state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::UdxEdxfDiscountGroupElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfDiscountGroupElementTypeContent>,
            fallback: &mut Option<UdxEdxfDiscountGroupElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfDiscountGroupElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = UdxEdxfDiscountGroupElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let can_have_more = self.content.len().saturating_add(1) < 2usize;
                    let ret = if can_have_more {
                        ElementHandlerOutput::from_event(event, allow_any)
                    } else {
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    };
                    match (can_have_more, &ret) {
                        (true, ElementHandlerOutput::Continue { .. }) => {
                            fallback.get_or_insert(
                                UdxEdxfDiscountGroupElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state = UdxEdxfDiscountGroupElementTypeDeserializerState::Next__;
                        }
                        (false, _) | (_, ElementHandlerOutput::Break { .. }) => {
                            *self.state =
                                UdxEdxfDiscountGroupElementTypeDeserializerState::Content__(
                                    deserializer,
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfDiscountGroupElementType>
        for UdxEdxfDiscountGroupElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDiscountGroupElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDiscountGroupElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfDiscountGroupElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: UdxEdxfDiscountGroupElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfDiscountGroupElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfDiscountGroupElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfDiscountGroupElementType {
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDiscountGroupElementTypeContentDeserializer {
        state: Box<UdxEdxfDiscountGroupElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum UdxEdxfDiscountGroupElementTypeContentDeserializerState {
        Init__,
        UdxEdxfDiscountGroupManufacturer(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfDiscountGroupSupplier(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        Done__(super::UdxEdxfDiscountGroupElementTypeContent),
        Unknown__,
    }
    impl UdxEdxfDiscountGroupElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<UdxEdxfDiscountGroupElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfDiscountGroupElementTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.DISCOUNT_GROUP_MANUFACTURER")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_discount_group_manufacturer(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.DISCOUNT_GROUP_SUPPLIER")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_discount_group_supplier(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(UdxEdxfDiscountGroupElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: UdxEdxfDiscountGroupElementTypeContentDeserializerState,
        ) -> Result<super::UdxEdxfDiscountGroupElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfDiscountGroupElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::UdxEdxfDiscountGroupManufacturer(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_discount_group_manufacturer(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfDiscountGroupElementTypeContent :: UdxEdxfDiscountGroupManufacturer (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.DISCOUNT_GROUP_MANUFACTURER" . into ())) ?))
                }
                S::UdxEdxfDiscountGroupSupplier(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_discount_group_supplier(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfDiscountGroupElementTypeContent::UdxEdxfDiscountGroupSupplier(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.DISCOUNT_GROUP_SUPPLIER".into())
                            })?,
                        ),
                    )
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_udx_edxf_discount_group_manufacturer(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DISCOUNT_GROUP_MANUFACTURER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_discount_group_supplier(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DISCOUNT_GROUP_SUPPLIER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_discount_group_manufacturer<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfDiscountGroupElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfDiscountGroupElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (_ , Some (deserializer))) => UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_discount_group_manufacturer (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_discount_group_manufacturer(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (values , None)) ? ;
                    *self.state =
                        UdxEdxfDiscountGroupElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_discount_group_supplier<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfDiscountGroupElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfDiscountGroupElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (_ , Some (deserializer))) => UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_discount_group_supplier (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_discount_group_supplier(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (values , None)) ? ;
                    *self.state =
                        UdxEdxfDiscountGroupElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfDiscountGroupElementTypeContent>
        for UdxEdxfDiscountGroupElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDiscountGroupElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(UdxEdxfDiscountGroupElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        UdxEdxfDiscountGroupElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDiscountGroupElementTypeContent>
        where
            R: DeserializeReader,
        {
            use UdxEdxfDiscountGroupElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfDiscountGroupManufacturer(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_discount_group_manufacturer(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfDiscountGroupSupplier(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_discount_group_supplier(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::UdxEdxfDiscountGroupManufacturer(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_discount_group_manufacturer(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfDiscountGroupSupplier(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_discount_group_supplier(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            self,
            reader: &R,
        ) -> Result<super::UdxEdxfDiscountGroupElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDeclarationElementTypeDeserializer {
        type_: String,
        date: Option<String>,
        content: Option<String>,
        state: Box<UdxEdxfDeclarationElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfDeclarationElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl UdxEdxfDeclarationElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            let mut date: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"date")
                ) {
                    reader.read_attrib(&mut date, b"date", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                date: date,
                content: None,
                state: Box::new(UdxEdxfDeclarationElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfDeclarationElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfDeclarationElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::UdxEdxfDeclarationElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfDeclarationElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfDeclarationElementType>
        for UdxEdxfDeclarationElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDeclarationElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDeclarationElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfDeclarationElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfDeclarationElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfDeclarationElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfDeclarationElementType {
                type_: self.type_,
                date: self.date,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfAdditionalFactorsElementTypeDeserializer {
        udx_edxf_additional_price_factor: Option<f64>,
        udx_edxf_additional_factor_info: Option<super::DtMlstringType>,
        state: Box<UdxEdxfAdditionalFactorsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfAdditionalFactorsElementTypeDeserializerState {
        Init__,
        UdxEdxfAdditionalPriceFactor(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfAdditionalFactorInfo(
            Option<<super::DtMlstringType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl UdxEdxfAdditionalFactorsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_additional_price_factor: None,
                udx_edxf_additional_factor_info: None,
                state: Box::new(UdxEdxfAdditionalFactorsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfAdditionalFactorsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfAdditionalFactorsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfAdditionalPriceFactor(Some(deserializer)) => {
                    self.store_udx_edxf_additional_price_factor(deserializer.finish(reader)?)?
                }
                S::UdxEdxfAdditionalFactorInfo(Some(deserializer)) => {
                    self.store_udx_edxf_additional_factor_info(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_additional_price_factor(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_additional_price_factor.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.ADDITIONAL_PRICE_FACTOR",
                )))?;
            }
            self.udx_edxf_additional_price_factor = Some(value);
            Ok(())
        }
        fn store_udx_edxf_additional_factor_info(
            &mut self,
            value: super::DtMlstringType,
        ) -> Result<(), Error> {
            if self.udx_edxf_additional_factor_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.ADDITIONAL_FACTOR_INFO",
                )))?;
            }
            self.udx_edxf_additional_factor_info = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_additional_price_factor<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfAdditionalFactorsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_additional_price_factor.is_some() {
                    fallback . get_or_insert (UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (None)) ;
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_additional_price_factor(data)?;
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (Some (deserializer))) ;
                            * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_additional_factor_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<UdxEdxfAdditionalFactorsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_additional_factor_info.is_some() {
                    fallback . get_or_insert (UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None)) ;
                    *self.state = UdxEdxfAdditionalFactorsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_additional_factor_info(data)?;
                    *self.state = UdxEdxfAdditionalFactorsElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (Some (deserializer))) ;
                            *self.state =
                                UdxEdxfAdditionalFactorsElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfAdditionalFactorsElementType>
        for UdxEdxfAdditionalFactorsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfAdditionalFactorsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfAdditionalFactorsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfAdditionalFactorsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfAdditionalPriceFactor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_additional_price_factor(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfAdditionalFactorInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_additional_factor_info(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (None) ;
                        event
                    }
                    (
                        S::UdxEdxfAdditionalPriceFactor(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.ADDITIONAL_PRICE_FACTOR",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_additional_price_factor(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfAdditionalFactorInfo(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfAdditionalFactorInfo(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.ADDITIONAL_FACTOR_INFO",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_additional_factor_info(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfAdditionalFactorsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfAdditionalFactorsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfAdditionalFactorsElementType {
                udx_edxf_additional_price_factor: self
                    .udx_edxf_additional_price_factor
                    .ok_or_else(|| {
                        ErrorKind::MissingElement("UDX.EDXF.ADDITIONAL_PRICE_FACTOR".into())
                    })?,
                udx_edxf_additional_factor_info: self.udx_edxf_additional_factor_info.ok_or_else(
                    || ErrorKind::MissingElement("UDX.EDXF.ADDITIONAL_FACTOR_INFO".into()),
                )?,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchNumbersElementTypeDeserializer {
        udx_edxf_country_branch_number:
            Vec<super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType>,
        state: Box<UdxEdxfCountryBranchNumbersElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfCountryBranchNumbersElementTypeDeserializerState {
        Init__ , UdxEdxfCountryBranchNumber (Option << super :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl UdxEdxfCountryBranchNumbersElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_country_branch_number: Vec::new(),
                state: Box::new(UdxEdxfCountryBranchNumbersElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfCountryBranchNumbersElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchNumbersElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfCountryBranchNumber(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_number(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_country_branch_number(
            &mut self,
            value: super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_country_branch_number.push(value);
            Ok(())
        }
        fn handle_udx_edxf_country_branch_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<
                'de,
                super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
            >,
            fallback: &mut Option<UdxEdxfCountryBranchNumbersElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_country_branch_number.len() < 1usize {
                    * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback . get_or_insert (UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None)) ;
                    *self.state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_number(data)?;
                    * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (Some (deserializer))) ;
                            if self.udx_edxf_country_branch_number.len().saturating_add(1) < 1usize
                            {
                                * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfCountryBranchNumbersElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfCountryBranchNumbersElementType>
        for UdxEdxfCountryBranchNumbersElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfCountryBranchNumbersElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfCountryBranchNumbersElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchNumbersElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfCountryBranchNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_number(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None) ;
                        event
                    }
                    (
                        S::UdxEdxfCountryBranchNumber(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_NUMBER",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_number(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfCountryBranchNumbersElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfCountryBranchNumbersElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfCountryBranchNumbersElementType {
                udx_edxf_country_branch_number: self.udx_edxf_country_branch_number,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchSupplierIdsElementTypeDeserializer {
        udx_edxf_country_branch_supplier_id:
            Vec<super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType>,
        state: Box<UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState {
        Init__ , UdxEdxfCountryBranchSupplierId (Option << super :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl UdxEdxfCountryBranchSupplierIdsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_country_branch_supplier_id: Vec::new(),
                state: Box::new(
                    UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState::Init__,
                ),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfCountryBranchSupplierId(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_supplier_id(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_country_branch_supplier_id(
            &mut self,
            value: super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_country_branch_supplier_id.push(value);
            Ok(())
        }
        fn handle_udx_edxf_country_branch_supplier_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<
                'de,
                super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
            >,
            fallback: &mut Option<UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_country_branch_supplier_id.len() < 1usize {
                    * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback . get_or_insert (UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None)) ;
                    *self.state =
                        UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_supplier_id(data)?;
                    * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (Some (deserializer))) ;
                            if self
                                .udx_edxf_country_branch_supplier_id
                                .len()
                                .saturating_add(1)
                                < 1usize
                            {
                                * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None) ;
                            } else {
                                * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: Done__ ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>
        for UdxEdxfCountryBranchSupplierIdsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfCountryBranchSupplierId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_supplier_id(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None) ;
                        event
                    }
                    (
                        S::UdxEdxfCountryBranchSupplierId(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_ID",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_supplier_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfCountryBranchSupplierIdsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfCountryBranchSupplierIdsElementType {
                udx_edxf_country_branch_supplier_id: self.udx_edxf_country_branch_supplier_id,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfPackingUnitsElementTypeDeserializer {
        udx_edxf_packing_unit: Vec<super::UdxEdxfPackingUnitElementType>,
        state: Box<UdxEdxfPackingUnitsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfPackingUnitsElementTypeDeserializerState {
        Init__,
        UdxEdxfPackingUnit(
            Option<<super::UdxEdxfPackingUnitElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl UdxEdxfPackingUnitsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_packing_unit: Vec::new(),
                state: Box::new(UdxEdxfPackingUnitsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfPackingUnitsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfPackingUnitsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfPackingUnit(Some(deserializer)) => {
                    self.store_udx_edxf_packing_unit(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_packing_unit(
            &mut self,
            value: super::UdxEdxfPackingUnitElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_packing_unit.push(value);
            Ok(())
        }
        fn handle_udx_edxf_packing_unit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfPackingUnitElementType>,
            fallback: &mut Option<UdxEdxfPackingUnitsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_packing_unit.len() < 1usize {
                    *self.state =
                        UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(None),
                    );
                    *self.state = UdxEdxfPackingUnitsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_unit(data)?;
                    *self.state =
                        UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(
                                    Some(deserializer),
                                ),
                            );
                            if self.udx_edxf_packing_unit.len().saturating_add(1) < 1usize {
                                * self . state = UdxEdxfPackingUnitsElementTypeDeserializerState :: UdxEdxfPackingUnit (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfPackingUnitsElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfPackingUnitsElementType>
        for UdxEdxfPackingUnitsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfPackingUnitsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfPackingUnitsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfPackingUnitsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfPackingUnit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(
                                None,
                            );
                        event
                    }
                    (S::UdxEdxfPackingUnit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_UNIT",
                        ) {
                            let output = < super :: UdxEdxfPackingUnitElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_packing_unit(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfPackingUnitsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfPackingUnitsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfPackingUnitsElementType {
                udx_edxf_packing_unit: self.udx_edxf_packing_unit,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductLogisticDetailsElementTypeDeserializer {
        udx_edxf_netweight: Option<f64>,
        udx_edxf_region_of_origin: Option<String>,
        state: Box<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfProductLogisticDetailsElementTypeDeserializerState {
        Init__,
        UdxEdxfNetweight(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfRegionOfOrigin(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfProductLogisticDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_netweight: None,
                udx_edxf_region_of_origin: None,
                state: Box::new(UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfProductLogisticDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductLogisticDetailsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfNetweight(Some(deserializer)) => {
                    self.store_udx_edxf_netweight(deserializer.finish(reader)?)?
                }
                S::UdxEdxfRegionOfOrigin(Some(deserializer)) => {
                    self.store_udx_edxf_region_of_origin(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_netweight(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_netweight.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NETWEIGHT",
                )))?;
            }
            self.udx_edxf_netweight = Some(value);
            Ok(())
        }
        fn store_udx_edxf_region_of_origin(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_region_of_origin.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REGION_OF_ORIGIN",
                )))?;
            }
            self.udx_edxf_region_of_origin = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_netweight<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetweight(
                        None,
                    ),
                );
                * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_netweight(data)?;
                    * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetweight (Some (deserializer))) ;
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetweight (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_region_of_origin<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (None)) ;
                *self.state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_region_of_origin(data)?;
                    *self.state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (Some (deserializer))) ;
                            *self.state =
                                UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfProductLogisticDetailsElementType>
        for UdxEdxfProductLogisticDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductLogisticDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductLogisticDetailsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductLogisticDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfNetweight(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_netweight(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfRegionOfOrigin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_region_of_origin(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetweight (None) ;
                        event
                    }
                    (S::UdxEdxfNetweight(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NETWEIGHT",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_netweight(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfRegionOfOrigin(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfRegionOfOrigin(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REGION_OF_ORIGIN",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_region_of_origin(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfProductLogisticDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfProductLogisticDetailsElementType {
                udx_edxf_netweight: self.udx_edxf_netweight,
                udx_edxf_region_of_origin: self.udx_edxf_region_of_origin,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfReachElementTypeDeserializer {
        udx_edxf_reach_listdate: Option<String>,
        udx_edxf_reach_info: Option<String>,
        state: Box<UdxEdxfReachElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfReachElementTypeDeserializerState {
        Init__,
        UdxEdxfReachListdate(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfReachInfo(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfReachElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_reach_listdate: None,
                udx_edxf_reach_info: None,
                state: Box::new(UdxEdxfReachElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfReachElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfReachElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfReachListdate(Some(deserializer)) => {
                    self.store_udx_edxf_reach_listdate(deserializer.finish(reader)?)?
                }
                S::UdxEdxfReachInfo(Some(deserializer)) => {
                    self.store_udx_edxf_reach_info(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_reach_listdate(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_reach_listdate.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REACH.LISTDATE",
                )))?;
            }
            self.udx_edxf_reach_listdate = Some(value);
            Ok(())
        }
        fn store_udx_edxf_reach_info(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_reach_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REACH.INFO",
                )))?;
            }
            self.udx_edxf_reach_info = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_reach_listdate<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfReachElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachListdate(None),
                );
                *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_reach_listdate(data)?;
                    *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachListdate(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachListdate(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_reach_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfReachElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_reach_info.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None),
                    );
                    *self.state = UdxEdxfReachElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_reach_info(data)?;
                    *self.state = UdxEdxfReachElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxEdxfReachElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfReachElementType>
        for UdxEdxfReachElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfReachElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfReachElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfReachElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfReachListdate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_reach_listdate(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfReachInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_reach_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachListdate(None);
                        event
                    }
                    (
                        S::UdxEdxfReachListdate(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REACH.LISTDATE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_reach_listdate(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfReachInfo(None);
                            event
                        }
                    }
                    (S::UdxEdxfReachInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REACH.INFO",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_reach_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfReachElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfReachElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfReachElementType {
                udx_edxf_reach_listdate: self.udx_edxf_reach_listdate,
                udx_edxf_reach_info: self
                    .udx_edxf_reach_info
                    .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.REACH.INFO".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeListElementTypeDeserializer {
        udx_edxf_surcharge: Vec<super::UdxEdxfSurchargeElementType>,
        state: Box<UdxEdxfSurchargeListElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfSurchargeListElementTypeDeserializerState {
        Init__,
        UdxEdxfSurcharge(
            Option<<super::UdxEdxfSurchargeElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl UdxEdxfSurchargeListElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_surcharge: Vec::new(),
                state: Box::new(UdxEdxfSurchargeListElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfSurchargeListElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeListElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfSurcharge(Some(deserializer)) => {
                    self.store_udx_edxf_surcharge(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_surcharge(
            &mut self,
            value: super::UdxEdxfSurchargeElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_surcharge.push(value);
            Ok(())
        }
        fn handle_udx_edxf_surcharge<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfSurchargeElementType>,
            fallback: &mut Option<UdxEdxfSurchargeListElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_surcharge.len() < 1usize {
                    *self.state =
                        UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(None),
                    );
                    *self.state = UdxEdxfSurchargeListElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_surcharge(data)?;
                    *self.state =
                        UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(
                                    Some(deserializer),
                                ),
                            );
                            if self.udx_edxf_surcharge.len().saturating_add(1) < 1usize {
                                * self . state = UdxEdxfSurchargeListElementTypeDeserializerState :: UdxEdxfSurcharge (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfSurchargeListElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfSurchargeListElementType>
        for UdxEdxfSurchargeListElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeListElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeListElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeListElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfSurcharge(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(
                                None,
                            );
                        event
                    }
                    (S::UdxEdxfSurcharge(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SURCHARGE",
                        ) {
                            let output = < super :: UdxEdxfSurchargeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_surcharge(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfSurchargeListElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfSurchargeListElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfSurchargeListElementType {
                udx_edxf_surcharge: self.udx_edxf_surcharge,
            })
        }
    }
    #[derive(Debug)]
    pub struct CustomsTariffNumberElementTypeDeserializer {
        customs_number: Option<String>,
        state: Box<CustomsTariffNumberElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CustomsTariffNumberElementTypeDeserializerState {
        Init__,
        CustomsNumber(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CustomsTariffNumberElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                customs_number: None,
                state: Box::new(CustomsTariffNumberElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CustomsTariffNumberElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CustomsTariffNumberElementTypeDeserializerState as S;
            match state {
                S::CustomsNumber(Some(deserializer)) => {
                    self.store_customs_number(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_customs_number(&mut self, value: String) -> Result<(), Error> {
            if self.customs_number.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CUSTOMS_NUMBER",
                )))?;
            }
            self.customs_number = Some(value);
            Ok(())
        }
        fn handle_customs_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CustomsTariffNumberElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.customs_number.is_some() {
                    fallback.get_or_insert(
                        CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(None),
                    );
                    *self.state = CustomsTariffNumberElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_customs_number(data)?;
                    *self.state = CustomsTariffNumberElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = CustomsTariffNumberElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CustomsTariffNumberElementType>
        for CustomsTariffNumberElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CustomsTariffNumberElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CustomsTariffNumberElementType>
        where
            R: DeserializeReader,
        {
            use CustomsTariffNumberElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CustomsNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_customs_number(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(None);
                        event
                    }
                    (S::CustomsNumber(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CUSTOMS_NUMBER",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_customs_number(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CustomsTariffNumberElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CustomsTariffNumberElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CustomsTariffNumberElementType {
                customs_number: self
                    .customs_number
                    .ok_or_else(|| ErrorKind::MissingElement("CUSTOMS_NUMBER".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializer {
        type_: String,
        country: String,
        content: Option<f64>,
        state:
            Box<UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState {
        Init__,
        Content__(<f64 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            let mut country: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"country")
                ) {
                    reader.read_attrib(&mut country, b"country", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok (Self { type_ : type_ . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("type" . into ()))) ? , country : country . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("country" . into ()))) ? , content : None , state : Box :: new (UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState :: Init__) , })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state : UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState :: Content__ (deserializer) = state { self . store_content (deserializer . finish (reader) ?) ? ; }
            Ok(())
        }
        fn store_content(&mut self, value: f64) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        >
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de>
        Deserializer<'de, super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType>
        for UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        >
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        >
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace (& mut * self . state , UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState :: Unknown__) ;
            self.finish_state(reader, state)?;
            Ok(
                super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType {
                    type_: self.type_,
                    country: self.country,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                },
            )
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializer { type_ : String , country : String , content : Option < f64 > , state : Box < UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState > , }
    #[derive(Debug)]
    enum UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState {
        Init__,
        Content__(<f64 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            let mut country: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"country")
                ) {
                    reader.read_attrib(&mut country, b"country", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib(attrib)?;
                }
            }
            Ok (Self { type_ : type_ . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("type" . into ()))) ? , country : country . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("country" . into ()))) ? , content : None , state : Box :: new (UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState :: Init__) , })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state : UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState :: Content__ (deserializer) = state { self . store_content (deserializer . finish (reader) ?) ? ; }
            Ok(())
        }
        fn store_content(&mut self, value: f64) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        >
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de>
        Deserializer<
            'de,
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        > for UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        >
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        >
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
            Error,
        >
        where
            R: DeserializeReader,
        {
            let state = replace (& mut * self . state , UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState :: Unknown__) ;
            self.finish_state(reader, state)?;
            Ok(
                super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType {
                    type_: self.type_,
                    country: self.country,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                },
            )
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfPackingUnitElementTypeDeserializer {
        udx_edxf_quantity_min: Option<f32>,
        udx_edxf_quantity_max: Option<f32>,
        udx_edxf_packing_unit_code: Option<super::DtPunitType>,
        udx_edxf_packing_unit_name: Vec<super::DtMlstringType>,
        udx_edxf_package_break: Option<String>,
        udx_edxf_volume: Option<f64>,
        udx_edxf_weight: Option<f64>,
        udx_edxf_length: Option<f64>,
        udx_edxf_width: Option<f64>,
        udx_edxf_depth: Option<f64>,
        udx_edxf_diameter: Option<f64>,
        udx_edxf_gtin: Option<String>,
        udx_edxf_gs_1128: Option<String>,
        state: Box<UdxEdxfPackingUnitElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfPackingUnitElementTypeDeserializerState {
        Init__,
        UdxEdxfQuantityMin(Option<<f32 as WithDeserializer>::Deserializer>),
        UdxEdxfQuantityMax(Option<<f32 as WithDeserializer>::Deserializer>),
        UdxEdxfPackingUnitCode(Option<<super::DtPunitType as WithDeserializer>::Deserializer>),
        UdxEdxfPackingUnitName(Option<<super::DtMlstringType as WithDeserializer>::Deserializer>),
        UdxEdxfPackageBreak(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfVolume(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfWeight(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfLength(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfWidth(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfDepth(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfDiameter(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfGtin(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfGs1128(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfPackingUnitElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                udx_edxf_quantity_min: None,
                udx_edxf_quantity_max: None,
                udx_edxf_packing_unit_code: None,
                udx_edxf_packing_unit_name: Vec::new(),
                udx_edxf_package_break: None,
                udx_edxf_volume: None,
                udx_edxf_weight: None,
                udx_edxf_length: None,
                udx_edxf_width: None,
                udx_edxf_depth: None,
                udx_edxf_diameter: None,
                udx_edxf_gtin: None,
                udx_edxf_gs_1128: None,
                state: Box::new(UdxEdxfPackingUnitElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfPackingUnitElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfPackingUnitElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfQuantityMin(Some(deserializer)) => {
                    self.store_udx_edxf_quantity_min(deserializer.finish(reader)?)?
                }
                S::UdxEdxfQuantityMax(Some(deserializer)) => {
                    self.store_udx_edxf_quantity_max(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackingUnitCode(Some(deserializer)) => {
                    self.store_udx_edxf_packing_unit_code(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackingUnitName(Some(deserializer)) => {
                    self.store_udx_edxf_packing_unit_name(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackageBreak(Some(deserializer)) => {
                    self.store_udx_edxf_package_break(deserializer.finish(reader)?)?
                }
                S::UdxEdxfVolume(Some(deserializer)) => {
                    self.store_udx_edxf_volume(deserializer.finish(reader)?)?
                }
                S::UdxEdxfWeight(Some(deserializer)) => {
                    self.store_udx_edxf_weight(deserializer.finish(reader)?)?
                }
                S::UdxEdxfLength(Some(deserializer)) => {
                    self.store_udx_edxf_length(deserializer.finish(reader)?)?
                }
                S::UdxEdxfWidth(Some(deserializer)) => {
                    self.store_udx_edxf_width(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDepth(Some(deserializer)) => {
                    self.store_udx_edxf_depth(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDiameter(Some(deserializer)) => {
                    self.store_udx_edxf_diameter(deserializer.finish(reader)?)?
                }
                S::UdxEdxfGtin(Some(deserializer)) => {
                    self.store_udx_edxf_gtin(deserializer.finish(reader)?)?
                }
                S::UdxEdxfGs1128(Some(deserializer)) => {
                    self.store_udx_edxf_gs_1128(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_quantity_min(&mut self, value: f32) -> Result<(), Error> {
            if self.udx_edxf_quantity_min.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.QUANTITY_MIN",
                )))?;
            }
            self.udx_edxf_quantity_min = Some(value);
            Ok(())
        }
        fn store_udx_edxf_quantity_max(&mut self, value: f32) -> Result<(), Error> {
            if self.udx_edxf_quantity_max.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.QUANTITY_MAX",
                )))?;
            }
            self.udx_edxf_quantity_max = Some(value);
            Ok(())
        }
        fn store_udx_edxf_packing_unit_code(
            &mut self,
            value: super::DtPunitType,
        ) -> Result<(), Error> {
            if self.udx_edxf_packing_unit_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PACKING_UNIT_CODE",
                )))?;
            }
            self.udx_edxf_packing_unit_code = Some(value);
            Ok(())
        }
        fn store_udx_edxf_packing_unit_name(
            &mut self,
            value: super::DtMlstringType,
        ) -> Result<(), Error> {
            self.udx_edxf_packing_unit_name.push(value);
            Ok(())
        }
        fn store_udx_edxf_package_break(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_package_break.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PACKAGE_BREAK",
                )))?;
            }
            self.udx_edxf_package_break = Some(value);
            Ok(())
        }
        fn store_udx_edxf_volume(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_volume.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.VOLUME",
                )))?;
            }
            self.udx_edxf_volume = Some(value);
            Ok(())
        }
        fn store_udx_edxf_weight(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_weight.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.WEIGHT",
                )))?;
            }
            self.udx_edxf_weight = Some(value);
            Ok(())
        }
        fn store_udx_edxf_length(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_length.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.LENGTH",
                )))?;
            }
            self.udx_edxf_length = Some(value);
            Ok(())
        }
        fn store_udx_edxf_width(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_width.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.WIDTH",
                )))?;
            }
            self.udx_edxf_width = Some(value);
            Ok(())
        }
        fn store_udx_edxf_depth(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_depth.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DEPTH",
                )))?;
            }
            self.udx_edxf_depth = Some(value);
            Ok(())
        }
        fn store_udx_edxf_diameter(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_diameter.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DIAMETER",
                )))?;
            }
            self.udx_edxf_diameter = Some(value);
            Ok(())
        }
        fn store_udx_edxf_gtin(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_gtin.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.GTIN",
                )))?;
            }
            self.udx_edxf_gtin = Some(value);
            Ok(())
        }
        fn store_udx_edxf_gs_1128(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_gs_1128.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.GS1_128",
                )))?;
            }
            self.udx_edxf_gs_1128 = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_quantity_min<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_quantity_min.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(None),
                    );
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_quantity_min(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_quantity_max<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(None),
                );
                *self.state =
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_quantity_max(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitCode(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitCode (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_packing_unit_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtPunitType>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_packing_unit_code.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitCode(
                            None,
                        ),
                    );
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitName(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitCode(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_unit_code(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitName(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitCode (Some (deserializer))) ;
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitName (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitCode (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_packing_unit_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitName(None),
                );
                *self.state =
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackageBreak(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_unit_name(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitName(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitName (Some (deserializer))) ;
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitName (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitName (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_package_break<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackageBreak(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_package_break(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackageBreak(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackageBreak(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_volume<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_volume(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_weight<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_weight(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_length<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_length(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_width<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_width(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_depth<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_depth(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_diameter<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_diameter(data)?;
                    *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_gtin<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_gtin(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_gs_1128<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_gs_1128(data)?;
                    *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfPackingUnitElementType>
        for UdxEdxfPackingUnitElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfPackingUnitElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfPackingUnitElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfPackingUnitElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfQuantityMin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_quantity_min(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfQuantityMax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_quantity_max(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackingUnitCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_unit_code(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackingUnitName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_unit_name(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackageBreak(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_package_break(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfVolume(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_volume(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfWeight(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_weight(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfLength(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_length(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfWidth(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_width(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDepth(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_depth(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDiameter(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_diameter(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfGtin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_gtin(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfGs1128(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_gs_1128(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(
                                None,
                            );
                        event
                    }
                    (S::UdxEdxfQuantityMin(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.QUANTITY_MIN",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_quantity_min(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfQuantityMax(None);
                            event
                        }
                    }
                    (S::UdxEdxfQuantityMax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.QUANTITY_MAX",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_quantity_max(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackingUnitCode(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfPackingUnitCode(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_UNIT_CODE",
                        ) {
                            let output =
                                <super::DtPunitType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_packing_unit_code(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackingUnitName(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfPackingUnitName(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_UNIT_NAME",
                        ) {
                            let output =
                                <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_packing_unit_name(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackageBreak(None);
                            event
                        }
                    }
                    (S::UdxEdxfPackageBreak(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKAGE_BREAK",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_package_break(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfVolume(None);
                            event
                        }
                    }
                    (S::UdxEdxfVolume(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.VOLUME",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_volume(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfWeight(None);
                            event
                        }
                    }
                    (S::UdxEdxfWeight(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.WEIGHT",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_weight(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfLength(None);
                            event
                        }
                    }
                    (S::UdxEdxfLength(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.LENGTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_length(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfWidth(None);
                            event
                        }
                    }
                    (S::UdxEdxfWidth(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.WIDTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_width(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDepth(None);
                            event
                        }
                    }
                    (S::UdxEdxfDepth(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DEPTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_depth(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDiameter(None);
                            event
                        }
                    }
                    (S::UdxEdxfDiameter(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DIAMETER",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_diameter(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfGtin(None);
                            event
                        }
                    }
                    (S::UdxEdxfGtin(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.GTIN",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_gtin(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfGs1128(None);
                            event
                        }
                    }
                    (S::UdxEdxfGs1128(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.GS1_128",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_gs_1128(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfPackingUnitElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfPackingUnitElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfPackingUnitElementType {
                udx_edxf_quantity_min: self
                    .udx_edxf_quantity_min
                    .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.QUANTITY_MIN".into()))?,
                udx_edxf_quantity_max: self.udx_edxf_quantity_max,
                udx_edxf_packing_unit_code: self.udx_edxf_packing_unit_code.ok_or_else(|| {
                    ErrorKind::MissingElement("UDX.EDXF.PACKING_UNIT_CODE".into())
                })?,
                udx_edxf_packing_unit_name: self.udx_edxf_packing_unit_name,
                udx_edxf_package_break: self.udx_edxf_package_break,
                udx_edxf_volume: self.udx_edxf_volume,
                udx_edxf_weight: self.udx_edxf_weight,
                udx_edxf_length: self.udx_edxf_length,
                udx_edxf_width: self.udx_edxf_width,
                udx_edxf_depth: self.udx_edxf_depth,
                udx_edxf_diameter: self.udx_edxf_diameter,
                udx_edxf_gtin: self.udx_edxf_gtin,
                udx_edxf_gs_1128: self.udx_edxf_gs_1128,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeElementTypeDeserializer {
        content: Vec<super::UdxEdxfSurchargeElementTypeContent>,
        state: Box<UdxEdxfSurchargeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfSurchargeElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::UdxEdxfSurchargeElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl UdxEdxfSurchargeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib(attrib)?;
            }
            Ok(Self {
                content: Vec::new(),
                state: Box::new(UdxEdxfSurchargeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfSurchargeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfSurchargeElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::UdxEdxfSurchargeElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfSurchargeElementTypeContent>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfSurchargeElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = UdxEdxfSurchargeElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxEdxfSurchargeElementTypeDeserializerState::Content__(
                                deserializer,
                            );
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfSurchargeElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state = UdxEdxfSurchargeElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfSurchargeElementType>
        for UdxEdxfSurchargeElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: UdxEdxfSurchargeElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfSurchargeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfSurchargeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfSurchargeElementType {
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeElementTypeContentDeserializer {
        state: Box<UdxEdxfSurchargeElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum UdxEdxfSurchargeElementTypeContentDeserializerState {
        Init__,
        UdxEdxfSurchargeType(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfSurchargeManner(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfSurchargePercentage(Option<f64>, Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfSurchargePriceAmount(Option<f64>, Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfSurchargeCalculation(Option<f64>, Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfMaterialBasis(Option<f64>, Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfMaterialBasisWeight(Option<f64>, Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfMaterialBasisSurchargeThreshold(
            Option<f64>,
            Option<<f64 as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfMaterialBasisSurchargeShutter(
            Option<i32>,
            Option<<i32 as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfMaterialBasisSurchargeCredit(
            Option<i32>,
            Option<<i32 as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfMaterialBasisSurchargeTable(
            Option<super::DtMlstringType>,
            Option<<super::DtMlstringType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::UdxEdxfSurchargeElementTypeContent),
        Unknown__,
    }
    impl UdxEdxfSurchargeElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfSurchargeElementTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_TYPE")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_type(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_MANNER")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_manner(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_PERCENTAGE")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_percentage(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_PRICE_AMOUNT")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_price_amount(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_CALCULATION")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_calculation(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_WEIGHT")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis_weight(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_THRESHOLD")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis_surcharge_threshold(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_SHUTTER")
            ) {
                let output = <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis_surcharge_shutter(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_CREDIT")
            ) {
                let output = <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis_surcharge_credit(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_TABLE")
            ) {
                let output =
                    <super::DtMlstringType as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis_surcharge_table(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(UdxEdxfSurchargeElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: UdxEdxfSurchargeElementTypeContentDeserializerState,
        ) -> Result<super::UdxEdxfSurchargeElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::UdxEdxfSurchargeType(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_type(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargeType(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_TYPE".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargeManner(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_manner(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargeManner(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_MANNER".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargePercentage(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_percentage(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargePercentage(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_PERCENTAGE".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargePriceAmount(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_price_amount(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargePriceAmount(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_PRICE_AMOUNT".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargeCalculation(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_calculation(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargeCalculation(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_CALCULATION".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfMaterialBasis(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfMaterialBasis(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.MATERIAL_BASIS".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfMaterialBasisWeight(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_weight(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfMaterialBasisWeight(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.MATERIAL_BASIS_WEIGHT".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfMaterialBasisSurchargeThreshold(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_surcharge_threshold(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeThreshold (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_THRESHOLD" . into ())) ?))
                }
                S::UdxEdxfMaterialBasisSurchargeShutter(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_surcharge_shutter(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeShutter (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_SHUTTER" . into ())) ?))
                }
                S::UdxEdxfMaterialBasisSurchargeCredit(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_surcharge_credit(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeCredit (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_CREDIT" . into ())) ?))
                }
                S::UdxEdxfMaterialBasisSurchargeTable(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_surcharge_table(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeTable (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_TABLE" . into ())) ?))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_udx_edxf_surcharge_type(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_TYPE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_manner(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_MANNER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_percentage(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_PERCENTAGE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_price_amount(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_PRICE_AMOUNT",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_calculation(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_CALCULATION",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_weight(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_WEIGHT",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_surcharge_threshold(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_THRESHOLD",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_surcharge_shutter(
            values: &mut Option<i32>,
            value: i32,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_SHUTTER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_surcharge_credit(
            values: &mut Option<i32>,
            value: i32,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_CREDIT",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_surcharge_table(
            values: &mut Option<super::DtMlstringType>,
            value: super::DtMlstringType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_TABLE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_surcharge_type<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => UdxEdxfSurchargeElementTypeContentDeserializerState::Init__,
                    Some(
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                            _,
                            Some(deserializer),
                        ),
                    ) => UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_surcharge_type(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_type(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_manner<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => UdxEdxfSurchargeElementTypeContentDeserializerState::Init__,
                    Some(
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            _,
                            Some(deserializer),
                        ),
                    ) => {
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            values,
                            Some(deserializer),
                        )
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_surcharge_manner(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_manner(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_percentage<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargePercentage(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_surcharge_percentage(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_percentage(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_price_amount<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_surcharge_price_amount (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_price_amount(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_calculation<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_surcharge_calculation (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_calculation(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => UdxEdxfSurchargeElementTypeContentDeserializerState::Init__,
                    Some(
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                            _,
                            Some(deserializer),
                        ),
                    ) => UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_material_basis(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_weight<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasisWeight(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_material_basis_weight(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_weight(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_surcharge_threshold<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_material_basis_surcharge_threshold (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_surcharge_threshold(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_surcharge_shutter<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<i32>,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_material_basis_surcharge_shutter (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_surcharge_shutter(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_surcharge_credit<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<i32>,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_material_basis_surcharge_credit (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_surcharge_credit(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_surcharge_table<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::DtMlstringType>,
            output: DeserializerOutput<'de, super::DtMlstringType>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: Init__ , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_material_basis_surcharge_table (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_surcharge_table(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfSurchargeElementTypeContent>
        for UdxEdxfSurchargeElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(UdxEdxfSurchargeElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeElementTypeContent>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfSurchargeType(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_type(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeManner(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_manner(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargePercentage(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_percentage(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargePriceAmount(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_price_amount(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeCalculation(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_calculation(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasis(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisWeight(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_weight(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfMaterialBasisSurchargeThreshold(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_threshold(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfMaterialBasisSurchargeShutter(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_shutter(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeCredit(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_credit(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeTable(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_table(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::UdxEdxfSurchargeType(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_type(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeManner(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_manner(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargePercentage(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_percentage(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargePriceAmount(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_price_amount(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeCalculation(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_calculation(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasis(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_material_basis(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisWeight(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_material_basis_weight(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeThreshold(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_threshold(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeShutter(values, None), event) => {
                        let output = <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_shutter(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeCredit(values, None), event) => {
                        let output = <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_credit(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeTable(values, None), event) => {
                        let output =
                            <super::DtMlstringType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_udx_edxf_material_basis_surcharge_table(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::UdxEdxfSurchargeElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
}
pub mod quick_xml_serialize {
    use core::iter::Iterator;
    use xsd_parser::quick_xml::{
        write_attrib, write_attrib_opt, BytesEnd, BytesStart, Error, Event, IterSerializer,
        WithSerializer,
    };
    #[derive(Debug)]
    pub struct BmecatElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::BmecatElementType,
        pub(super) state: Box<BmecatElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum BmecatElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::BmecatElementTypeContent],
                super::BmecatElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BmecatElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BmecatElementTypeSerializerState::Init__ => {
                        *self.state = BmecatElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "version", &self.value.version)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    BmecatElementTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = BmecatElementTypeSerializerState::End__,
                    },
                    BmecatElementTypeSerializerState::End__ => {
                        *self.state = BmecatElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    BmecatElementTypeSerializerState::Done__ => return Ok(None),
                    BmecatElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BmecatElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BmecatElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct BmecatElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::BmecatElementTypeContent,
        pub(super) state: Box<BmecatElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum BmecatElementTypeContentSerializerState<'ser> {
        Init__,
        Header(<super::HeaderElementType as WithSerializer>::Serializer<'ser>),
        TNewCatalog(<super::TNewCatalogElementType as WithSerializer>::Serializer<'ser>),
        TUpdateProducts(<super::TUpdateProductsElementType as WithSerializer>::Serializer<'ser>),
        TUpdatePrices(<super::TUpdatePricesElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BmecatElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BmecatElementTypeContentSerializerState::Init__ => match self.value {
                        super::BmecatElementTypeContent::Header(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::Header(
                                WithSerializer::serializer(x, Some("HEADER"), false)?,
                            )
                        }
                        super::BmecatElementTypeContent::TNewCatalog(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::TNewCatalog(
                                WithSerializer::serializer(x, Some("T_NEW_CATALOG"), false)?,
                            )
                        }
                        super::BmecatElementTypeContent::TUpdateProducts(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::TUpdateProducts(
                                WithSerializer::serializer(x, Some("T_UPDATE_PRODUCTS"), false)?,
                            )
                        }
                        super::BmecatElementTypeContent::TUpdatePrices(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::TUpdatePrices(
                                WithSerializer::serializer(x, Some("T_UPDATE_PRICES"), false)?,
                            )
                        }
                    },
                    BmecatElementTypeContentSerializerState::Header(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::TNewCatalog(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::TUpdateProducts(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::TUpdatePrices(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::Done__ => return Ok(None),
                    BmecatElementTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BmecatElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BmecatElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct HeaderElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::HeaderElementType,
        pub(super) state: Box<HeaderElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum HeaderElementTypeSerializerState<'ser> {
        Init__,
        GeneratorInfo(IterSerializer<'ser, Option<&'ser String>, String>),
        Catalog(<super::CatalogElementType as WithSerializer>::Serializer<'ser>),
        Buyer(<super::BuyerElementType as WithSerializer>::Serializer<'ser>),
        Supplier(<super::SupplierElementType as WithSerializer>::Serializer<'ser>),
        UserDefinedExtensions(<super::UdxHeaderType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> HeaderElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    HeaderElementTypeSerializerState::Init__ => {
                        *self.state =
                            HeaderElementTypeSerializerState::GeneratorInfo(IterSerializer::new(
                                self.value.generator_info.as_ref(),
                                Some("GENERATOR_INFO"),
                                false,
                            ));
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    HeaderElementTypeSerializerState::GeneratorInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = HeaderElementTypeSerializerState::Catalog(
                                    WithSerializer::serializer(
                                        &self.value.catalog,
                                        Some("CATALOG"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    HeaderElementTypeSerializerState::Catalog(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                HeaderElementTypeSerializerState::Buyer(WithSerializer::serializer(
                                    &self.value.buyer,
                                    Some("BUYER"),
                                    false,
                                )?)
                        }
                    },
                    HeaderElementTypeSerializerState::Buyer(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = HeaderElementTypeSerializerState::Supplier(
                                WithSerializer::serializer(
                                    &self.value.supplier,
                                    Some("SUPPLIER"),
                                    false,
                                )?,
                            )
                        }
                    },
                    HeaderElementTypeSerializerState::Supplier(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = HeaderElementTypeSerializerState::UserDefinedExtensions(
                                WithSerializer::serializer(
                                    &self.value.user_defined_extensions,
                                    Some("USER_DEFINED_EXTENSIONS"),
                                    false,
                                )?,
                            )
                        }
                    },
                    HeaderElementTypeSerializerState::UserDefinedExtensions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = HeaderElementTypeSerializerState::End__,
                        }
                    }
                    HeaderElementTypeSerializerState::End__ => {
                        *self.state = HeaderElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    HeaderElementTypeSerializerState::Done__ => return Ok(None),
                    HeaderElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for HeaderElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = HeaderElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TNewCatalogElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TNewCatalogElementType,
        pub(super) state: Box<TNewCatalogElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TNewCatalogElementTypeSerializerState<'ser> {
        Init__,
        Product(
            IterSerializer<
                'ser,
                &'ser [super::TNewCatalogProductElementType],
                super::TNewCatalogProductElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TNewCatalogElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TNewCatalogElementTypeSerializerState::Init__ => {
                        *self.state = TNewCatalogElementTypeSerializerState::Product(
                            IterSerializer::new(&self.value.product[..], Some("PRODUCT"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TNewCatalogElementTypeSerializerState::Product(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TNewCatalogElementTypeSerializerState::End__,
                        }
                    }
                    TNewCatalogElementTypeSerializerState::End__ => {
                        *self.state = TNewCatalogElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TNewCatalogElementTypeSerializerState::Done__ => return Ok(None),
                    TNewCatalogElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TNewCatalogElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TNewCatalogElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TUpdateProductsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TUpdateProductsElementType,
        pub(super) state: Box<TUpdateProductsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TUpdateProductsElementTypeSerializerState<'ser> {
        Init__,
        Product(
            IterSerializer<
                'ser,
                &'ser [super::TUpdateProductsProductElementType],
                super::TUpdateProductsProductElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TUpdateProductsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TUpdateProductsElementTypeSerializerState::Init__ => {
                        *self.state = TUpdateProductsElementTypeSerializerState::Product(
                            IterSerializer::new(&self.value.product[..], Some("PRODUCT"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "prev_version", &self.value.prev_version)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TUpdateProductsElementTypeSerializerState::Product(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TUpdateProductsElementTypeSerializerState::End__,
                        }
                    }
                    TUpdateProductsElementTypeSerializerState::End__ => {
                        *self.state = TUpdateProductsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TUpdateProductsElementTypeSerializerState::Done__ => return Ok(None),
                    TUpdateProductsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TUpdateProductsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TUpdateProductsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TUpdatePricesElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TUpdatePricesElementType,
        pub(super) state: Box<TUpdatePricesElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TUpdatePricesElementTypeSerializerState<'ser> {
        Init__,
        Product(
            IterSerializer<
                'ser,
                &'ser [super::TUpdatePricesProductElementType],
                super::TUpdatePricesProductElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TUpdatePricesElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TUpdatePricesElementTypeSerializerState::Init__ => {
                        *self.state = TUpdatePricesElementTypeSerializerState::Product(
                            IterSerializer::new(&self.value.product[..], Some("PRODUCT"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "prev_version", &self.value.prev_version)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TUpdatePricesElementTypeSerializerState::Product(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TUpdatePricesElementTypeSerializerState::End__,
                        }
                    }
                    TUpdatePricesElementTypeSerializerState::End__ => {
                        *self.state = TUpdatePricesElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TUpdatePricesElementTypeSerializerState::Done__ => return Ok(None),
                    TUpdatePricesElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TUpdatePricesElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TUpdatePricesElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CatalogElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CatalogElementType,
        pub(super) state: Box<CatalogElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CatalogElementTypeSerializerState<'ser> {
        Init__,
        Language(
            IterSerializer<'ser, &'ser [super::LanguageElementType], super::LanguageElementType>,
        ),
        CatalogId(<String as WithSerializer>::Serializer<'ser>),
        CatalogVersion(<String as WithSerializer>::Serializer<'ser>),
        CatalogName(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        Datetime(<super::CatalogDatetimeElementType as WithSerializer>::Serializer<'ser>),
        Territory(IterSerializer<'ser, &'ser [String], String>),
        Currency(
            IterSerializer<'ser, Option<&'ser super::DtCurrenciesType>, super::DtCurrenciesType>,
        ),
        MimeRoot(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CatalogElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CatalogElementTypeSerializerState::Init__ => {
                        *self.state = CatalogElementTypeSerializerState::Language(
                            IterSerializer::new(&self.value.language[..], Some("LANGUAGE"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CatalogElementTypeSerializerState::Language(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CatalogElementTypeSerializerState::CatalogId(
                                WithSerializer::serializer(
                                    &self.value.catalog_id,
                                    Some("CATALOG_ID"),
                                    false,
                                )?,
                            )
                        }
                    },
                    CatalogElementTypeSerializerState::CatalogId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogElementTypeSerializerState::CatalogVersion(
                                    WithSerializer::serializer(
                                        &self.value.catalog_version,
                                        Some("CATALOG_VERSION"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    CatalogElementTypeSerializerState::CatalogVersion(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogElementTypeSerializerState::CatalogName(
                                    IterSerializer::new(
                                        &self.value.catalog_name[..],
                                        Some("CATALOG_NAME"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    CatalogElementTypeSerializerState::CatalogName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogElementTypeSerializerState::Datetime(
                                    WithSerializer::serializer(
                                        &self.value.datetime,
                                        Some("DATETIME"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    CatalogElementTypeSerializerState::Datetime(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CatalogElementTypeSerializerState::Territory(IterSerializer::new(
                                    &self.value.territory[..],
                                    Some("TERRITORY"),
                                    false,
                                ))
                        }
                    },
                    CatalogElementTypeSerializerState::Territory(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogElementTypeSerializerState::Currency(
                                    IterSerializer::new(
                                        self.value.currency.as_ref(),
                                        Some("CURRENCY"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    CatalogElementTypeSerializerState::Currency(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CatalogElementTypeSerializerState::MimeRoot(IterSerializer::new(
                                    &self.value.mime_root[..],
                                    Some("MIME_ROOT"),
                                    false,
                                ))
                        }
                    },
                    CatalogElementTypeSerializerState::MimeRoot(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CatalogElementTypeSerializerState::End__,
                    },
                    CatalogElementTypeSerializerState::End__ => {
                        *self.state = CatalogElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CatalogElementTypeSerializerState::Done__ => return Ok(None),
                    CatalogElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CatalogElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CatalogElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct BuyerElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::BuyerElementType,
        pub(super) state: Box<BuyerElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum BuyerElementTypeSerializerState<'ser> {
        Init__,
        BuyerId(IterSerializer<'ser, Option<&'ser super::TypePartyIdType>, super::TypePartyIdType>),
        BuyerName(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BuyerElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BuyerElementTypeSerializerState::Init__ => {
                        *self.state =
                            BuyerElementTypeSerializerState::BuyerId(IterSerializer::new(
                                self.value.buyer_id.as_ref(),
                                Some("BUYER_ID"),
                                false,
                            ));
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    BuyerElementTypeSerializerState::BuyerId(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = BuyerElementTypeSerializerState::BuyerName(
                                WithSerializer::serializer(
                                    &self.value.buyer_name,
                                    Some("BUYER_NAME"),
                                    false,
                                )?,
                            )
                        }
                    },
                    BuyerElementTypeSerializerState::BuyerName(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = BuyerElementTypeSerializerState::End__,
                    },
                    BuyerElementTypeSerializerState::End__ => {
                        *self.state = BuyerElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    BuyerElementTypeSerializerState::Done__ => return Ok(None),
                    BuyerElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BuyerElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BuyerElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplierElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplierElementType,
        pub(super) state: Box<SupplierElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplierElementTypeSerializerState<'ser> {
        Init__,
        SupplierId(IterSerializer<'ser, &'ser [super::TypePartyIdType], super::TypePartyIdType>),
        SupplierName(<String as WithSerializer>::Serializer<'ser>),
        Address(
            IterSerializer<
                'ser,
                Option<&'ser super::SupplierAddressElementType>,
                super::SupplierAddressElementType,
            >,
        ),
        MimeInfo(
            IterSerializer<
                'ser,
                Option<&'ser super::MimeInfoElementType>,
                super::MimeInfoElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplierElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SupplierElementTypeSerializerState::Init__ => {
                        *self.state =
                            SupplierElementTypeSerializerState::SupplierId(IterSerializer::new(
                                &self.value.supplier_id[..],
                                Some("SUPPLIER_ID"),
                                false,
                            ));
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SupplierElementTypeSerializerState::SupplierId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierElementTypeSerializerState::SupplierName(
                                    WithSerializer::serializer(
                                        &self.value.supplier_name,
                                        Some("SUPPLIER_NAME"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    SupplierElementTypeSerializerState::SupplierName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierElementTypeSerializerState::Address(
                                    IterSerializer::new(
                                        self.value.address.as_ref(),
                                        Some("ADDRESS"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SupplierElementTypeSerializerState::Address(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                SupplierElementTypeSerializerState::MimeInfo(IterSerializer::new(
                                    self.value.mime_info.as_ref(),
                                    Some("MIME_INFO"),
                                    false,
                                ))
                        }
                    },
                    SupplierElementTypeSerializerState::MimeInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SupplierElementTypeSerializerState::End__,
                        }
                    }
                    SupplierElementTypeSerializerState::End__ => {
                        *self.state = SupplierElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SupplierElementTypeSerializerState::Done__ => return Ok(None),
                    SupplierElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SupplierElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplierElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxHeaderTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxHeaderType,
        pub(super) state: Box<UdxHeaderTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxHeaderTypeSerializerState<'ser> {
        Init__,
        UdxEdxfVersion(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxHeaderTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxHeaderTypeSerializerState::Init__ => {
                        *self.state = UdxHeaderTypeSerializerState::UdxEdxfVersion(
                            WithSerializer::serializer(
                                &self.value.udx_edxf_version,
                                Some("UDX.EDXF.VERSION"),
                                false,
                            )?,
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxHeaderTypeSerializerState::UdxEdxfVersion(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxHeaderTypeSerializerState::End__,
                        }
                    }
                    UdxHeaderTypeSerializerState::End__ => {
                        *self.state = UdxHeaderTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxHeaderTypeSerializerState::Done__ => return Ok(None),
                    UdxHeaderTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxHeaderTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxHeaderTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TNewCatalogProductElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TNewCatalogProductElementType,
        pub(super) state: Box<TNewCatalogProductElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TNewCatalogProductElementTypeSerializerState<'ser> {
        Init__,
        SupplierPid(<super::SupplierPidElementType as WithSerializer>::Serializer<'ser>),
        ProductDetails(<super::ProductDetailsElementType as WithSerializer>::Serializer<'ser>),
        ProductFeatures(
            IterSerializer<
                'ser,
                &'ser [super::ProductFeaturesElementType],
                super::ProductFeaturesElementType,
            >,
        ),
        ProductOrderDetails(
            <super::ProductOrderDetailsElementType as WithSerializer>::Serializer<'ser>,
        ),
        ProductPriceDetails(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceDetailsElementType],
                super::ProductPriceDetailsElementType,
            >,
        ),
        MimeInfo(
            IterSerializer<
                'ser,
                Option<&'ser super::MimeInfoElementType>,
                super::MimeInfoElementType,
            >,
        ),
        UserDefinedExtensions(<super::UdxProductType as WithSerializer>::Serializer<'ser>),
        ProductReference(
            IterSerializer<
                'ser,
                &'ser [super::ProductReferenceElementType],
                super::ProductReferenceElementType,
            >,
        ),
        ProductLogisticDetails(
            IterSerializer<
                'ser,
                Option<&'ser super::ProductLogisticDetailsElementType>,
                super::ProductLogisticDetailsElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TNewCatalogProductElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TNewCatalogProductElementTypeSerializerState::Init__ => {
                        *self.state = TNewCatalogProductElementTypeSerializerState::SupplierPid(
                            WithSerializer::serializer(
                                &self.value.supplier_pid,
                                Some("SUPPLIER_PID"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "mode", &self.value.mode)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TNewCatalogProductElementTypeSerializerState::SupplierPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TNewCatalogProductElementTypeSerializerState::ProductDetails(
                                        WithSerializer::serializer(
                                            &self.value.product_details,
                                            Some("PRODUCT_DETAILS"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TNewCatalogProductElementTypeSerializerState::ProductFeatures(
                                        IterSerializer::new(
                                            &self.value.product_features[..],
                                            Some("PRODUCT_FEATURES"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductFeatures(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TNewCatalogProductElementTypeSerializerState::ProductOrderDetails(
                                    WithSerializer::serializer(
                                        &self.value.product_order_details,
                                        Some("PRODUCT_ORDER_DETAILS"),
                                        false,
                                    )?,
                                ),
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductOrderDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TNewCatalogProductElementTypeSerializerState::ProductPriceDetails(
                                    IterSerializer::new(
                                        &self.value.product_price_details[..],
                                        Some("PRODUCT_PRICE_DETAILS"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductPriceDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TNewCatalogProductElementTypeSerializerState::MimeInfo(
                                    IterSerializer::new(
                                        self.value.mime_info.as_ref(),
                                        Some("MIME_INFO"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::MimeInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TNewCatalogProductElementTypeSerializerState::UserDefinedExtensions(
                                    WithSerializer::serializer(
                                        &self.value.user_defined_extensions,
                                        Some("USER_DEFINED_EXTENSIONS"),
                                        false,
                                    )?,
                                ),
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::UserDefinedExtensions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TNewCatalogProductElementTypeSerializerState::ProductReference(
                                        IterSerializer::new(
                                            &self.value.product_reference[..],
                                            Some("PRODUCT_REFERENCE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductReference(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TNewCatalogProductElementTypeSerializerState::ProductLogisticDetails(
                                    IterSerializer::new(
                                        self.value.product_logistic_details.as_ref(),
                                        Some("PRODUCT_LOGISTIC_DETAILS"),
                                        false,
                                    ),
                                )
                        }
                    },
                    TNewCatalogProductElementTypeSerializerState::ProductLogisticDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TNewCatalogProductElementTypeSerializerState::End__
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::End__ => {
                        *self.state = TNewCatalogProductElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TNewCatalogProductElementTypeSerializerState::Done__ => return Ok(None),
                    TNewCatalogProductElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TNewCatalogProductElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TNewCatalogProductElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TUpdateProductsProductElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TUpdateProductsProductElementType,
        pub(super) state: Box<TUpdateProductsProductElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TUpdateProductsProductElementTypeSerializerState<'ser> {
        Init__,
        SupplierPid(<super::SupplierPidElementType as WithSerializer>::Serializer<'ser>),
        ProductDetails(<super::ProductDetailsElementType as WithSerializer>::Serializer<'ser>),
        ProductFeatures(
            IterSerializer<
                'ser,
                &'ser [super::ProductFeaturesElementType],
                super::ProductFeaturesElementType,
            >,
        ),
        ProductOrderDetails(
            <super::ProductOrderDetailsElementType as WithSerializer>::Serializer<'ser>,
        ),
        ProductPriceDetails(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceDetailsElementType],
                super::ProductPriceDetailsElementType,
            >,
        ),
        MimeInfo(
            IterSerializer<
                'ser,
                Option<&'ser super::MimeInfoElementType>,
                super::MimeInfoElementType,
            >,
        ),
        UserDefinedExtensions(
            IterSerializer<'ser, Option<&'ser super::UdxProductType>, super::UdxProductType>,
        ),
        ProductReference(
            IterSerializer<
                'ser,
                &'ser [super::ProductReferenceElementType],
                super::ProductReferenceElementType,
            >,
        ),
        ProductLogisticDetails(
            IterSerializer<
                'ser,
                Option<&'ser super::ProductLogisticDetailsElementType>,
                super::ProductLogisticDetailsElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TUpdateProductsProductElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { TUpdateProductsProductElementTypeSerializerState :: Init__ => { * self . state = TUpdateProductsProductElementTypeSerializerState :: SupplierPid (WithSerializer :: serializer (& self . value . supplier_pid , Some ("SUPPLIER_PID") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; write_attrib (& mut bytes , "mode" , & self . value . mode) ? ; return Ok (Some (Event :: Start (bytes))) } TUpdateProductsProductElementTypeSerializerState :: SupplierPid (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductDetails (WithSerializer :: serializer (& self . value . product_details , Some ("PRODUCT_DETAILS") , false) ?) , } TUpdateProductsProductElementTypeSerializerState :: ProductDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductFeatures (IterSerializer :: new (& self . value . product_features [..] , Some ("PRODUCT_FEATURES") , false)) , } TUpdateProductsProductElementTypeSerializerState :: ProductFeatures (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductOrderDetails (WithSerializer :: serializer (& self . value . product_order_details , Some ("PRODUCT_ORDER_DETAILS") , false) ?) , } TUpdateProductsProductElementTypeSerializerState :: ProductOrderDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductPriceDetails (IterSerializer :: new (& self . value . product_price_details [..] , Some ("PRODUCT_PRICE_DETAILS") , false)) , } TUpdateProductsProductElementTypeSerializerState :: ProductPriceDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: MimeInfo (IterSerializer :: new (self . value . mime_info . as_ref () , Some ("MIME_INFO") , false)) , } TUpdateProductsProductElementTypeSerializerState :: MimeInfo (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: UserDefinedExtensions (IterSerializer :: new (self . value . user_defined_extensions . as_ref () , Some ("USER_DEFINED_EXTENSIONS") , false)) , } TUpdateProductsProductElementTypeSerializerState :: UserDefinedExtensions (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductReference (IterSerializer :: new (& self . value . product_reference [..] , Some ("PRODUCT_REFERENCE") , false)) , } TUpdateProductsProductElementTypeSerializerState :: ProductReference (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductLogisticDetails (IterSerializer :: new (self . value . product_logistic_details . as_ref () , Some ("PRODUCT_LOGISTIC_DETAILS") , false)) , } TUpdateProductsProductElementTypeSerializerState :: ProductLogisticDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: End__ , } TUpdateProductsProductElementTypeSerializerState :: End__ => { * self . state = TUpdateProductsProductElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } TUpdateProductsProductElementTypeSerializerState :: Done__ => return Ok (None) , TUpdateProductsProductElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for TUpdateProductsProductElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TUpdateProductsProductElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TUpdatePricesProductElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TUpdatePricesProductElementType,
        pub(super) state: Box<TUpdatePricesProductElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TUpdatePricesProductElementTypeSerializerState<'ser> {
        Init__,
        SupplierPid(<super::SupplierPidElementType as WithSerializer>::Serializer<'ser>),
        ProductPriceDetails(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceDetailsElementType],
                super::ProductPriceDetailsElementType,
            >,
        ),
        UserDefinedExtensions(
            IterSerializer<'ser, Option<&'ser super::UdxProductType>, super::UdxProductType>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TUpdatePricesProductElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { TUpdatePricesProductElementTypeSerializerState :: Init__ => { * self . state = TUpdatePricesProductElementTypeSerializerState :: SupplierPid (WithSerializer :: serializer (& self . value . supplier_pid , Some ("SUPPLIER_PID") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; write_attrib (& mut bytes , "mode" , & self . value . mode) ? ; return Ok (Some (Event :: Start (bytes))) } TUpdatePricesProductElementTypeSerializerState :: SupplierPid (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdatePricesProductElementTypeSerializerState :: ProductPriceDetails (IterSerializer :: new (& self . value . product_price_details [..] , Some ("PRODUCT_PRICE_DETAILS") , false)) , } TUpdatePricesProductElementTypeSerializerState :: ProductPriceDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdatePricesProductElementTypeSerializerState :: UserDefinedExtensions (IterSerializer :: new (self . value . user_defined_extensions . as_ref () , Some ("USER_DEFINED_EXTENSIONS") , false)) , } TUpdatePricesProductElementTypeSerializerState :: UserDefinedExtensions (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdatePricesProductElementTypeSerializerState :: End__ , } TUpdatePricesProductElementTypeSerializerState :: End__ => { * self . state = TUpdatePricesProductElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } TUpdatePricesProductElementTypeSerializerState :: Done__ => return Ok (None) , TUpdatePricesProductElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for TUpdatePricesProductElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TUpdatePricesProductElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LanguageElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::LanguageElementType,
        pub(super) state: Box<LanguageElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LanguageElementTypeSerializerState<'ser> {
        Init__,
        Content__(<super::DtLangType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LanguageElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    LanguageElementTypeSerializerState::Init__ => {
                        *self.state = LanguageElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "default", &self.value.default)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    LanguageElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = LanguageElementTypeSerializerState::End__,
                        }
                    }
                    LanguageElementTypeSerializerState::End__ => {
                        *self.state = LanguageElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    LanguageElementTypeSerializerState::Done__ => return Ok(None),
                    LanguageElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for LanguageElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LanguageElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DtMlstringTypeSerializer<'ser> {
        pub(super) value: &'ser super::DtMlstringType,
        pub(super) state: Box<DtMlstringTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DtMlstringTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DtMlstringTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DtMlstringTypeSerializerState::Init__ => {
                        *self.state = DtMlstringTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DtMlstringTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DtMlstringTypeSerializerState::End__,
                    },
                    DtMlstringTypeSerializerState::End__ => {
                        *self.state = DtMlstringTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DtMlstringTypeSerializerState::Done__ => return Ok(None),
                    DtMlstringTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DtMlstringTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DtMlstringTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CatalogDatetimeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CatalogDatetimeElementType,
        pub(super) state: Box<CatalogDatetimeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CatalogDatetimeElementTypeSerializerState<'ser> {
        Init__,
        Date(<String as WithSerializer>::Serializer<'ser>),
        Time(IterSerializer<'ser, Option<&'ser String>, String>),
        Timezone(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CatalogDatetimeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CatalogDatetimeElementTypeSerializerState::Init__ => {
                        *self.state = CatalogDatetimeElementTypeSerializerState::Date(
                            WithSerializer::serializer(&self.value.date, Some("DATE"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CatalogDatetimeElementTypeSerializerState::Date(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CatalogDatetimeElementTypeSerializerState::Time(
                                IterSerializer::new(self.value.time.as_ref(), Some("TIME"), false),
                            )
                        }
                    },
                    CatalogDatetimeElementTypeSerializerState::Time(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogDatetimeElementTypeSerializerState::Timezone(
                                    IterSerializer::new(
                                        self.value.timezone.as_ref(),
                                        Some("TIMEZONE"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    CatalogDatetimeElementTypeSerializerState::Timezone(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CatalogDatetimeElementTypeSerializerState::End__,
                        }
                    }
                    CatalogDatetimeElementTypeSerializerState::End__ => {
                        *self.state = CatalogDatetimeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CatalogDatetimeElementTypeSerializerState::Done__ => return Ok(None),
                    CatalogDatetimeElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CatalogDatetimeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CatalogDatetimeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TypePartyIdTypeSerializer<'ser> {
        pub(super) value: &'ser super::TypePartyIdType,
        pub(super) state: Box<TypePartyIdTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TypePartyIdTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TypePartyIdTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TypePartyIdTypeSerializerState::Init__ => {
                        *self.state = TypePartyIdTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TypePartyIdTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = TypePartyIdTypeSerializerState::End__,
                    },
                    TypePartyIdTypeSerializerState::End__ => {
                        *self.state = TypePartyIdTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TypePartyIdTypeSerializerState::Done__ => return Ok(None),
                    TypePartyIdTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TypePartyIdTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TypePartyIdTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplierAddressElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplierAddressElementType,
        pub(super) state: Box<SupplierAddressElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplierAddressElementTypeSerializerState<'ser> {
        Init__,
        Contact(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        Street(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        Zip(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        City(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        Country(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        VatId(IterSerializer<'ser, Option<&'ser String>, String>),
        Email(<String as WithSerializer>::Serializer<'ser>),
        Url(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplierAddressElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SupplierAddressElementTypeSerializerState::Init__ => {
                        *self.state = SupplierAddressElementTypeSerializerState::Contact(
                            IterSerializer::new(&self.value.contact[..], Some("CONTACT"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SupplierAddressElementTypeSerializerState::Contact(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = SupplierAddressElementTypeSerializerState::Street(
                                IterSerializer::new(&self.value.street[..], Some("STREET"), false),
                            )
                        }
                    },
                    SupplierAddressElementTypeSerializerState::Street(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::Zip(
                                    IterSerializer::new(&self.value.zip[..], Some("ZIP"), false),
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::Zip(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::City(
                                    IterSerializer::new(&self.value.city[..], Some("CITY"), false),
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::City(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::Country(
                                    IterSerializer::new(
                                        &self.value.country[..],
                                        Some("COUNTRY"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::Country(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::VatId(
                                    IterSerializer::new(
                                        self.value.vat_id.as_ref(),
                                        Some("VAT_ID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::VatId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::Email(
                                    WithSerializer::serializer(
                                        &self.value.email,
                                        Some("EMAIL"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::Email(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = SupplierAddressElementTypeSerializerState::Url(
                                IterSerializer::new(self.value.url.as_ref(), Some("URL"), false),
                            )
                        }
                    },
                    SupplierAddressElementTypeSerializerState::Url(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SupplierAddressElementTypeSerializerState::End__,
                        }
                    }
                    SupplierAddressElementTypeSerializerState::End__ => {
                        *self.state = SupplierAddressElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SupplierAddressElementTypeSerializerState::Done__ => return Ok(None),
                    SupplierAddressElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SupplierAddressElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplierAddressElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct MimeInfoElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::MimeInfoElementType,
        pub(super) state: Box<MimeInfoElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum MimeInfoElementTypeSerializerState<'ser> {
        Init__,
        Mime(IterSerializer<'ser, &'ser [super::MimeElementType], super::MimeElementType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> MimeInfoElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    MimeInfoElementTypeSerializerState::Init__ => {
                        *self.state = MimeInfoElementTypeSerializerState::Mime(
                            IterSerializer::new(&self.value.mime[..], Some("MIME"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    MimeInfoElementTypeSerializerState::Mime(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = MimeInfoElementTypeSerializerState::End__,
                    },
                    MimeInfoElementTypeSerializerState::End__ => {
                        *self.state = MimeInfoElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    MimeInfoElementTypeSerializerState::Done__ => return Ok(None),
                    MimeInfoElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for MimeInfoElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = MimeInfoElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplierPidElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplierPidElementType,
        pub(super) state: Box<SupplierPidElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplierPidElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplierPidElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SupplierPidElementTypeSerializerState::Init__ => {
                        *self.state = SupplierPidElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SupplierPidElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SupplierPidElementTypeSerializerState::End__,
                        }
                    }
                    SupplierPidElementTypeSerializerState::End__ => {
                        *self.state = SupplierPidElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SupplierPidElementTypeSerializerState::Done__ => return Ok(None),
                    SupplierPidElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SupplierPidElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplierPidElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductDetailsElementType,
        pub(super) state: Box<ProductDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductDetailsElementTypeSerializerState<'ser> {
        Init__,
        DescriptionShort(
            IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>,
        ),
        DescriptionLong(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        InternationalPid(
            IterSerializer<
                'ser,
                &'ser [super::InternationalPidElementType],
                super::InternationalPidElementType,
            >,
        ),
        SupplierAltPid(IterSerializer<'ser, Option<&'ser String>, String>),
        BuyerPid(
            IterSerializer<'ser, &'ser [super::BuyerPidElementType], super::BuyerPidElementType>,
        ),
        ManufacturerPid(IterSerializer<'ser, Option<&'ser String>, String>),
        ManufacturerName(IterSerializer<'ser, Option<&'ser String>, String>),
        ManufacturerTypeDescr(
            IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>,
        ),
        SpecialTreatmentClass(
            IterSerializer<
                'ser,
                &'ser [super::SpecialTreatmentClassElementType],
                super::SpecialTreatmentClassElementType,
            >,
        ),
        Keyword(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        Remarks(IterSerializer<'ser, &'ser [super::RemarksElementType], super::RemarksElementType>),
        ProductStatus(
            IterSerializer<
                'ser,
                &'ser [super::ProductStatusElementType],
                super::ProductStatusElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductDetailsElementTypeSerializerState::Init__ => {
                        *self.state = ProductDetailsElementTypeSerializerState::DescriptionShort(
                            IterSerializer::new(
                                &self.value.description_short[..],
                                Some("DESCRIPTION_SHORT"),
                                false,
                            ),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductDetailsElementTypeSerializerState::DescriptionShort(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::DescriptionLong(
                                        IterSerializer::new(
                                            &self.value.description_long[..],
                                            Some("DESCRIPTION_LONG"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::DescriptionLong(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::InternationalPid(
                                        IterSerializer::new(
                                            &self.value.international_pid[..],
                                            Some("INTERNATIONAL_PID"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::InternationalPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::SupplierAltPid(
                                        IterSerializer::new(
                                            self.value.supplier_alt_pid.as_ref(),
                                            Some("SUPPLIER_ALT_PID"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::SupplierAltPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductDetailsElementTypeSerializerState::BuyerPid(
                                    IterSerializer::new(
                                        &self.value.buyer_pid[..],
                                        Some("BUYER_PID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::BuyerPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::ManufacturerPid(
                                        IterSerializer::new(
                                            self.value.manufacturer_pid.as_ref(),
                                            Some("MANUFACTURER_PID"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ManufacturerPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::ManufacturerName(
                                        IterSerializer::new(
                                            self.value.manufacturer_name.as_ref(),
                                            Some("MANUFACTURER_NAME"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ManufacturerName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::ManufacturerTypeDescr(
                                        IterSerializer::new(
                                            &self.value.manufacturer_type_descr[..],
                                            Some("MANUFACTURER_TYPE_DESCR"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ManufacturerTypeDescr(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::SpecialTreatmentClass(
                                        IterSerializer::new(
                                            &self.value.special_treatment_class[..],
                                            Some("SPECIAL_TREATMENT_CLASS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::SpecialTreatmentClass(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductDetailsElementTypeSerializerState::Keyword(
                                    IterSerializer::new(
                                        &self.value.keyword[..],
                                        Some("KEYWORD"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::Keyword(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductDetailsElementTypeSerializerState::Remarks(
                                    IterSerializer::new(
                                        &self.value.remarks[..],
                                        Some("REMARKS"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::Remarks(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::ProductStatus(
                                        IterSerializer::new(
                                            &self.value.product_status[..],
                                            Some("PRODUCT_STATUS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ProductStatus(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductDetailsElementTypeSerializerState::End__,
                        }
                    }
                    ProductDetailsElementTypeSerializerState::End__ => {
                        *self.state = ProductDetailsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductDetailsElementTypeSerializerState::Done__ => return Ok(None),
                    ProductDetailsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductFeaturesElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductFeaturesElementType,
        pub(super) state: Box<ProductFeaturesElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductFeaturesElementTypeSerializerState<'ser> {
        Init__,
        ReferenceFeatureSystemName(<String as WithSerializer>::Serializer<'ser>),
        ReferenceFeatureGroupId(
            <super::TypeClassificationGroupIdType as WithSerializer>::Serializer<'ser>,
        ),
        Feature(IterSerializer<'ser, &'ser [super::FeatureElementType], super::FeatureElementType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductFeaturesElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductFeaturesElementTypeSerializerState::Init__ => {
                        *self.state =
                            ProductFeaturesElementTypeSerializerState::ReferenceFeatureSystemName(
                                WithSerializer::serializer(
                                    &self.value.reference_feature_system_name,
                                    Some("REFERENCE_FEATURE_SYSTEM_NAME"),
                                    false,
                                )?,
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductFeaturesElementTypeSerializerState::ReferenceFeatureSystemName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                ProductFeaturesElementTypeSerializerState::ReferenceFeatureGroupId(
                                    WithSerializer::serializer(
                                        &self.value.reference_feature_group_id,
                                        Some("REFERENCE_FEATURE_GROUP_ID"),
                                        false,
                                    )?,
                                ),
                        }
                    }
                    ProductFeaturesElementTypeSerializerState::ReferenceFeatureGroupId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductFeaturesElementTypeSerializerState::Feature(
                                    IterSerializer::new(
                                        &self.value.feature[..],
                                        Some("FEATURE"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductFeaturesElementTypeSerializerState::Feature(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductFeaturesElementTypeSerializerState::End__,
                        }
                    }
                    ProductFeaturesElementTypeSerializerState::End__ => {
                        *self.state = ProductFeaturesElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductFeaturesElementTypeSerializerState::Done__ => return Ok(None),
                    ProductFeaturesElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductFeaturesElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductFeaturesElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductOrderDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductOrderDetailsElementType,
        pub(super) state: Box<ProductOrderDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductOrderDetailsElementTypeSerializerState<'ser> {
        Init__,
        OrderUnit(<super::DtPunitType as WithSerializer>::Serializer<'ser>),
        ContentUnit(<super::DtPunitType as WithSerializer>::Serializer<'ser>),
        NoCuPerOu(IterSerializer<'ser, Option<&'ser f64>, f64>),
        PriceQuantity(IterSerializer<'ser, Option<&'ser f64>, f64>),
        QuantityMin(IterSerializer<'ser, Option<&'ser f32>, f32>),
        QuantityInterval(IterSerializer<'ser, Option<&'ser f32>, f32>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductOrderDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductOrderDetailsElementTypeSerializerState::Init__ => {
                        *self.state = ProductOrderDetailsElementTypeSerializerState::OrderUnit(
                            WithSerializer::serializer(
                                &self.value.order_unit,
                                Some("ORDER_UNIT"),
                                false,
                            )?,
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductOrderDetailsElementTypeSerializerState::OrderUnit(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::ContentUnit(
                                        WithSerializer::serializer(
                                            &self.value.content_unit,
                                            Some("CONTENT_UNIT"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::ContentUnit(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::NoCuPerOu(
                                        IterSerializer::new(
                                            self.value.no_cu_per_ou.as_ref(),
                                            Some("NO_CU_PER_OU"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::NoCuPerOu(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::PriceQuantity(
                                        IterSerializer::new(
                                            self.value.price_quantity.as_ref(),
                                            Some("PRICE_QUANTITY"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::PriceQuantity(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::QuantityMin(
                                        IterSerializer::new(
                                            self.value.quantity_min.as_ref(),
                                            Some("QUANTITY_MIN"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::QuantityMin(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::QuantityInterval(
                                        IterSerializer::new(
                                            self.value.quantity_interval.as_ref(),
                                            Some("QUANTITY_INTERVAL"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::QuantityInterval(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = ProductOrderDetailsElementTypeSerializerState::End__,
                    },
                    ProductOrderDetailsElementTypeSerializerState::End__ => {
                        *self.state = ProductOrderDetailsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductOrderDetailsElementTypeSerializerState::Done__ => return Ok(None),
                    ProductOrderDetailsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductOrderDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductOrderDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductPriceDetailsElementType,
        pub(super) state: Box<ProductPriceDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductPriceDetailsElementTypeSerializerState<'ser> {
        Init__,
        Datetime(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceDetailsDatetimeElementType],
                super::ProductPriceDetailsDatetimeElementType,
            >,
        ),
        DailyPrice(IterSerializer<'ser, Option<&'ser String>, String>),
        ProductPrice(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceElementType],
                super::ProductPriceElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductPriceDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductPriceDetailsElementTypeSerializerState::Init__ => {
                        *self.state = ProductPriceDetailsElementTypeSerializerState::Datetime(
                            IterSerializer::new(&self.value.datetime[..], Some("DATETIME"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductPriceDetailsElementTypeSerializerState::Datetime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsElementTypeSerializerState::DailyPrice(
                                        IterSerializer::new(
                                            self.value.daily_price.as_ref(),
                                            Some("DAILY_PRICE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductPriceDetailsElementTypeSerializerState::DailyPrice(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsElementTypeSerializerState::ProductPrice(
                                        IterSerializer::new(
                                            &self.value.product_price[..],
                                            Some("PRODUCT_PRICE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductPriceDetailsElementTypeSerializerState::ProductPrice(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = ProductPriceDetailsElementTypeSerializerState::End__,
                    },
                    ProductPriceDetailsElementTypeSerializerState::End__ => {
                        *self.state = ProductPriceDetailsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductPriceDetailsElementTypeSerializerState::Done__ => return Ok(None),
                    ProductPriceDetailsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductPriceDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductPriceDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxProductTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxProductType,
        pub(super) state: Box<UdxProductTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxProductTypeSerializerState<'ser> {
        Init__,
        UdxEdxfManufacturerAcronym(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfDescriptionVeryShort(
            IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>,
        ),
        UdxEdxfBrandName(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfTenderText(
            IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>,
        ),
        UdxEdxfValidFrom(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfExpirationDate(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfDiscountGroup(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfDiscountGroupElementType>,
                super::UdxEdxfDiscountGroupElementType,
            >,
        ),
        UdxEdxfBonusGroupSupplier(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfPkwiu(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfDeclaration(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfDeclarationElementType],
                super::UdxEdxfDeclarationElementType,
            >,
        ),
        UdxEdxfAdditionalFactors(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfAdditionalFactorsElementType>,
                super::UdxEdxfAdditionalFactorsElementType,
            >,
        ),
        UdxEdxfProductToStock(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfProductSeries(
            IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>,
        ),
        UdxEdxfProductVariation(
            IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>,
        ),
        UdxEdxfAtReverseChargeInfo(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfCountryBranchNumbers(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfCountryBranchNumbersElementType>,
                super::UdxEdxfCountryBranchNumbersElementType,
            >,
        ),
        UdxEdxfCountryBranchSupplierIds(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfCountryBranchSupplierIdsElementType>,
                super::UdxEdxfCountryBranchSupplierIdsElementType,
            >,
        ),
        UdxEdxfPackingUnits(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfPackingUnitsElementType>,
                super::UdxEdxfPackingUnitsElementType,
            >,
        ),
        UdxEdxfProductLogisticDetails(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfProductLogisticDetailsElementType>,
                super::UdxEdxfProductLogisticDetailsElementType,
            >,
        ),
        UdxEdxfReach(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfReachElementType>,
                super::UdxEdxfReachElementType,
            >,
        ),
        UdxEdxfSurchargeList(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfSurchargeListElementType>,
                super::UdxEdxfSurchargeListElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxProductTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxProductTypeSerializerState::Init__ => {
                        *self.state = UdxProductTypeSerializerState::UdxEdxfManufacturerAcronym(
                            IterSerializer::new(
                                self.value.udx_edxf_manufacturer_acronym.as_ref(),
                                Some("UDX.EDXF.MANUFACTURER_ACRONYM"),
                                false,
                            ),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxProductTypeSerializerState::UdxEdxfManufacturerAcronym(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductTypeSerializerState::UdxEdxfDescriptionVeryShort(
                                        IterSerializer::new(
                                            &self.value.udx_edxf_description_very_short[..],
                                            Some("UDX.EDXF.DESCRIPTION_VERY_SHORT"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfDescriptionVeryShort(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfBrandName(
                                    IterSerializer::new(
                                        self.value.udx_edxf_brand_name.as_ref(),
                                        Some("UDX.EDXF.BRAND_NAME"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfBrandName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfTenderText(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_tender_text[..],
                                        Some("UDX.EDXF.TENDER_TEXT"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfTenderText(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfValidFrom(
                                    IterSerializer::new(
                                        self.value.udx_edxf_valid_from.as_ref(),
                                        Some("UDX.EDXF.VALID_FROM"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfValidFrom(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfExpirationDate(
                                    IterSerializer::new(
                                        self.value.udx_edxf_expiration_date.as_ref(),
                                        Some("UDX.EDXF.EXPIRATION_DATE"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfExpirationDate(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfDiscountGroup(
                                    IterSerializer::new(
                                        self.value.udx_edxf_discount_group.as_ref(),
                                        Some("UDX.EDXF.DISCOUNT_GROUP"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfDiscountGroup(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductTypeSerializerState::UdxEdxfBonusGroupSupplier(
                                        IterSerializer::new(
                                            self.value.udx_edxf_bonus_group_supplier.as_ref(),
                                            Some("UDX.EDXF.BONUS_GROUP_SUPPLIER"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfBonusGroupSupplier(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfPkwiu(
                                    IterSerializer::new(
                                        self.value.udx_edxf_pkwiu.as_ref(),
                                        Some("UDX.EDXF.PKWIU"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfPkwiu(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = UdxProductTypeSerializerState::UdxEdxfDeclaration(
                                IterSerializer::new(
                                    &self.value.udx_edxf_declaration[..],
                                    Some("UDX.EDXF.DECLARATION"),
                                    false,
                                ),
                            )
                        }
                    },
                    UdxProductTypeSerializerState::UdxEdxfDeclaration(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductTypeSerializerState::UdxEdxfAdditionalFactors(
                                        IterSerializer::new(
                                            self.value.udx_edxf_additional_factors.as_ref(),
                                            Some("UDX.EDXF.ADDITIONAL_FACTORS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfAdditionalFactors(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfProductToStock(
                                    IterSerializer::new(
                                        self.value.udx_edxf_product_to_stock.as_ref(),
                                        Some("UDX.EDXF.PRODUCT_TO_STOCK"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfProductToStock(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfProductSeries(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_product_series[..],
                                        Some("UDX.EDXF.PRODUCT_SERIES"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfProductSeries(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfProductVariation(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_product_variation[..],
                                        Some("UDX.EDXF.PRODUCT_VARIATION"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfProductVariation(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductTypeSerializerState::UdxEdxfAtReverseChargeInfo(
                                        IterSerializer::new(
                                            self.value.udx_edxf_at_reverse_charge_info.as_ref(),
                                            Some("UDX.EDXF.AT.REVERSE_CHARGE_INFO"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfAtReverseChargeInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductTypeSerializerState::UdxEdxfCountryBranchNumbers(
                                        IterSerializer::new(
                                            self.value.udx_edxf_country_branch_numbers.as_ref(),
                                            Some("UDX.EDXF.COUNTRY_BRANCH_NUMBERS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfCountryBranchNumbers(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                UdxProductTypeSerializerState::UdxEdxfCountryBranchSupplierIds(
                                    IterSerializer::new(
                                        self.value.udx_edxf_country_branch_supplier_ids.as_ref(),
                                        Some("UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS"),
                                        false,
                                    ),
                                )
                        }
                    },
                    UdxProductTypeSerializerState::UdxEdxfCountryBranchSupplierIds(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfPackingUnits(
                                    IterSerializer::new(
                                        self.value.udx_edxf_packing_units.as_ref(),
                                        Some("UDX.EDXF.PACKING_UNITS"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfPackingUnits(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductTypeSerializerState::UdxEdxfProductLogisticDetails(
                                        IterSerializer::new(
                                            self.value.udx_edxf_product_logistic_details.as_ref(),
                                            Some("UDX.EDXF.PRODUCT_LOGISTIC_DETAILS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfProductLogisticDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductTypeSerializerState::UdxEdxfReach(
                                    IterSerializer::new(
                                        self.value.udx_edxf_reach.as_ref(),
                                        Some("UDX.EDXF.REACH"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductTypeSerializerState::UdxEdxfReach(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = UdxProductTypeSerializerState::UdxEdxfSurchargeList(
                                IterSerializer::new(
                                    self.value.udx_edxf_surcharge_list.as_ref(),
                                    Some("UDX.EDXF.SURCHARGE_LIST"),
                                    false,
                                ),
                            )
                        }
                    },
                    UdxProductTypeSerializerState::UdxEdxfSurchargeList(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxProductTypeSerializerState::End__,
                        }
                    }
                    UdxProductTypeSerializerState::End__ => {
                        *self.state = UdxProductTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxProductTypeSerializerState::Done__ => return Ok(None),
                    UdxProductTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxProductTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxProductTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductReferenceElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductReferenceElementType,
        pub(super) state: Box<ProductReferenceElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductReferenceElementTypeSerializerState<'ser> {
        Init__,
        ProdIdTo(<String as WithSerializer>::Serializer<'ser>),
        CatalogId(IterSerializer<'ser, Option<&'ser String>, String>),
        CatalogVersion(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductReferenceElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductReferenceElementTypeSerializerState::Init__ => {
                        *self.state = ProductReferenceElementTypeSerializerState::ProdIdTo(
                            WithSerializer::serializer(
                                &self.value.prod_id_to,
                                Some("PROD_ID_TO"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        write_attrib_opt(&mut bytes, "quantity", &self.value.quantity)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductReferenceElementTypeSerializerState::ProdIdTo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductReferenceElementTypeSerializerState::CatalogId(
                                    IterSerializer::new(
                                        self.value.catalog_id.as_ref(),
                                        Some("CATALOG_ID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductReferenceElementTypeSerializerState::CatalogId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductReferenceElementTypeSerializerState::CatalogVersion(
                                        IterSerializer::new(
                                            self.value.catalog_version.as_ref(),
                                            Some("CATALOG_VERSION"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductReferenceElementTypeSerializerState::CatalogVersion(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductReferenceElementTypeSerializerState::End__,
                        }
                    }
                    ProductReferenceElementTypeSerializerState::End__ => {
                        *self.state = ProductReferenceElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductReferenceElementTypeSerializerState::Done__ => return Ok(None),
                    ProductReferenceElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductReferenceElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductReferenceElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductLogisticDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductLogisticDetailsElementType,
        pub(super) state: Box<ProductLogisticDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductLogisticDetailsElementTypeSerializerState<'ser> {
        Init__,
        CustomsTariffNumber(
            IterSerializer<
                'ser,
                &'ser [super::CustomsTariffNumberElementType],
                super::CustomsTariffNumberElementType,
            >,
        ),
        StatisticsFactor(IterSerializer<'ser, Option<&'ser f64>, f64>),
        CountryOfOrigin(IterSerializer<'ser, &'ser [String], String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductLogisticDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductLogisticDetailsElementTypeSerializerState::Init__ => {
                        *self.state =
                            ProductLogisticDetailsElementTypeSerializerState::CustomsTariffNumber(
                                IterSerializer::new(
                                    &self.value.customs_tariff_number[..],
                                    Some("CUSTOMS_TARIFF_NUMBER"),
                                    false,
                                ),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductLogisticDetailsElementTypeSerializerState::CustomsTariffNumber(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                ProductLogisticDetailsElementTypeSerializerState::StatisticsFactor(
                                    IterSerializer::new(
                                        self.value.statistics_factor.as_ref(),
                                        Some("STATISTICS_FACTOR"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    ProductLogisticDetailsElementTypeSerializerState::StatisticsFactor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                ProductLogisticDetailsElementTypeSerializerState::CountryOfOrigin(
                                    IterSerializer::new(
                                        &self.value.country_of_origin[..],
                                        Some("COUNTRY_OF_ORIGIN"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    ProductLogisticDetailsElementTypeSerializerState::CountryOfOrigin(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductLogisticDetailsElementTypeSerializerState::End__
                            }
                        }
                    }
                    ProductLogisticDetailsElementTypeSerializerState::End__ => {
                        *self.state = ProductLogisticDetailsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductLogisticDetailsElementTypeSerializerState::Done__ => return Ok(None),
                    ProductLogisticDetailsElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for ProductLogisticDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductLogisticDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct MimeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::MimeElementType,
        pub(super) state: Box<MimeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum MimeElementTypeSerializerState<'ser> {
        Init__,
        MimeType(<String as WithSerializer>::Serializer<'ser>),
        MimeSource(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        MimeDescr(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        MimeAlt(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        MimePurpose(<super::MimePurposeElementType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> MimeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    MimeElementTypeSerializerState::Init__ => {
                        *self.state =
                            MimeElementTypeSerializerState::MimeType(WithSerializer::serializer(
                                &self.value.mime_type,
                                Some("MIME_TYPE"),
                                false,
                            )?);
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    MimeElementTypeSerializerState::MimeType(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                MimeElementTypeSerializerState::MimeSource(IterSerializer::new(
                                    &self.value.mime_source[..],
                                    Some("MIME_SOURCE"),
                                    false,
                                ))
                        }
                    },
                    MimeElementTypeSerializerState::MimeSource(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                MimeElementTypeSerializerState::MimeDescr(IterSerializer::new(
                                    &self.value.mime_descr[..],
                                    Some("MIME_DESCR"),
                                    false,
                                ))
                        }
                    },
                    MimeElementTypeSerializerState::MimeDescr(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                MimeElementTypeSerializerState::MimeAlt(IterSerializer::new(
                                    &self.value.mime_alt[..],
                                    Some("MIME_ALT"),
                                    false,
                                ))
                        }
                    },
                    MimeElementTypeSerializerState::MimeAlt(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = MimeElementTypeSerializerState::MimePurpose(
                                WithSerializer::serializer(
                                    &self.value.mime_purpose,
                                    Some("MIME_PURPOSE"),
                                    false,
                                )?,
                            )
                        }
                    },
                    MimeElementTypeSerializerState::MimePurpose(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = MimeElementTypeSerializerState::End__,
                    },
                    MimeElementTypeSerializerState::End__ => {
                        *self.state = MimeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    MimeElementTypeSerializerState::Done__ => return Ok(None),
                    MimeElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for MimeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = MimeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct InternationalPidElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::InternationalPidElementType,
        pub(super) state: Box<InternationalPidElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum InternationalPidElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> InternationalPidElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    InternationalPidElementTypeSerializerState::Init__ => {
                        *self.state = InternationalPidElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    InternationalPidElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = InternationalPidElementTypeSerializerState::End__,
                        }
                    }
                    InternationalPidElementTypeSerializerState::End__ => {
                        *self.state = InternationalPidElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    InternationalPidElementTypeSerializerState::Done__ => return Ok(None),
                    InternationalPidElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for InternationalPidElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = InternationalPidElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct BuyerPidElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::BuyerPidElementType,
        pub(super) state: Box<BuyerPidElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum BuyerPidElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BuyerPidElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BuyerPidElementTypeSerializerState::Init__ => {
                        *self.state = BuyerPidElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    BuyerPidElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BuyerPidElementTypeSerializerState::End__,
                        }
                    }
                    BuyerPidElementTypeSerializerState::End__ => {
                        *self.state = BuyerPidElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    BuyerPidElementTypeSerializerState::Done__ => return Ok(None),
                    BuyerPidElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BuyerPidElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BuyerPidElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SpecialTreatmentClassElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SpecialTreatmentClassElementType,
        pub(super) state: Box<SpecialTreatmentClassElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SpecialTreatmentClassElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SpecialTreatmentClassElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SpecialTreatmentClassElementTypeSerializerState::Init__ => {
                        *self.state = SpecialTreatmentClassElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SpecialTreatmentClassElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SpecialTreatmentClassElementTypeSerializerState::End__
                            }
                        }
                    }
                    SpecialTreatmentClassElementTypeSerializerState::End__ => {
                        *self.state = SpecialTreatmentClassElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SpecialTreatmentClassElementTypeSerializerState::Done__ => return Ok(None),
                    SpecialTreatmentClassElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SpecialTreatmentClassElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SpecialTreatmentClassElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct RemarksElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::RemarksElementType,
        pub(super) state: Box<RemarksElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum RemarksElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> RemarksElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    RemarksElementTypeSerializerState::Init__ => {
                        *self.state = RemarksElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                        write_attrib_opt(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    RemarksElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = RemarksElementTypeSerializerState::End__,
                        }
                    }
                    RemarksElementTypeSerializerState::End__ => {
                        *self.state = RemarksElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    RemarksElementTypeSerializerState::Done__ => return Ok(None),
                    RemarksElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for RemarksElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = RemarksElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductStatusElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductStatusElementType,
        pub(super) state: Box<ProductStatusElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductStatusElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductStatusElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductStatusElementTypeSerializerState::Init__ => {
                        *self.state = ProductStatusElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductStatusElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductStatusElementTypeSerializerState::End__,
                        }
                    }
                    ProductStatusElementTypeSerializerState::End__ => {
                        *self.state = ProductStatusElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductStatusElementTypeSerializerState::Done__ => return Ok(None),
                    ProductStatusElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductStatusElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductStatusElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TypeClassificationGroupIdTypeSerializer<'ser> {
        pub(super) value: &'ser super::TypeClassificationGroupIdType,
        pub(super) state: Box<TypeClassificationGroupIdTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TypeClassificationGroupIdTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TypeClassificationGroupIdTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TypeClassificationGroupIdTypeSerializerState::Init__ => {
                        *self.state = TypeClassificationGroupIdTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TypeClassificationGroupIdTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = TypeClassificationGroupIdTypeSerializerState::End__,
                    },
                    TypeClassificationGroupIdTypeSerializerState::End__ => {
                        *self.state = TypeClassificationGroupIdTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TypeClassificationGroupIdTypeSerializerState::Done__ => return Ok(None),
                    TypeClassificationGroupIdTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TypeClassificationGroupIdTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TypeClassificationGroupIdTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct FeatureElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::FeatureElementType,
        pub(super) state: Box<FeatureElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum FeatureElementTypeSerializerState<'ser> {
        Init__,
        Fname(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        Fvalue(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        Funit(IterSerializer<'ser, Option<&'ser String>, String>),
        FvalueDetails(IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> FeatureElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    FeatureElementTypeSerializerState::Init__ => {
                        *self.state = FeatureElementTypeSerializerState::Fname(
                            IterSerializer::new(&self.value.fname[..], Some("FNAME"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    FeatureElementTypeSerializerState::Fname(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = FeatureElementTypeSerializerState::Fvalue(
                                IterSerializer::new(&self.value.fvalue[..], Some("FVALUE"), false),
                            )
                        }
                    },
                    FeatureElementTypeSerializerState::Fvalue(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                FeatureElementTypeSerializerState::Funit(IterSerializer::new(
                                    self.value.funit.as_ref(),
                                    Some("FUNIT"),
                                    false,
                                ))
                        }
                    },
                    FeatureElementTypeSerializerState::Funit(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = FeatureElementTypeSerializerState::FvalueDetails(
                                IterSerializer::new(
                                    &self.value.fvalue_details[..],
                                    Some("FVALUE_DETAILS"),
                                    false,
                                ),
                            )
                        }
                    },
                    FeatureElementTypeSerializerState::FvalueDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FeatureElementTypeSerializerState::End__,
                        }
                    }
                    FeatureElementTypeSerializerState::End__ => {
                        *self.state = FeatureElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    FeatureElementTypeSerializerState::Done__ => return Ok(None),
                    FeatureElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for FeatureElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = FeatureElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceDetailsDatetimeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductPriceDetailsDatetimeElementType,
        pub(super) state: Box<ProductPriceDetailsDatetimeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductPriceDetailsDatetimeElementTypeSerializerState<'ser> {
        Init__,
        Date(<String as WithSerializer>::Serializer<'ser>),
        Time(IterSerializer<'ser, Option<&'ser String>, String>),
        Timezone(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductPriceDetailsDatetimeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Init__ => {
                        *self.state = ProductPriceDetailsDatetimeElementTypeSerializerState::Date(
                            WithSerializer::serializer(&self.value.date, Some("DATE"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Date(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsDatetimeElementTypeSerializerState::Time(
                                        IterSerializer::new(
                                            self.value.time.as_ref(),
                                            Some("TIME"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Time(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsDatetimeElementTypeSerializerState::Timezone(
                                        IterSerializer::new(
                                            self.value.timezone.as_ref(),
                                            Some("TIMEZONE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Timezone(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsDatetimeElementTypeSerializerState::End__
                            }
                        }
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::End__ => {
                        *self.state = ProductPriceDetailsDatetimeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for ProductPriceDetailsDatetimeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductPriceDetailsDatetimeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductPriceElementType,
        pub(super) state: Box<ProductPriceElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductPriceElementTypeSerializerState<'ser> {
        Init__,
        PriceAmount(<f64 as WithSerializer>::Serializer<'ser>),
        PriceCurrency(
            IterSerializer<'ser, Option<&'ser super::DtCurrenciesType>, super::DtCurrenciesType>,
        ),
        Tax(IterSerializer<'ser, Option<&'ser f64>, f64>),
        PriceFactor(IterSerializer<'ser, Option<&'ser f64>, f64>),
        LowerBound(IterSerializer<'ser, Option<&'ser f64>, f64>),
        Territory(IterSerializer<'ser, &'ser [String], String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductPriceElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductPriceElementTypeSerializerState::Init__ => {
                        *self.state = ProductPriceElementTypeSerializerState::PriceAmount(
                            WithSerializer::serializer(
                                &self.value.price_amount,
                                Some("PRICE_AMOUNT"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "price_type", &self.value.price_type)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductPriceElementTypeSerializerState::PriceAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductPriceElementTypeSerializerState::PriceCurrency(
                                    IterSerializer::new(
                                        self.value.price_currency.as_ref(),
                                        Some("PRICE_CURRENCY"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductPriceElementTypeSerializerState::PriceCurrency(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = ProductPriceElementTypeSerializerState::Tax(
                                IterSerializer::new(self.value.tax.as_ref(), Some("TAX"), false),
                            )
                        }
                    },
                    ProductPriceElementTypeSerializerState::Tax(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = ProductPriceElementTypeSerializerState::PriceFactor(
                                IterSerializer::new(
                                    self.value.price_factor.as_ref(),
                                    Some("PRICE_FACTOR"),
                                    false,
                                ),
                            )
                        }
                    },
                    ProductPriceElementTypeSerializerState::PriceFactor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductPriceElementTypeSerializerState::LowerBound(
                                    IterSerializer::new(
                                        self.value.lower_bound.as_ref(),
                                        Some("LOWER_BOUND"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductPriceElementTypeSerializerState::LowerBound(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductPriceElementTypeSerializerState::Territory(
                                    IterSerializer::new(
                                        &self.value.territory[..],
                                        Some("TERRITORY"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductPriceElementTypeSerializerState::Territory(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductPriceElementTypeSerializerState::End__,
                        }
                    }
                    ProductPriceElementTypeSerializerState::End__ => {
                        *self.state = ProductPriceElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductPriceElementTypeSerializerState::Done__ => return Ok(None),
                    ProductPriceElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductPriceElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductPriceElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDiscountGroupElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfDiscountGroupElementType,
        pub(super) state: Box<UdxEdxfDiscountGroupElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfDiscountGroupElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfDiscountGroupElementTypeContent],
                super::UdxEdxfDiscountGroupElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfDiscountGroupElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfDiscountGroupElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfDiscountGroupElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfDiscountGroupElementTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose(
                    )? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxEdxfDiscountGroupElementTypeSerializerState::End__,
                    },
                    UdxEdxfDiscountGroupElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfDiscountGroupElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfDiscountGroupElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfDiscountGroupElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfDiscountGroupElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfDiscountGroupElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDiscountGroupElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfDiscountGroupElementTypeContent,
        pub(super) state: Box<UdxEdxfDiscountGroupElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfDiscountGroupElementTypeContentSerializerState<'ser> {
        Init__,
        UdxEdxfDiscountGroupManufacturer(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfDiscountGroupSupplier(<String as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfDiscountGroupElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfDiscountGroupElementTypeContentSerializerState :: Init__ => { match self . value { super :: UdxEdxfDiscountGroupElementTypeContent :: UdxEdxfDiscountGroupManufacturer (x) => * self . state = UdxEdxfDiscountGroupElementTypeContentSerializerState :: UdxEdxfDiscountGroupManufacturer (WithSerializer :: serializer (x , Some ("UDX.EDXF.DISCOUNT_GROUP_MANUFACTURER") , false) ?) , super :: UdxEdxfDiscountGroupElementTypeContent :: UdxEdxfDiscountGroupSupplier (x) => * self . state = UdxEdxfDiscountGroupElementTypeContentSerializerState :: UdxEdxfDiscountGroupSupplier (WithSerializer :: serializer (x , Some ("UDX.EDXF.DISCOUNT_GROUP_SUPPLIER") , false) ?) , } } UdxEdxfDiscountGroupElementTypeContentSerializerState :: UdxEdxfDiscountGroupManufacturer (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfDiscountGroupElementTypeContentSerializerState :: Done__ , } } UdxEdxfDiscountGroupElementTypeContentSerializerState :: UdxEdxfDiscountGroupSupplier (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfDiscountGroupElementTypeContentSerializerState :: Done__ , } } UdxEdxfDiscountGroupElementTypeContentSerializerState :: Done__ => return Ok (None) , UdxEdxfDiscountGroupElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfDiscountGroupElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfDiscountGroupElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDeclarationElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfDeclarationElementType,
        pub(super) state: Box<UdxEdxfDeclarationElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfDeclarationElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfDeclarationElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfDeclarationElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfDeclarationElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        write_attrib_opt(&mut bytes, "date", &self.value.date)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfDeclarationElementTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxEdxfDeclarationElementTypeSerializerState::End__,
                    },
                    UdxEdxfDeclarationElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfDeclarationElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfDeclarationElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfDeclarationElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfDeclarationElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfDeclarationElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfAdditionalFactorsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfAdditionalFactorsElementType,
        pub(super) state: Box<UdxEdxfAdditionalFactorsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfAdditionalFactorsElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfAdditionalPriceFactor(<f64 as WithSerializer>::Serializer<'ser>),
        UdxEdxfAdditionalFactorInfo(<super::DtMlstringType as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfAdditionalFactorsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfAdditionalFactorsElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfAdditionalFactorsElementTypeSerializerState :: UdxEdxfAdditionalPriceFactor (WithSerializer :: serializer (& self . value . udx_edxf_additional_price_factor , Some ("UDX.EDXF.ADDITIONAL_PRICE_FACTOR") , false) ?) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfAdditionalFactorsElementTypeSerializerState :: UdxEdxfAdditionalPriceFactor (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfAdditionalFactorsElementTypeSerializerState :: UdxEdxfAdditionalFactorInfo (WithSerializer :: serializer (& self . value . udx_edxf_additional_factor_info , Some ("UDX.EDXF.ADDITIONAL_FACTOR_INFO") , false) ?) , } UdxEdxfAdditionalFactorsElementTypeSerializerState :: UdxEdxfAdditionalFactorInfo (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfAdditionalFactorsElementTypeSerializerState :: End__ , } UdxEdxfAdditionalFactorsElementTypeSerializerState :: End__ => { * self . state = UdxEdxfAdditionalFactorsElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfAdditionalFactorsElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfAdditionalFactorsElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfAdditionalFactorsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfAdditionalFactorsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchNumbersElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfCountryBranchNumbersElementType,
        pub(super) state: Box<UdxEdxfCountryBranchNumbersElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfCountryBranchNumbersElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfCountryBranchNumber(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType],
                super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfCountryBranchNumbersElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfCountryBranchNumbersElementTypeSerializerState :: UdxEdxfCountryBranchNumber (IterSerializer :: new (& self . value . udx_edxf_country_branch_number [..] , Some ("UDX.EDXF.COUNTRY_BRANCH_NUMBER") , false)) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfCountryBranchNumbersElementTypeSerializerState :: UdxEdxfCountryBranchNumber (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfCountryBranchNumbersElementTypeSerializerState :: End__ , } UdxEdxfCountryBranchNumbersElementTypeSerializerState :: End__ => { * self . state = UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfCountryBranchNumbersElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfCountryBranchNumbersElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchSupplierIdsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfCountryBranchSupplierIdsElementType,
        pub(super) state: Box<UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState<'ser> {
        Init__ , UdxEdxfCountryBranchSupplierId (IterSerializer < 'ser , & 'ser [super :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType] , super :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType >) , End__ , Done__ , Phantom__ (& 'ser ()) , }
    impl<'ser> UdxEdxfCountryBranchSupplierIdsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: UdxEdxfCountryBranchSupplierId (IterSerializer :: new (& self . value . udx_edxf_country_branch_supplier_id [..] , Some ("UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_ID") , false)) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: UdxEdxfCountryBranchSupplierId (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: End__ , } UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: End__ => { * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfCountryBranchSupplierIdsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfPackingUnitsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfPackingUnitsElementType,
        pub(super) state: Box<UdxEdxfPackingUnitsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfPackingUnitsElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfPackingUnit(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfPackingUnitElementType],
                super::UdxEdxfPackingUnitElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfPackingUnitsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfPackingUnitsElementTypeSerializerState::Init__ => {
                        *self.state =
                            UdxEdxfPackingUnitsElementTypeSerializerState::UdxEdxfPackingUnit(
                                IterSerializer::new(
                                    &self.value.udx_edxf_packing_unit[..],
                                    Some("UDX.EDXF.PACKING_UNIT"),
                                    false,
                                ),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfPackingUnitsElementTypeSerializerState::UdxEdxfPackingUnit(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxEdxfPackingUnitsElementTypeSerializerState::End__,
                    },
                    UdxEdxfPackingUnitsElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfPackingUnitsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfPackingUnitsElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfPackingUnitsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfPackingUnitsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfPackingUnitsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductLogisticDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfProductLogisticDetailsElementType,
        pub(super) state: Box<UdxEdxfProductLogisticDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfProductLogisticDetailsElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfNetweight(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfRegionOfOrigin(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfProductLogisticDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetweight (IterSerializer :: new (self . value . udx_edxf_netweight . as_ref () , Some ("UDX.EDXF.NETWEIGHT") , false)) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetweight (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfRegionOfOrigin (IterSerializer :: new (self . value . udx_edxf_region_of_origin . as_ref () , Some ("UDX.EDXF.REGION_OF_ORIGIN") , false)) , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfRegionOfOrigin (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: End__ , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: End__ => { * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfProductLogisticDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfProductLogisticDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfReachElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfReachElementType,
        pub(super) state: Box<UdxEdxfReachElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfReachElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfReachListdate(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfReachInfo(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfReachElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfReachElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfReachElementTypeSerializerState::UdxEdxfReachListdate(
                            IterSerializer::new(
                                self.value.udx_edxf_reach_listdate.as_ref(),
                                Some("UDX.EDXF.REACH.LISTDATE"),
                                false,
                            ),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfReachElementTypeSerializerState::UdxEdxfReachListdate(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfReachElementTypeSerializerState::UdxEdxfReachInfo(
                                        WithSerializer::serializer(
                                            &self.value.udx_edxf_reach_info,
                                            Some("UDX.EDXF.REACH.INFO"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    UdxEdxfReachElementTypeSerializerState::UdxEdxfReachInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxEdxfReachElementTypeSerializerState::End__,
                        }
                    }
                    UdxEdxfReachElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfReachElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfReachElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfReachElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfReachElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfReachElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeListElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfSurchargeListElementType,
        pub(super) state: Box<UdxEdxfSurchargeListElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfSurchargeListElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfSurcharge(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfSurchargeElementType],
                super::UdxEdxfSurchargeElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfSurchargeListElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfSurchargeListElementTypeSerializerState::Init__ => {
                        *self.state =
                            UdxEdxfSurchargeListElementTypeSerializerState::UdxEdxfSurcharge(
                                IterSerializer::new(
                                    &self.value.udx_edxf_surcharge[..],
                                    Some("UDX.EDXF.SURCHARGE"),
                                    false,
                                ),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfSurchargeListElementTypeSerializerState::UdxEdxfSurcharge(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxEdxfSurchargeListElementTypeSerializerState::End__,
                    },
                    UdxEdxfSurchargeListElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfSurchargeListElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfSurchargeListElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfSurchargeListElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfSurchargeListElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfSurchargeListElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CustomsTariffNumberElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CustomsTariffNumberElementType,
        pub(super) state: Box<CustomsTariffNumberElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CustomsTariffNumberElementTypeSerializerState<'ser> {
        Init__,
        CustomsNumber(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CustomsTariffNumberElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CustomsTariffNumberElementTypeSerializerState::Init__ => {
                        *self.state = CustomsTariffNumberElementTypeSerializerState::CustomsNumber(
                            WithSerializer::serializer(
                                &self.value.customs_number,
                                Some("CUSTOMS_NUMBER"),
                                false,
                            )?,
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CustomsTariffNumberElementTypeSerializerState::CustomsNumber(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CustomsTariffNumberElementTypeSerializerState::End__,
                    },
                    CustomsTariffNumberElementTypeSerializerState::End__ => {
                        *self.state = CustomsTariffNumberElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CustomsTariffNumberElementTypeSerializerState::Done__ => return Ok(None),
                    CustomsTariffNumberElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CustomsTariffNumberElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CustomsTariffNumberElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer<'ser> {
        pub(super) value:
            &'ser super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        pub(super) state: Box<
            UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState<'ser>,
        >,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState<
        'ser,
    > {
        Init__,
        Content__(<f64 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Content__ (WithSerializer :: serializer (& self . value . content , None , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; write_attrib (& mut bytes , "type" , & self . value . type_) ? ; write_attrib (& mut bytes , "country" , & self . value . country) ? ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Content__ (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: End__ , } UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: End__ => { * self . state = UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator
        for UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer<'ser>
    {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    * self . state = UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Done__ ;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer<
        'ser,
    > {
        pub(super) value:
            &'ser super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        pub(super) state: Box<
            UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState<
                'ser,
            >,
        >,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState<
        'ser,
    > {
        Init__,
        Content__(<f64 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser>
        UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer<'ser>
    {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Content__ (WithSerializer :: serializer (& self . value . content , None , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; write_attrib (& mut bytes , "type" , & self . value . type_) ? ; write_attrib (& mut bytes , "country" , & self . value . country) ? ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Content__ (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: End__ , } UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: End__ => { * self . state = UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator
        for UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer<'ser>
    {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    * self . state = UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Done__ ;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfPackingUnitElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfPackingUnitElementType,
        pub(super) state: Box<UdxEdxfPackingUnitElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfPackingUnitElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfQuantityMin(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfQuantityMax(IterSerializer<'ser, Option<&'ser f32>, f32>),
        UdxEdxfPackingUnitCode(<super::DtPunitType as WithSerializer>::Serializer<'ser>),
        UdxEdxfPackingUnitName(
            IterSerializer<'ser, &'ser [super::DtMlstringType], super::DtMlstringType>,
        ),
        UdxEdxfPackageBreak(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfVolume(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfWeight(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfLength(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfWidth(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfDepth(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfDiameter(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfGtin(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfGs1128(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfPackingUnitElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfPackingUnitElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfQuantityMin (WithSerializer :: serializer (& self . value . udx_edxf_quantity_min , Some ("UDX.EDXF.QUANTITY_MIN") , false) ?) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfQuantityMin (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfQuantityMax (IterSerializer :: new (self . value . udx_edxf_quantity_max . as_ref () , Some ("UDX.EDXF.QUANTITY_MAX") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfQuantityMax (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingUnitCode (WithSerializer :: serializer (& self . value . udx_edxf_packing_unit_code , Some ("UDX.EDXF.PACKING_UNIT_CODE") , false) ?) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingUnitCode (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingUnitName (IterSerializer :: new (& self . value . udx_edxf_packing_unit_name [..] , Some ("UDX.EDXF.PACKING_UNIT_NAME") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingUnitName (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackageBreak (IterSerializer :: new (self . value . udx_edxf_package_break . as_ref () , Some ("UDX.EDXF.PACKAGE_BREAK") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackageBreak (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfVolume (IterSerializer :: new (self . value . udx_edxf_volume . as_ref () , Some ("UDX.EDXF.VOLUME") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfVolume (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfWeight (IterSerializer :: new (self . value . udx_edxf_weight . as_ref () , Some ("UDX.EDXF.WEIGHT") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfWeight (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfLength (IterSerializer :: new (self . value . udx_edxf_length . as_ref () , Some ("UDX.EDXF.LENGTH") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfLength (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfWidth (IterSerializer :: new (self . value . udx_edxf_width . as_ref () , Some ("UDX.EDXF.WIDTH") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfWidth (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfDepth (IterSerializer :: new (self . value . udx_edxf_depth . as_ref () , Some ("UDX.EDXF.DEPTH") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfDepth (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfDiameter (IterSerializer :: new (self . value . udx_edxf_diameter . as_ref () , Some ("UDX.EDXF.DIAMETER") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfDiameter (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfGtin (IterSerializer :: new (self . value . udx_edxf_gtin . as_ref () , Some ("UDX.EDXF.GTIN") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfGtin (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfGs1128 (IterSerializer :: new (self . value . udx_edxf_gs_1128 . as_ref () , Some ("UDX.EDXF.GS1_128") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfGs1128 (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: End__ , } UdxEdxfPackingUnitElementTypeSerializerState :: End__ => { * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfPackingUnitElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfPackingUnitElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfPackingUnitElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfPackingUnitElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfSurchargeElementType,
        pub(super) state: Box<UdxEdxfSurchargeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfSurchargeElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfSurchargeElementTypeContent],
                super::UdxEdxfSurchargeElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfSurchargeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfSurchargeElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfSurchargeElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfSurchargeElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxEdxfSurchargeElementTypeSerializerState::End__,
                        }
                    }
                    UdxEdxfSurchargeElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfSurchargeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfSurchargeElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfSurchargeElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfSurchargeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfSurchargeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfSurchargeElementTypeContent,
        pub(super) state: Box<UdxEdxfSurchargeElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfSurchargeElementTypeContentSerializerState<'ser> {
        Init__,
        UdxEdxfSurchargeType(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfSurchargeManner(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfSurchargePercentage(<f64 as WithSerializer>::Serializer<'ser>),
        UdxEdxfSurchargePriceAmount(<f64 as WithSerializer>::Serializer<'ser>),
        UdxEdxfSurchargeCalculation(<f64 as WithSerializer>::Serializer<'ser>),
        UdxEdxfMaterialBasis(<f64 as WithSerializer>::Serializer<'ser>),
        UdxEdxfMaterialBasisWeight(<f64 as WithSerializer>::Serializer<'ser>),
        UdxEdxfMaterialBasisSurchargeThreshold(<f64 as WithSerializer>::Serializer<'ser>),
        UdxEdxfMaterialBasisSurchargeShutter(<i32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfMaterialBasisSurchargeCredit(<i32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfMaterialBasisSurchargeTable(
            <super::DtMlstringType as WithSerializer>::Serializer<'ser>,
        ),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfSurchargeElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfSurchargeElementTypeContentSerializerState :: Init__ => { match self . value { super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargeType (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeType (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_TYPE") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargeManner (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeManner (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_MANNER") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargePercentage (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargePercentage (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_PERCENTAGE") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargePriceAmount (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargePriceAmount (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_PRICE_AMOUNT") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargeCalculation (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeCalculation (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_CALCULATION") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasis (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasis (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisWeight (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisWeight (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_WEIGHT") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeThreshold (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeThreshold (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_THRESHOLD") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeShutter (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeShutter (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_SHUTTER") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeCredit (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeCredit (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_CREDIT") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeTable (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeTable (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_TABLE") , false) ?) , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeType (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeManner (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargePercentage (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargePriceAmount (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeCalculation (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasis (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisWeight (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeThreshold (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeShutter (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeCredit (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeTable (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ => return Ok (None) , UdxEdxfSurchargeElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfSurchargeElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfSurchargeElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
}
