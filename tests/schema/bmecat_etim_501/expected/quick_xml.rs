use std::borrow::Cow;
use xsd_parser::{
    models::schema::Namespace,
    quick_xml::{
        DeserializeBytes, DeserializeReader, Error, ErrorKind, RawByteStr, SerializeBytes,
        WithDeserializer, WithSerializer,
    },
};
pub const NS_XS: Namespace = Namespace::new_const(b"http://www.w3.org/2001/XMLSchema");
pub const NS_XML: Namespace = Namespace::new_const(b"http://www.w3.org/XML/1998/namespace");
pub const NS_DEFAULT: Namespace =
    Namespace::new_const(b"https://www.etim-international.com/bmecat/50");
pub type BmecatElement = BmecatElementType;
#[derive(Debug)]
pub struct BmecatElementType {
    pub version: TypeBmEcatVersion,
    pub content: Vec<BmecatElementTypeContent>,
}
#[derive(Debug)]
pub enum BmecatElementTypeContent {
    Header(HeaderElementType),
    TNewCatalog(TNewCatalogElementType),
    TUpdateProducts(TUpdateProductsElementType),
    TUpdatePrices(TUpdatePricesElementType),
    TNewProductdata(TNewProductdataElementType),
}
impl WithSerializer for BmecatElementType {
    type Serializer<'x> = quick_xml_serialize::BmecatElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::BmecatElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BmecatElementTypeSerializerState::Init__),
            name: name.unwrap_or("BMECAT"),
            is_root,
        })
    }
}
impl WithSerializer for BmecatElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::BmecatElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(quick_xml_serialize::BmecatElementTypeContentSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BmecatElementTypeContentSerializerState::Init__),
        })
    }
}
impl WithDeserializer for BmecatElementType {
    type Deserializer = quick_xml_deserialize::BmecatElementTypeDeserializer;
}
impl WithDeserializer for BmecatElementTypeContent {
    type Deserializer = quick_xml_deserialize::BmecatElementTypeContentDeserializer;
}
#[derive(Debug)]
pub enum TypeBmEcatVersion {
    _2005,
}
impl SerializeBytes for TypeBmEcatVersion {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_2005 => Ok(Some(Cow::Borrowed("2005"))),
        }
    }
}
impl DeserializeBytes for TypeBmEcatVersion {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"2005" => Ok(Self::_2005),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct HeaderElementType {
    pub generator_info: Option<String>,
    pub catalog: CatalogElementType,
    pub buyer: BuyerElementType,
    pub supplier: SupplierElementType,
    pub user_defined_extensions: UdxHeader,
}
impl WithSerializer for HeaderElementType {
    type Serializer<'x> = quick_xml_serialize::HeaderElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::HeaderElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::HeaderElementTypeSerializerState::Init__),
            name: name.unwrap_or("HEADER"),
            is_root,
        })
    }
}
impl WithDeserializer for HeaderElementType {
    type Deserializer = quick_xml_deserialize::HeaderElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TNewCatalogElementType {
    pub product: Vec<TNewCatalogProductElementType>,
}
impl WithSerializer for TNewCatalogElementType {
    type Serializer<'x> = quick_xml_serialize::TNewCatalogElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TNewCatalogElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TNewCatalogElementTypeSerializerState::Init__),
            name: name.unwrap_or("T_NEW_CATALOG"),
            is_root,
        })
    }
}
impl WithDeserializer for TNewCatalogElementType {
    type Deserializer = quick_xml_deserialize::TNewCatalogElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TUpdateProductsElementType {
    pub prev_version: i32,
    pub product: Vec<TUpdateProductsProductElementType>,
}
impl WithSerializer for TUpdateProductsElementType {
    type Serializer<'x> = quick_xml_serialize::TUpdateProductsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TUpdateProductsElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TUpdateProductsElementTypeSerializerState::Init__),
            name: name.unwrap_or("T_UPDATE_PRODUCTS"),
            is_root,
        })
    }
}
impl WithDeserializer for TUpdateProductsElementType {
    type Deserializer = quick_xml_deserialize::TUpdateProductsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TUpdatePricesElementType {
    pub prev_version: i32,
    pub product: Vec<TUpdatePricesProductElementType>,
}
impl WithSerializer for TUpdatePricesElementType {
    type Serializer<'x> = quick_xml_serialize::TUpdatePricesElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TUpdatePricesElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TUpdatePricesElementTypeSerializerState::Init__),
            name: name.unwrap_or("T_UPDATE_PRICES"),
            is_root,
        })
    }
}
impl WithDeserializer for TUpdatePricesElementType {
    type Deserializer = quick_xml_deserialize::TUpdatePricesElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TNewProductdataElementType {
    pub product: Vec<TNewProductdataProductElementType>,
}
impl WithSerializer for TNewProductdataElementType {
    type Serializer<'x> = quick_xml_serialize::TNewProductdataElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TNewProductdataElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TNewProductdataElementTypeSerializerState::Init__),
            name: name.unwrap_or("T_NEW_PRODUCTDATA"),
            is_root,
        })
    }
}
impl WithDeserializer for TNewProductdataElementType {
    type Deserializer = quick_xml_deserialize::TNewProductdataElementTypeDeserializer;
}
#[derive(Debug)]
pub struct CatalogElementType {
    pub language: Vec<LanguageElementType>,
    pub catalog_id: String,
    pub catalog_version: String,
    pub catalog_name: Vec<DtMlstring>,
    pub datetime: CatalogDatetimeElementType,
    pub territory: Vec<String>,
    pub currency: Option<DtCurrencies>,
    pub mime_root: Vec<DtMlstring>,
}
impl WithSerializer for CatalogElementType {
    type Serializer<'x> = quick_xml_serialize::CatalogElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CatalogElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CatalogElementTypeSerializerState::Init__),
            name: name.unwrap_or("CATALOG"),
            is_root,
        })
    }
}
impl WithDeserializer for CatalogElementType {
    type Deserializer = quick_xml_deserialize::CatalogElementTypeDeserializer;
}
#[derive(Debug)]
pub struct BuyerElementType {
    pub buyer_id: Vec<TypePartyId>,
    pub buyer_name: String,
}
impl WithSerializer for BuyerElementType {
    type Serializer<'x> = quick_xml_serialize::BuyerElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::BuyerElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BuyerElementTypeSerializerState::Init__),
            name: name.unwrap_or("BUYER"),
            is_root,
        })
    }
}
impl WithDeserializer for BuyerElementType {
    type Deserializer = quick_xml_deserialize::BuyerElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SupplierElementType {
    pub supplier_id: Vec<TypePartyId>,
    pub supplier_name: String,
    pub address: Option<SupplierAddressElementType>,
    pub mime_info: Option<MimeInfoElementType>,
}
impl WithSerializer for SupplierElementType {
    type Serializer<'x> = quick_xml_serialize::SupplierElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SupplierElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SupplierElementTypeSerializerState::Init__),
            name: name.unwrap_or("SUPPLIER"),
            is_root,
        })
    }
}
impl WithDeserializer for SupplierElementType {
    type Deserializer = quick_xml_deserialize::SupplierElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxHeader {
    pub udx_edxf_version: TypeBmEcatEtimVersion,
}
impl WithSerializer for UdxHeader {
    type Serializer<'x> = quick_xml_serialize::UdxHeaderSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxHeaderSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxHeaderSerializerState::Init__),
            name: name.unwrap_or("udxHEADER"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxHeader {
    type Deserializer = quick_xml_deserialize::UdxHeaderDeserializer;
}
#[derive(Debug)]
pub struct TNewCatalogProductElementType {
    pub mode: TNewCatalogProductMode,
    pub supplier_pid: String,
    pub product_details: ProductDetailsElementType,
    pub product_features: Vec<ProductFeaturesElementType>,
    pub product_order_details: ProductOrderDetailsElementType,
    pub product_price_details: Vec<ProductPriceDetailsElementType>,
    pub user_defined_extensions: UdxProduct,
    pub product_reference: Vec<ProductReferenceElementType>,
    pub product_logistic_details: Option<ProductLogisticDetailsElementType>,
}
impl TNewCatalogProductElementType {
    #[must_use]
    pub fn default_mode() -> TNewCatalogProductMode {
        TNewCatalogProductMode::New
    }
}
impl WithSerializer for TNewCatalogProductElementType {
    type Serializer<'x> = quick_xml_serialize::TNewCatalogProductElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TNewCatalogProductElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TNewCatalogProductElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("TNewCatalogProduct"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TNewCatalogProductElementType {
    type Deserializer = quick_xml_deserialize::TNewCatalogProductElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TUpdateProductsProductElementType {
    pub mode: TUpdateProductsProductMode,
    pub supplier_pid: String,
    pub product_details: ProductDetailsElementType,
    pub product_features: Vec<ProductFeaturesElementType>,
    pub product_order_details: ProductOrderDetailsElementType,
    pub product_price_details: Vec<ProductPriceDetailsElementType>,
    pub user_defined_extensions: Option<UdxProduct>,
    pub product_reference: Vec<ProductReferenceElementType>,
    pub product_logistic_details: Option<ProductLogisticDetailsElementType>,
}
impl WithSerializer for TUpdateProductsProductElementType {
    type Serializer<'x> = quick_xml_serialize::TUpdateProductsProductElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TUpdateProductsProductElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TUpdateProductsProductElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("TUpdateProductsProduct"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TUpdateProductsProductElementType {
    type Deserializer = quick_xml_deserialize::TUpdateProductsProductElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TUpdatePricesProductElementType {
    pub mode: TUpdatePricesProductMode,
    pub supplier_pid: String,
    pub product_price_details: Vec<ProductPriceDetailsElementType>,
    pub user_defined_extensions: Option<UdxProduct>,
}
impl TUpdatePricesProductElementType {
    #[must_use]
    pub fn default_mode() -> TUpdatePricesProductMode {
        TUpdatePricesProductMode::Update
    }
}
impl WithSerializer for TUpdatePricesProductElementType {
    type Serializer<'x> = quick_xml_serialize::TUpdatePricesProductElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TUpdatePricesProductElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TUpdatePricesProductElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("TUpdatePricesProduct"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TUpdatePricesProductElementType {
    type Deserializer = quick_xml_deserialize::TUpdatePricesProductElementTypeDeserializer;
}
#[derive(Debug)]
pub struct TNewProductdataProductElementType {
    pub mode: TNewProductdataProductMode,
    pub supplier_pid: String,
    pub product_details: ProductDetailsElementType,
    pub product_features: Vec<ProductFeaturesElementType>,
    pub user_defined_extensions: Option<UdxProductdata>,
    pub product_reference: Vec<ProductReferenceElementType>,
}
impl TNewProductdataProductElementType {
    #[must_use]
    pub fn default_mode() -> TNewProductdataProductMode {
        TNewProductdataProductMode::New
    }
}
impl WithSerializer for TNewProductdataProductElementType {
    type Serializer<'x> = quick_xml_serialize::TNewProductdataProductElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::TNewProductdataProductElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::TNewProductdataProductElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("TNewProductdataProduct"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for TNewProductdataProductElementType {
    type Deserializer = quick_xml_deserialize::TNewProductdataProductElementTypeDeserializer;
}
#[derive(Debug)]
pub struct LanguageElementType {
    pub default: Option<String>,
    pub content: DtLang,
}
impl WithSerializer for LanguageElementType {
    type Serializer<'x> = quick_xml_serialize::LanguageElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::LanguageElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::LanguageElementTypeSerializerState::Init__),
            name: name.unwrap_or("LANGUAGE"),
            is_root,
        })
    }
}
impl WithDeserializer for LanguageElementType {
    type Deserializer = quick_xml_deserialize::LanguageElementTypeDeserializer;
}
#[derive(Debug)]
pub struct DtMlstring {
    pub lang: Option<DtLang>,
    pub content: String,
}
impl WithSerializer for DtMlstring {
    type Serializer<'x> = quick_xml_serialize::DtMlstringSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::DtMlstringSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::DtMlstringSerializerState::Init__),
            name: name.unwrap_or("dtMLSTRING"),
            is_root,
        })
    }
}
impl WithDeserializer for DtMlstring {
    type Deserializer = quick_xml_deserialize::DtMlstringDeserializer;
}
#[derive(Debug)]
pub struct CatalogDatetimeElementType {
    pub type_: CatalogDatetimeType,
    pub date: String,
}
impl WithSerializer for CatalogDatetimeElementType {
    type Serializer<'x> = quick_xml_serialize::CatalogDatetimeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::CatalogDatetimeElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::CatalogDatetimeElementTypeSerializerState::Init__),
            name: name.unwrap_or("CatalogDatetime"),
            is_root,
        })
    }
}
impl WithDeserializer for CatalogDatetimeElementType {
    type Deserializer = quick_xml_deserialize::CatalogDatetimeElementTypeDeserializer;
}
#[derive(Debug)]
pub enum DtCurrencies {
    Adp,
    Aed,
    Afa,
    Afn,
    All,
    Amd,
    Ang,
    Aoa,
    Aok,
    Ara,
    Ars,
    Ats,
    Aud,
    Awg,
    Azn,
    Bam,
    Bbd,
    Bdt,
    Bef,
    Bgl,
    Bgn,
    Bhd,
    Bif,
    Bmd,
    Bnd,
    Bob,
    Bov,
    Brc,
    Brl,
    Bsd,
    Btn,
    Buk,
    Bwp,
    Byn,
    Bzd,
    Cad,
    Cdf,
    Che,
    Chf,
    Chw,
    Clf,
    Clp,
    Cny,
    Cop,
    Cou,
    Crc,
    Csk,
    Cuc,
    Cup,
    Cve,
    Cyp,
    Czk,
    Ddm,
    Dem,
    Djf,
    Dkk,
    Dop,
    Dzd,
    Ecs,
    Egp,
    Ern,
    Esp,
    Etb,
    Eur,
    Fim,
    Fjd,
    Fkp,
    Frf,
    Gbp,
    Gel,
    Ghc,
    Ghs,
    Gip,
    Gmd,
    Gnf,
    Grd,
    Gtq,
    Gwp,
    Gyd,
    Hkd,
    Hnl,
    Hrk,
    Htg,
    Huf,
    Idr,
    Iep,
    Ils,
    Inr,
    Iqd,
    Irr,
    Isk,
    Itl,
    Jmd,
    Jod,
    Jpy,
    Kes,
    Kgs,
    Khr,
    Kmf,
    Kpw,
    Krw,
    Kwd,
    Kyd,
    Kzt,
    Lak,
    Lbp,
    Lkr,
    Lrd,
    Lsl,
    Luf,
    Lyd,
    Mad,
    Mdl,
    Mga,
    Mgf,
    Mkd,
    Mmk,
    Mnt,
    Mop,
    Mro,
    Mru,
    Mtl,
    Mur,
    Mvr,
    Mwk,
    Mxn,
    Mxp,
    Mxv,
    Myr,
    Mzm,
    Mzn,
    Nad,
    Ngn,
    Nic,
    Nio,
    Nlg,
    Nok,
    Npr,
    Nzd,
    Omr,
    Pab,
    Pei,
    Pen,
    Pgk,
    Php,
    Pkr,
    Plz,
    Pln,
    Pte,
    Pyg,
    Qar,
    Rol,
    Ron,
    Rsd,
    Rub,
    Rwf,
    Sar,
    Sbd,
    Scr,
    Sdg,
    Sdp,
    Sek,
    Sgd,
    Shp,
    Sll,
    Skk,
    Sos,
    Srd,
    Srg,
    Ssp,
    Std,
    Stn,
    Sur,
    Svc,
    Syp,
    Szl,
    Thb,
    Tjs,
    Tmt,
    Tnd,
    Top,
    Tpe,
    Trl,
    Try,
    Ttd,
    Twd,
    Tzs,
    Uah,
    Ugs,
    Ugx,
    Usd,
    Usn,
    Uyi,
    Uyp,
    Uyu,
    Uyw,
    Uzs,
    Veb,
    Ves,
    Vnd,
    Vuv,
    Wst,
    Xaf,
    Xag,
    Xau,
    Xba,
    Xbb,
    Xbc,
    Xbd,
    Xcd,
    Xdr,
    Xof,
    Xpd,
    Xpf,
    Xpt,
    Xsu,
    Xts,
    Xua,
    Xxx,
    Ydd,
    Yer,
    Yud,
    Zar,
    Zmk,
    Zmw,
    Zrz,
    Zwd,
    Zwl,
}
impl SerializeBytes for DtCurrencies {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Adp => Ok(Some(Cow::Borrowed("ADP"))),
            Self::Aed => Ok(Some(Cow::Borrowed("AED"))),
            Self::Afa => Ok(Some(Cow::Borrowed("AFA"))),
            Self::Afn => Ok(Some(Cow::Borrowed("AFN"))),
            Self::All => Ok(Some(Cow::Borrowed("ALL"))),
            Self::Amd => Ok(Some(Cow::Borrowed("AMD"))),
            Self::Ang => Ok(Some(Cow::Borrowed("ANG"))),
            Self::Aoa => Ok(Some(Cow::Borrowed("AOA"))),
            Self::Aok => Ok(Some(Cow::Borrowed("AOK"))),
            Self::Ara => Ok(Some(Cow::Borrowed("ARA"))),
            Self::Ars => Ok(Some(Cow::Borrowed("ARS"))),
            Self::Ats => Ok(Some(Cow::Borrowed("ATS"))),
            Self::Aud => Ok(Some(Cow::Borrowed("AUD"))),
            Self::Awg => Ok(Some(Cow::Borrowed("AWG"))),
            Self::Azn => Ok(Some(Cow::Borrowed("AZN"))),
            Self::Bam => Ok(Some(Cow::Borrowed("BAM"))),
            Self::Bbd => Ok(Some(Cow::Borrowed("BBD"))),
            Self::Bdt => Ok(Some(Cow::Borrowed("BDT"))),
            Self::Bef => Ok(Some(Cow::Borrowed("BEF"))),
            Self::Bgl => Ok(Some(Cow::Borrowed("BGL"))),
            Self::Bgn => Ok(Some(Cow::Borrowed("BGN"))),
            Self::Bhd => Ok(Some(Cow::Borrowed("BHD"))),
            Self::Bif => Ok(Some(Cow::Borrowed("BIF"))),
            Self::Bmd => Ok(Some(Cow::Borrowed("BMD"))),
            Self::Bnd => Ok(Some(Cow::Borrowed("BND"))),
            Self::Bob => Ok(Some(Cow::Borrowed("BOB"))),
            Self::Bov => Ok(Some(Cow::Borrowed("BOV"))),
            Self::Brc => Ok(Some(Cow::Borrowed("BRC"))),
            Self::Brl => Ok(Some(Cow::Borrowed("BRL"))),
            Self::Bsd => Ok(Some(Cow::Borrowed("BSD"))),
            Self::Btn => Ok(Some(Cow::Borrowed("BTN"))),
            Self::Buk => Ok(Some(Cow::Borrowed("BUK"))),
            Self::Bwp => Ok(Some(Cow::Borrowed("BWP"))),
            Self::Byn => Ok(Some(Cow::Borrowed("BYN"))),
            Self::Bzd => Ok(Some(Cow::Borrowed("BZD"))),
            Self::Cad => Ok(Some(Cow::Borrowed("CAD"))),
            Self::Cdf => Ok(Some(Cow::Borrowed("CDF"))),
            Self::Che => Ok(Some(Cow::Borrowed("CHE"))),
            Self::Chf => Ok(Some(Cow::Borrowed("CHF"))),
            Self::Chw => Ok(Some(Cow::Borrowed("CHW"))),
            Self::Clf => Ok(Some(Cow::Borrowed("CLF"))),
            Self::Clp => Ok(Some(Cow::Borrowed("CLP"))),
            Self::Cny => Ok(Some(Cow::Borrowed("CNY"))),
            Self::Cop => Ok(Some(Cow::Borrowed("COP"))),
            Self::Cou => Ok(Some(Cow::Borrowed("COU"))),
            Self::Crc => Ok(Some(Cow::Borrowed("CRC"))),
            Self::Csk => Ok(Some(Cow::Borrowed("CSK"))),
            Self::Cuc => Ok(Some(Cow::Borrowed("CUC"))),
            Self::Cup => Ok(Some(Cow::Borrowed("CUP"))),
            Self::Cve => Ok(Some(Cow::Borrowed("CVE"))),
            Self::Cyp => Ok(Some(Cow::Borrowed("CYP"))),
            Self::Czk => Ok(Some(Cow::Borrowed("CZK"))),
            Self::Ddm => Ok(Some(Cow::Borrowed("DDM"))),
            Self::Dem => Ok(Some(Cow::Borrowed("DEM"))),
            Self::Djf => Ok(Some(Cow::Borrowed("DJF"))),
            Self::Dkk => Ok(Some(Cow::Borrowed("DKK"))),
            Self::Dop => Ok(Some(Cow::Borrowed("DOP"))),
            Self::Dzd => Ok(Some(Cow::Borrowed("DZD"))),
            Self::Ecs => Ok(Some(Cow::Borrowed("ECS"))),
            Self::Egp => Ok(Some(Cow::Borrowed("EGP"))),
            Self::Ern => Ok(Some(Cow::Borrowed("ERN"))),
            Self::Esp => Ok(Some(Cow::Borrowed("ESP"))),
            Self::Etb => Ok(Some(Cow::Borrowed("ETB"))),
            Self::Eur => Ok(Some(Cow::Borrowed("EUR"))),
            Self::Fim => Ok(Some(Cow::Borrowed("FIM"))),
            Self::Fjd => Ok(Some(Cow::Borrowed("FJD"))),
            Self::Fkp => Ok(Some(Cow::Borrowed("FKP"))),
            Self::Frf => Ok(Some(Cow::Borrowed("FRF"))),
            Self::Gbp => Ok(Some(Cow::Borrowed("GBP"))),
            Self::Gel => Ok(Some(Cow::Borrowed("GEL"))),
            Self::Ghc => Ok(Some(Cow::Borrowed("GHC"))),
            Self::Ghs => Ok(Some(Cow::Borrowed("GHS"))),
            Self::Gip => Ok(Some(Cow::Borrowed("GIP"))),
            Self::Gmd => Ok(Some(Cow::Borrowed("GMD"))),
            Self::Gnf => Ok(Some(Cow::Borrowed("GNF"))),
            Self::Grd => Ok(Some(Cow::Borrowed("GRD"))),
            Self::Gtq => Ok(Some(Cow::Borrowed("GTQ"))),
            Self::Gwp => Ok(Some(Cow::Borrowed("GWP"))),
            Self::Gyd => Ok(Some(Cow::Borrowed("GYD"))),
            Self::Hkd => Ok(Some(Cow::Borrowed("HKD"))),
            Self::Hnl => Ok(Some(Cow::Borrowed("HNL"))),
            Self::Hrk => Ok(Some(Cow::Borrowed("HRK"))),
            Self::Htg => Ok(Some(Cow::Borrowed("HTG"))),
            Self::Huf => Ok(Some(Cow::Borrowed("HUF"))),
            Self::Idr => Ok(Some(Cow::Borrowed("IDR"))),
            Self::Iep => Ok(Some(Cow::Borrowed("IEP"))),
            Self::Ils => Ok(Some(Cow::Borrowed("ILS"))),
            Self::Inr => Ok(Some(Cow::Borrowed("INR"))),
            Self::Iqd => Ok(Some(Cow::Borrowed("IQD"))),
            Self::Irr => Ok(Some(Cow::Borrowed("IRR"))),
            Self::Isk => Ok(Some(Cow::Borrowed("ISK"))),
            Self::Itl => Ok(Some(Cow::Borrowed("ITL"))),
            Self::Jmd => Ok(Some(Cow::Borrowed("JMD"))),
            Self::Jod => Ok(Some(Cow::Borrowed("JOD"))),
            Self::Jpy => Ok(Some(Cow::Borrowed("JPY"))),
            Self::Kes => Ok(Some(Cow::Borrowed("KES"))),
            Self::Kgs => Ok(Some(Cow::Borrowed("KGS"))),
            Self::Khr => Ok(Some(Cow::Borrowed("KHR"))),
            Self::Kmf => Ok(Some(Cow::Borrowed("KMF"))),
            Self::Kpw => Ok(Some(Cow::Borrowed("KPW"))),
            Self::Krw => Ok(Some(Cow::Borrowed("KRW"))),
            Self::Kwd => Ok(Some(Cow::Borrowed("KWD"))),
            Self::Kyd => Ok(Some(Cow::Borrowed("KYD"))),
            Self::Kzt => Ok(Some(Cow::Borrowed("KZT"))),
            Self::Lak => Ok(Some(Cow::Borrowed("LAK"))),
            Self::Lbp => Ok(Some(Cow::Borrowed("LBP"))),
            Self::Lkr => Ok(Some(Cow::Borrowed("LKR"))),
            Self::Lrd => Ok(Some(Cow::Borrowed("LRD"))),
            Self::Lsl => Ok(Some(Cow::Borrowed("LSL"))),
            Self::Luf => Ok(Some(Cow::Borrowed("LUF"))),
            Self::Lyd => Ok(Some(Cow::Borrowed("LYD"))),
            Self::Mad => Ok(Some(Cow::Borrowed("MAD"))),
            Self::Mdl => Ok(Some(Cow::Borrowed("MDL"))),
            Self::Mga => Ok(Some(Cow::Borrowed("MGA"))),
            Self::Mgf => Ok(Some(Cow::Borrowed("MGF"))),
            Self::Mkd => Ok(Some(Cow::Borrowed("MKD"))),
            Self::Mmk => Ok(Some(Cow::Borrowed("MMK"))),
            Self::Mnt => Ok(Some(Cow::Borrowed("MNT"))),
            Self::Mop => Ok(Some(Cow::Borrowed("MOP"))),
            Self::Mro => Ok(Some(Cow::Borrowed("MRO"))),
            Self::Mru => Ok(Some(Cow::Borrowed("MRU"))),
            Self::Mtl => Ok(Some(Cow::Borrowed("MTL"))),
            Self::Mur => Ok(Some(Cow::Borrowed("MUR"))),
            Self::Mvr => Ok(Some(Cow::Borrowed("MVR"))),
            Self::Mwk => Ok(Some(Cow::Borrowed("MWK"))),
            Self::Mxn => Ok(Some(Cow::Borrowed("MXN"))),
            Self::Mxp => Ok(Some(Cow::Borrowed("MXP"))),
            Self::Mxv => Ok(Some(Cow::Borrowed("MXV"))),
            Self::Myr => Ok(Some(Cow::Borrowed("MYR"))),
            Self::Mzm => Ok(Some(Cow::Borrowed("MZM"))),
            Self::Mzn => Ok(Some(Cow::Borrowed("MZN"))),
            Self::Nad => Ok(Some(Cow::Borrowed("NAD"))),
            Self::Ngn => Ok(Some(Cow::Borrowed("NGN"))),
            Self::Nic => Ok(Some(Cow::Borrowed("NIC"))),
            Self::Nio => Ok(Some(Cow::Borrowed("NIO"))),
            Self::Nlg => Ok(Some(Cow::Borrowed("NLG"))),
            Self::Nok => Ok(Some(Cow::Borrowed("NOK"))),
            Self::Npr => Ok(Some(Cow::Borrowed("NPR"))),
            Self::Nzd => Ok(Some(Cow::Borrowed("NZD"))),
            Self::Omr => Ok(Some(Cow::Borrowed("OMR"))),
            Self::Pab => Ok(Some(Cow::Borrowed("PAB"))),
            Self::Pei => Ok(Some(Cow::Borrowed("PEI"))),
            Self::Pen => Ok(Some(Cow::Borrowed("PEN"))),
            Self::Pgk => Ok(Some(Cow::Borrowed("PGK"))),
            Self::Php => Ok(Some(Cow::Borrowed("PHP"))),
            Self::Pkr => Ok(Some(Cow::Borrowed("PKR"))),
            Self::Plz => Ok(Some(Cow::Borrowed("PLZ"))),
            Self::Pln => Ok(Some(Cow::Borrowed("PLN"))),
            Self::Pte => Ok(Some(Cow::Borrowed("PTE"))),
            Self::Pyg => Ok(Some(Cow::Borrowed("PYG"))),
            Self::Qar => Ok(Some(Cow::Borrowed("QAR"))),
            Self::Rol => Ok(Some(Cow::Borrowed("ROL"))),
            Self::Ron => Ok(Some(Cow::Borrowed("RON"))),
            Self::Rsd => Ok(Some(Cow::Borrowed("RSD"))),
            Self::Rub => Ok(Some(Cow::Borrowed("RUB"))),
            Self::Rwf => Ok(Some(Cow::Borrowed("RWF"))),
            Self::Sar => Ok(Some(Cow::Borrowed("SAR"))),
            Self::Sbd => Ok(Some(Cow::Borrowed("SBD"))),
            Self::Scr => Ok(Some(Cow::Borrowed("SCR"))),
            Self::Sdg => Ok(Some(Cow::Borrowed("SDG"))),
            Self::Sdp => Ok(Some(Cow::Borrowed("SDP"))),
            Self::Sek => Ok(Some(Cow::Borrowed("SEK"))),
            Self::Sgd => Ok(Some(Cow::Borrowed("SGD"))),
            Self::Shp => Ok(Some(Cow::Borrowed("SHP"))),
            Self::Sll => Ok(Some(Cow::Borrowed("SLL"))),
            Self::Skk => Ok(Some(Cow::Borrowed("SKK"))),
            Self::Sos => Ok(Some(Cow::Borrowed("SOS"))),
            Self::Srd => Ok(Some(Cow::Borrowed("SRD"))),
            Self::Srg => Ok(Some(Cow::Borrowed("SRG"))),
            Self::Ssp => Ok(Some(Cow::Borrowed("SSP"))),
            Self::Std => Ok(Some(Cow::Borrowed("STD"))),
            Self::Stn => Ok(Some(Cow::Borrowed("STN"))),
            Self::Sur => Ok(Some(Cow::Borrowed("SUR"))),
            Self::Svc => Ok(Some(Cow::Borrowed("SVC"))),
            Self::Syp => Ok(Some(Cow::Borrowed("SYP"))),
            Self::Szl => Ok(Some(Cow::Borrowed("SZL"))),
            Self::Thb => Ok(Some(Cow::Borrowed("THB"))),
            Self::Tjs => Ok(Some(Cow::Borrowed("TJS"))),
            Self::Tmt => Ok(Some(Cow::Borrowed("TMT"))),
            Self::Tnd => Ok(Some(Cow::Borrowed("TND"))),
            Self::Top => Ok(Some(Cow::Borrowed("TOP"))),
            Self::Tpe => Ok(Some(Cow::Borrowed("TPE"))),
            Self::Trl => Ok(Some(Cow::Borrowed("TRL"))),
            Self::Try => Ok(Some(Cow::Borrowed("TRY"))),
            Self::Ttd => Ok(Some(Cow::Borrowed("TTD"))),
            Self::Twd => Ok(Some(Cow::Borrowed("TWD"))),
            Self::Tzs => Ok(Some(Cow::Borrowed("TZS"))),
            Self::Uah => Ok(Some(Cow::Borrowed("UAH"))),
            Self::Ugs => Ok(Some(Cow::Borrowed("UGS"))),
            Self::Ugx => Ok(Some(Cow::Borrowed("UGX"))),
            Self::Usd => Ok(Some(Cow::Borrowed("USD"))),
            Self::Usn => Ok(Some(Cow::Borrowed("USN"))),
            Self::Uyi => Ok(Some(Cow::Borrowed("UYI"))),
            Self::Uyp => Ok(Some(Cow::Borrowed("UYP"))),
            Self::Uyu => Ok(Some(Cow::Borrowed("UYU"))),
            Self::Uyw => Ok(Some(Cow::Borrowed("UYW"))),
            Self::Uzs => Ok(Some(Cow::Borrowed("UZS"))),
            Self::Veb => Ok(Some(Cow::Borrowed("VEB"))),
            Self::Ves => Ok(Some(Cow::Borrowed("VES"))),
            Self::Vnd => Ok(Some(Cow::Borrowed("VND"))),
            Self::Vuv => Ok(Some(Cow::Borrowed("VUV"))),
            Self::Wst => Ok(Some(Cow::Borrowed("WST"))),
            Self::Xaf => Ok(Some(Cow::Borrowed("XAF"))),
            Self::Xag => Ok(Some(Cow::Borrowed("XAG"))),
            Self::Xau => Ok(Some(Cow::Borrowed("XAU"))),
            Self::Xba => Ok(Some(Cow::Borrowed("XBA"))),
            Self::Xbb => Ok(Some(Cow::Borrowed("XBB"))),
            Self::Xbc => Ok(Some(Cow::Borrowed("XBC"))),
            Self::Xbd => Ok(Some(Cow::Borrowed("XBD"))),
            Self::Xcd => Ok(Some(Cow::Borrowed("XCD"))),
            Self::Xdr => Ok(Some(Cow::Borrowed("XDR"))),
            Self::Xof => Ok(Some(Cow::Borrowed("XOF"))),
            Self::Xpd => Ok(Some(Cow::Borrowed("XPD"))),
            Self::Xpf => Ok(Some(Cow::Borrowed("XPF"))),
            Self::Xpt => Ok(Some(Cow::Borrowed("XPT"))),
            Self::Xsu => Ok(Some(Cow::Borrowed("XSU"))),
            Self::Xts => Ok(Some(Cow::Borrowed("XTS"))),
            Self::Xua => Ok(Some(Cow::Borrowed("XUA"))),
            Self::Xxx => Ok(Some(Cow::Borrowed("XXX"))),
            Self::Ydd => Ok(Some(Cow::Borrowed("YDD"))),
            Self::Yer => Ok(Some(Cow::Borrowed("YER"))),
            Self::Yud => Ok(Some(Cow::Borrowed("YUD"))),
            Self::Zar => Ok(Some(Cow::Borrowed("ZAR"))),
            Self::Zmk => Ok(Some(Cow::Borrowed("ZMK"))),
            Self::Zmw => Ok(Some(Cow::Borrowed("ZMW"))),
            Self::Zrz => Ok(Some(Cow::Borrowed("ZRZ"))),
            Self::Zwd => Ok(Some(Cow::Borrowed("ZWD"))),
            Self::Zwl => Ok(Some(Cow::Borrowed("ZWL"))),
        }
    }
}
impl DeserializeBytes for DtCurrencies {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"ADP" => Ok(Self::Adp),
            b"AED" => Ok(Self::Aed),
            b"AFA" => Ok(Self::Afa),
            b"AFN" => Ok(Self::Afn),
            b"ALL" => Ok(Self::All),
            b"AMD" => Ok(Self::Amd),
            b"ANG" => Ok(Self::Ang),
            b"AOA" => Ok(Self::Aoa),
            b"AOK" => Ok(Self::Aok),
            b"ARA" => Ok(Self::Ara),
            b"ARS" => Ok(Self::Ars),
            b"ATS" => Ok(Self::Ats),
            b"AUD" => Ok(Self::Aud),
            b"AWG" => Ok(Self::Awg),
            b"AZN" => Ok(Self::Azn),
            b"BAM" => Ok(Self::Bam),
            b"BBD" => Ok(Self::Bbd),
            b"BDT" => Ok(Self::Bdt),
            b"BEF" => Ok(Self::Bef),
            b"BGL" => Ok(Self::Bgl),
            b"BGN" => Ok(Self::Bgn),
            b"BHD" => Ok(Self::Bhd),
            b"BIF" => Ok(Self::Bif),
            b"BMD" => Ok(Self::Bmd),
            b"BND" => Ok(Self::Bnd),
            b"BOB" => Ok(Self::Bob),
            b"BOV" => Ok(Self::Bov),
            b"BRC" => Ok(Self::Brc),
            b"BRL" => Ok(Self::Brl),
            b"BSD" => Ok(Self::Bsd),
            b"BTN" => Ok(Self::Btn),
            b"BUK" => Ok(Self::Buk),
            b"BWP" => Ok(Self::Bwp),
            b"BYN" => Ok(Self::Byn),
            b"BZD" => Ok(Self::Bzd),
            b"CAD" => Ok(Self::Cad),
            b"CDF" => Ok(Self::Cdf),
            b"CHE" => Ok(Self::Che),
            b"CHF" => Ok(Self::Chf),
            b"CHW" => Ok(Self::Chw),
            b"CLF" => Ok(Self::Clf),
            b"CLP" => Ok(Self::Clp),
            b"CNY" => Ok(Self::Cny),
            b"COP" => Ok(Self::Cop),
            b"COU" => Ok(Self::Cou),
            b"CRC" => Ok(Self::Crc),
            b"CSK" => Ok(Self::Csk),
            b"CUC" => Ok(Self::Cuc),
            b"CUP" => Ok(Self::Cup),
            b"CVE" => Ok(Self::Cve),
            b"CYP" => Ok(Self::Cyp),
            b"CZK" => Ok(Self::Czk),
            b"DDM" => Ok(Self::Ddm),
            b"DEM" => Ok(Self::Dem),
            b"DJF" => Ok(Self::Djf),
            b"DKK" => Ok(Self::Dkk),
            b"DOP" => Ok(Self::Dop),
            b"DZD" => Ok(Self::Dzd),
            b"ECS" => Ok(Self::Ecs),
            b"EGP" => Ok(Self::Egp),
            b"ERN" => Ok(Self::Ern),
            b"ESP" => Ok(Self::Esp),
            b"ETB" => Ok(Self::Etb),
            b"EUR" => Ok(Self::Eur),
            b"FIM" => Ok(Self::Fim),
            b"FJD" => Ok(Self::Fjd),
            b"FKP" => Ok(Self::Fkp),
            b"FRF" => Ok(Self::Frf),
            b"GBP" => Ok(Self::Gbp),
            b"GEL" => Ok(Self::Gel),
            b"GHC" => Ok(Self::Ghc),
            b"GHS" => Ok(Self::Ghs),
            b"GIP" => Ok(Self::Gip),
            b"GMD" => Ok(Self::Gmd),
            b"GNF" => Ok(Self::Gnf),
            b"GRD" => Ok(Self::Grd),
            b"GTQ" => Ok(Self::Gtq),
            b"GWP" => Ok(Self::Gwp),
            b"GYD" => Ok(Self::Gyd),
            b"HKD" => Ok(Self::Hkd),
            b"HNL" => Ok(Self::Hnl),
            b"HRK" => Ok(Self::Hrk),
            b"HTG" => Ok(Self::Htg),
            b"HUF" => Ok(Self::Huf),
            b"IDR" => Ok(Self::Idr),
            b"IEP" => Ok(Self::Iep),
            b"ILS" => Ok(Self::Ils),
            b"INR" => Ok(Self::Inr),
            b"IQD" => Ok(Self::Iqd),
            b"IRR" => Ok(Self::Irr),
            b"ISK" => Ok(Self::Isk),
            b"ITL" => Ok(Self::Itl),
            b"JMD" => Ok(Self::Jmd),
            b"JOD" => Ok(Self::Jod),
            b"JPY" => Ok(Self::Jpy),
            b"KES" => Ok(Self::Kes),
            b"KGS" => Ok(Self::Kgs),
            b"KHR" => Ok(Self::Khr),
            b"KMF" => Ok(Self::Kmf),
            b"KPW" => Ok(Self::Kpw),
            b"KRW" => Ok(Self::Krw),
            b"KWD" => Ok(Self::Kwd),
            b"KYD" => Ok(Self::Kyd),
            b"KZT" => Ok(Self::Kzt),
            b"LAK" => Ok(Self::Lak),
            b"LBP" => Ok(Self::Lbp),
            b"LKR" => Ok(Self::Lkr),
            b"LRD" => Ok(Self::Lrd),
            b"LSL" => Ok(Self::Lsl),
            b"LUF" => Ok(Self::Luf),
            b"LYD" => Ok(Self::Lyd),
            b"MAD" => Ok(Self::Mad),
            b"MDL" => Ok(Self::Mdl),
            b"MGA" => Ok(Self::Mga),
            b"MGF" => Ok(Self::Mgf),
            b"MKD" => Ok(Self::Mkd),
            b"MMK" => Ok(Self::Mmk),
            b"MNT" => Ok(Self::Mnt),
            b"MOP" => Ok(Self::Mop),
            b"MRO" => Ok(Self::Mro),
            b"MRU" => Ok(Self::Mru),
            b"MTL" => Ok(Self::Mtl),
            b"MUR" => Ok(Self::Mur),
            b"MVR" => Ok(Self::Mvr),
            b"MWK" => Ok(Self::Mwk),
            b"MXN" => Ok(Self::Mxn),
            b"MXP" => Ok(Self::Mxp),
            b"MXV" => Ok(Self::Mxv),
            b"MYR" => Ok(Self::Myr),
            b"MZM" => Ok(Self::Mzm),
            b"MZN" => Ok(Self::Mzn),
            b"NAD" => Ok(Self::Nad),
            b"NGN" => Ok(Self::Ngn),
            b"NIC" => Ok(Self::Nic),
            b"NIO" => Ok(Self::Nio),
            b"NLG" => Ok(Self::Nlg),
            b"NOK" => Ok(Self::Nok),
            b"NPR" => Ok(Self::Npr),
            b"NZD" => Ok(Self::Nzd),
            b"OMR" => Ok(Self::Omr),
            b"PAB" => Ok(Self::Pab),
            b"PEI" => Ok(Self::Pei),
            b"PEN" => Ok(Self::Pen),
            b"PGK" => Ok(Self::Pgk),
            b"PHP" => Ok(Self::Php),
            b"PKR" => Ok(Self::Pkr),
            b"PLZ" => Ok(Self::Plz),
            b"PLN" => Ok(Self::Pln),
            b"PTE" => Ok(Self::Pte),
            b"PYG" => Ok(Self::Pyg),
            b"QAR" => Ok(Self::Qar),
            b"ROL" => Ok(Self::Rol),
            b"RON" => Ok(Self::Ron),
            b"RSD" => Ok(Self::Rsd),
            b"RUB" => Ok(Self::Rub),
            b"RWF" => Ok(Self::Rwf),
            b"SAR" => Ok(Self::Sar),
            b"SBD" => Ok(Self::Sbd),
            b"SCR" => Ok(Self::Scr),
            b"SDG" => Ok(Self::Sdg),
            b"SDP" => Ok(Self::Sdp),
            b"SEK" => Ok(Self::Sek),
            b"SGD" => Ok(Self::Sgd),
            b"SHP" => Ok(Self::Shp),
            b"SLL" => Ok(Self::Sll),
            b"SKK" => Ok(Self::Skk),
            b"SOS" => Ok(Self::Sos),
            b"SRD" => Ok(Self::Srd),
            b"SRG" => Ok(Self::Srg),
            b"SSP" => Ok(Self::Ssp),
            b"STD" => Ok(Self::Std),
            b"STN" => Ok(Self::Stn),
            b"SUR" => Ok(Self::Sur),
            b"SVC" => Ok(Self::Svc),
            b"SYP" => Ok(Self::Syp),
            b"SZL" => Ok(Self::Szl),
            b"THB" => Ok(Self::Thb),
            b"TJS" => Ok(Self::Tjs),
            b"TMT" => Ok(Self::Tmt),
            b"TND" => Ok(Self::Tnd),
            b"TOP" => Ok(Self::Top),
            b"TPE" => Ok(Self::Tpe),
            b"TRL" => Ok(Self::Trl),
            b"TRY" => Ok(Self::Try),
            b"TTD" => Ok(Self::Ttd),
            b"TWD" => Ok(Self::Twd),
            b"TZS" => Ok(Self::Tzs),
            b"UAH" => Ok(Self::Uah),
            b"UGS" => Ok(Self::Ugs),
            b"UGX" => Ok(Self::Ugx),
            b"USD" => Ok(Self::Usd),
            b"USN" => Ok(Self::Usn),
            b"UYI" => Ok(Self::Uyi),
            b"UYP" => Ok(Self::Uyp),
            b"UYU" => Ok(Self::Uyu),
            b"UYW" => Ok(Self::Uyw),
            b"UZS" => Ok(Self::Uzs),
            b"VEB" => Ok(Self::Veb),
            b"VES" => Ok(Self::Ves),
            b"VND" => Ok(Self::Vnd),
            b"VUV" => Ok(Self::Vuv),
            b"WST" => Ok(Self::Wst),
            b"XAF" => Ok(Self::Xaf),
            b"XAG" => Ok(Self::Xag),
            b"XAU" => Ok(Self::Xau),
            b"XBA" => Ok(Self::Xba),
            b"XBB" => Ok(Self::Xbb),
            b"XBC" => Ok(Self::Xbc),
            b"XBD" => Ok(Self::Xbd),
            b"XCD" => Ok(Self::Xcd),
            b"XDR" => Ok(Self::Xdr),
            b"XOF" => Ok(Self::Xof),
            b"XPD" => Ok(Self::Xpd),
            b"XPF" => Ok(Self::Xpf),
            b"XPT" => Ok(Self::Xpt),
            b"XSU" => Ok(Self::Xsu),
            b"XTS" => Ok(Self::Xts),
            b"XUA" => Ok(Self::Xua),
            b"XXX" => Ok(Self::Xxx),
            b"YDD" => Ok(Self::Ydd),
            b"YER" => Ok(Self::Yer),
            b"YUD" => Ok(Self::Yud),
            b"ZAR" => Ok(Self::Zar),
            b"ZMK" => Ok(Self::Zmk),
            b"ZMW" => Ok(Self::Zmw),
            b"ZRZ" => Ok(Self::Zrz),
            b"ZWD" => Ok(Self::Zwd),
            b"ZWL" => Ok(Self::Zwl),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct TypePartyId {
    pub type_: String,
    pub content: String,
}
impl WithSerializer for TypePartyId {
    type Serializer<'x> = quick_xml_serialize::TypePartyIdSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::TypePartyIdSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::TypePartyIdSerializerState::Init__),
            name: name.unwrap_or("typePARTY_ID"),
            is_root,
        })
    }
}
impl WithDeserializer for TypePartyId {
    type Deserializer = quick_xml_deserialize::TypePartyIdDeserializer;
}
#[derive(Debug)]
pub struct SupplierAddressElementType {
    pub type_: SupplierAddressType,
    pub contact: Vec<DtMlstring>,
    pub street: Vec<DtMlstring>,
    pub zip: Vec<DtMlstring>,
    pub city: Vec<DtMlstring>,
    pub country: Vec<DtMlstring>,
    pub vat_id: Option<String>,
    pub email: String,
    pub url: Option<String>,
}
impl WithSerializer for SupplierAddressElementType {
    type Serializer<'x> = quick_xml_serialize::SupplierAddressElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::SupplierAddressElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::SupplierAddressElementTypeSerializerState::Init__),
            name: name.unwrap_or("SupplierAddress"),
            is_root,
        })
    }
}
impl WithDeserializer for SupplierAddressElementType {
    type Deserializer = quick_xml_deserialize::SupplierAddressElementTypeDeserializer;
}
#[derive(Debug)]
pub struct MimeInfoElementType {
    pub mime: Vec<MimeElementType>,
}
impl WithSerializer for MimeInfoElementType {
    type Serializer<'x> = quick_xml_serialize::MimeInfoElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::MimeInfoElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::MimeInfoElementTypeSerializerState::Init__),
            name: name.unwrap_or("MIME_INFO"),
            is_root,
        })
    }
}
impl WithDeserializer for MimeInfoElementType {
    type Deserializer = quick_xml_deserialize::MimeInfoElementTypeDeserializer;
}
#[derive(Debug)]
pub enum TypeBmEcatEtimVersion {
    _50,
}
impl SerializeBytes for TypeBmEcatEtimVersion {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_50 => Ok(Some(Cow::Borrowed("5.0"))),
        }
    }
}
impl DeserializeBytes for TypeBmEcatEtimVersion {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"5.0" => Ok(Self::_50),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum TNewCatalogProductMode {
    New,
}
impl SerializeBytes for TNewCatalogProductMode {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::New => Ok(Some(Cow::Borrowed("new"))),
        }
    }
}
impl DeserializeBytes for TNewCatalogProductMode {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"new" => Ok(Self::New),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct ProductDetailsElementType {
    pub description_short: Vec<DtMlstring>,
    pub description_long: Vec<DtMlstring>,
    pub international_pid: Vec<InternationalPidElementType>,
    pub supplier_alt_pid: Option<String>,
    pub buyer_pid: Option<BuyerPidElementType>,
    pub manufacturer_pid: Option<String>,
    pub manufacturer_name: Option<String>,
    pub manufacturer_type_descr: Vec<DtMlstring>,
    pub delivery_time: Option<f64>,
    pub special_treatment_class: Vec<SpecialTreatmentClassElementType>,
    pub keyword: Vec<DtMlstring>,
    pub remarks: Vec<DtMlstring>,
    pub product_status: Vec<ProductStatusElementType>,
    pub product_type: Option<ProductTypeElementType>,
}
impl WithSerializer for ProductDetailsElementType {
    type Serializer<'x> = quick_xml_serialize::ProductDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductDetailsElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductDetailsElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRODUCT_DETAILS"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductDetailsElementType {
    type Deserializer = quick_xml_deserialize::ProductDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductFeaturesElementType {
    pub reference_feature_system_name: TypeClassificationSystemName,
    pub reference_feature_group_id: String,
    pub feature: Vec<FeatureElementType>,
}
impl WithSerializer for ProductFeaturesElementType {
    type Serializer<'x> = quick_xml_serialize::ProductFeaturesElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductFeaturesElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductFeaturesElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRODUCT_FEATURES"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductFeaturesElementType {
    type Deserializer = quick_xml_deserialize::ProductFeaturesElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductOrderDetailsElementType {
    pub order_unit: DtUnit,
    pub content_unit: DtUnit,
    pub no_cu_per_ou: Option<f64>,
    pub price_quantity: Option<f64>,
    pub quantity_min: Option<f32>,
    pub quantity_interval: Option<f32>,
}
impl WithSerializer for ProductOrderDetailsElementType {
    type Serializer<'x> = quick_xml_serialize::ProductOrderDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::ProductOrderDetailsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ProductOrderDetailsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PRODUCT_ORDER_DETAILS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for ProductOrderDetailsElementType {
    type Deserializer = quick_xml_deserialize::ProductOrderDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductPriceDetailsElementType {
    pub datetime: Vec<ProductPriceDetailsDatetimeElementType>,
    pub daily_price: Option<String>,
    pub product_price: Vec<ProductPriceElementType>,
    pub price_base: Option<PriceBaseElementType>,
}
impl WithSerializer for ProductPriceDetailsElementType {
    type Serializer<'x> = quick_xml_serialize::ProductPriceDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::ProductPriceDetailsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ProductPriceDetailsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PRODUCT_PRICE_DETAILS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for ProductPriceDetailsElementType {
    type Deserializer = quick_xml_deserialize::ProductPriceDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxProduct {
    pub udx_edxf_mime_info: Option<UdxEdxfMimeInfoElementType>,
    pub udx_edxf_manufacturer_acronym: Option<String>,
    pub udx_edxf_description_very_short: Vec<DtMlstring>,
    pub udx_edxf_brand_name: Option<String>,
    pub udx_edxf_tender_text: Vec<DtMlstring>,
    pub udx_edxf_valid_from: Option<String>,
    pub udx_edxf_expiration_date: Option<String>,
    pub udx_edxf_discount_group: Option<UdxEdxfDiscountGroupElementType>,
    pub udx_edxf_bonus_group_supplier: Option<String>,
    pub udx_edxf_additional_factors: Option<UdxEdxfAdditionalFactorsElementType>,
    pub udx_edxf_product_to_stock: Option<String>,
    pub udx_edxf_product_series: Vec<DtMlstring>,
    pub udx_edxf_product_variation: Vec<DtMlstring>,
    pub udx_edxf_predecessor_pid: Vec<String>,
    pub udx_edxf_country_branch_numbers: Option<UdxEdxfCountryBranchNumbersElementType>,
    pub udx_edxf_country_branch_supplier_ids: Option<UdxEdxfCountryBranchSupplierIdsElementType>,
    pub udx_edxf_packing_units: Option<UdxEdxfPackingUnitsElementType>,
    pub udx_edxf_product_logistic_details: Option<UdxEdxfProductLogisticDetailsElementType>,
    pub udx_edxf_shelf_life_period: Option<i32>,
    pub udx_edxf_battery_contained: Option<String>,
    pub udx_edxf_rohs_indicator: Option<UdxEdxfRohsIndicatorElementType>,
    pub udx_edxf_ce_marking: Option<String>,
    pub udx_edxf_reach: Option<UdxEdxfReachElementType>,
    pub udx_edxf_special_treatment_class_details:
        Option<UdxEdxfSpecialTreatmentClassDetailsElementType>,
    pub udx_edxf_surcharge_list: Option<UdxEdxfSurchargeListElementType>,
    pub udx_edxf_warranty: Option<UdxEdxfWarrantyElementType>,
    pub udx_edxf_product_etim_dynamic: Option<UdxEdxfProductEtimDynamicElementType>,
    pub udx_edxf_product_features_mc: Option<UdxEdxfProductFeaturesMcElementType>,
    pub udx_edxf_product_characteristics: Option<UdxEdxfProductCharacteristicsElementType>,
}
impl WithSerializer for UdxProduct {
    type Serializer<'x> = quick_xml_serialize::UdxProductSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxProductSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxProductSerializerState::Init__),
            name: name.unwrap_or("udxPRODUCT"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxProduct {
    type Deserializer = quick_xml_deserialize::UdxProductDeserializer;
}
#[derive(Debug)]
pub struct ProductReferenceElementType {
    pub type_: ProductReferenceType,
    pub quantity: Option<i32>,
    pub prod_id_to: String,
    pub catalog_id: Option<String>,
    pub catalog_version: Option<String>,
    pub reference_descr: Vec<DtMlstring>,
}
impl WithSerializer for ProductReferenceElementType {
    type Serializer<'x> = quick_xml_serialize::ProductReferenceElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductReferenceElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::ProductReferenceElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("PRODUCT_REFERENCE"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductReferenceElementType {
    type Deserializer = quick_xml_deserialize::ProductReferenceElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductLogisticDetailsElementType {
    pub customs_tariff_number: Vec<CustomsTariffNumberElementType>,
    pub statistics_factor: Option<f64>,
    pub country_of_origin: Vec<String>,
}
impl WithSerializer for ProductLogisticDetailsElementType {
    type Serializer<'x> = quick_xml_serialize::ProductLogisticDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::ProductLogisticDetailsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ProductLogisticDetailsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PRODUCT_LOGISTIC_DETAILS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for ProductLogisticDetailsElementType {
    type Deserializer = quick_xml_deserialize::ProductLogisticDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub enum TUpdateProductsProductMode {
    Delete,
    New,
    Update,
}
impl SerializeBytes for TUpdateProductsProductMode {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Delete => Ok(Some(Cow::Borrowed("delete"))),
            Self::New => Ok(Some(Cow::Borrowed("new"))),
            Self::Update => Ok(Some(Cow::Borrowed("update"))),
        }
    }
}
impl DeserializeBytes for TUpdateProductsProductMode {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"delete" => Ok(Self::Delete),
            b"new" => Ok(Self::New),
            b"update" => Ok(Self::Update),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum TUpdatePricesProductMode {
    Update,
}
impl SerializeBytes for TUpdatePricesProductMode {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Update => Ok(Some(Cow::Borrowed("update"))),
        }
    }
}
impl DeserializeBytes for TUpdatePricesProductMode {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"update" => Ok(Self::Update),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum TNewProductdataProductMode {
    New,
}
impl SerializeBytes for TNewProductdataProductMode {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::New => Ok(Some(Cow::Borrowed("new"))),
        }
    }
}
impl DeserializeBytes for TNewProductdataProductMode {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"new" => Ok(Self::New),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct UdxProductdata {
    pub udx_edxf_mime_info: Option<UdxEdxfMimeInfoElementType>,
    pub udx_edxf_manufacturer_acronym: Option<String>,
    pub udx_edxf_description_very_short: Vec<DtMlstring>,
    pub udx_edxf_brand_name: Option<String>,
    pub udx_edxf_tender_text: Vec<DtMlstring>,
    pub udx_edxf_valid_from: Option<String>,
    pub udx_edxf_expiration_date: Option<String>,
    pub udx_edxf_product_series: Vec<DtMlstring>,
    pub udx_edxf_product_variation: Vec<DtMlstring>,
    pub udx_edxf_predecessor_pid: Vec<String>,
    pub udx_edxf_country_branch_numbers: Option<UdxEdxfCountryBranchNumbersElementType>,
    pub udx_edxf_country_branch_supplier_ids: Option<UdxEdxfCountryBranchSupplierIdsElementType>,
    pub udx_edxf_product_etim_dynamic: Option<UdxEdxfProductEtimDynamicElementType>,
    pub udx_edxf_product_features_mc: Option<UdxEdxfProductFeaturesMcElementType>,
    pub udx_edxf_product_characteristics: Option<UdxEdxfProductCharacteristicsElementType>,
}
impl WithSerializer for UdxProductdata {
    type Serializer<'x> = quick_xml_serialize::UdxProductdataSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxProductdataSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxProductdataSerializerState::Init__),
            name: name.unwrap_or("udxPRODUCTDATA"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxProductdata {
    type Deserializer = quick_xml_deserialize::UdxProductdataDeserializer;
}
#[derive(Debug)]
pub enum DtLang {
    Aar,
    Abk,
    Ace,
    Ach,
    Ada,
    Afa,
    Afh,
    Afr,
    Aka,
    Akk,
    Alb,
    Ale,
    Alg,
    Amh,
    Ang,
    Apa,
    Ara,
    Arc,
    Arm,
    Arn,
    Arp,
    Art,
    Arw,
    Asm,
    Ath,
    Aus,
    Ava,
    Ave,
    Awa,
    Aym,
    Aze,
    Bad,
    Bai,
    Bak,
    Bal,
    Bam,
    Ban,
    Baq,
    Bas,
    Bat,
    Bej,
    Bel,
    Bem,
    Ben,
    Ber,
    Bho,
    Bih,
    Bik,
    Bin,
    Bis,
    Bla,
    Bnt,
    Bod,
    Bos,
    Bra,
    Bre,
    Btk,
    Bua,
    Bug,
    Bul,
    Bur,
    Cad,
    Cai,
    Car,
    Cat,
    Cau,
    Ceb,
    Cel,
    Ces,
    Cha,
    Chb,
    Che,
    Chg,
    Chi,
    Chk,
    Chm,
    Chn,
    Cho,
    Chp,
    Chr,
    Chu,
    Chv,
    Chy,
    Cmc,
    Cop,
    Cor,
    Cos,
    Cpe,
    Cpf,
    Cpp,
    Cre,
    Crp,
    Cus,
    Cym,
    Cze,
    Dak,
    Dan,
    Day,
    Del,
    Den,
    Deu,
    Dgr,
    Din,
    Div,
    Doi,
    Dra,
    Dua,
    Dum,
    Dut,
    Dyu,
    Dzo,
    Efi,
    Egy,
    Eka,
    Ell,
    Elx,
    Eng,
    Enm,
    Epo,
    Est,
    Eus,
    Ewe,
    Ewo,
    Fan,
    Fao,
    Fas,
    Fat,
    Fij,
    Fin,
    Fiu,
    Fon,
    Fra,
    Fre,
    Frm,
    Fro,
    Fry,
    Ful,
    Fur,
    Gaa,
    Gay,
    Gba,
    Gem,
    Geo,
    Ger,
    Gez,
    Gil,
    Gla,
    Gle,
    Glg,
    Glv,
    Gmh,
    Goh,
    Gon,
    Gor,
    Got,
    Grb,
    Grc,
    Gre,
    Grn,
    Guj,
    Gwi,
    Hai,
    Hau,
    Haw,
    Heb,
    Her,
    Hil,
    Him,
    Hin,
    Hit,
    Hmn,
    Hmo,
    Hrv,
    Hun,
    Hup,
    Hye,
    Iba,
    Ibo,
    Ice,
    Ijo,
    Iku,
    Ile,
    Ilo,
    Ina,
    Inc,
    Ind,
    Ine,
    Ipk,
    Ira,
    Iro,
    Isl,
    Ita,
    Jav,
    Jpn,
    Jpr,
    Jrb,
    Kaa,
    Kab,
    Kac,
    Kal,
    Kam,
    Kan,
    Kar,
    Kas,
    Kat,
    Kau,
    Kaw,
    Kaz,
    Kha,
    Khi,
    Khm,
    Kho,
    Kik,
    Kin,
    Kir,
    Kmb,
    Kok,
    Kom,
    Kon,
    Kor,
    Kos,
    Kpe,
    Kro,
    Kru,
    Kua,
    Kum,
    Kur,
    Kut,
    Lad,
    Lah,
    Lam,
    Lao,
    Lat,
    Lav,
    Lez,
    Lin,
    Lit,
    Lol,
    Loz,
    Ltz,
    Lua,
    Lub,
    Lug,
    Lui,
    Lun,
    Luo,
    Lus,
    Mac,
    Mad,
    Mag,
    Mah,
    Mai,
    Mak,
    Mal,
    Man,
    Mao,
    Map,
    Mar,
    Mas,
    May,
    Mdr,
    Men,
    Mga,
    Mic,
    Min,
    Mis,
    Mkd,
    Mkh,
    Mlg,
    Mlt,
    Mnc,
    Mni,
    Mno,
    Moh,
    Mol,
    Mon,
    Mos,
    Mri,
    Msa,
    Mul,
    Mun,
    Mus,
    Mwr,
    Mya,
    Myn,
    Nah,
    Nai,
    Nau,
    Nav,
    Nbl,
    Nde,
    Ndo,
    Nds,
    Nep,
    New,
    Nia,
    Nic,
    Niu,
    Nld,
    Nno,
    Nob,
    Non,
    Nor,
    Nso,
    Nub,
    Nya,
    Nym,
    Nyn,
    Nyo,
    Nzi,
    Oci,
    Oji,
    Ori,
    Orm,
    Osa,
    Oss,
    Ota,
    Oto,
    Paa,
    Pag,
    Pal,
    Pam,
    Pan,
    Pap,
    Pau,
    Peo,
    Per,
    Phi,
    Phn,
    Pli,
    Pol,
    Pon,
    Por,
    Pra,
    Pro,
    Pus,
    Qaa,
    Que,
    Raj,
    Rap,
    Rar,
    Roa,
    Roh,
    Rom,
    Ron,
    Rum,
    Run,
    Rus,
    Sad,
    Sag,
    Sah,
    Sai,
    Sal,
    Sam,
    San,
    Sas,
    Sat,
    Scc,
    Sco,
    Scr,
    Sel,
    Sem,
    Sga,
    Sgn,
    Shn,
    Sid,
    Sin,
    Sio,
    Sit,
    Sla,
    Slk,
    Slo,
    Slv,
    Sme,
    Smi,
    Smo,
    Sna,
    Snd,
    Snk,
    Sog,
    Som,
    Son,
    Sot,
    Spa,
    Sqi,
    Srd,
    Srp,
    Srr,
    Ssa,
    Ssw,
    Suk,
    Sun,
    Sus,
    Sux,
    Swa,
    Swe,
    Syr,
    Tah,
    Tai,
    Tam,
    Tat,
    Tel,
    Tem,
    Ter,
    Tet,
    Tgk,
    Tgl,
    Tha,
    Tib,
    Tig,
    Tir,
    Tiv,
    Tkl,
    Tli,
    Tmh,
    Tog,
    Ton,
    Tpi,
    Tsi,
    Tsn,
    Tso,
    Tuk,
    Tum,
    Tur,
    Tut,
    Tvl,
    Twi,
    Tyv,
    Uga,
    Uig,
    Ukr,
    Umb,
    Und,
    Urd,
    Uzb,
    Vai,
    Ven,
    Vie,
    Vol,
    Vot,
    Wak,
    Wal,
    War,
    Was,
    Wel,
    Wen,
    Wln,
    Wol,
    Xho,
    Yao,
    Yap,
    Yid,
    Yor,
    Ypk,
    Zap,
    Zen,
    Zha,
    Zho,
    Znd,
    Zul,
}
impl SerializeBytes for DtLang {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Aar => Ok(Some(Cow::Borrowed("aar"))),
            Self::Abk => Ok(Some(Cow::Borrowed("abk"))),
            Self::Ace => Ok(Some(Cow::Borrowed("ace"))),
            Self::Ach => Ok(Some(Cow::Borrowed("ach"))),
            Self::Ada => Ok(Some(Cow::Borrowed("ada"))),
            Self::Afa => Ok(Some(Cow::Borrowed("afa"))),
            Self::Afh => Ok(Some(Cow::Borrowed("afh"))),
            Self::Afr => Ok(Some(Cow::Borrowed("afr"))),
            Self::Aka => Ok(Some(Cow::Borrowed("aka"))),
            Self::Akk => Ok(Some(Cow::Borrowed("akk"))),
            Self::Alb => Ok(Some(Cow::Borrowed("alb"))),
            Self::Ale => Ok(Some(Cow::Borrowed("ale"))),
            Self::Alg => Ok(Some(Cow::Borrowed("alg"))),
            Self::Amh => Ok(Some(Cow::Borrowed("amh"))),
            Self::Ang => Ok(Some(Cow::Borrowed("ang"))),
            Self::Apa => Ok(Some(Cow::Borrowed("apa"))),
            Self::Ara => Ok(Some(Cow::Borrowed("ara"))),
            Self::Arc => Ok(Some(Cow::Borrowed("arc"))),
            Self::Arm => Ok(Some(Cow::Borrowed("arm"))),
            Self::Arn => Ok(Some(Cow::Borrowed("arn"))),
            Self::Arp => Ok(Some(Cow::Borrowed("arp"))),
            Self::Art => Ok(Some(Cow::Borrowed("art"))),
            Self::Arw => Ok(Some(Cow::Borrowed("arw"))),
            Self::Asm => Ok(Some(Cow::Borrowed("asm"))),
            Self::Ath => Ok(Some(Cow::Borrowed("ath"))),
            Self::Aus => Ok(Some(Cow::Borrowed("aus"))),
            Self::Ava => Ok(Some(Cow::Borrowed("ava"))),
            Self::Ave => Ok(Some(Cow::Borrowed("ave"))),
            Self::Awa => Ok(Some(Cow::Borrowed("awa"))),
            Self::Aym => Ok(Some(Cow::Borrowed("aym"))),
            Self::Aze => Ok(Some(Cow::Borrowed("aze"))),
            Self::Bad => Ok(Some(Cow::Borrowed("bad"))),
            Self::Bai => Ok(Some(Cow::Borrowed("bai"))),
            Self::Bak => Ok(Some(Cow::Borrowed("bak"))),
            Self::Bal => Ok(Some(Cow::Borrowed("bal"))),
            Self::Bam => Ok(Some(Cow::Borrowed("bam"))),
            Self::Ban => Ok(Some(Cow::Borrowed("ban"))),
            Self::Baq => Ok(Some(Cow::Borrowed("baq"))),
            Self::Bas => Ok(Some(Cow::Borrowed("bas"))),
            Self::Bat => Ok(Some(Cow::Borrowed("bat"))),
            Self::Bej => Ok(Some(Cow::Borrowed("bej"))),
            Self::Bel => Ok(Some(Cow::Borrowed("bel"))),
            Self::Bem => Ok(Some(Cow::Borrowed("bem"))),
            Self::Ben => Ok(Some(Cow::Borrowed("ben"))),
            Self::Ber => Ok(Some(Cow::Borrowed("ber"))),
            Self::Bho => Ok(Some(Cow::Borrowed("bho"))),
            Self::Bih => Ok(Some(Cow::Borrowed("bih"))),
            Self::Bik => Ok(Some(Cow::Borrowed("bik"))),
            Self::Bin => Ok(Some(Cow::Borrowed("bin"))),
            Self::Bis => Ok(Some(Cow::Borrowed("bis"))),
            Self::Bla => Ok(Some(Cow::Borrowed("bla"))),
            Self::Bnt => Ok(Some(Cow::Borrowed("bnt"))),
            Self::Bod => Ok(Some(Cow::Borrowed("bod"))),
            Self::Bos => Ok(Some(Cow::Borrowed("bos"))),
            Self::Bra => Ok(Some(Cow::Borrowed("bra"))),
            Self::Bre => Ok(Some(Cow::Borrowed("bre"))),
            Self::Btk => Ok(Some(Cow::Borrowed("btk"))),
            Self::Bua => Ok(Some(Cow::Borrowed("bua"))),
            Self::Bug => Ok(Some(Cow::Borrowed("bug"))),
            Self::Bul => Ok(Some(Cow::Borrowed("bul"))),
            Self::Bur => Ok(Some(Cow::Borrowed("bur"))),
            Self::Cad => Ok(Some(Cow::Borrowed("cad"))),
            Self::Cai => Ok(Some(Cow::Borrowed("cai"))),
            Self::Car => Ok(Some(Cow::Borrowed("car"))),
            Self::Cat => Ok(Some(Cow::Borrowed("cat"))),
            Self::Cau => Ok(Some(Cow::Borrowed("cau"))),
            Self::Ceb => Ok(Some(Cow::Borrowed("ceb"))),
            Self::Cel => Ok(Some(Cow::Borrowed("cel"))),
            Self::Ces => Ok(Some(Cow::Borrowed("ces"))),
            Self::Cha => Ok(Some(Cow::Borrowed("cha"))),
            Self::Chb => Ok(Some(Cow::Borrowed("chb"))),
            Self::Che => Ok(Some(Cow::Borrowed("che"))),
            Self::Chg => Ok(Some(Cow::Borrowed("chg"))),
            Self::Chi => Ok(Some(Cow::Borrowed("chi"))),
            Self::Chk => Ok(Some(Cow::Borrowed("chk"))),
            Self::Chm => Ok(Some(Cow::Borrowed("chm"))),
            Self::Chn => Ok(Some(Cow::Borrowed("chn"))),
            Self::Cho => Ok(Some(Cow::Borrowed("cho"))),
            Self::Chp => Ok(Some(Cow::Borrowed("chp"))),
            Self::Chr => Ok(Some(Cow::Borrowed("chr"))),
            Self::Chu => Ok(Some(Cow::Borrowed("chu"))),
            Self::Chv => Ok(Some(Cow::Borrowed("chv"))),
            Self::Chy => Ok(Some(Cow::Borrowed("chy"))),
            Self::Cmc => Ok(Some(Cow::Borrowed("cmc"))),
            Self::Cop => Ok(Some(Cow::Borrowed("cop"))),
            Self::Cor => Ok(Some(Cow::Borrowed("cor"))),
            Self::Cos => Ok(Some(Cow::Borrowed("cos"))),
            Self::Cpe => Ok(Some(Cow::Borrowed("cpe"))),
            Self::Cpf => Ok(Some(Cow::Borrowed("cpf"))),
            Self::Cpp => Ok(Some(Cow::Borrowed("cpp"))),
            Self::Cre => Ok(Some(Cow::Borrowed("cre"))),
            Self::Crp => Ok(Some(Cow::Borrowed("crp"))),
            Self::Cus => Ok(Some(Cow::Borrowed("cus"))),
            Self::Cym => Ok(Some(Cow::Borrowed("cym"))),
            Self::Cze => Ok(Some(Cow::Borrowed("cze"))),
            Self::Dak => Ok(Some(Cow::Borrowed("dak"))),
            Self::Dan => Ok(Some(Cow::Borrowed("dan"))),
            Self::Day => Ok(Some(Cow::Borrowed("day"))),
            Self::Del => Ok(Some(Cow::Borrowed("del"))),
            Self::Den => Ok(Some(Cow::Borrowed("den"))),
            Self::Deu => Ok(Some(Cow::Borrowed("deu"))),
            Self::Dgr => Ok(Some(Cow::Borrowed("dgr"))),
            Self::Din => Ok(Some(Cow::Borrowed("din"))),
            Self::Div => Ok(Some(Cow::Borrowed("div"))),
            Self::Doi => Ok(Some(Cow::Borrowed("doi"))),
            Self::Dra => Ok(Some(Cow::Borrowed("dra"))),
            Self::Dua => Ok(Some(Cow::Borrowed("dua"))),
            Self::Dum => Ok(Some(Cow::Borrowed("dum"))),
            Self::Dut => Ok(Some(Cow::Borrowed("dut"))),
            Self::Dyu => Ok(Some(Cow::Borrowed("dyu"))),
            Self::Dzo => Ok(Some(Cow::Borrowed("dzo"))),
            Self::Efi => Ok(Some(Cow::Borrowed("efi"))),
            Self::Egy => Ok(Some(Cow::Borrowed("egy"))),
            Self::Eka => Ok(Some(Cow::Borrowed("eka"))),
            Self::Ell => Ok(Some(Cow::Borrowed("ell"))),
            Self::Elx => Ok(Some(Cow::Borrowed("elx"))),
            Self::Eng => Ok(Some(Cow::Borrowed("eng"))),
            Self::Enm => Ok(Some(Cow::Borrowed("enm"))),
            Self::Epo => Ok(Some(Cow::Borrowed("epo"))),
            Self::Est => Ok(Some(Cow::Borrowed("est"))),
            Self::Eus => Ok(Some(Cow::Borrowed("eus"))),
            Self::Ewe => Ok(Some(Cow::Borrowed("ewe"))),
            Self::Ewo => Ok(Some(Cow::Borrowed("ewo"))),
            Self::Fan => Ok(Some(Cow::Borrowed("fan"))),
            Self::Fao => Ok(Some(Cow::Borrowed("fao"))),
            Self::Fas => Ok(Some(Cow::Borrowed("fas"))),
            Self::Fat => Ok(Some(Cow::Borrowed("fat"))),
            Self::Fij => Ok(Some(Cow::Borrowed("fij"))),
            Self::Fin => Ok(Some(Cow::Borrowed("fin"))),
            Self::Fiu => Ok(Some(Cow::Borrowed("fiu"))),
            Self::Fon => Ok(Some(Cow::Borrowed("fon"))),
            Self::Fra => Ok(Some(Cow::Borrowed("fra"))),
            Self::Fre => Ok(Some(Cow::Borrowed("fre"))),
            Self::Frm => Ok(Some(Cow::Borrowed("frm"))),
            Self::Fro => Ok(Some(Cow::Borrowed("fro"))),
            Self::Fry => Ok(Some(Cow::Borrowed("fry"))),
            Self::Ful => Ok(Some(Cow::Borrowed("ful"))),
            Self::Fur => Ok(Some(Cow::Borrowed("fur"))),
            Self::Gaa => Ok(Some(Cow::Borrowed("gaa"))),
            Self::Gay => Ok(Some(Cow::Borrowed("gay"))),
            Self::Gba => Ok(Some(Cow::Borrowed("gba"))),
            Self::Gem => Ok(Some(Cow::Borrowed("gem"))),
            Self::Geo => Ok(Some(Cow::Borrowed("geo"))),
            Self::Ger => Ok(Some(Cow::Borrowed("ger"))),
            Self::Gez => Ok(Some(Cow::Borrowed("gez"))),
            Self::Gil => Ok(Some(Cow::Borrowed("gil"))),
            Self::Gla => Ok(Some(Cow::Borrowed("gla"))),
            Self::Gle => Ok(Some(Cow::Borrowed("gle"))),
            Self::Glg => Ok(Some(Cow::Borrowed("glg"))),
            Self::Glv => Ok(Some(Cow::Borrowed("glv"))),
            Self::Gmh => Ok(Some(Cow::Borrowed("gmh"))),
            Self::Goh => Ok(Some(Cow::Borrowed("goh"))),
            Self::Gon => Ok(Some(Cow::Borrowed("gon"))),
            Self::Gor => Ok(Some(Cow::Borrowed("gor"))),
            Self::Got => Ok(Some(Cow::Borrowed("got"))),
            Self::Grb => Ok(Some(Cow::Borrowed("grb"))),
            Self::Grc => Ok(Some(Cow::Borrowed("grc"))),
            Self::Gre => Ok(Some(Cow::Borrowed("gre"))),
            Self::Grn => Ok(Some(Cow::Borrowed("grn"))),
            Self::Guj => Ok(Some(Cow::Borrowed("guj"))),
            Self::Gwi => Ok(Some(Cow::Borrowed("gwi"))),
            Self::Hai => Ok(Some(Cow::Borrowed("hai"))),
            Self::Hau => Ok(Some(Cow::Borrowed("hau"))),
            Self::Haw => Ok(Some(Cow::Borrowed("haw"))),
            Self::Heb => Ok(Some(Cow::Borrowed("heb"))),
            Self::Her => Ok(Some(Cow::Borrowed("her"))),
            Self::Hil => Ok(Some(Cow::Borrowed("hil"))),
            Self::Him => Ok(Some(Cow::Borrowed("him"))),
            Self::Hin => Ok(Some(Cow::Borrowed("hin"))),
            Self::Hit => Ok(Some(Cow::Borrowed("hit"))),
            Self::Hmn => Ok(Some(Cow::Borrowed("hmn"))),
            Self::Hmo => Ok(Some(Cow::Borrowed("hmo"))),
            Self::Hrv => Ok(Some(Cow::Borrowed("hrv"))),
            Self::Hun => Ok(Some(Cow::Borrowed("hun"))),
            Self::Hup => Ok(Some(Cow::Borrowed("hup"))),
            Self::Hye => Ok(Some(Cow::Borrowed("hye"))),
            Self::Iba => Ok(Some(Cow::Borrowed("iba"))),
            Self::Ibo => Ok(Some(Cow::Borrowed("ibo"))),
            Self::Ice => Ok(Some(Cow::Borrowed("ice"))),
            Self::Ijo => Ok(Some(Cow::Borrowed("ijo"))),
            Self::Iku => Ok(Some(Cow::Borrowed("iku"))),
            Self::Ile => Ok(Some(Cow::Borrowed("ile"))),
            Self::Ilo => Ok(Some(Cow::Borrowed("ilo"))),
            Self::Ina => Ok(Some(Cow::Borrowed("ina"))),
            Self::Inc => Ok(Some(Cow::Borrowed("inc"))),
            Self::Ind => Ok(Some(Cow::Borrowed("ind"))),
            Self::Ine => Ok(Some(Cow::Borrowed("ine"))),
            Self::Ipk => Ok(Some(Cow::Borrowed("ipk"))),
            Self::Ira => Ok(Some(Cow::Borrowed("ira"))),
            Self::Iro => Ok(Some(Cow::Borrowed("iro"))),
            Self::Isl => Ok(Some(Cow::Borrowed("isl"))),
            Self::Ita => Ok(Some(Cow::Borrowed("ita"))),
            Self::Jav => Ok(Some(Cow::Borrowed("jav"))),
            Self::Jpn => Ok(Some(Cow::Borrowed("jpn"))),
            Self::Jpr => Ok(Some(Cow::Borrowed("jpr"))),
            Self::Jrb => Ok(Some(Cow::Borrowed("jrb"))),
            Self::Kaa => Ok(Some(Cow::Borrowed("kaa"))),
            Self::Kab => Ok(Some(Cow::Borrowed("kab"))),
            Self::Kac => Ok(Some(Cow::Borrowed("kac"))),
            Self::Kal => Ok(Some(Cow::Borrowed("kal"))),
            Self::Kam => Ok(Some(Cow::Borrowed("kam"))),
            Self::Kan => Ok(Some(Cow::Borrowed("kan"))),
            Self::Kar => Ok(Some(Cow::Borrowed("kar"))),
            Self::Kas => Ok(Some(Cow::Borrowed("kas"))),
            Self::Kat => Ok(Some(Cow::Borrowed("kat"))),
            Self::Kau => Ok(Some(Cow::Borrowed("kau"))),
            Self::Kaw => Ok(Some(Cow::Borrowed("kaw"))),
            Self::Kaz => Ok(Some(Cow::Borrowed("kaz"))),
            Self::Kha => Ok(Some(Cow::Borrowed("kha"))),
            Self::Khi => Ok(Some(Cow::Borrowed("khi"))),
            Self::Khm => Ok(Some(Cow::Borrowed("khm"))),
            Self::Kho => Ok(Some(Cow::Borrowed("kho"))),
            Self::Kik => Ok(Some(Cow::Borrowed("kik"))),
            Self::Kin => Ok(Some(Cow::Borrowed("kin"))),
            Self::Kir => Ok(Some(Cow::Borrowed("kir"))),
            Self::Kmb => Ok(Some(Cow::Borrowed("kmb"))),
            Self::Kok => Ok(Some(Cow::Borrowed("kok"))),
            Self::Kom => Ok(Some(Cow::Borrowed("kom"))),
            Self::Kon => Ok(Some(Cow::Borrowed("kon"))),
            Self::Kor => Ok(Some(Cow::Borrowed("kor"))),
            Self::Kos => Ok(Some(Cow::Borrowed("kos"))),
            Self::Kpe => Ok(Some(Cow::Borrowed("kpe"))),
            Self::Kro => Ok(Some(Cow::Borrowed("kro"))),
            Self::Kru => Ok(Some(Cow::Borrowed("kru"))),
            Self::Kua => Ok(Some(Cow::Borrowed("kua"))),
            Self::Kum => Ok(Some(Cow::Borrowed("kum"))),
            Self::Kur => Ok(Some(Cow::Borrowed("kur"))),
            Self::Kut => Ok(Some(Cow::Borrowed("kut"))),
            Self::Lad => Ok(Some(Cow::Borrowed("lad"))),
            Self::Lah => Ok(Some(Cow::Borrowed("lah"))),
            Self::Lam => Ok(Some(Cow::Borrowed("lam"))),
            Self::Lao => Ok(Some(Cow::Borrowed("lao"))),
            Self::Lat => Ok(Some(Cow::Borrowed("lat"))),
            Self::Lav => Ok(Some(Cow::Borrowed("lav"))),
            Self::Lez => Ok(Some(Cow::Borrowed("lez"))),
            Self::Lin => Ok(Some(Cow::Borrowed("lin"))),
            Self::Lit => Ok(Some(Cow::Borrowed("lit"))),
            Self::Lol => Ok(Some(Cow::Borrowed("lol"))),
            Self::Loz => Ok(Some(Cow::Borrowed("loz"))),
            Self::Ltz => Ok(Some(Cow::Borrowed("ltz"))),
            Self::Lua => Ok(Some(Cow::Borrowed("lua"))),
            Self::Lub => Ok(Some(Cow::Borrowed("lub"))),
            Self::Lug => Ok(Some(Cow::Borrowed("lug"))),
            Self::Lui => Ok(Some(Cow::Borrowed("lui"))),
            Self::Lun => Ok(Some(Cow::Borrowed("lun"))),
            Self::Luo => Ok(Some(Cow::Borrowed("luo"))),
            Self::Lus => Ok(Some(Cow::Borrowed("lus"))),
            Self::Mac => Ok(Some(Cow::Borrowed("mac"))),
            Self::Mad => Ok(Some(Cow::Borrowed("mad"))),
            Self::Mag => Ok(Some(Cow::Borrowed("mag"))),
            Self::Mah => Ok(Some(Cow::Borrowed("mah"))),
            Self::Mai => Ok(Some(Cow::Borrowed("mai"))),
            Self::Mak => Ok(Some(Cow::Borrowed("mak"))),
            Self::Mal => Ok(Some(Cow::Borrowed("mal"))),
            Self::Man => Ok(Some(Cow::Borrowed("man"))),
            Self::Mao => Ok(Some(Cow::Borrowed("mao"))),
            Self::Map => Ok(Some(Cow::Borrowed("map"))),
            Self::Mar => Ok(Some(Cow::Borrowed("mar"))),
            Self::Mas => Ok(Some(Cow::Borrowed("mas"))),
            Self::May => Ok(Some(Cow::Borrowed("may"))),
            Self::Mdr => Ok(Some(Cow::Borrowed("mdr"))),
            Self::Men => Ok(Some(Cow::Borrowed("men"))),
            Self::Mga => Ok(Some(Cow::Borrowed("mga"))),
            Self::Mic => Ok(Some(Cow::Borrowed("mic"))),
            Self::Min => Ok(Some(Cow::Borrowed("min"))),
            Self::Mis => Ok(Some(Cow::Borrowed("mis"))),
            Self::Mkd => Ok(Some(Cow::Borrowed("mkd"))),
            Self::Mkh => Ok(Some(Cow::Borrowed("mkh"))),
            Self::Mlg => Ok(Some(Cow::Borrowed("mlg"))),
            Self::Mlt => Ok(Some(Cow::Borrowed("mlt"))),
            Self::Mnc => Ok(Some(Cow::Borrowed("mnc"))),
            Self::Mni => Ok(Some(Cow::Borrowed("mni"))),
            Self::Mno => Ok(Some(Cow::Borrowed("mno"))),
            Self::Moh => Ok(Some(Cow::Borrowed("moh"))),
            Self::Mol => Ok(Some(Cow::Borrowed("mol"))),
            Self::Mon => Ok(Some(Cow::Borrowed("mon"))),
            Self::Mos => Ok(Some(Cow::Borrowed("mos"))),
            Self::Mri => Ok(Some(Cow::Borrowed("mri"))),
            Self::Msa => Ok(Some(Cow::Borrowed("msa"))),
            Self::Mul => Ok(Some(Cow::Borrowed("mul"))),
            Self::Mun => Ok(Some(Cow::Borrowed("mun"))),
            Self::Mus => Ok(Some(Cow::Borrowed("mus"))),
            Self::Mwr => Ok(Some(Cow::Borrowed("mwr"))),
            Self::Mya => Ok(Some(Cow::Borrowed("mya"))),
            Self::Myn => Ok(Some(Cow::Borrowed("myn"))),
            Self::Nah => Ok(Some(Cow::Borrowed("nah"))),
            Self::Nai => Ok(Some(Cow::Borrowed("nai"))),
            Self::Nau => Ok(Some(Cow::Borrowed("nau"))),
            Self::Nav => Ok(Some(Cow::Borrowed("nav"))),
            Self::Nbl => Ok(Some(Cow::Borrowed("nbl"))),
            Self::Nde => Ok(Some(Cow::Borrowed("nde"))),
            Self::Ndo => Ok(Some(Cow::Borrowed("ndo"))),
            Self::Nds => Ok(Some(Cow::Borrowed("nds"))),
            Self::Nep => Ok(Some(Cow::Borrowed("nep"))),
            Self::New => Ok(Some(Cow::Borrowed("new"))),
            Self::Nia => Ok(Some(Cow::Borrowed("nia"))),
            Self::Nic => Ok(Some(Cow::Borrowed("nic"))),
            Self::Niu => Ok(Some(Cow::Borrowed("niu"))),
            Self::Nld => Ok(Some(Cow::Borrowed("nld"))),
            Self::Nno => Ok(Some(Cow::Borrowed("nno"))),
            Self::Nob => Ok(Some(Cow::Borrowed("nob"))),
            Self::Non => Ok(Some(Cow::Borrowed("non"))),
            Self::Nor => Ok(Some(Cow::Borrowed("nor"))),
            Self::Nso => Ok(Some(Cow::Borrowed("nso"))),
            Self::Nub => Ok(Some(Cow::Borrowed("nub"))),
            Self::Nya => Ok(Some(Cow::Borrowed("nya"))),
            Self::Nym => Ok(Some(Cow::Borrowed("nym"))),
            Self::Nyn => Ok(Some(Cow::Borrowed("nyn"))),
            Self::Nyo => Ok(Some(Cow::Borrowed("nyo"))),
            Self::Nzi => Ok(Some(Cow::Borrowed("nzi"))),
            Self::Oci => Ok(Some(Cow::Borrowed("oci"))),
            Self::Oji => Ok(Some(Cow::Borrowed("oji"))),
            Self::Ori => Ok(Some(Cow::Borrowed("ori"))),
            Self::Orm => Ok(Some(Cow::Borrowed("orm"))),
            Self::Osa => Ok(Some(Cow::Borrowed("osa"))),
            Self::Oss => Ok(Some(Cow::Borrowed("oss"))),
            Self::Ota => Ok(Some(Cow::Borrowed("ota"))),
            Self::Oto => Ok(Some(Cow::Borrowed("oto"))),
            Self::Paa => Ok(Some(Cow::Borrowed("paa"))),
            Self::Pag => Ok(Some(Cow::Borrowed("pag"))),
            Self::Pal => Ok(Some(Cow::Borrowed("pal"))),
            Self::Pam => Ok(Some(Cow::Borrowed("pam"))),
            Self::Pan => Ok(Some(Cow::Borrowed("pan"))),
            Self::Pap => Ok(Some(Cow::Borrowed("pap"))),
            Self::Pau => Ok(Some(Cow::Borrowed("pau"))),
            Self::Peo => Ok(Some(Cow::Borrowed("peo"))),
            Self::Per => Ok(Some(Cow::Borrowed("per"))),
            Self::Phi => Ok(Some(Cow::Borrowed("phi"))),
            Self::Phn => Ok(Some(Cow::Borrowed("phn"))),
            Self::Pli => Ok(Some(Cow::Borrowed("pli"))),
            Self::Pol => Ok(Some(Cow::Borrowed("pol"))),
            Self::Pon => Ok(Some(Cow::Borrowed("pon"))),
            Self::Por => Ok(Some(Cow::Borrowed("por"))),
            Self::Pra => Ok(Some(Cow::Borrowed("pra"))),
            Self::Pro => Ok(Some(Cow::Borrowed("pro"))),
            Self::Pus => Ok(Some(Cow::Borrowed("pus"))),
            Self::Qaa => Ok(Some(Cow::Borrowed("qaa"))),
            Self::Que => Ok(Some(Cow::Borrowed("que"))),
            Self::Raj => Ok(Some(Cow::Borrowed("raj"))),
            Self::Rap => Ok(Some(Cow::Borrowed("rap"))),
            Self::Rar => Ok(Some(Cow::Borrowed("rar"))),
            Self::Roa => Ok(Some(Cow::Borrowed("roa"))),
            Self::Roh => Ok(Some(Cow::Borrowed("roh"))),
            Self::Rom => Ok(Some(Cow::Borrowed("rom"))),
            Self::Ron => Ok(Some(Cow::Borrowed("ron"))),
            Self::Rum => Ok(Some(Cow::Borrowed("rum"))),
            Self::Run => Ok(Some(Cow::Borrowed("run"))),
            Self::Rus => Ok(Some(Cow::Borrowed("rus"))),
            Self::Sad => Ok(Some(Cow::Borrowed("sad"))),
            Self::Sag => Ok(Some(Cow::Borrowed("sag"))),
            Self::Sah => Ok(Some(Cow::Borrowed("sah"))),
            Self::Sai => Ok(Some(Cow::Borrowed("sai"))),
            Self::Sal => Ok(Some(Cow::Borrowed("sal"))),
            Self::Sam => Ok(Some(Cow::Borrowed("sam"))),
            Self::San => Ok(Some(Cow::Borrowed("san"))),
            Self::Sas => Ok(Some(Cow::Borrowed("sas"))),
            Self::Sat => Ok(Some(Cow::Borrowed("sat"))),
            Self::Scc => Ok(Some(Cow::Borrowed("scc"))),
            Self::Sco => Ok(Some(Cow::Borrowed("sco"))),
            Self::Scr => Ok(Some(Cow::Borrowed("scr"))),
            Self::Sel => Ok(Some(Cow::Borrowed("sel"))),
            Self::Sem => Ok(Some(Cow::Borrowed("sem"))),
            Self::Sga => Ok(Some(Cow::Borrowed("sga"))),
            Self::Sgn => Ok(Some(Cow::Borrowed("sgn"))),
            Self::Shn => Ok(Some(Cow::Borrowed("shn"))),
            Self::Sid => Ok(Some(Cow::Borrowed("sid"))),
            Self::Sin => Ok(Some(Cow::Borrowed("sin"))),
            Self::Sio => Ok(Some(Cow::Borrowed("sio"))),
            Self::Sit => Ok(Some(Cow::Borrowed("sit"))),
            Self::Sla => Ok(Some(Cow::Borrowed("sla"))),
            Self::Slk => Ok(Some(Cow::Borrowed("slk"))),
            Self::Slo => Ok(Some(Cow::Borrowed("slo"))),
            Self::Slv => Ok(Some(Cow::Borrowed("slv"))),
            Self::Sme => Ok(Some(Cow::Borrowed("sme"))),
            Self::Smi => Ok(Some(Cow::Borrowed("smi"))),
            Self::Smo => Ok(Some(Cow::Borrowed("smo"))),
            Self::Sna => Ok(Some(Cow::Borrowed("sna"))),
            Self::Snd => Ok(Some(Cow::Borrowed("snd"))),
            Self::Snk => Ok(Some(Cow::Borrowed("snk"))),
            Self::Sog => Ok(Some(Cow::Borrowed("sog"))),
            Self::Som => Ok(Some(Cow::Borrowed("som"))),
            Self::Son => Ok(Some(Cow::Borrowed("son"))),
            Self::Sot => Ok(Some(Cow::Borrowed("sot"))),
            Self::Spa => Ok(Some(Cow::Borrowed("spa"))),
            Self::Sqi => Ok(Some(Cow::Borrowed("sqi"))),
            Self::Srd => Ok(Some(Cow::Borrowed("srd"))),
            Self::Srp => Ok(Some(Cow::Borrowed("srp"))),
            Self::Srr => Ok(Some(Cow::Borrowed("srr"))),
            Self::Ssa => Ok(Some(Cow::Borrowed("ssa"))),
            Self::Ssw => Ok(Some(Cow::Borrowed("ssw"))),
            Self::Suk => Ok(Some(Cow::Borrowed("suk"))),
            Self::Sun => Ok(Some(Cow::Borrowed("sun"))),
            Self::Sus => Ok(Some(Cow::Borrowed("sus"))),
            Self::Sux => Ok(Some(Cow::Borrowed("sux"))),
            Self::Swa => Ok(Some(Cow::Borrowed("swa"))),
            Self::Swe => Ok(Some(Cow::Borrowed("swe"))),
            Self::Syr => Ok(Some(Cow::Borrowed("syr"))),
            Self::Tah => Ok(Some(Cow::Borrowed("tah"))),
            Self::Tai => Ok(Some(Cow::Borrowed("tai"))),
            Self::Tam => Ok(Some(Cow::Borrowed("tam"))),
            Self::Tat => Ok(Some(Cow::Borrowed("tat"))),
            Self::Tel => Ok(Some(Cow::Borrowed("tel"))),
            Self::Tem => Ok(Some(Cow::Borrowed("tem"))),
            Self::Ter => Ok(Some(Cow::Borrowed("ter"))),
            Self::Tet => Ok(Some(Cow::Borrowed("tet"))),
            Self::Tgk => Ok(Some(Cow::Borrowed("tgk"))),
            Self::Tgl => Ok(Some(Cow::Borrowed("tgl"))),
            Self::Tha => Ok(Some(Cow::Borrowed("tha"))),
            Self::Tib => Ok(Some(Cow::Borrowed("tib"))),
            Self::Tig => Ok(Some(Cow::Borrowed("tig"))),
            Self::Tir => Ok(Some(Cow::Borrowed("tir"))),
            Self::Tiv => Ok(Some(Cow::Borrowed("tiv"))),
            Self::Tkl => Ok(Some(Cow::Borrowed("tkl"))),
            Self::Tli => Ok(Some(Cow::Borrowed("tli"))),
            Self::Tmh => Ok(Some(Cow::Borrowed("tmh"))),
            Self::Tog => Ok(Some(Cow::Borrowed("tog"))),
            Self::Ton => Ok(Some(Cow::Borrowed("ton"))),
            Self::Tpi => Ok(Some(Cow::Borrowed("tpi"))),
            Self::Tsi => Ok(Some(Cow::Borrowed("tsi"))),
            Self::Tsn => Ok(Some(Cow::Borrowed("tsn"))),
            Self::Tso => Ok(Some(Cow::Borrowed("tso"))),
            Self::Tuk => Ok(Some(Cow::Borrowed("tuk"))),
            Self::Tum => Ok(Some(Cow::Borrowed("tum"))),
            Self::Tur => Ok(Some(Cow::Borrowed("tur"))),
            Self::Tut => Ok(Some(Cow::Borrowed("tut"))),
            Self::Tvl => Ok(Some(Cow::Borrowed("tvl"))),
            Self::Twi => Ok(Some(Cow::Borrowed("twi"))),
            Self::Tyv => Ok(Some(Cow::Borrowed("tyv"))),
            Self::Uga => Ok(Some(Cow::Borrowed("uga"))),
            Self::Uig => Ok(Some(Cow::Borrowed("uig"))),
            Self::Ukr => Ok(Some(Cow::Borrowed("ukr"))),
            Self::Umb => Ok(Some(Cow::Borrowed("umb"))),
            Self::Und => Ok(Some(Cow::Borrowed("und"))),
            Self::Urd => Ok(Some(Cow::Borrowed("urd"))),
            Self::Uzb => Ok(Some(Cow::Borrowed("uzb"))),
            Self::Vai => Ok(Some(Cow::Borrowed("vai"))),
            Self::Ven => Ok(Some(Cow::Borrowed("ven"))),
            Self::Vie => Ok(Some(Cow::Borrowed("vie"))),
            Self::Vol => Ok(Some(Cow::Borrowed("vol"))),
            Self::Vot => Ok(Some(Cow::Borrowed("vot"))),
            Self::Wak => Ok(Some(Cow::Borrowed("wak"))),
            Self::Wal => Ok(Some(Cow::Borrowed("wal"))),
            Self::War => Ok(Some(Cow::Borrowed("war"))),
            Self::Was => Ok(Some(Cow::Borrowed("was"))),
            Self::Wel => Ok(Some(Cow::Borrowed("wel"))),
            Self::Wen => Ok(Some(Cow::Borrowed("wen"))),
            Self::Wln => Ok(Some(Cow::Borrowed("wln"))),
            Self::Wol => Ok(Some(Cow::Borrowed("wol"))),
            Self::Xho => Ok(Some(Cow::Borrowed("xho"))),
            Self::Yao => Ok(Some(Cow::Borrowed("yao"))),
            Self::Yap => Ok(Some(Cow::Borrowed("yap"))),
            Self::Yid => Ok(Some(Cow::Borrowed("yid"))),
            Self::Yor => Ok(Some(Cow::Borrowed("yor"))),
            Self::Ypk => Ok(Some(Cow::Borrowed("ypk"))),
            Self::Zap => Ok(Some(Cow::Borrowed("zap"))),
            Self::Zen => Ok(Some(Cow::Borrowed("zen"))),
            Self::Zha => Ok(Some(Cow::Borrowed("zha"))),
            Self::Zho => Ok(Some(Cow::Borrowed("zho"))),
            Self::Znd => Ok(Some(Cow::Borrowed("znd"))),
            Self::Zul => Ok(Some(Cow::Borrowed("zul"))),
        }
    }
}
impl DeserializeBytes for DtLang {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"aar" => Ok(Self::Aar),
            b"abk" => Ok(Self::Abk),
            b"ace" => Ok(Self::Ace),
            b"ach" => Ok(Self::Ach),
            b"ada" => Ok(Self::Ada),
            b"afa" => Ok(Self::Afa),
            b"afh" => Ok(Self::Afh),
            b"afr" => Ok(Self::Afr),
            b"aka" => Ok(Self::Aka),
            b"akk" => Ok(Self::Akk),
            b"alb" => Ok(Self::Alb),
            b"ale" => Ok(Self::Ale),
            b"alg" => Ok(Self::Alg),
            b"amh" => Ok(Self::Amh),
            b"ang" => Ok(Self::Ang),
            b"apa" => Ok(Self::Apa),
            b"ara" => Ok(Self::Ara),
            b"arc" => Ok(Self::Arc),
            b"arm" => Ok(Self::Arm),
            b"arn" => Ok(Self::Arn),
            b"arp" => Ok(Self::Arp),
            b"art" => Ok(Self::Art),
            b"arw" => Ok(Self::Arw),
            b"asm" => Ok(Self::Asm),
            b"ath" => Ok(Self::Ath),
            b"aus" => Ok(Self::Aus),
            b"ava" => Ok(Self::Ava),
            b"ave" => Ok(Self::Ave),
            b"awa" => Ok(Self::Awa),
            b"aym" => Ok(Self::Aym),
            b"aze" => Ok(Self::Aze),
            b"bad" => Ok(Self::Bad),
            b"bai" => Ok(Self::Bai),
            b"bak" => Ok(Self::Bak),
            b"bal" => Ok(Self::Bal),
            b"bam" => Ok(Self::Bam),
            b"ban" => Ok(Self::Ban),
            b"baq" => Ok(Self::Baq),
            b"bas" => Ok(Self::Bas),
            b"bat" => Ok(Self::Bat),
            b"bej" => Ok(Self::Bej),
            b"bel" => Ok(Self::Bel),
            b"bem" => Ok(Self::Bem),
            b"ben" => Ok(Self::Ben),
            b"ber" => Ok(Self::Ber),
            b"bho" => Ok(Self::Bho),
            b"bih" => Ok(Self::Bih),
            b"bik" => Ok(Self::Bik),
            b"bin" => Ok(Self::Bin),
            b"bis" => Ok(Self::Bis),
            b"bla" => Ok(Self::Bla),
            b"bnt" => Ok(Self::Bnt),
            b"bod" => Ok(Self::Bod),
            b"bos" => Ok(Self::Bos),
            b"bra" => Ok(Self::Bra),
            b"bre" => Ok(Self::Bre),
            b"btk" => Ok(Self::Btk),
            b"bua" => Ok(Self::Bua),
            b"bug" => Ok(Self::Bug),
            b"bul" => Ok(Self::Bul),
            b"bur" => Ok(Self::Bur),
            b"cad" => Ok(Self::Cad),
            b"cai" => Ok(Self::Cai),
            b"car" => Ok(Self::Car),
            b"cat" => Ok(Self::Cat),
            b"cau" => Ok(Self::Cau),
            b"ceb" => Ok(Self::Ceb),
            b"cel" => Ok(Self::Cel),
            b"ces" => Ok(Self::Ces),
            b"cha" => Ok(Self::Cha),
            b"chb" => Ok(Self::Chb),
            b"che" => Ok(Self::Che),
            b"chg" => Ok(Self::Chg),
            b"chi" => Ok(Self::Chi),
            b"chk" => Ok(Self::Chk),
            b"chm" => Ok(Self::Chm),
            b"chn" => Ok(Self::Chn),
            b"cho" => Ok(Self::Cho),
            b"chp" => Ok(Self::Chp),
            b"chr" => Ok(Self::Chr),
            b"chu" => Ok(Self::Chu),
            b"chv" => Ok(Self::Chv),
            b"chy" => Ok(Self::Chy),
            b"cmc" => Ok(Self::Cmc),
            b"cop" => Ok(Self::Cop),
            b"cor" => Ok(Self::Cor),
            b"cos" => Ok(Self::Cos),
            b"cpe" => Ok(Self::Cpe),
            b"cpf" => Ok(Self::Cpf),
            b"cpp" => Ok(Self::Cpp),
            b"cre" => Ok(Self::Cre),
            b"crp" => Ok(Self::Crp),
            b"cus" => Ok(Self::Cus),
            b"cym" => Ok(Self::Cym),
            b"cze" => Ok(Self::Cze),
            b"dak" => Ok(Self::Dak),
            b"dan" => Ok(Self::Dan),
            b"day" => Ok(Self::Day),
            b"del" => Ok(Self::Del),
            b"den" => Ok(Self::Den),
            b"deu" => Ok(Self::Deu),
            b"dgr" => Ok(Self::Dgr),
            b"din" => Ok(Self::Din),
            b"div" => Ok(Self::Div),
            b"doi" => Ok(Self::Doi),
            b"dra" => Ok(Self::Dra),
            b"dua" => Ok(Self::Dua),
            b"dum" => Ok(Self::Dum),
            b"dut" => Ok(Self::Dut),
            b"dyu" => Ok(Self::Dyu),
            b"dzo" => Ok(Self::Dzo),
            b"efi" => Ok(Self::Efi),
            b"egy" => Ok(Self::Egy),
            b"eka" => Ok(Self::Eka),
            b"ell" => Ok(Self::Ell),
            b"elx" => Ok(Self::Elx),
            b"eng" => Ok(Self::Eng),
            b"enm" => Ok(Self::Enm),
            b"epo" => Ok(Self::Epo),
            b"est" => Ok(Self::Est),
            b"eus" => Ok(Self::Eus),
            b"ewe" => Ok(Self::Ewe),
            b"ewo" => Ok(Self::Ewo),
            b"fan" => Ok(Self::Fan),
            b"fao" => Ok(Self::Fao),
            b"fas" => Ok(Self::Fas),
            b"fat" => Ok(Self::Fat),
            b"fij" => Ok(Self::Fij),
            b"fin" => Ok(Self::Fin),
            b"fiu" => Ok(Self::Fiu),
            b"fon" => Ok(Self::Fon),
            b"fra" => Ok(Self::Fra),
            b"fre" => Ok(Self::Fre),
            b"frm" => Ok(Self::Frm),
            b"fro" => Ok(Self::Fro),
            b"fry" => Ok(Self::Fry),
            b"ful" => Ok(Self::Ful),
            b"fur" => Ok(Self::Fur),
            b"gaa" => Ok(Self::Gaa),
            b"gay" => Ok(Self::Gay),
            b"gba" => Ok(Self::Gba),
            b"gem" => Ok(Self::Gem),
            b"geo" => Ok(Self::Geo),
            b"ger" => Ok(Self::Ger),
            b"gez" => Ok(Self::Gez),
            b"gil" => Ok(Self::Gil),
            b"gla" => Ok(Self::Gla),
            b"gle" => Ok(Self::Gle),
            b"glg" => Ok(Self::Glg),
            b"glv" => Ok(Self::Glv),
            b"gmh" => Ok(Self::Gmh),
            b"goh" => Ok(Self::Goh),
            b"gon" => Ok(Self::Gon),
            b"gor" => Ok(Self::Gor),
            b"got" => Ok(Self::Got),
            b"grb" => Ok(Self::Grb),
            b"grc" => Ok(Self::Grc),
            b"gre" => Ok(Self::Gre),
            b"grn" => Ok(Self::Grn),
            b"guj" => Ok(Self::Guj),
            b"gwi" => Ok(Self::Gwi),
            b"hai" => Ok(Self::Hai),
            b"hau" => Ok(Self::Hau),
            b"haw" => Ok(Self::Haw),
            b"heb" => Ok(Self::Heb),
            b"her" => Ok(Self::Her),
            b"hil" => Ok(Self::Hil),
            b"him" => Ok(Self::Him),
            b"hin" => Ok(Self::Hin),
            b"hit" => Ok(Self::Hit),
            b"hmn" => Ok(Self::Hmn),
            b"hmo" => Ok(Self::Hmo),
            b"hrv" => Ok(Self::Hrv),
            b"hun" => Ok(Self::Hun),
            b"hup" => Ok(Self::Hup),
            b"hye" => Ok(Self::Hye),
            b"iba" => Ok(Self::Iba),
            b"ibo" => Ok(Self::Ibo),
            b"ice" => Ok(Self::Ice),
            b"ijo" => Ok(Self::Ijo),
            b"iku" => Ok(Self::Iku),
            b"ile" => Ok(Self::Ile),
            b"ilo" => Ok(Self::Ilo),
            b"ina" => Ok(Self::Ina),
            b"inc" => Ok(Self::Inc),
            b"ind" => Ok(Self::Ind),
            b"ine" => Ok(Self::Ine),
            b"ipk" => Ok(Self::Ipk),
            b"ira" => Ok(Self::Ira),
            b"iro" => Ok(Self::Iro),
            b"isl" => Ok(Self::Isl),
            b"ita" => Ok(Self::Ita),
            b"jav" => Ok(Self::Jav),
            b"jpn" => Ok(Self::Jpn),
            b"jpr" => Ok(Self::Jpr),
            b"jrb" => Ok(Self::Jrb),
            b"kaa" => Ok(Self::Kaa),
            b"kab" => Ok(Self::Kab),
            b"kac" => Ok(Self::Kac),
            b"kal" => Ok(Self::Kal),
            b"kam" => Ok(Self::Kam),
            b"kan" => Ok(Self::Kan),
            b"kar" => Ok(Self::Kar),
            b"kas" => Ok(Self::Kas),
            b"kat" => Ok(Self::Kat),
            b"kau" => Ok(Self::Kau),
            b"kaw" => Ok(Self::Kaw),
            b"kaz" => Ok(Self::Kaz),
            b"kha" => Ok(Self::Kha),
            b"khi" => Ok(Self::Khi),
            b"khm" => Ok(Self::Khm),
            b"kho" => Ok(Self::Kho),
            b"kik" => Ok(Self::Kik),
            b"kin" => Ok(Self::Kin),
            b"kir" => Ok(Self::Kir),
            b"kmb" => Ok(Self::Kmb),
            b"kok" => Ok(Self::Kok),
            b"kom" => Ok(Self::Kom),
            b"kon" => Ok(Self::Kon),
            b"kor" => Ok(Self::Kor),
            b"kos" => Ok(Self::Kos),
            b"kpe" => Ok(Self::Kpe),
            b"kro" => Ok(Self::Kro),
            b"kru" => Ok(Self::Kru),
            b"kua" => Ok(Self::Kua),
            b"kum" => Ok(Self::Kum),
            b"kur" => Ok(Self::Kur),
            b"kut" => Ok(Self::Kut),
            b"lad" => Ok(Self::Lad),
            b"lah" => Ok(Self::Lah),
            b"lam" => Ok(Self::Lam),
            b"lao" => Ok(Self::Lao),
            b"lat" => Ok(Self::Lat),
            b"lav" => Ok(Self::Lav),
            b"lez" => Ok(Self::Lez),
            b"lin" => Ok(Self::Lin),
            b"lit" => Ok(Self::Lit),
            b"lol" => Ok(Self::Lol),
            b"loz" => Ok(Self::Loz),
            b"ltz" => Ok(Self::Ltz),
            b"lua" => Ok(Self::Lua),
            b"lub" => Ok(Self::Lub),
            b"lug" => Ok(Self::Lug),
            b"lui" => Ok(Self::Lui),
            b"lun" => Ok(Self::Lun),
            b"luo" => Ok(Self::Luo),
            b"lus" => Ok(Self::Lus),
            b"mac" => Ok(Self::Mac),
            b"mad" => Ok(Self::Mad),
            b"mag" => Ok(Self::Mag),
            b"mah" => Ok(Self::Mah),
            b"mai" => Ok(Self::Mai),
            b"mak" => Ok(Self::Mak),
            b"mal" => Ok(Self::Mal),
            b"man" => Ok(Self::Man),
            b"mao" => Ok(Self::Mao),
            b"map" => Ok(Self::Map),
            b"mar" => Ok(Self::Mar),
            b"mas" => Ok(Self::Mas),
            b"may" => Ok(Self::May),
            b"mdr" => Ok(Self::Mdr),
            b"men" => Ok(Self::Men),
            b"mga" => Ok(Self::Mga),
            b"mic" => Ok(Self::Mic),
            b"min" => Ok(Self::Min),
            b"mis" => Ok(Self::Mis),
            b"mkd" => Ok(Self::Mkd),
            b"mkh" => Ok(Self::Mkh),
            b"mlg" => Ok(Self::Mlg),
            b"mlt" => Ok(Self::Mlt),
            b"mnc" => Ok(Self::Mnc),
            b"mni" => Ok(Self::Mni),
            b"mno" => Ok(Self::Mno),
            b"moh" => Ok(Self::Moh),
            b"mol" => Ok(Self::Mol),
            b"mon" => Ok(Self::Mon),
            b"mos" => Ok(Self::Mos),
            b"mri" => Ok(Self::Mri),
            b"msa" => Ok(Self::Msa),
            b"mul" => Ok(Self::Mul),
            b"mun" => Ok(Self::Mun),
            b"mus" => Ok(Self::Mus),
            b"mwr" => Ok(Self::Mwr),
            b"mya" => Ok(Self::Mya),
            b"myn" => Ok(Self::Myn),
            b"nah" => Ok(Self::Nah),
            b"nai" => Ok(Self::Nai),
            b"nau" => Ok(Self::Nau),
            b"nav" => Ok(Self::Nav),
            b"nbl" => Ok(Self::Nbl),
            b"nde" => Ok(Self::Nde),
            b"ndo" => Ok(Self::Ndo),
            b"nds" => Ok(Self::Nds),
            b"nep" => Ok(Self::Nep),
            b"new" => Ok(Self::New),
            b"nia" => Ok(Self::Nia),
            b"nic" => Ok(Self::Nic),
            b"niu" => Ok(Self::Niu),
            b"nld" => Ok(Self::Nld),
            b"nno" => Ok(Self::Nno),
            b"nob" => Ok(Self::Nob),
            b"non" => Ok(Self::Non),
            b"nor" => Ok(Self::Nor),
            b"nso" => Ok(Self::Nso),
            b"nub" => Ok(Self::Nub),
            b"nya" => Ok(Self::Nya),
            b"nym" => Ok(Self::Nym),
            b"nyn" => Ok(Self::Nyn),
            b"nyo" => Ok(Self::Nyo),
            b"nzi" => Ok(Self::Nzi),
            b"oci" => Ok(Self::Oci),
            b"oji" => Ok(Self::Oji),
            b"ori" => Ok(Self::Ori),
            b"orm" => Ok(Self::Orm),
            b"osa" => Ok(Self::Osa),
            b"oss" => Ok(Self::Oss),
            b"ota" => Ok(Self::Ota),
            b"oto" => Ok(Self::Oto),
            b"paa" => Ok(Self::Paa),
            b"pag" => Ok(Self::Pag),
            b"pal" => Ok(Self::Pal),
            b"pam" => Ok(Self::Pam),
            b"pan" => Ok(Self::Pan),
            b"pap" => Ok(Self::Pap),
            b"pau" => Ok(Self::Pau),
            b"peo" => Ok(Self::Peo),
            b"per" => Ok(Self::Per),
            b"phi" => Ok(Self::Phi),
            b"phn" => Ok(Self::Phn),
            b"pli" => Ok(Self::Pli),
            b"pol" => Ok(Self::Pol),
            b"pon" => Ok(Self::Pon),
            b"por" => Ok(Self::Por),
            b"pra" => Ok(Self::Pra),
            b"pro" => Ok(Self::Pro),
            b"pus" => Ok(Self::Pus),
            b"qaa" => Ok(Self::Qaa),
            b"que" => Ok(Self::Que),
            b"raj" => Ok(Self::Raj),
            b"rap" => Ok(Self::Rap),
            b"rar" => Ok(Self::Rar),
            b"roa" => Ok(Self::Roa),
            b"roh" => Ok(Self::Roh),
            b"rom" => Ok(Self::Rom),
            b"ron" => Ok(Self::Ron),
            b"rum" => Ok(Self::Rum),
            b"run" => Ok(Self::Run),
            b"rus" => Ok(Self::Rus),
            b"sad" => Ok(Self::Sad),
            b"sag" => Ok(Self::Sag),
            b"sah" => Ok(Self::Sah),
            b"sai" => Ok(Self::Sai),
            b"sal" => Ok(Self::Sal),
            b"sam" => Ok(Self::Sam),
            b"san" => Ok(Self::San),
            b"sas" => Ok(Self::Sas),
            b"sat" => Ok(Self::Sat),
            b"scc" => Ok(Self::Scc),
            b"sco" => Ok(Self::Sco),
            b"scr" => Ok(Self::Scr),
            b"sel" => Ok(Self::Sel),
            b"sem" => Ok(Self::Sem),
            b"sga" => Ok(Self::Sga),
            b"sgn" => Ok(Self::Sgn),
            b"shn" => Ok(Self::Shn),
            b"sid" => Ok(Self::Sid),
            b"sin" => Ok(Self::Sin),
            b"sio" => Ok(Self::Sio),
            b"sit" => Ok(Self::Sit),
            b"sla" => Ok(Self::Sla),
            b"slk" => Ok(Self::Slk),
            b"slo" => Ok(Self::Slo),
            b"slv" => Ok(Self::Slv),
            b"sme" => Ok(Self::Sme),
            b"smi" => Ok(Self::Smi),
            b"smo" => Ok(Self::Smo),
            b"sna" => Ok(Self::Sna),
            b"snd" => Ok(Self::Snd),
            b"snk" => Ok(Self::Snk),
            b"sog" => Ok(Self::Sog),
            b"som" => Ok(Self::Som),
            b"son" => Ok(Self::Son),
            b"sot" => Ok(Self::Sot),
            b"spa" => Ok(Self::Spa),
            b"sqi" => Ok(Self::Sqi),
            b"srd" => Ok(Self::Srd),
            b"srp" => Ok(Self::Srp),
            b"srr" => Ok(Self::Srr),
            b"ssa" => Ok(Self::Ssa),
            b"ssw" => Ok(Self::Ssw),
            b"suk" => Ok(Self::Suk),
            b"sun" => Ok(Self::Sun),
            b"sus" => Ok(Self::Sus),
            b"sux" => Ok(Self::Sux),
            b"swa" => Ok(Self::Swa),
            b"swe" => Ok(Self::Swe),
            b"syr" => Ok(Self::Syr),
            b"tah" => Ok(Self::Tah),
            b"tai" => Ok(Self::Tai),
            b"tam" => Ok(Self::Tam),
            b"tat" => Ok(Self::Tat),
            b"tel" => Ok(Self::Tel),
            b"tem" => Ok(Self::Tem),
            b"ter" => Ok(Self::Ter),
            b"tet" => Ok(Self::Tet),
            b"tgk" => Ok(Self::Tgk),
            b"tgl" => Ok(Self::Tgl),
            b"tha" => Ok(Self::Tha),
            b"tib" => Ok(Self::Tib),
            b"tig" => Ok(Self::Tig),
            b"tir" => Ok(Self::Tir),
            b"tiv" => Ok(Self::Tiv),
            b"tkl" => Ok(Self::Tkl),
            b"tli" => Ok(Self::Tli),
            b"tmh" => Ok(Self::Tmh),
            b"tog" => Ok(Self::Tog),
            b"ton" => Ok(Self::Ton),
            b"tpi" => Ok(Self::Tpi),
            b"tsi" => Ok(Self::Tsi),
            b"tsn" => Ok(Self::Tsn),
            b"tso" => Ok(Self::Tso),
            b"tuk" => Ok(Self::Tuk),
            b"tum" => Ok(Self::Tum),
            b"tur" => Ok(Self::Tur),
            b"tut" => Ok(Self::Tut),
            b"tvl" => Ok(Self::Tvl),
            b"twi" => Ok(Self::Twi),
            b"tyv" => Ok(Self::Tyv),
            b"uga" => Ok(Self::Uga),
            b"uig" => Ok(Self::Uig),
            b"ukr" => Ok(Self::Ukr),
            b"umb" => Ok(Self::Umb),
            b"und" => Ok(Self::Und),
            b"urd" => Ok(Self::Urd),
            b"uzb" => Ok(Self::Uzb),
            b"vai" => Ok(Self::Vai),
            b"ven" => Ok(Self::Ven),
            b"vie" => Ok(Self::Vie),
            b"vol" => Ok(Self::Vol),
            b"vot" => Ok(Self::Vot),
            b"wak" => Ok(Self::Wak),
            b"wal" => Ok(Self::Wal),
            b"war" => Ok(Self::War),
            b"was" => Ok(Self::Was),
            b"wel" => Ok(Self::Wel),
            b"wen" => Ok(Self::Wen),
            b"wln" => Ok(Self::Wln),
            b"wol" => Ok(Self::Wol),
            b"xho" => Ok(Self::Xho),
            b"yao" => Ok(Self::Yao),
            b"yap" => Ok(Self::Yap),
            b"yid" => Ok(Self::Yid),
            b"yor" => Ok(Self::Yor),
            b"ypk" => Ok(Self::Ypk),
            b"zap" => Ok(Self::Zap),
            b"zen" => Ok(Self::Zen),
            b"zha" => Ok(Self::Zha),
            b"zho" => Ok(Self::Zho),
            b"znd" => Ok(Self::Znd),
            b"zul" => Ok(Self::Zul),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum CatalogDatetimeType {
    GenerationDate,
}
impl SerializeBytes for CatalogDatetimeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::GenerationDate => Ok(Some(Cow::Borrowed("generation_date"))),
        }
    }
}
impl DeserializeBytes for CatalogDatetimeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"generation_date" => Ok(Self::GenerationDate),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum SupplierAddressType {
    Supplier,
}
impl SerializeBytes for SupplierAddressType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Supplier => Ok(Some(Cow::Borrowed("supplier"))),
        }
    }
}
impl DeserializeBytes for SupplierAddressType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"supplier" => Ok(Self::Supplier),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct MimeElementType {
    pub mime_source: Vec<DtMlstring>,
    pub mime_descr: Vec<DtMlstring>,
    pub mime_alt: Vec<DtMlstring>,
}
impl WithSerializer for MimeElementType {
    type Serializer<'x> = quick_xml_serialize::MimeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::MimeElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::MimeElementTypeSerializerState::Init__),
            name: name.unwrap_or("MIME"),
            is_root,
        })
    }
}
impl WithDeserializer for MimeElementType {
    type Deserializer = quick_xml_deserialize::MimeElementTypeDeserializer;
}
#[derive(Debug)]
pub struct InternationalPidElementType {
    pub type_: Option<String>,
    pub content: String,
}
impl WithSerializer for InternationalPidElementType {
    type Serializer<'x> = quick_xml_serialize::InternationalPidElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::InternationalPidElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::InternationalPidElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("INTERNATIONAL_PID"),
            is_root,
        })
    }
}
impl WithDeserializer for InternationalPidElementType {
    type Deserializer = quick_xml_deserialize::InternationalPidElementTypeDeserializer;
}
#[derive(Debug)]
pub struct BuyerPidElementType {
    pub type_: Option<String>,
    pub content: String,
}
impl WithSerializer for BuyerPidElementType {
    type Serializer<'x> = quick_xml_serialize::BuyerPidElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::BuyerPidElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::BuyerPidElementTypeSerializerState::Init__),
            name: name.unwrap_or("BUYER_PID"),
            is_root,
        })
    }
}
impl WithDeserializer for BuyerPidElementType {
    type Deserializer = quick_xml_deserialize::BuyerPidElementTypeDeserializer;
}
#[derive(Debug)]
pub struct SpecialTreatmentClassElementType {
    pub type_: String,
    pub content: String,
}
impl WithSerializer for SpecialTreatmentClassElementType {
    type Serializer<'x> = quick_xml_serialize::SpecialTreatmentClassElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::SpecialTreatmentClassElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::SpecialTreatmentClassElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("SPECIAL_TREATMENT_CLASS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for SpecialTreatmentClassElementType {
    type Deserializer = quick_xml_deserialize::SpecialTreatmentClassElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductStatusElementType {
    pub lang: Option<DtLang>,
    pub type_: ProductStatusType,
    pub content: String,
}
impl WithSerializer for ProductStatusElementType {
    type Serializer<'x> = quick_xml_serialize::ProductStatusElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductStatusElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductStatusElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRODUCT_STATUS"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductStatusElementType {
    type Deserializer = quick_xml_deserialize::ProductStatusElementTypeDeserializer;
}
#[derive(Debug)]
pub enum ProductTypeElementType {
    Contract,
    License,
    Physical,
    Service,
}
impl SerializeBytes for ProductTypeElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Contract => Ok(Some(Cow::Borrowed("contract"))),
            Self::License => Ok(Some(Cow::Borrowed("license"))),
            Self::Physical => Ok(Some(Cow::Borrowed("physical"))),
            Self::Service => Ok(Some(Cow::Borrowed("service"))),
        }
    }
}
impl DeserializeBytes for ProductTypeElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"contract" => Ok(Self::Contract),
            b"license" => Ok(Self::License),
            b"physical" => Ok(Self::Physical),
            b"service" => Ok(Self::Service),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum TypeClassificationSystemName {
    String(String),
    Dynamic,
}
impl SerializeBytes for TypeClassificationSystemName {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::String(x) => x.serialize_bytes(),
            Self::Dynamic => Ok(Some(Cow::Borrowed("DYNAMIC"))),
        }
    }
}
impl DeserializeBytes for TypeClassificationSystemName {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"DYNAMIC" => Ok(Self::Dynamic),
            x => Ok(Self::String(String::deserialize_bytes(reader, x)?)),
        }
    }
}
#[derive(Debug)]
pub struct FeatureElementType {
    pub fname: Vec<DtMlstring>,
    pub fvalue: Vec<DtMlstring>,
    pub funit: Option<String>,
    pub fvalue_details: Vec<DtMlstring>,
}
impl WithSerializer for FeatureElementType {
    type Serializer<'x> = quick_xml_serialize::FeatureElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::FeatureElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::FeatureElementTypeSerializerState::Init__),
            name: name.unwrap_or("FEATURE"),
            is_root,
        })
    }
}
impl WithDeserializer for FeatureElementType {
    type Deserializer = quick_xml_deserialize::FeatureElementTypeDeserializer;
}
#[derive(Debug)]
pub enum DtUnit {
    Ann,
    Be,
    Bg,
    Bo,
    Bx,
    C62,
    Ca,
    Cl,
    Cmk,
    Cmq,
    Cmt,
    Cq,
    Cr,
    Cs,
    Ct,
    D99,
    Day,
    Dr,
    Grm,
    Hur,
    Kg,
    Kgm,
    Ktm,
    Ltr,
    Mgm,
    Mlt,
    Mmk,
    Mmt,
    Mmq,
    Mtr,
    Mtk,
    Mtq,
    Pa,
    Pf,
    Pk,
    Pl,
    Pr,
    Pu,
    Rg,
    Rl,
    Ro,
    Sa,
    Sec,
    Set,
    St,
    Tn,
    Tne,
    Tu,
    Wee,
    Z2,
    Z3,
}
impl SerializeBytes for DtUnit {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Ann => Ok(Some(Cow::Borrowed("ANN"))),
            Self::Be => Ok(Some(Cow::Borrowed("BE"))),
            Self::Bg => Ok(Some(Cow::Borrowed("BG"))),
            Self::Bo => Ok(Some(Cow::Borrowed("BO"))),
            Self::Bx => Ok(Some(Cow::Borrowed("BX"))),
            Self::C62 => Ok(Some(Cow::Borrowed("C62"))),
            Self::Ca => Ok(Some(Cow::Borrowed("CA"))),
            Self::Cl => Ok(Some(Cow::Borrowed("CL"))),
            Self::Cmk => Ok(Some(Cow::Borrowed("CMK"))),
            Self::Cmq => Ok(Some(Cow::Borrowed("CMQ"))),
            Self::Cmt => Ok(Some(Cow::Borrowed("CMT"))),
            Self::Cq => Ok(Some(Cow::Borrowed("CQ"))),
            Self::Cr => Ok(Some(Cow::Borrowed("CR"))),
            Self::Cs => Ok(Some(Cow::Borrowed("CS"))),
            Self::Ct => Ok(Some(Cow::Borrowed("CT"))),
            Self::D99 => Ok(Some(Cow::Borrowed("D99"))),
            Self::Day => Ok(Some(Cow::Borrowed("DAY"))),
            Self::Dr => Ok(Some(Cow::Borrowed("DR"))),
            Self::Grm => Ok(Some(Cow::Borrowed("GRM"))),
            Self::Hur => Ok(Some(Cow::Borrowed("HUR"))),
            Self::Kg => Ok(Some(Cow::Borrowed("KG"))),
            Self::Kgm => Ok(Some(Cow::Borrowed("KGM"))),
            Self::Ktm => Ok(Some(Cow::Borrowed("KTM"))),
            Self::Ltr => Ok(Some(Cow::Borrowed("LTR"))),
            Self::Mgm => Ok(Some(Cow::Borrowed("MGM"))),
            Self::Mlt => Ok(Some(Cow::Borrowed("MLT"))),
            Self::Mmk => Ok(Some(Cow::Borrowed("MMK"))),
            Self::Mmt => Ok(Some(Cow::Borrowed("MMT"))),
            Self::Mmq => Ok(Some(Cow::Borrowed("MMQ"))),
            Self::Mtr => Ok(Some(Cow::Borrowed("MTR"))),
            Self::Mtk => Ok(Some(Cow::Borrowed("MTK"))),
            Self::Mtq => Ok(Some(Cow::Borrowed("MTQ"))),
            Self::Pa => Ok(Some(Cow::Borrowed("PA"))),
            Self::Pf => Ok(Some(Cow::Borrowed("PF"))),
            Self::Pk => Ok(Some(Cow::Borrowed("PK"))),
            Self::Pl => Ok(Some(Cow::Borrowed("PL"))),
            Self::Pr => Ok(Some(Cow::Borrowed("PR"))),
            Self::Pu => Ok(Some(Cow::Borrowed("PU"))),
            Self::Rg => Ok(Some(Cow::Borrowed("RG"))),
            Self::Rl => Ok(Some(Cow::Borrowed("RL"))),
            Self::Ro => Ok(Some(Cow::Borrowed("RO"))),
            Self::Sa => Ok(Some(Cow::Borrowed("SA"))),
            Self::Sec => Ok(Some(Cow::Borrowed("SEC"))),
            Self::Set => Ok(Some(Cow::Borrowed("SET"))),
            Self::St => Ok(Some(Cow::Borrowed("ST"))),
            Self::Tn => Ok(Some(Cow::Borrowed("TN"))),
            Self::Tne => Ok(Some(Cow::Borrowed("TNE"))),
            Self::Tu => Ok(Some(Cow::Borrowed("TU"))),
            Self::Wee => Ok(Some(Cow::Borrowed("WEE"))),
            Self::Z2 => Ok(Some(Cow::Borrowed("Z2"))),
            Self::Z3 => Ok(Some(Cow::Borrowed("Z3"))),
        }
    }
}
impl DeserializeBytes for DtUnit {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"ANN" => Ok(Self::Ann),
            b"BE" => Ok(Self::Be),
            b"BG" => Ok(Self::Bg),
            b"BO" => Ok(Self::Bo),
            b"BX" => Ok(Self::Bx),
            b"C62" => Ok(Self::C62),
            b"CA" => Ok(Self::Ca),
            b"CL" => Ok(Self::Cl),
            b"CMK" => Ok(Self::Cmk),
            b"CMQ" => Ok(Self::Cmq),
            b"CMT" => Ok(Self::Cmt),
            b"CQ" => Ok(Self::Cq),
            b"CR" => Ok(Self::Cr),
            b"CS" => Ok(Self::Cs),
            b"CT" => Ok(Self::Ct),
            b"D99" => Ok(Self::D99),
            b"DAY" => Ok(Self::Day),
            b"DR" => Ok(Self::Dr),
            b"GRM" => Ok(Self::Grm),
            b"HUR" => Ok(Self::Hur),
            b"KG" => Ok(Self::Kg),
            b"KGM" => Ok(Self::Kgm),
            b"KTM" => Ok(Self::Ktm),
            b"LTR" => Ok(Self::Ltr),
            b"MGM" => Ok(Self::Mgm),
            b"MLT" => Ok(Self::Mlt),
            b"MMK" => Ok(Self::Mmk),
            b"MMT" => Ok(Self::Mmt),
            b"MMQ" => Ok(Self::Mmq),
            b"MTR" => Ok(Self::Mtr),
            b"MTK" => Ok(Self::Mtk),
            b"MTQ" => Ok(Self::Mtq),
            b"PA" => Ok(Self::Pa),
            b"PF" => Ok(Self::Pf),
            b"PK" => Ok(Self::Pk),
            b"PL" => Ok(Self::Pl),
            b"PR" => Ok(Self::Pr),
            b"PU" => Ok(Self::Pu),
            b"RG" => Ok(Self::Rg),
            b"RL" => Ok(Self::Rl),
            b"RO" => Ok(Self::Ro),
            b"SA" => Ok(Self::Sa),
            b"SEC" => Ok(Self::Sec),
            b"SET" => Ok(Self::Set),
            b"ST" => Ok(Self::St),
            b"TN" => Ok(Self::Tn),
            b"TNE" => Ok(Self::Tne),
            b"TU" => Ok(Self::Tu),
            b"WEE" => Ok(Self::Wee),
            b"Z2" => Ok(Self::Z2),
            b"Z3" => Ok(Self::Z3),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct ProductPriceDetailsDatetimeElementType {
    pub type_: ProductPriceDetailsDatetimeType,
    pub date: String,
}
impl WithSerializer for ProductPriceDetailsDatetimeElementType {
    type Serializer<'x> = quick_xml_serialize::ProductPriceDetailsDatetimeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: ProductPriceDetailsDatetimeElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ProductPriceDetailsDatetimeElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ProductPriceDetailsDatetime") , is_root , })
    }
}
impl WithDeserializer for ProductPriceDetailsDatetimeElementType {
    type Deserializer = quick_xml_deserialize::ProductPriceDetailsDatetimeElementTypeDeserializer;
}
#[derive(Debug)]
pub struct ProductPriceElementType {
    pub price_type: String,
    pub price_amount: f64,
    pub price_currency: Option<DtCurrencies>,
    pub tax: Option<f64>,
    pub price_factor: Option<f64>,
    pub lower_bound: Option<f64>,
    pub territory: Vec<String>,
}
impl WithSerializer for ProductPriceElementType {
    type Serializer<'x> = quick_xml_serialize::ProductPriceElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::ProductPriceElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::ProductPriceElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRODUCT_PRICE"),
            is_root,
        })
    }
}
impl WithDeserializer for ProductPriceElementType {
    type Deserializer = quick_xml_deserialize::ProductPriceElementTypeDeserializer;
}
#[derive(Debug)]
pub struct PriceBaseElementType {
    pub price_unit: DtUnit,
    pub price_unit_factor: Option<f32>,
}
impl WithSerializer for PriceBaseElementType {
    type Serializer<'x> = quick_xml_serialize::PriceBaseElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::PriceBaseElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::PriceBaseElementTypeSerializerState::Init__),
            name: name.unwrap_or("PRICE_BASE"),
            is_root,
        })
    }
}
impl WithDeserializer for PriceBaseElementType {
    type Deserializer = quick_xml_deserialize::PriceBaseElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfMimeInfoElementType {
    pub udx_edxf_mime: Vec<UdxEdxfMimeElementType>,
}
impl WithSerializer for UdxEdxfMimeInfoElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfMimeInfoElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxEdxfMimeInfoElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxEdxfMimeInfoElementTypeSerializerState::Init__),
            name: name.unwrap_or("UDX.EDXF.MIME_INFO"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxEdxfMimeInfoElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfMimeInfoElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfDiscountGroupElementType {
    pub content: Vec<UdxEdxfDiscountGroupElementTypeContent>,
}
#[derive(Debug)]
pub enum UdxEdxfDiscountGroupElementTypeContent {
    UdxEdxfDiscountGroupManufacturer(String),
    UdxEdxfDiscountGroupSupplier(String),
}
impl WithSerializer for UdxEdxfDiscountGroupElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfDiscountGroupElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfDiscountGroupElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfDiscountGroupElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.DISCOUNT_GROUP"),
                is_root,
            },
        )
    }
}
impl WithSerializer for UdxEdxfDiscountGroupElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfDiscountGroupElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok (quick_xml_serialize :: UdxEdxfDiscountGroupElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfDiscountGroupElementTypeContentSerializerState :: Init__) , })
    }
}
impl WithDeserializer for UdxEdxfDiscountGroupElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfDiscountGroupElementTypeDeserializer;
}
impl WithDeserializer for UdxEdxfDiscountGroupElementTypeContent {
    type Deserializer = quick_xml_deserialize::UdxEdxfDiscountGroupElementTypeContentDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfAdditionalFactorsElementType {
    pub udx_edxf_additional_price_factor: f64,
    pub udx_edxf_additional_factor_info: Vec<DtMlstring>,
}
impl WithSerializer for UdxEdxfAdditionalFactorsElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfAdditionalFactorsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfAdditionalFactorsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfAdditionalFactorsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.ADDITIONAL_FACTORS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfAdditionalFactorsElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfAdditionalFactorsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfCountryBranchNumbersElementType {
    pub udx_edxf_country_branch_number:
        Vec<UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType>,
}
impl WithSerializer for UdxEdxfCountryBranchNumbersElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfCountryBranchNumbersElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfCountryBranchNumbersElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.COUNTRY_BRANCH_NUMBERS") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfCountryBranchNumbersElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfCountryBranchNumbersElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfCountryBranchSupplierIdsElementType {
    pub udx_edxf_country_branch_supplier_id:
        Vec<UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType>,
}
impl WithSerializer for UdxEdxfCountryBranchSupplierIdsElementType {
    type Serializer<'x> =
        quick_xml_serialize::UdxEdxfCountryBranchSupplierIdsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfCountryBranchSupplierIdsElementType {
    type Deserializer =
        quick_xml_deserialize::UdxEdxfCountryBranchSupplierIdsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfPackingUnitsElementType {
    pub udx_edxf_packing_unit: Vec<UdxEdxfPackingUnitElementType>,
}
impl WithSerializer for UdxEdxfPackingUnitsElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfPackingUnitsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfPackingUnitsElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfPackingUnitsElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.PACKING_UNITS"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfPackingUnitsElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfPackingUnitsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfProductLogisticDetailsElementType {
    pub udx_edxf_netvolume: Option<f64>,
    pub udx_edxf_netweight: Option<f64>,
    pub udx_edxf_netlength: Option<f64>,
    pub udx_edxf_netwidth: Option<f64>,
    pub udx_edxf_netdepth: Option<f64>,
    pub udx_edxf_netdiameter: Option<f64>,
    pub udx_edxf_region_of_origin: Option<String>,
}
impl WithSerializer for UdxEdxfProductLogisticDetailsElementType {
    type Serializer<'x> =
        quick_xml_serialize::UdxEdxfProductLogisticDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfProductLogisticDetailsElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.PRODUCT_LOGISTIC_DETAILS") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfProductLogisticDetailsElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfProductLogisticDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub enum UdxEdxfRohsIndicatorElementType {
    True,
    False,
    Exempt,
}
impl SerializeBytes for UdxEdxfRohsIndicatorElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::True => Ok(Some(Cow::Borrowed("true"))),
            Self::False => Ok(Some(Cow::Borrowed("false"))),
            Self::Exempt => Ok(Some(Cow::Borrowed("exempt"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfRohsIndicatorElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"true" => Ok(Self::True),
            b"false" => Ok(Self::False),
            b"exempt" => Ok(Self::Exempt),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct UdxEdxfReachElementType {
    pub udx_edxf_reach_listdate: Option<String>,
    pub udx_edxf_reach_info: UdxEdxfReachInfoElementType,
    pub udx_edxf_scip_number: Option<String>,
    pub udx_edxf_ufi_code: Option<String>,
}
impl WithSerializer for UdxEdxfReachElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfReachElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxEdxfReachElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxEdxfReachElementTypeSerializerState::Init__),
            name: name.unwrap_or("UDX.EDXF.REACH"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxEdxfReachElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfReachElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfSpecialTreatmentClassDetailsElementType {
    pub udx_edxf_hazardous_substances: Vec<UdxEdxfHazardousSubstancesElementType>,
    pub udx_edxf_shipping_name: Option<DtMlstring>,
    pub udx_edxf_packing_group: Option<UdxEdxfPackingGroupElementType>,
    pub udx_edxf_transport_category: Option<i32>,
    pub udx_edxf_multiplication_factor: Option<i32>,
    pub udx_edxf_limited_quantities: Option<String>,
    pub udx_edxf_excepted_quantities: Option<String>,
    pub udx_edxf_aggregation_state: Option<UdxEdxfAggregationStateElementType>,
    pub udx_edxf_special_provision_id: Vec<String>,
    pub udx_edxf_hazard_class: Vec<UdxEdxfHazardClassElementType>,
    pub udx_edxf_classification_code: Option<String>,
    pub udx_edxf_hazard_label: Vec<String>,
    pub udx_edxf_environmental_hazards: Option<String>,
    pub udx_edxf_tunnel_code: Option<UdxEdxfTunnelCodeElementType>,
    pub udx_edxf_ghs_label_code: Vec<UdxEdxfGhsLabelCodeElementType>,
    pub udx_edxf_ghs_signal_word: Option<UdxEdxfGhsSignalWordElementType>,
    pub udx_edxf_hazard_statement: Vec<String>,
    pub udx_edxf_precautionary_statement: Vec<String>,
    pub udx_edxf_li_ion_tested: Option<String>,
    pub udx_edxf_lithium_amount: Option<f64>,
    pub udx_edxf_battery_energy: Option<f64>,
    pub udx_edxf_nos_274: Option<String>,
    pub udx_edxf_hazard_trigger: Vec<String>,
}
impl WithSerializer for UdxEdxfSpecialTreatmentClassDetailsElementType {
    type Serializer<'x> =
        quick_xml_serialize::UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.SPECIAL_TREATMENT_CLASS_DETAILS") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfSpecialTreatmentClassDetailsElementType {
    type Deserializer =
        quick_xml_deserialize::UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfSurchargeListElementType {
    pub udx_edxf_surcharge: Vec<UdxEdxfSurchargeElementType>,
}
impl WithSerializer for UdxEdxfSurchargeListElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfSurchargeListElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfSurchargeListElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfSurchargeListElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.SURCHARGE_LIST"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfSurchargeListElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfSurchargeListElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfWarrantyElementType {
    pub udx_edxf_warranty_business: Option<i32>,
    pub udx_edxf_warranty_consumer: Option<i32>,
}
impl WithSerializer for UdxEdxfWarrantyElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfWarrantyElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxEdxfWarrantyElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxEdxfWarrantyElementTypeSerializerState::Init__),
            name: name.unwrap_or("UDX.EDXF.WARRANTY"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxEdxfWarrantyElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfWarrantyElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfProductEtimDynamicElementType {
    pub udx_edxf_product_etim_release_date: String,
}
impl WithSerializer for UdxEdxfProductEtimDynamicElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfProductEtimDynamicElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfProductEtimDynamicElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfProductEtimDynamicElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.PRODUCT_ETIM_DYNAMIC") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfProductEtimDynamicElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfProductEtimDynamicElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfProductFeaturesMcElementType {
    pub udx_edxf_reference_feature_mc_id: String,
    pub udx_edxf_reference_feature_mc_version: i32,
    pub udx_edxf_bim_status: Option<UdxEdxfBimStatusElementType>,
    pub udx_edxf_feature_mc: Vec<UdxEdxfFeatureMcElementType>,
}
impl WithSerializer for UdxEdxfProductFeaturesMcElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfProductFeaturesMcElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfProductFeaturesMcElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfProductFeaturesMcElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.PRODUCT_FEATURES_MC"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfProductFeaturesMcElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfProductFeaturesMcElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfProductCharacteristicsElementType {
    pub udx_edxf_product_characteristic: Vec<UdxEdxfProductCharacteristicElementType>,
}
impl WithSerializer for UdxEdxfProductCharacteristicsElementType {
    type Serializer<'x> =
        quick_xml_serialize::UdxEdxfProductCharacteristicsElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfProductCharacteristicsElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfProductCharacteristicsElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.PRODUCT_CHARACTERISTICS") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfProductCharacteristicsElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfProductCharacteristicsElementTypeDeserializer;
}
#[derive(Debug)]
pub enum ProductReferenceType {
    Accessories,
    BaseProduct,
    ConsistsOf,
    Followup,
    Mandatory,
    Similar,
    Select,
    Sparepart,
    Others,
}
impl SerializeBytes for ProductReferenceType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Accessories => Ok(Some(Cow::Borrowed("accessories"))),
            Self::BaseProduct => Ok(Some(Cow::Borrowed("base_product"))),
            Self::ConsistsOf => Ok(Some(Cow::Borrowed("consists_of"))),
            Self::Followup => Ok(Some(Cow::Borrowed("followup"))),
            Self::Mandatory => Ok(Some(Cow::Borrowed("mandatory"))),
            Self::Similar => Ok(Some(Cow::Borrowed("similar"))),
            Self::Select => Ok(Some(Cow::Borrowed("select"))),
            Self::Sparepart => Ok(Some(Cow::Borrowed("sparepart"))),
            Self::Others => Ok(Some(Cow::Borrowed("others"))),
        }
    }
}
impl DeserializeBytes for ProductReferenceType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"accessories" => Ok(Self::Accessories),
            b"base_product" => Ok(Self::BaseProduct),
            b"consists_of" => Ok(Self::ConsistsOf),
            b"followup" => Ok(Self::Followup),
            b"mandatory" => Ok(Self::Mandatory),
            b"similar" => Ok(Self::Similar),
            b"select" => Ok(Self::Select),
            b"sparepart" => Ok(Self::Sparepart),
            b"others" => Ok(Self::Others),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct CustomsTariffNumberElementType {
    pub customs_number: String,
}
impl WithSerializer for CustomsTariffNumberElementType {
    type Serializer<'x> = quick_xml_serialize::CustomsTariffNumberElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::CustomsTariffNumberElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CustomsTariffNumberElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CUSTOMS_TARIFF_NUMBER"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for CustomsTariffNumberElementType {
    type Deserializer = quick_xml_deserialize::CustomsTariffNumberElementTypeDeserializer;
}
#[derive(Debug)]
pub enum ProductStatusType {
    Bargain,
    CoreProduct,
    New,
    NewProduct,
    OldProduct,
    Refurbished,
    Used,
    Others,
}
impl SerializeBytes for ProductStatusType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Bargain => Ok(Some(Cow::Borrowed("bargain"))),
            Self::CoreProduct => Ok(Some(Cow::Borrowed("core_product"))),
            Self::New => Ok(Some(Cow::Borrowed("new"))),
            Self::NewProduct => Ok(Some(Cow::Borrowed("new_product"))),
            Self::OldProduct => Ok(Some(Cow::Borrowed("old_product"))),
            Self::Refurbished => Ok(Some(Cow::Borrowed("refurbished"))),
            Self::Used => Ok(Some(Cow::Borrowed("used"))),
            Self::Others => Ok(Some(Cow::Borrowed("others"))),
        }
    }
}
impl DeserializeBytes for ProductStatusType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"bargain" => Ok(Self::Bargain),
            b"core_product" => Ok(Self::CoreProduct),
            b"new" => Ok(Self::New),
            b"new_product" => Ok(Self::NewProduct),
            b"old_product" => Ok(Self::OldProduct),
            b"refurbished" => Ok(Self::Refurbished),
            b"used" => Ok(Self::Used),
            b"others" => Ok(Self::Others),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum ProductPriceDetailsDatetimeType {
    ValidStartDate,
    ValidEndDate,
}
impl SerializeBytes for ProductPriceDetailsDatetimeType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::ValidStartDate => Ok(Some(Cow::Borrowed("valid_start_date"))),
            Self::ValidEndDate => Ok(Some(Cow::Borrowed("valid_end_date"))),
        }
    }
}
impl DeserializeBytes for ProductPriceDetailsDatetimeType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"valid_start_date" => Ok(Self::ValidStartDate),
            b"valid_end_date" => Ok(Self::ValidEndDate),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct UdxEdxfMimeElementType {
    pub udx_edxf_mime_source: Vec<DtMlstring>,
    pub udx_edxf_mime_code: UdxEdxfMimeCodeElementType,
    pub udx_edxf_mime_filename: Vec<DtMlstring>,
    pub udx_edxf_mime_designation: Vec<DtMlstring>,
    pub udx_edxf_mime_alt: Vec<DtMlstring>,
    pub udx_edxf_mime_issue_date: Option<String>,
    pub udx_edxf_mime_expiry_date: Option<String>,
    pub udx_edxf_mime_order: Option<i32>,
}
impl WithSerializer for UdxEdxfMimeElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfMimeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxEdxfMimeElementTypeSerializer {
            value: self,
            state: Box::new(quick_xml_serialize::UdxEdxfMimeElementTypeSerializerState::Init__),
            name: name.unwrap_or("UDX.EDXF.MIME"),
            is_root,
        })
    }
}
impl WithDeserializer for UdxEdxfMimeElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfMimeElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType {
    pub type_: String,
    pub country: String,
    pub content: i32,
}
impl WithSerializer for UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType {
    type Serializer < 'x > = quick_xml_serialize :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer < 'x > ;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumber") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType {
    type Deserializer = quick_xml_deserialize :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializer ;
}
#[derive(Debug)]
pub struct UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType {
    pub type_: String,
    pub country: String,
    pub content: i32,
}
impl WithSerializer for UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType {
    type Serializer < 'x > = quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer < 'x > ;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierId") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType {
    type Deserializer = quick_xml_deserialize :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializer ;
}
#[derive(Debug)]
pub struct UdxEdxfPackingUnitElementType {
    pub udx_edxf_quantity_min: f32,
    pub udx_edxf_quantity_max: Option<f32>,
    pub udx_edxf_packing_unit_code: DtPunit,
    pub udx_edxf_packing_unit_name: Vec<DtMlstring>,
    pub udx_edxf_package_break: Option<String>,
    pub udx_edxf_packing_parts: Option<i32>,
    pub udx_edxf_volume: Option<f64>,
    pub udx_edxf_weight: Option<f64>,
    pub udx_edxf_length: Option<f64>,
    pub udx_edxf_width: Option<f64>,
    pub udx_edxf_depth: Option<f64>,
    pub udx_edxf_diameter: Option<f64>,
    pub udx_edxf_gtin: Option<String>,
    pub udx_edxf_gs_1128: Option<String>,
}
impl WithSerializer for UdxEdxfPackingUnitElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfPackingUnitElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfPackingUnitElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfPackingUnitElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.PACKING_UNIT"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfPackingUnitElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfPackingUnitElementTypeDeserializer;
}
#[derive(Debug)]
pub enum UdxEdxfReachInfoElementType {
    True,
    False,
    NoData,
}
impl SerializeBytes for UdxEdxfReachInfoElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::True => Ok(Some(Cow::Borrowed("true"))),
            Self::False => Ok(Some(Cow::Borrowed("false"))),
            Self::NoData => Ok(Some(Cow::Borrowed("no data"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfReachInfoElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"true" => Ok(Self::True),
            b"false" => Ok(Self::False),
            b"no data" => Ok(Self::NoData),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct UdxEdxfHazardousSubstancesElementType {
    pub udx_edxf_un_number: String,
    pub udx_edxf_net_weight_of_hazardous_substance: Option<f64>,
    pub udx_edxf_volume_of_hazardous_substances: Option<f64>,
}
impl WithSerializer for UdxEdxfHazardousSubstancesElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfHazardousSubstancesElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfHazardousSubstancesElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfHazardousSubstancesElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.HAZARDOUS_SUBSTANCES") , is_root , })
    }
}
impl WithDeserializer for UdxEdxfHazardousSubstancesElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfHazardousSubstancesElementTypeDeserializer;
}
#[derive(Debug)]
pub enum UdxEdxfPackingGroupElementType {
    I,
    Ii,
    Iii,
}
impl SerializeBytes for UdxEdxfPackingGroupElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::I => Ok(Some(Cow::Borrowed("I"))),
            Self::Ii => Ok(Some(Cow::Borrowed("II"))),
            Self::Iii => Ok(Some(Cow::Borrowed("III"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfPackingGroupElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"I" => Ok(Self::I),
            b"II" => Ok(Self::Ii),
            b"III" => Ok(Self::Iii),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfAggregationStateElementType {
    L,
    S,
    G,
}
impl SerializeBytes for UdxEdxfAggregationStateElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::L => Ok(Some(Cow::Borrowed("L"))),
            Self::S => Ok(Some(Cow::Borrowed("S"))),
            Self::G => Ok(Some(Cow::Borrowed("G"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfAggregationStateElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"L" => Ok(Self::L),
            b"S" => Ok(Self::S),
            b"G" => Ok(Self::G),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfHazardClassElementType {
    _1,
    _21,
    _22,
    _23,
    _3,
    _41,
    _42,
    _43,
    _51,
    _52,
    _61,
    _62,
    _7,
    _8,
    _9,
}
impl SerializeBytes for UdxEdxfHazardClassElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_1 => Ok(Some(Cow::Borrowed("1"))),
            Self::_21 => Ok(Some(Cow::Borrowed("2.1"))),
            Self::_22 => Ok(Some(Cow::Borrowed("2.2"))),
            Self::_23 => Ok(Some(Cow::Borrowed("2.3"))),
            Self::_3 => Ok(Some(Cow::Borrowed("3"))),
            Self::_41 => Ok(Some(Cow::Borrowed("4.1"))),
            Self::_42 => Ok(Some(Cow::Borrowed("4.2"))),
            Self::_43 => Ok(Some(Cow::Borrowed("4.3"))),
            Self::_51 => Ok(Some(Cow::Borrowed("5.1"))),
            Self::_52 => Ok(Some(Cow::Borrowed("5.2"))),
            Self::_61 => Ok(Some(Cow::Borrowed("6.1"))),
            Self::_62 => Ok(Some(Cow::Borrowed("6.2"))),
            Self::_7 => Ok(Some(Cow::Borrowed("7"))),
            Self::_8 => Ok(Some(Cow::Borrowed("8"))),
            Self::_9 => Ok(Some(Cow::Borrowed("9"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfHazardClassElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"1" => Ok(Self::_1),
            b"2.1" => Ok(Self::_21),
            b"2.2" => Ok(Self::_22),
            b"2.3" => Ok(Self::_23),
            b"3" => Ok(Self::_3),
            b"4.1" => Ok(Self::_41),
            b"4.2" => Ok(Self::_42),
            b"4.3" => Ok(Self::_43),
            b"5.1" => Ok(Self::_51),
            b"5.2" => Ok(Self::_52),
            b"6.1" => Ok(Self::_61),
            b"6.2" => Ok(Self::_62),
            b"7" => Ok(Self::_7),
            b"8" => Ok(Self::_8),
            b"9" => Ok(Self::_9),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfTunnelCodeElementType {
    A,
    B,
    C,
    D,
    E,
}
impl SerializeBytes for UdxEdxfTunnelCodeElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::A => Ok(Some(Cow::Borrowed("A"))),
            Self::B => Ok(Some(Cow::Borrowed("B"))),
            Self::C => Ok(Some(Cow::Borrowed("C"))),
            Self::D => Ok(Some(Cow::Borrowed("D"))),
            Self::E => Ok(Some(Cow::Borrowed("E"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfTunnelCodeElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"A" => Ok(Self::A),
            b"B" => Ok(Self::B),
            b"C" => Ok(Self::C),
            b"D" => Ok(Self::D),
            b"E" => Ok(Self::E),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfGhsLabelCodeElementType {
    Ghs01,
    Ghs02,
    Ghs03,
    Ghs04,
    Ghs05,
    Ghs06,
    Ghs07,
    Ghs08,
    Ghs09,
}
impl SerializeBytes for UdxEdxfGhsLabelCodeElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Ghs01 => Ok(Some(Cow::Borrowed("GHS01"))),
            Self::Ghs02 => Ok(Some(Cow::Borrowed("GHS02"))),
            Self::Ghs03 => Ok(Some(Cow::Borrowed("GHS03"))),
            Self::Ghs04 => Ok(Some(Cow::Borrowed("GHS04"))),
            Self::Ghs05 => Ok(Some(Cow::Borrowed("GHS05"))),
            Self::Ghs06 => Ok(Some(Cow::Borrowed("GHS06"))),
            Self::Ghs07 => Ok(Some(Cow::Borrowed("GHS07"))),
            Self::Ghs08 => Ok(Some(Cow::Borrowed("GHS08"))),
            Self::Ghs09 => Ok(Some(Cow::Borrowed("GHS09"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfGhsLabelCodeElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"GHS01" => Ok(Self::Ghs01),
            b"GHS02" => Ok(Self::Ghs02),
            b"GHS03" => Ok(Self::Ghs03),
            b"GHS04" => Ok(Self::Ghs04),
            b"GHS05" => Ok(Self::Ghs05),
            b"GHS06" => Ok(Self::Ghs06),
            b"GHS07" => Ok(Self::Ghs07),
            b"GHS08" => Ok(Self::Ghs08),
            b"GHS09" => Ok(Self::Ghs09),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfGhsSignalWordElementType {
    D,
    W,
}
impl SerializeBytes for UdxEdxfGhsSignalWordElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::D => Ok(Some(Cow::Borrowed("D"))),
            Self::W => Ok(Some(Cow::Borrowed("W"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfGhsSignalWordElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"D" => Ok(Self::D),
            b"W" => Ok(Self::W),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct UdxEdxfSurchargeElementType {
    pub content: Vec<UdxEdxfSurchargeElementTypeContent>,
}
#[derive(Debug)]
pub enum UdxEdxfSurchargeElementTypeContent {
    UdxEdxfSurchargeType(String),
    UdxEdxfSurchargeClass(String),
    UdxEdxfSurchargeManner(UdxEdxfSurchargeMannerElementType),
    UdxEdxfSurchargePercentage(f64),
    UdxEdxfSurchargePriceAmount(f64),
    UdxEdxfSurchargeCalculation(UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType),
    UdxEdxfMaterialBasis(f64),
    UdxEdxfMaterialBasisWeight(f64),
    UdxEdxfMaterialBasisSurchargeThreshold(f64),
    UdxEdxfMaterialBasisSurchargeShutter(
        UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType,
    ),
    UdxEdxfMaterialBasisSurchargeCredit(
        UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType,
    ),
    UdxEdxfMaterialBasisSurchargeTable(DtMlstring),
}
impl WithSerializer for UdxEdxfSurchargeElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfSurchargeElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxEdxfSurchargeElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::UdxEdxfSurchargeElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("UDX.EDXF.SURCHARGE"),
            is_root,
        })
    }
}
impl WithSerializer for UdxEdxfSurchargeElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfSurchargeElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(
            quick_xml_serialize::UdxEdxfSurchargeElementTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfSurchargeElementTypeContentSerializerState::Init__,
                ),
            },
        )
    }
}
impl WithDeserializer for UdxEdxfSurchargeElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfSurchargeElementTypeDeserializer;
}
impl WithDeserializer for UdxEdxfSurchargeElementTypeContent {
    type Deserializer = quick_xml_deserialize::UdxEdxfSurchargeElementTypeContentDeserializer;
}
#[derive(Debug)]
pub enum UdxEdxfBimStatusElementType {
    Ready,
    Test,
    Incomplete,
}
impl SerializeBytes for UdxEdxfBimStatusElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Ready => Ok(Some(Cow::Borrowed("ready"))),
            Self::Test => Ok(Some(Cow::Borrowed("test"))),
            Self::Incomplete => Ok(Some(Cow::Borrowed("incomplete"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfBimStatusElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"ready" => Ok(Self::Ready),
            b"test" => Ok(Self::Test),
            b"incomplete" => Ok(Self::Incomplete),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct UdxEdxfFeatureMcElementType {
    pub content: Vec<UdxEdxfFeatureMcElementTypeContent>,
}
#[derive(Debug)]
pub enum UdxEdxfFeatureMcElementTypeContent {
    UdxEdxfPortcode(i32),
    UdxEdxfFname(String),
    UdxEdxfFvalue(String),
    UdxEdxfCoordinateX(f32),
    UdxEdxfCoordinateY(f32),
    UdxEdxfCoordinateZ(f32),
    UdxEdxfMatrixValues(UdxEdxfMatrixValuesElementType),
}
impl WithSerializer for UdxEdxfFeatureMcElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfFeatureMcElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(quick_xml_serialize::UdxEdxfFeatureMcElementTypeSerializer {
            value: self,
            state: Box::new(
                quick_xml_serialize::UdxEdxfFeatureMcElementTypeSerializerState::Init__,
            ),
            name: name.unwrap_or("UDX.EDXF.FEATURE_MC"),
            is_root,
        })
    }
}
impl WithSerializer for UdxEdxfFeatureMcElementTypeContent {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfFeatureMcElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok(
            quick_xml_serialize::UdxEdxfFeatureMcElementTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfFeatureMcElementTypeContentSerializerState::Init__,
                ),
            },
        )
    }
}
impl WithDeserializer for UdxEdxfFeatureMcElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfFeatureMcElementTypeDeserializer;
}
impl WithDeserializer for UdxEdxfFeatureMcElementTypeContent {
    type Deserializer = quick_xml_deserialize::UdxEdxfFeatureMcElementTypeContentDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfProductCharacteristicElementType {
    pub content: Vec<UdxEdxfProductCharacteristicElementTypeContent>,
}
#[derive(Debug)]
pub enum UdxEdxfProductCharacteristicElementTypeContent {
    UdxEdxfProductCharacteristicCode(String),
    UdxEdxfProductCharacteristicName(DtMlstring),
    UdxEdxfProductCharacteristicValueBoolean(String),
    UdxEdxfProductCharacteristicValueNumeric(f32),
    UdxEdxfProductCharacteristicValueRangeFrom(f32),
    UdxEdxfProductCharacteristicValueRangeTo(f32),
    UdxEdxfProductCharacteristicValueString(DtMlstring),
    UdxEdxfProductCharacteristicValueSet(DtMlstring),
    UdxEdxfProductCharacteristicValueSelect(String),
    UdxEdxfProductCharacteristicValueUnitCode(String),
    UdxEdxfProductCharacteristicReferenceGtin(String),
}
impl WithSerializer for UdxEdxfProductCharacteristicElementType {
    type Serializer<'x> =
        quick_xml_serialize::UdxEdxfProductCharacteristicElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok (quick_xml_serialize :: UdxEdxfProductCharacteristicElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfProductCharacteristicElementTypeSerializerState :: Init__) , name : name . unwrap_or ("UDX.EDXF.PRODUCT_CHARACTERISTIC") , is_root , })
    }
}
impl WithSerializer for UdxEdxfProductCharacteristicElementTypeContent {
    type Serializer<'x> =
        quick_xml_serialize::UdxEdxfProductCharacteristicElementTypeContentSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        let _name = name;
        let _is_root = is_root;
        Ok (quick_xml_serialize :: UdxEdxfProductCharacteristicElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Init__) , })
    }
}
impl WithDeserializer for UdxEdxfProductCharacteristicElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfProductCharacteristicElementTypeDeserializer;
}
impl WithDeserializer for UdxEdxfProductCharacteristicElementTypeContent {
    type Deserializer =
        quick_xml_deserialize::UdxEdxfProductCharacteristicElementTypeContentDeserializer;
}
#[derive(Debug)]
pub enum UdxEdxfMimeCodeElementType {
    Md01,
    Md02,
    Md03,
    Md04,
    Md05,
    Md06,
    Md07,
    Md08,
    Md09,
    Md10,
    Md11,
    Md12,
    Md13,
    Md14,
    Md15,
    Md16,
    Md17,
    Md18,
    Md19,
    Md20,
    Md21,
    Md22,
    Md23,
    Md24,
    Md25,
    Md26,
    Md27,
    Md28,
    Md29,
    Md30,
    Md31,
    Md32,
    Md33,
    Md34,
    Md35,
    Md37,
    Md38,
    Md39,
    Md40,
    Md41,
    Md42,
    Md43,
    Md44,
    Md45,
    Md46,
    Md47,
    Md48,
    Md49,
    Md50,
    Md51,
    Md52,
    Md53,
    Md54,
    Md55,
    Md56,
    Md57,
    Md58,
    Md59,
    Md60,
    Md61,
    Md62,
    Md63,
    Md64,
    Md65,
    Md99,
}
impl SerializeBytes for UdxEdxfMimeCodeElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Md01 => Ok(Some(Cow::Borrowed("MD01"))),
            Self::Md02 => Ok(Some(Cow::Borrowed("MD02"))),
            Self::Md03 => Ok(Some(Cow::Borrowed("MD03"))),
            Self::Md04 => Ok(Some(Cow::Borrowed("MD04"))),
            Self::Md05 => Ok(Some(Cow::Borrowed("MD05"))),
            Self::Md06 => Ok(Some(Cow::Borrowed("MD06"))),
            Self::Md07 => Ok(Some(Cow::Borrowed("MD07"))),
            Self::Md08 => Ok(Some(Cow::Borrowed("MD08"))),
            Self::Md09 => Ok(Some(Cow::Borrowed("MD09"))),
            Self::Md10 => Ok(Some(Cow::Borrowed("MD10"))),
            Self::Md11 => Ok(Some(Cow::Borrowed("MD11"))),
            Self::Md12 => Ok(Some(Cow::Borrowed("MD12"))),
            Self::Md13 => Ok(Some(Cow::Borrowed("MD13"))),
            Self::Md14 => Ok(Some(Cow::Borrowed("MD14"))),
            Self::Md15 => Ok(Some(Cow::Borrowed("MD15"))),
            Self::Md16 => Ok(Some(Cow::Borrowed("MD16"))),
            Self::Md17 => Ok(Some(Cow::Borrowed("MD17"))),
            Self::Md18 => Ok(Some(Cow::Borrowed("MD18"))),
            Self::Md19 => Ok(Some(Cow::Borrowed("MD19"))),
            Self::Md20 => Ok(Some(Cow::Borrowed("MD20"))),
            Self::Md21 => Ok(Some(Cow::Borrowed("MD21"))),
            Self::Md22 => Ok(Some(Cow::Borrowed("MD22"))),
            Self::Md23 => Ok(Some(Cow::Borrowed("MD23"))),
            Self::Md24 => Ok(Some(Cow::Borrowed("MD24"))),
            Self::Md25 => Ok(Some(Cow::Borrowed("MD25"))),
            Self::Md26 => Ok(Some(Cow::Borrowed("MD26"))),
            Self::Md27 => Ok(Some(Cow::Borrowed("MD27"))),
            Self::Md28 => Ok(Some(Cow::Borrowed("MD28"))),
            Self::Md29 => Ok(Some(Cow::Borrowed("MD29"))),
            Self::Md30 => Ok(Some(Cow::Borrowed("MD30"))),
            Self::Md31 => Ok(Some(Cow::Borrowed("MD31"))),
            Self::Md32 => Ok(Some(Cow::Borrowed("MD32"))),
            Self::Md33 => Ok(Some(Cow::Borrowed("MD33"))),
            Self::Md34 => Ok(Some(Cow::Borrowed("MD34"))),
            Self::Md35 => Ok(Some(Cow::Borrowed("MD35"))),
            Self::Md37 => Ok(Some(Cow::Borrowed("MD37"))),
            Self::Md38 => Ok(Some(Cow::Borrowed("MD38"))),
            Self::Md39 => Ok(Some(Cow::Borrowed("MD39"))),
            Self::Md40 => Ok(Some(Cow::Borrowed("MD40"))),
            Self::Md41 => Ok(Some(Cow::Borrowed("MD41"))),
            Self::Md42 => Ok(Some(Cow::Borrowed("MD42"))),
            Self::Md43 => Ok(Some(Cow::Borrowed("MD43"))),
            Self::Md44 => Ok(Some(Cow::Borrowed("MD44"))),
            Self::Md45 => Ok(Some(Cow::Borrowed("MD45"))),
            Self::Md46 => Ok(Some(Cow::Borrowed("MD46"))),
            Self::Md47 => Ok(Some(Cow::Borrowed("MD47"))),
            Self::Md48 => Ok(Some(Cow::Borrowed("MD48"))),
            Self::Md49 => Ok(Some(Cow::Borrowed("MD49"))),
            Self::Md50 => Ok(Some(Cow::Borrowed("MD50"))),
            Self::Md51 => Ok(Some(Cow::Borrowed("MD51"))),
            Self::Md52 => Ok(Some(Cow::Borrowed("MD52"))),
            Self::Md53 => Ok(Some(Cow::Borrowed("MD53"))),
            Self::Md54 => Ok(Some(Cow::Borrowed("MD54"))),
            Self::Md55 => Ok(Some(Cow::Borrowed("MD55"))),
            Self::Md56 => Ok(Some(Cow::Borrowed("MD56"))),
            Self::Md57 => Ok(Some(Cow::Borrowed("MD57"))),
            Self::Md58 => Ok(Some(Cow::Borrowed("MD58"))),
            Self::Md59 => Ok(Some(Cow::Borrowed("MD59"))),
            Self::Md60 => Ok(Some(Cow::Borrowed("MD60"))),
            Self::Md61 => Ok(Some(Cow::Borrowed("MD61"))),
            Self::Md62 => Ok(Some(Cow::Borrowed("MD62"))),
            Self::Md63 => Ok(Some(Cow::Borrowed("MD63"))),
            Self::Md64 => Ok(Some(Cow::Borrowed("MD64"))),
            Self::Md65 => Ok(Some(Cow::Borrowed("MD65"))),
            Self::Md99 => Ok(Some(Cow::Borrowed("MD99"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfMimeCodeElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"MD01" => Ok(Self::Md01),
            b"MD02" => Ok(Self::Md02),
            b"MD03" => Ok(Self::Md03),
            b"MD04" => Ok(Self::Md04),
            b"MD05" => Ok(Self::Md05),
            b"MD06" => Ok(Self::Md06),
            b"MD07" => Ok(Self::Md07),
            b"MD08" => Ok(Self::Md08),
            b"MD09" => Ok(Self::Md09),
            b"MD10" => Ok(Self::Md10),
            b"MD11" => Ok(Self::Md11),
            b"MD12" => Ok(Self::Md12),
            b"MD13" => Ok(Self::Md13),
            b"MD14" => Ok(Self::Md14),
            b"MD15" => Ok(Self::Md15),
            b"MD16" => Ok(Self::Md16),
            b"MD17" => Ok(Self::Md17),
            b"MD18" => Ok(Self::Md18),
            b"MD19" => Ok(Self::Md19),
            b"MD20" => Ok(Self::Md20),
            b"MD21" => Ok(Self::Md21),
            b"MD22" => Ok(Self::Md22),
            b"MD23" => Ok(Self::Md23),
            b"MD24" => Ok(Self::Md24),
            b"MD25" => Ok(Self::Md25),
            b"MD26" => Ok(Self::Md26),
            b"MD27" => Ok(Self::Md27),
            b"MD28" => Ok(Self::Md28),
            b"MD29" => Ok(Self::Md29),
            b"MD30" => Ok(Self::Md30),
            b"MD31" => Ok(Self::Md31),
            b"MD32" => Ok(Self::Md32),
            b"MD33" => Ok(Self::Md33),
            b"MD34" => Ok(Self::Md34),
            b"MD35" => Ok(Self::Md35),
            b"MD37" => Ok(Self::Md37),
            b"MD38" => Ok(Self::Md38),
            b"MD39" => Ok(Self::Md39),
            b"MD40" => Ok(Self::Md40),
            b"MD41" => Ok(Self::Md41),
            b"MD42" => Ok(Self::Md42),
            b"MD43" => Ok(Self::Md43),
            b"MD44" => Ok(Self::Md44),
            b"MD45" => Ok(Self::Md45),
            b"MD46" => Ok(Self::Md46),
            b"MD47" => Ok(Self::Md47),
            b"MD48" => Ok(Self::Md48),
            b"MD49" => Ok(Self::Md49),
            b"MD50" => Ok(Self::Md50),
            b"MD51" => Ok(Self::Md51),
            b"MD52" => Ok(Self::Md52),
            b"MD53" => Ok(Self::Md53),
            b"MD54" => Ok(Self::Md54),
            b"MD55" => Ok(Self::Md55),
            b"MD56" => Ok(Self::Md56),
            b"MD57" => Ok(Self::Md57),
            b"MD58" => Ok(Self::Md58),
            b"MD59" => Ok(Self::Md59),
            b"MD60" => Ok(Self::Md60),
            b"MD61" => Ok(Self::Md61),
            b"MD62" => Ok(Self::Md62),
            b"MD63" => Ok(Self::Md63),
            b"MD64" => Ok(Self::Md64),
            b"MD65" => Ok(Self::Md65),
            b"MD99" => Ok(Self::Md99),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum DtPunit {
    Be,
    Bg,
    Bo,
    Bx,
    C62,
    Ca,
    Cl,
    Cq,
    Cr,
    Cs,
    Ct,
    Cy,
    D99,
    Dr,
    Ev,
    Kg,
    Ne,
    Pa,
    Pf,
    Pk,
    Pl,
    Pr,
    Pu,
    Rg,
    Rl,
    Ro,
    Sa,
    Set,
    Tn,
    Tu,
    Wr,
    Z2,
    Z3,
}
impl SerializeBytes for DtPunit {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Be => Ok(Some(Cow::Borrowed("BE"))),
            Self::Bg => Ok(Some(Cow::Borrowed("BG"))),
            Self::Bo => Ok(Some(Cow::Borrowed("BO"))),
            Self::Bx => Ok(Some(Cow::Borrowed("BX"))),
            Self::C62 => Ok(Some(Cow::Borrowed("C62"))),
            Self::Ca => Ok(Some(Cow::Borrowed("CA"))),
            Self::Cl => Ok(Some(Cow::Borrowed("CL"))),
            Self::Cq => Ok(Some(Cow::Borrowed("CQ"))),
            Self::Cr => Ok(Some(Cow::Borrowed("CR"))),
            Self::Cs => Ok(Some(Cow::Borrowed("CS"))),
            Self::Ct => Ok(Some(Cow::Borrowed("CT"))),
            Self::Cy => Ok(Some(Cow::Borrowed("CY"))),
            Self::D99 => Ok(Some(Cow::Borrowed("D99"))),
            Self::Dr => Ok(Some(Cow::Borrowed("DR"))),
            Self::Ev => Ok(Some(Cow::Borrowed("EV"))),
            Self::Kg => Ok(Some(Cow::Borrowed("KG"))),
            Self::Ne => Ok(Some(Cow::Borrowed("NE"))),
            Self::Pa => Ok(Some(Cow::Borrowed("PA"))),
            Self::Pf => Ok(Some(Cow::Borrowed("PF"))),
            Self::Pk => Ok(Some(Cow::Borrowed("PK"))),
            Self::Pl => Ok(Some(Cow::Borrowed("PL"))),
            Self::Pr => Ok(Some(Cow::Borrowed("PR"))),
            Self::Pu => Ok(Some(Cow::Borrowed("PU"))),
            Self::Rg => Ok(Some(Cow::Borrowed("RG"))),
            Self::Rl => Ok(Some(Cow::Borrowed("RL"))),
            Self::Ro => Ok(Some(Cow::Borrowed("RO"))),
            Self::Sa => Ok(Some(Cow::Borrowed("SA"))),
            Self::Set => Ok(Some(Cow::Borrowed("SET"))),
            Self::Tn => Ok(Some(Cow::Borrowed("TN"))),
            Self::Tu => Ok(Some(Cow::Borrowed("TU"))),
            Self::Wr => Ok(Some(Cow::Borrowed("WR"))),
            Self::Z2 => Ok(Some(Cow::Borrowed("Z2"))),
            Self::Z3 => Ok(Some(Cow::Borrowed("Z3"))),
        }
    }
}
impl DeserializeBytes for DtPunit {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"BE" => Ok(Self::Be),
            b"BG" => Ok(Self::Bg),
            b"BO" => Ok(Self::Bo),
            b"BX" => Ok(Self::Bx),
            b"C62" => Ok(Self::C62),
            b"CA" => Ok(Self::Ca),
            b"CL" => Ok(Self::Cl),
            b"CQ" => Ok(Self::Cq),
            b"CR" => Ok(Self::Cr),
            b"CS" => Ok(Self::Cs),
            b"CT" => Ok(Self::Ct),
            b"CY" => Ok(Self::Cy),
            b"D99" => Ok(Self::D99),
            b"DR" => Ok(Self::Dr),
            b"EV" => Ok(Self::Ev),
            b"KG" => Ok(Self::Kg),
            b"NE" => Ok(Self::Ne),
            b"PA" => Ok(Self::Pa),
            b"PF" => Ok(Self::Pf),
            b"PK" => Ok(Self::Pk),
            b"PL" => Ok(Self::Pl),
            b"PR" => Ok(Self::Pr),
            b"PU" => Ok(Self::Pu),
            b"RG" => Ok(Self::Rg),
            b"RL" => Ok(Self::Rl),
            b"RO" => Ok(Self::Ro),
            b"SA" => Ok(Self::Sa),
            b"SET" => Ok(Self::Set),
            b"TN" => Ok(Self::Tn),
            b"TU" => Ok(Self::Tu),
            b"WR" => Ok(Self::Wr),
            b"Z2" => Ok(Self::Z2),
            b"Z3" => Ok(Self::Z3),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfSurchargeMannerElementType {
    Base,
    Cumulated,
}
impl SerializeBytes for UdxEdxfSurchargeMannerElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::Base => Ok(Some(Cow::Borrowed("base"))),
            Self::Cumulated => Ok(Some(Cow::Borrowed("cumulated"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfSurchargeMannerElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"base" => Ok(Self::Base),
            b"cumulated" => Ok(Self::Cumulated),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType {
    _1,
    _2,
}
impl SerializeBytes for UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_1 => Ok(Some(Cow::Borrowed("1"))),
            Self::_2 => Ok(Some(Cow::Borrowed("2"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"1" => Ok(Self::_1),
            b"2" => Ok(Self::_2),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType {
    _1,
    _2,
}
impl SerializeBytes for UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_1 => Ok(Some(Cow::Borrowed("1"))),
            Self::_2 => Ok(Some(Cow::Borrowed("2"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"1" => Ok(Self::_1),
            b"2" => Ok(Self::_2),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub enum UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType {
    _1,
    _2,
}
impl SerializeBytes for UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType {
    fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
        match self {
            Self::_1 => Ok(Some(Cow::Borrowed("1"))),
            Self::_2 => Ok(Some(Cow::Borrowed("2"))),
        }
    }
}
impl DeserializeBytes for UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType {
    fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
    where
        R: DeserializeReader,
    {
        match bytes {
            b"1" => Ok(Self::_1),
            b"2" => Ok(Self::_2),
            x => Err(reader.map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x)))),
        }
    }
}
#[derive(Debug)]
pub struct UdxEdxfMatrixValuesElementType {
    pub udx_edxf_matrix_value: Vec<UdxEdxfMatrixValueElementType>,
}
impl WithSerializer for UdxEdxfMatrixValuesElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfMatrixValuesElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfMatrixValuesElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfMatrixValuesElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.MATRIX_VALUES"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfMatrixValuesElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfMatrixValuesElementTypeDeserializer;
}
#[derive(Debug)]
pub struct UdxEdxfMatrixValueElementType {
    pub udx_edxf_matrix_source_value: f32,
    pub udx_edxf_matrix_result_value: f32,
}
impl WithSerializer for UdxEdxfMatrixValueElementType {
    type Serializer<'x> = quick_xml_serialize::UdxEdxfMatrixValueElementTypeSerializer<'x>;
    fn serializer<'ser>(
        &'ser self,
        name: Option<&'ser str>,
        is_root: bool,
    ) -> Result<Self::Serializer<'ser>, Error> {
        Ok(
            quick_xml_serialize::UdxEdxfMatrixValueElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::UdxEdxfMatrixValueElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("UDX.EDXF.MATRIX_VALUE"),
                is_root,
            },
        )
    }
}
impl WithDeserializer for UdxEdxfMatrixValueElementType {
    type Deserializer = quick_xml_deserialize::UdxEdxfMatrixValueElementTypeDeserializer;
}
pub mod quick_xml_deserialize {
    use core::mem::replace;
    use xsd_parser::quick_xml::{
        filter_xmlns_attributes, BytesStart, ContentDeserializer, DeserializeReader, Deserializer,
        DeserializerArtifact, DeserializerEvent, DeserializerOutput, DeserializerResult,
        ElementHandlerOutput, Error, ErrorKind, Event, RawByteStr, WithDeserializer,
    };
    #[derive(Debug)]
    pub struct BmecatElementTypeDeserializer {
        version: super::TypeBmEcatVersion,
        content: Vec<super::BmecatElementTypeContent>,
        state: Box<BmecatElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum BmecatElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::BmecatElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl BmecatElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut version: Option<super::TypeBmEcatVersion> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"version")
                ) {
                    reader.read_attrib(&mut version, b"version", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                version: version.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("version".into()))
                })?,
                content: Vec::new(),
                state: Box::new(BmecatElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: BmecatElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let BmecatElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::BmecatElementTypeContent) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::BmecatElementTypeContent>,
            fallback: &mut Option<BmecatElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(BmecatElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = BmecatElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let can_have_more = self.content.len().saturating_add(1) < 5usize;
                    let ret = if can_have_more {
                        ElementHandlerOutput::from_event(event, allow_any)
                    } else {
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    };
                    match (can_have_more, &ret) {
                        (true, ElementHandlerOutput::Continue { .. }) => {
                            fallback.get_or_insert(BmecatElementTypeDeserializerState::Content__(
                                deserializer,
                            ));
                            *self.state = BmecatElementTypeDeserializerState::Next__;
                        }
                        (false, _) | (_, ElementHandlerOutput::Break { .. }) => {
                            *self.state =
                                BmecatElementTypeDeserializerState::Content__(deserializer);
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::BmecatElementType> for BmecatElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BmecatElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BmecatElementType>
        where
            R: DeserializeReader,
        {
            use BmecatElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: BmecatElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::BmecatElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                BmecatElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::BmecatElementType {
                version: self.version,
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct BmecatElementTypeContentDeserializer {
        state: Box<BmecatElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum BmecatElementTypeContentDeserializerState {
        Init__,
        Header(
            Option<super::HeaderElementType>,
            Option<<super::HeaderElementType as WithDeserializer>::Deserializer>,
        ),
        TNewCatalog(
            Option<super::TNewCatalogElementType>,
            Option<<super::TNewCatalogElementType as WithDeserializer>::Deserializer>,
        ),
        TUpdateProducts(
            Option<super::TUpdateProductsElementType>,
            Option<<super::TUpdateProductsElementType as WithDeserializer>::Deserializer>,
        ),
        TUpdatePrices(
            Option<super::TUpdatePricesElementType>,
            Option<<super::TUpdatePricesElementType as WithDeserializer>::Deserializer>,
        ),
        TNewProductdata(
            Option<super::TNewProductdataElementType>,
            Option<<super::TNewProductdataElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::BmecatElementTypeContent),
        Unknown__,
    }
    impl BmecatElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(BmecatElementTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"HEADER")
            ) {
                let output = <super::HeaderElementType as WithDeserializer>::Deserializer::init(
                    reader, event,
                )?;
                return self.handle_header(reader, Default::default(), output, &mut *fallback);
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"T_NEW_CATALOG")
            ) {
                let output =
                    <super::TNewCatalogElementType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                return self.handle_t_new_catalog(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"T_UPDATE_PRODUCTS")
            ) {
                let output =
                    <super::TUpdateProductsElementType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                return self.handle_t_update_products(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"T_UPDATE_PRICES")
            ) {
                let output =
                    <super::TUpdatePricesElementType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                return self.handle_t_update_prices(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"T_NEW_PRODUCTDATA")
            ) {
                let output =
                    <super::TNewProductdataElementType as WithDeserializer>::Deserializer::init(
                        reader, event,
                    )?;
                return self.handle_t_new_productdata(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(BmecatElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: BmecatElementTypeContentDeserializerState,
        ) -> Result<super::BmecatElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use BmecatElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::Header(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_header(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::Header(values.ok_or_else(
                        || ErrorKind::MissingElement("HEADER".into()),
                    )?))
                }
                S::TNewCatalog(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_t_new_catalog(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::TNewCatalog(
                        values.ok_or_else(|| ErrorKind::MissingElement("T_NEW_CATALOG".into()))?,
                    ))
                }
                S::TUpdateProducts(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_t_update_products(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::TUpdateProducts(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("T_UPDATE_PRODUCTS".into()))?,
                    ))
                }
                S::TUpdatePrices(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_t_update_prices(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::TUpdatePrices(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("T_UPDATE_PRICES".into()))?,
                    ))
                }
                S::TNewProductdata(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_t_new_productdata(&mut values, value)?;
                    }
                    Ok(super::BmecatElementTypeContent::TNewProductdata(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("T_NEW_PRODUCTDATA".into()))?,
                    ))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_header(
            values: &mut Option<super::HeaderElementType>,
            value: super::HeaderElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"HEADER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_t_new_catalog(
            values: &mut Option<super::TNewCatalogElementType>,
            value: super::TNewCatalogElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"T_NEW_CATALOG",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_t_update_products(
            values: &mut Option<super::TUpdateProductsElementType>,
            value: super::TUpdateProductsElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"T_UPDATE_PRODUCTS",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_t_update_prices(
            values: &mut Option<super::TUpdatePricesElementType>,
            value: super::TUpdatePricesElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"T_UPDATE_PRICES",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_t_new_productdata(
            values: &mut Option<super::TNewProductdataElementType>,
            value: super::TNewProductdataElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"T_NEW_PRODUCTDATA",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_header<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::HeaderElementType>,
            output: DeserializerOutput<'de, super::HeaderElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => BmecatElementTypeContentDeserializerState::Header(values, None),
                    Some(BmecatElementTypeContentDeserializerState::Header(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::Header(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::Header(_, Some(deserializer))) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_header(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_header(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::Header(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::Header(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_t_new_catalog<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::TNewCatalogElementType>,
            output: DeserializerOutput<'de, super::TNewCatalogElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => BmecatElementTypeContentDeserializerState::TNewCatalog(values, None),
                    Some(BmecatElementTypeContentDeserializerState::TNewCatalog(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::TNewCatalog(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::TNewCatalog(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_t_new_catalog(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_t_new_catalog(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::TNewCatalog(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::TNewCatalog(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_t_update_products<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::TUpdateProductsElementType>,
            output: DeserializerOutput<'de, super::TUpdateProductsElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        BmecatElementTypeContentDeserializerState::TUpdateProducts(values, None)
                    }
                    Some(BmecatElementTypeContentDeserializerState::TUpdateProducts(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::TUpdateProducts(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::TUpdateProducts(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_t_update_products(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_t_update_products(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::TUpdateProducts(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::TUpdateProducts(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_t_update_prices<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::TUpdatePricesElementType>,
            output: DeserializerOutput<'de, super::TUpdatePricesElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => BmecatElementTypeContentDeserializerState::TUpdatePrices(values, None),
                    Some(BmecatElementTypeContentDeserializerState::TUpdatePrices(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::TUpdatePrices(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::TUpdatePrices(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_t_update_prices(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_t_update_prices(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::TUpdatePrices(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::TUpdatePrices(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_t_new_productdata<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::TNewProductdataElementType>,
            output: DeserializerOutput<'de, super::TNewProductdataElementType>,
            fallback: &mut Option<BmecatElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        BmecatElementTypeContentDeserializerState::TNewProductdata(values, None)
                    }
                    Some(BmecatElementTypeContentDeserializerState::TNewProductdata(
                        _,
                        Some(deserializer),
                    )) => BmecatElementTypeContentDeserializerState::TNewProductdata(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(BmecatElementTypeContentDeserializerState::TNewProductdata(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_t_new_productdata(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_t_new_productdata(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        BmecatElementTypeContentDeserializerState::TNewProductdata(values, None),
                    )?;
                    *self.state = BmecatElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = BmecatElementTypeContentDeserializerState::TNewProductdata(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::BmecatElementTypeContent>
        for BmecatElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BmecatElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(BmecatElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(&*x.state, BmecatElementTypeContentDeserializerState::Init__) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BmecatElementTypeContent>
        where
            R: DeserializeReader,
        {
            use BmecatElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Header(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_header(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TNewCatalog(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_t_new_catalog(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TUpdateProducts(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_t_update_products(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TUpdatePrices(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_t_update_prices(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TNewProductdata(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_t_new_productdata(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::Header(values, None), event) => {
                        let output =
                            <super::HeaderElementType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        match self.handle_header(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TNewCatalog(values, None), event) => {
                        let output = < super :: TNewCatalogElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_t_new_catalog(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TUpdateProducts(values, None), event) => {
                        let output = < super :: TUpdateProductsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_t_update_products(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TUpdatePrices(values, None), event) => {
                        let output = < super :: TUpdatePricesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_t_update_prices(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::TNewProductdata(values, None), event) => {
                        let output = < super :: TNewProductdataElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_t_new_productdata(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::BmecatElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct HeaderElementTypeDeserializer {
        generator_info: Option<String>,
        catalog: Option<super::CatalogElementType>,
        buyer: Option<super::BuyerElementType>,
        supplier: Option<super::SupplierElementType>,
        user_defined_extensions: Option<super::UdxHeader>,
        state: Box<HeaderElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum HeaderElementTypeDeserializerState {
        Init__,
        GeneratorInfo(Option<<String as WithDeserializer>::Deserializer>),
        Catalog(Option<<super::CatalogElementType as WithDeserializer>::Deserializer>),
        Buyer(Option<<super::BuyerElementType as WithDeserializer>::Deserializer>),
        Supplier(Option<<super::SupplierElementType as WithDeserializer>::Deserializer>),
        UserDefinedExtensions(Option<<super::UdxHeader as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl HeaderElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                generator_info: None,
                catalog: None,
                buyer: None,
                supplier: None,
                user_defined_extensions: None,
                state: Box::new(HeaderElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: HeaderElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use HeaderElementTypeDeserializerState as S;
            match state {
                S::GeneratorInfo(Some(deserializer)) => {
                    self.store_generator_info(deserializer.finish(reader)?)?
                }
                S::Catalog(Some(deserializer)) => {
                    self.store_catalog(deserializer.finish(reader)?)?
                }
                S::Buyer(Some(deserializer)) => self.store_buyer(deserializer.finish(reader)?)?,
                S::Supplier(Some(deserializer)) => {
                    self.store_supplier(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_generator_info(&mut self, value: String) -> Result<(), Error> {
            if self.generator_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"GENERATOR_INFO",
                )))?;
            }
            self.generator_info = Some(value);
            Ok(())
        }
        fn store_catalog(&mut self, value: super::CatalogElementType) -> Result<(), Error> {
            if self.catalog.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG",
                )))?;
            }
            self.catalog = Some(value);
            Ok(())
        }
        fn store_buyer(&mut self, value: super::BuyerElementType) -> Result<(), Error> {
            if self.buyer.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BUYER",
                )))?;
            }
            self.buyer = Some(value);
            Ok(())
        }
        fn store_supplier(&mut self, value: super::SupplierElementType) -> Result<(), Error> {
            if self.supplier.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER",
                )))?;
            }
            self.supplier = Some(value);
            Ok(())
        }
        fn store_user_defined_extensions(&mut self, value: super::UdxHeader) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn handle_generator_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(HeaderElementTypeDeserializerState::GeneratorInfo(None));
                *self.state = HeaderElementTypeDeserializerState::Catalog(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_generator_info(data)?;
                    *self.state = HeaderElementTypeDeserializerState::Catalog(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderElementTypeDeserializerState::GeneratorInfo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = HeaderElementTypeDeserializerState::Catalog(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = HeaderElementTypeDeserializerState::GeneratorInfo(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CatalogElementType>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.catalog.is_some() {
                    fallback.get_or_insert(HeaderElementTypeDeserializerState::Catalog(None));
                    *self.state = HeaderElementTypeDeserializerState::Buyer(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderElementTypeDeserializerState::Catalog(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog(data)?;
                    *self.state = HeaderElementTypeDeserializerState::Buyer(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(HeaderElementTypeDeserializerState::Catalog(
                                Some(deserializer),
                            ));
                            *self.state = HeaderElementTypeDeserializerState::Buyer(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderElementTypeDeserializerState::Catalog(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::BuyerElementType>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.buyer.is_some() {
                    fallback.get_or_insert(HeaderElementTypeDeserializerState::Buyer(None));
                    *self.state = HeaderElementTypeDeserializerState::Supplier(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderElementTypeDeserializerState::Buyer(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer(data)?;
                    *self.state = HeaderElementTypeDeserializerState::Supplier(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(HeaderElementTypeDeserializerState::Buyer(
                                Some(deserializer),
                            ));
                            *self.state = HeaderElementTypeDeserializerState::Supplier(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderElementTypeDeserializerState::Buyer(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_supplier<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplierElementType>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier.is_some() {
                    fallback.get_or_insert(HeaderElementTypeDeserializerState::Supplier(None));
                    *self.state = HeaderElementTypeDeserializerState::UserDefinedExtensions(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderElementTypeDeserializerState::Supplier(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier(data)?;
                    *self.state = HeaderElementTypeDeserializerState::UserDefinedExtensions(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(HeaderElementTypeDeserializerState::Supplier(
                                Some(deserializer),
                            ));
                            *self.state =
                                HeaderElementTypeDeserializerState::UserDefinedExtensions(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                HeaderElementTypeDeserializerState::Supplier(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxHeader>,
            fallback: &mut Option<HeaderElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.user_defined_extensions.is_some() {
                    fallback.get_or_insert(
                        HeaderElementTypeDeserializerState::UserDefinedExtensions(None),
                    );
                    *self.state = HeaderElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = HeaderElementTypeDeserializerState::UserDefinedExtensions(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state = HeaderElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                HeaderElementTypeDeserializerState::UserDefinedExtensions(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = HeaderElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = HeaderElementTypeDeserializerState::UserDefinedExtensions(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::HeaderElementType> for HeaderElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::HeaderElementType>
        where
            R: DeserializeReader,
        {
            use HeaderElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::GeneratorInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_generator_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Catalog(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Buyer(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Supplier(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = HeaderElementTypeDeserializerState::GeneratorInfo(None);
                        event
                    }
                    (S::GeneratorInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"GENERATOR_INFO",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_generator_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Catalog(None);
                            event
                        }
                    }
                    (S::Catalog(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"CATALOG")
                        {
                            let output = < super :: CatalogElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_catalog(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Buyer(None);
                            event
                        }
                    }
                    (S::Buyer(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"BUYER") {
                            let output =
                                <super::BuyerElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_buyer(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Supplier(None);
                            event
                        }
                    }
                    (S::Supplier(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER",
                        ) {
                            let output = < super :: SupplierElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_supplier(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxHeader as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::HeaderElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                HeaderElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::HeaderElementType {
                generator_info: self.generator_info,
                catalog: self
                    .catalog
                    .ok_or_else(|| ErrorKind::MissingElement("CATALOG".into()))?,
                buyer: self
                    .buyer
                    .ok_or_else(|| ErrorKind::MissingElement("BUYER".into()))?,
                supplier: self
                    .supplier
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER".into()))?,
                user_defined_extensions: self
                    .user_defined_extensions
                    .ok_or_else(|| ErrorKind::MissingElement("USER_DEFINED_EXTENSIONS".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TNewCatalogElementTypeDeserializer {
        product: Vec<super::TNewCatalogProductElementType>,
        state: Box<TNewCatalogElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TNewCatalogElementTypeDeserializerState {
        Init__,
        Product(Option<<super::TNewCatalogProductElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TNewCatalogElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                product: Vec::new(),
                state: Box::new(TNewCatalogElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TNewCatalogElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TNewCatalogElementTypeDeserializerState as S;
            match state {
                S::Product(Some(deserializer)) => {
                    self.store_product(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_product(
            &mut self,
            value: super::TNewCatalogProductElementType,
        ) -> Result<(), Error> {
            self.product.push(value);
            Ok(())
        }
        fn handle_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TNewCatalogProductElementType>,
            fallback: &mut Option<TNewCatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product.len() < 1usize {
                    *self.state = TNewCatalogElementTypeDeserializerState::Product(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(TNewCatalogElementTypeDeserializerState::Product(None));
                    *self.state = TNewCatalogElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product(data)?;
                    *self.state = TNewCatalogElementTypeDeserializerState::Product(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogElementTypeDeserializerState::Product(Some(
                                    deserializer,
                                )),
                            );
                            if self.product.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TNewCatalogElementTypeDeserializerState::Product(None);
                            } else {
                                *self.state = TNewCatalogElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TNewCatalogElementTypeDeserializerState::Product(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TNewCatalogElementType> for TNewCatalogElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewCatalogElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewCatalogElementType>
        where
            R: DeserializeReader,
        {
            use TNewCatalogElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Product(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TNewCatalogElementTypeDeserializerState::Product(None);
                        event
                    }
                    (S::Product(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"PRODUCT")
                        {
                            let output = < super :: TNewCatalogProductElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TNewCatalogElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TNewCatalogElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TNewCatalogElementType {
                product: self.product,
            })
        }
    }
    #[derive(Debug)]
    pub struct TUpdateProductsElementTypeDeserializer {
        prev_version: i32,
        product: Vec<super::TUpdateProductsProductElementType>,
        state: Box<TUpdateProductsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TUpdateProductsElementTypeDeserializerState {
        Init__,
        Product(
            Option<<super::TUpdateProductsProductElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TUpdateProductsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut prev_version: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"prev_version")
                ) {
                    reader.read_attrib(&mut prev_version, b"prev_version", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                prev_version: prev_version.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("prev_version".into()))
                })?,
                product: Vec::new(),
                state: Box::new(TUpdateProductsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TUpdateProductsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TUpdateProductsElementTypeDeserializerState as S;
            match state {
                S::Product(Some(deserializer)) => {
                    self.store_product(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_product(
            &mut self,
            value: super::TUpdateProductsProductElementType,
        ) -> Result<(), Error> {
            self.product.push(value);
            Ok(())
        }
        fn handle_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TUpdateProductsProductElementType>,
            fallback: &mut Option<TUpdateProductsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product.len() < 1usize {
                    *self.state = TUpdateProductsElementTypeDeserializerState::Product(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(TUpdateProductsElementTypeDeserializerState::Product(None));
                    *self.state = TUpdateProductsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product(data)?;
                    *self.state = TUpdateProductsElementTypeDeserializerState::Product(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsElementTypeDeserializerState::Product(Some(
                                    deserializer,
                                )),
                            );
                            if self.product.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TUpdateProductsElementTypeDeserializerState::Product(None);
                            } else {
                                *self.state = TUpdateProductsElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TUpdateProductsElementTypeDeserializerState::Product(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TUpdateProductsElementType>
        for TUpdateProductsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdateProductsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdateProductsElementType>
        where
            R: DeserializeReader,
        {
            use TUpdateProductsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Product(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TUpdateProductsElementTypeDeserializerState::Product(None);
                        event
                    }
                    (S::Product(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"PRODUCT")
                        {
                            let output = < super :: TUpdateProductsProductElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TUpdateProductsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TUpdateProductsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TUpdateProductsElementType {
                prev_version: self.prev_version,
                product: self.product,
            })
        }
    }
    #[derive(Debug)]
    pub struct TUpdatePricesElementTypeDeserializer {
        prev_version: i32,
        product: Vec<super::TUpdatePricesProductElementType>,
        state: Box<TUpdatePricesElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TUpdatePricesElementTypeDeserializerState {
        Init__,
        Product(Option<<super::TUpdatePricesProductElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TUpdatePricesElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut prev_version: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"prev_version")
                ) {
                    reader.read_attrib(&mut prev_version, b"prev_version", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                prev_version: prev_version.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("prev_version".into()))
                })?,
                product: Vec::new(),
                state: Box::new(TUpdatePricesElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TUpdatePricesElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TUpdatePricesElementTypeDeserializerState as S;
            match state {
                S::Product(Some(deserializer)) => {
                    self.store_product(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_product(
            &mut self,
            value: super::TUpdatePricesProductElementType,
        ) -> Result<(), Error> {
            self.product.push(value);
            Ok(())
        }
        fn handle_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TUpdatePricesProductElementType>,
            fallback: &mut Option<TUpdatePricesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product.len() < 1usize {
                    *self.state = TUpdatePricesElementTypeDeserializerState::Product(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(TUpdatePricesElementTypeDeserializerState::Product(None));
                    *self.state = TUpdatePricesElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product(data)?;
                    *self.state = TUpdatePricesElementTypeDeserializerState::Product(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdatePricesElementTypeDeserializerState::Product(Some(
                                    deserializer,
                                )),
                            );
                            if self.product.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TUpdatePricesElementTypeDeserializerState::Product(None);
                            } else {
                                *self.state = TUpdatePricesElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TUpdatePricesElementTypeDeserializerState::Product(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TUpdatePricesElementType>
        for TUpdatePricesElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdatePricesElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdatePricesElementType>
        where
            R: DeserializeReader,
        {
            use TUpdatePricesElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Product(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TUpdatePricesElementTypeDeserializerState::Product(None);
                        event
                    }
                    (S::Product(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"PRODUCT")
                        {
                            let output = < super :: TUpdatePricesProductElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TUpdatePricesElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TUpdatePricesElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TUpdatePricesElementType {
                prev_version: self.prev_version,
                product: self.product,
            })
        }
    }
    #[derive(Debug)]
    pub struct TNewProductdataElementTypeDeserializer {
        product: Vec<super::TNewProductdataProductElementType>,
        state: Box<TNewProductdataElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TNewProductdataElementTypeDeserializerState {
        Init__,
        Product(
            Option<<super::TNewProductdataProductElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TNewProductdataElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                product: Vec::new(),
                state: Box::new(TNewProductdataElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TNewProductdataElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TNewProductdataElementTypeDeserializerState as S;
            match state {
                S::Product(Some(deserializer)) => {
                    self.store_product(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_product(
            &mut self,
            value: super::TNewProductdataProductElementType,
        ) -> Result<(), Error> {
            self.product.push(value);
            Ok(())
        }
        fn handle_product<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TNewProductdataProductElementType>,
            fallback: &mut Option<TNewProductdataElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product.len() < 1usize {
                    *self.state = TNewProductdataElementTypeDeserializerState::Product(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback
                        .get_or_insert(TNewProductdataElementTypeDeserializerState::Product(None));
                    *self.state = TNewProductdataElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product(data)?;
                    *self.state = TNewProductdataElementTypeDeserializerState::Product(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewProductdataElementTypeDeserializerState::Product(Some(
                                    deserializer,
                                )),
                            );
                            if self.product.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TNewProductdataElementTypeDeserializerState::Product(None);
                            } else {
                                *self.state = TNewProductdataElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = TNewProductdataElementTypeDeserializerState::Product(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TNewProductdataElementType>
        for TNewProductdataElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewProductdataElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewProductdataElementType>
        where
            R: DeserializeReader,
        {
            use TNewProductdataElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Product(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = TNewProductdataElementTypeDeserializerState::Product(None);
                        event
                    }
                    (S::Product(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"PRODUCT")
                        {
                            let output = < super :: TNewProductdataProductElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TNewProductdataElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TNewProductdataElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TNewProductdataElementType {
                product: self.product,
            })
        }
    }
    #[derive(Debug)]
    pub struct CatalogElementTypeDeserializer {
        language: Vec<super::LanguageElementType>,
        catalog_id: Option<String>,
        catalog_version: Option<String>,
        catalog_name: Vec<super::DtMlstring>,
        datetime: Option<super::CatalogDatetimeElementType>,
        territory: Vec<String>,
        currency: Option<super::DtCurrencies>,
        mime_root: Vec<super::DtMlstring>,
        state: Box<CatalogElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CatalogElementTypeDeserializerState {
        Init__,
        Language(Option<<super::LanguageElementType as WithDeserializer>::Deserializer>),
        CatalogId(Option<<String as WithDeserializer>::Deserializer>),
        CatalogVersion(Option<<String as WithDeserializer>::Deserializer>),
        CatalogName(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Datetime(Option<<super::CatalogDatetimeElementType as WithDeserializer>::Deserializer>),
        Territory(Option<<String as WithDeserializer>::Deserializer>),
        Currency(Option<<super::DtCurrencies as WithDeserializer>::Deserializer>),
        MimeRoot(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CatalogElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                language: Vec::new(),
                catalog_id: None,
                catalog_version: None,
                catalog_name: Vec::new(),
                datetime: None,
                territory: Vec::new(),
                currency: None,
                mime_root: Vec::new(),
                state: Box::new(CatalogElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CatalogElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CatalogElementTypeDeserializerState as S;
            match state {
                S::Language(Some(deserializer)) => {
                    self.store_language(deserializer.finish(reader)?)?
                }
                S::CatalogId(Some(deserializer)) => {
                    self.store_catalog_id(deserializer.finish(reader)?)?
                }
                S::CatalogVersion(Some(deserializer)) => {
                    self.store_catalog_version(deserializer.finish(reader)?)?
                }
                S::CatalogName(Some(deserializer)) => {
                    self.store_catalog_name(deserializer.finish(reader)?)?
                }
                S::Datetime(Some(deserializer)) => {
                    self.store_datetime(deserializer.finish(reader)?)?
                }
                S::Territory(Some(deserializer)) => {
                    self.store_territory(deserializer.finish(reader)?)?
                }
                S::Currency(Some(deserializer)) => {
                    self.store_currency(deserializer.finish(reader)?)?
                }
                S::MimeRoot(Some(deserializer)) => {
                    self.store_mime_root(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_language(&mut self, value: super::LanguageElementType) -> Result<(), Error> {
            self.language.push(value);
            Ok(())
        }
        fn store_catalog_id(&mut self, value: String) -> Result<(), Error> {
            if self.catalog_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG_ID",
                )))?;
            }
            self.catalog_id = Some(value);
            Ok(())
        }
        fn store_catalog_version(&mut self, value: String) -> Result<(), Error> {
            if self.catalog_version.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG_VERSION",
                )))?;
            }
            self.catalog_version = Some(value);
            Ok(())
        }
        fn store_catalog_name(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.catalog_name.push(value);
            Ok(())
        }
        fn store_datetime(
            &mut self,
            value: super::CatalogDatetimeElementType,
        ) -> Result<(), Error> {
            if self.datetime.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DATETIME",
                )))?;
            }
            self.datetime = Some(value);
            Ok(())
        }
        fn store_territory(&mut self, value: String) -> Result<(), Error> {
            self.territory.push(value);
            Ok(())
        }
        fn store_currency(&mut self, value: super::DtCurrencies) -> Result<(), Error> {
            if self.currency.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CURRENCY",
                )))?;
            }
            self.currency = Some(value);
            Ok(())
        }
        fn store_mime_root(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.mime_root.push(value);
            Ok(())
        }
        fn handle_language<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::LanguageElementType>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.language.len() < 1usize {
                    *self.state = CatalogElementTypeDeserializerState::Language(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CatalogElementTypeDeserializerState::Language(None));
                    *self.state = CatalogElementTypeDeserializerState::CatalogId(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_language(data)?;
                    *self.state = CatalogElementTypeDeserializerState::Language(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::Language(
                                Some(deserializer),
                            ));
                            if self.language.len().saturating_add(1) < 1usize {
                                *self.state = CatalogElementTypeDeserializerState::Language(None);
                            } else {
                                *self.state = CatalogElementTypeDeserializerState::CatalogId(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::Language(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.catalog_id.is_some() {
                    fallback.get_or_insert(CatalogElementTypeDeserializerState::CatalogId(None));
                    *self.state = CatalogElementTypeDeserializerState::CatalogVersion(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CatalogElementTypeDeserializerState::CatalogId(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_id(data)?;
                    *self.state = CatalogElementTypeDeserializerState::CatalogVersion(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::CatalogId(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::CatalogVersion(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::CatalogId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.catalog_version.is_some() {
                    fallback
                        .get_or_insert(CatalogElementTypeDeserializerState::CatalogVersion(None));
                    *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CatalogElementTypeDeserializerState::CatalogVersion(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_version(data)?;
                    *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CatalogElementTypeDeserializerState::CatalogVersion(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CatalogElementTypeDeserializerState::CatalogVersion(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.catalog_name.len() < 1usize {
                    *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(CatalogElementTypeDeserializerState::CatalogName(None));
                    *self.state = CatalogElementTypeDeserializerState::Datetime(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_name(data)?;
                    *self.state = CatalogElementTypeDeserializerState::CatalogName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CatalogElementTypeDeserializerState::CatalogName(Some(
                                    deserializer,
                                )),
                            );
                            if self.catalog_name.len().saturating_add(1) < 1usize {
                                *self.state =
                                    CatalogElementTypeDeserializerState::CatalogName(None);
                            } else {
                                *self.state = CatalogElementTypeDeserializerState::Datetime(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CatalogElementTypeDeserializerState::CatalogName(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_datetime<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CatalogDatetimeElementType>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.datetime.is_some() {
                    fallback.get_or_insert(CatalogElementTypeDeserializerState::Datetime(None));
                    *self.state = CatalogElementTypeDeserializerState::Territory(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CatalogElementTypeDeserializerState::Datetime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_datetime(data)?;
                    *self.state = CatalogElementTypeDeserializerState::Territory(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::Datetime(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::Territory(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::Datetime(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_territory<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CatalogElementTypeDeserializerState::Territory(None));
                *self.state = CatalogElementTypeDeserializerState::Currency(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_territory(data)?;
                    *self.state = CatalogElementTypeDeserializerState::Territory(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::Territory(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::Territory(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::Territory(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_currency<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtCurrencies>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CatalogElementTypeDeserializerState::Currency(None));
                *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_currency(data)?;
                    *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::Currency(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::Currency(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_root<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<CatalogElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(CatalogElementTypeDeserializerState::MimeRoot(None));
                *self.state = CatalogElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_root(data)?;
                    *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(CatalogElementTypeDeserializerState::MimeRoot(
                                Some(deserializer),
                            ));
                            *self.state = CatalogElementTypeDeserializerState::MimeRoot(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CatalogElementTypeDeserializerState::MimeRoot(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CatalogElementType> for CatalogElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CatalogElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CatalogElementType>
        where
            R: DeserializeReader,
        {
            use CatalogElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Language(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_language(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogVersion(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Datetime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_datetime(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Territory(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_territory(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Currency(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_currency(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeRoot(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_root(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CatalogElementTypeDeserializerState::Language(None);
                        event
                    }
                    (S::Language(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"LANGUAGE",
                        ) {
                            let output = < super :: LanguageElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_language(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogId(None);
                            event
                        }
                    }
                    (S::CatalogId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_ID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_catalog_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogVersion(None);
                            event
                        }
                    }
                    (S::CatalogVersion(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_VERSION",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_catalog_version(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogName(None);
                            event
                        }
                    }
                    (S::CatalogName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_NAME",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_catalog_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Datetime(None);
                            event
                        }
                    }
                    (S::Datetime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DATETIME",
                        ) {
                            let output = < super :: CatalogDatetimeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_datetime(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Territory(None);
                            event
                        }
                    }
                    (S::Territory(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"TERRITORY",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_territory(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Currency(None);
                            event
                        }
                    }
                    (S::Currency(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CURRENCY",
                        ) {
                            let output =
                                <super::DtCurrencies as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_currency(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeRoot(None);
                            event
                        }
                    }
                    (S::MimeRoot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_ROOT",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime_root(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CatalogElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CatalogElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CatalogElementType {
                language: self.language,
                catalog_id: self
                    .catalog_id
                    .ok_or_else(|| ErrorKind::MissingElement("CATALOG_ID".into()))?,
                catalog_version: self
                    .catalog_version
                    .ok_or_else(|| ErrorKind::MissingElement("CATALOG_VERSION".into()))?,
                catalog_name: self.catalog_name,
                datetime: self
                    .datetime
                    .ok_or_else(|| ErrorKind::MissingElement("DATETIME".into()))?,
                territory: self.territory,
                currency: self.currency,
                mime_root: self.mime_root,
            })
        }
    }
    #[derive(Debug)]
    pub struct BuyerElementTypeDeserializer {
        buyer_id: Vec<super::TypePartyId>,
        buyer_name: Option<String>,
        state: Box<BuyerElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum BuyerElementTypeDeserializerState {
        Init__,
        BuyerId(Option<<super::TypePartyId as WithDeserializer>::Deserializer>),
        BuyerName(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl BuyerElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                buyer_id: Vec::new(),
                buyer_name: None,
                state: Box::new(BuyerElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: BuyerElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use BuyerElementTypeDeserializerState as S;
            match state {
                S::BuyerId(Some(deserializer)) => {
                    self.store_buyer_id(deserializer.finish(reader)?)?
                }
                S::BuyerName(Some(deserializer)) => {
                    self.store_buyer_name(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_buyer_id(&mut self, value: super::TypePartyId) -> Result<(), Error> {
            self.buyer_id.push(value);
            Ok(())
        }
        fn store_buyer_name(&mut self, value: String) -> Result<(), Error> {
            if self.buyer_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BUYER_NAME",
                )))?;
            }
            self.buyer_name = Some(value);
            Ok(())
        }
        fn handle_buyer_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TypePartyId>,
            fallback: &mut Option<BuyerElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(BuyerElementTypeDeserializerState::BuyerId(None));
                *self.state = BuyerElementTypeDeserializerState::BuyerName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_id(data)?;
                    if self.buyer_id.len() < 2usize {
                        *self.state = BuyerElementTypeDeserializerState::BuyerId(None);
                    } else {
                        *self.state = BuyerElementTypeDeserializerState::BuyerName(None);
                    }
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(BuyerElementTypeDeserializerState::BuyerId(
                                Some(deserializer),
                            ));
                            *self.state = BuyerElementTypeDeserializerState::BuyerId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                BuyerElementTypeDeserializerState::BuyerId(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<BuyerElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.buyer_name.is_some() {
                    fallback.get_or_insert(BuyerElementTypeDeserializerState::BuyerName(None));
                    *self.state = BuyerElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = BuyerElementTypeDeserializerState::BuyerName(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_name(data)?;
                    *self.state = BuyerElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(BuyerElementTypeDeserializerState::BuyerName(
                                Some(deserializer),
                            ));
                            *self.state = BuyerElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                BuyerElementTypeDeserializerState::BuyerName(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::BuyerElementType> for BuyerElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BuyerElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BuyerElementType>
        where
            R: DeserializeReader,
        {
            use BuyerElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::BuyerId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = BuyerElementTypeDeserializerState::BuyerId(None);
                        event
                    }
                    (S::BuyerId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"BUYER_ID",
                        ) {
                            let output =
                                <super::TypePartyId as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_buyer_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerName(None);
                            event
                        }
                    }
                    (S::BuyerName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"BUYER_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_buyer_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::BuyerElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                BuyerElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::BuyerElementType {
                buyer_id: self.buyer_id,
                buyer_name: self
                    .buyer_name
                    .ok_or_else(|| ErrorKind::MissingElement("BUYER_NAME".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct SupplierElementTypeDeserializer {
        supplier_id: Vec<super::TypePartyId>,
        supplier_name: Option<String>,
        address: Option<super::SupplierAddressElementType>,
        mime_info: Option<super::MimeInfoElementType>,
        state: Box<SupplierElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplierElementTypeDeserializerState {
        Init__,
        SupplierId(Option<<super::TypePartyId as WithDeserializer>::Deserializer>),
        SupplierName(Option<<String as WithDeserializer>::Deserializer>),
        Address(Option<<super::SupplierAddressElementType as WithDeserializer>::Deserializer>),
        MimeInfo(Option<<super::MimeInfoElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SupplierElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                supplier_id: Vec::new(),
                supplier_name: None,
                address: None,
                mime_info: None,
                state: Box::new(SupplierElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplierElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SupplierElementTypeDeserializerState as S;
            match state {
                S::SupplierId(Some(deserializer)) => {
                    self.store_supplier_id(deserializer.finish(reader)?)?
                }
                S::SupplierName(Some(deserializer)) => {
                    self.store_supplier_name(deserializer.finish(reader)?)?
                }
                S::Address(Some(deserializer)) => {
                    self.store_address(deserializer.finish(reader)?)?
                }
                S::MimeInfo(Some(deserializer)) => {
                    self.store_mime_info(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_id(&mut self, value: super::TypePartyId) -> Result<(), Error> {
            self.supplier_id.push(value);
            Ok(())
        }
        fn store_supplier_name(&mut self, value: String) -> Result<(), Error> {
            if self.supplier_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_NAME",
                )))?;
            }
            self.supplier_name = Some(value);
            Ok(())
        }
        fn store_address(&mut self, value: super::SupplierAddressElementType) -> Result<(), Error> {
            if self.address.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ADDRESS",
                )))?;
            }
            self.address = Some(value);
            Ok(())
        }
        fn store_mime_info(&mut self, value: super::MimeInfoElementType) -> Result<(), Error> {
            if self.mime_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MIME_INFO",
                )))?;
            }
            self.mime_info = Some(value);
            Ok(())
        }
        fn handle_supplier_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TypePartyId>,
            fallback: &mut Option<SupplierElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierElementTypeDeserializerState::SupplierId(None));
                *self.state = SupplierElementTypeDeserializerState::SupplierName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_id(data)?;
                    if self.supplier_id.len() < 2usize {
                        *self.state = SupplierElementTypeDeserializerState::SupplierId(None);
                    } else {
                        *self.state = SupplierElementTypeDeserializerState::SupplierName(None);
                    }
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierElementTypeDeserializerState::SupplierId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierElementTypeDeserializerState::SupplierId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierElementTypeDeserializerState::SupplierId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_supplier_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SupplierElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_name.is_some() {
                    fallback
                        .get_or_insert(SupplierElementTypeDeserializerState::SupplierName(None));
                    *self.state = SupplierElementTypeDeserializerState::Address(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = SupplierElementTypeDeserializerState::SupplierName(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_name(data)?;
                    *self.state = SupplierElementTypeDeserializerState::Address(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierElementTypeDeserializerState::SupplierName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierElementTypeDeserializerState::Address(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierElementTypeDeserializerState::SupplierName(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_address<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SupplierAddressElementType>,
            fallback: &mut Option<SupplierElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierElementTypeDeserializerState::Address(None));
                *self.state = SupplierElementTypeDeserializerState::MimeInfo(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_address(data)?;
                    *self.state = SupplierElementTypeDeserializerState::MimeInfo(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(SupplierElementTypeDeserializerState::Address(
                                Some(deserializer),
                            ));
                            *self.state = SupplierElementTypeDeserializerState::MimeInfo(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SupplierElementTypeDeserializerState::Address(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MimeInfoElementType>,
            fallback: &mut Option<SupplierElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierElementTypeDeserializerState::MimeInfo(None));
                *self.state = SupplierElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_info(data)?;
                    *self.state = SupplierElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(SupplierElementTypeDeserializerState::MimeInfo(
                                Some(deserializer),
                            ));
                            *self.state = SupplierElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                SupplierElementTypeDeserializerState::MimeInfo(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SupplierElementType> for SupplierElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierElementType>
        where
            R: DeserializeReader,
        {
            use SupplierElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SupplierName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Address(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_address(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = SupplierElementTypeDeserializerState::SupplierId(None);
                        event
                    }
                    (S::SupplierId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_ID",
                        ) {
                            let output =
                                <super::TypePartyId as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_supplier_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SupplierName(None);
                            event
                        }
                    }
                    (S::SupplierName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_supplier_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Address(None);
                            event
                        }
                    }
                    (S::Address(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"ADDRESS")
                        {
                            let output = < super :: SupplierAddressElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_address(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeInfo(None);
                            event
                        }
                    }
                    (S::MimeInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_INFO",
                        ) {
                            let output = < super :: MimeInfoElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_mime_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplierElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplierElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplierElementType {
                supplier_id: self.supplier_id,
                supplier_name: self
                    .supplier_name
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_NAME".into()))?,
                address: self.address,
                mime_info: self.mime_info,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxHeaderDeserializer {
        udx_edxf_version: Option<super::TypeBmEcatEtimVersion>,
        state: Box<UdxHeaderDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxHeaderDeserializerState {
        Init__,
        UdxEdxfVersion(Option<<super::TypeBmEcatEtimVersion as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxHeaderDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_version: None,
                state: Box::new(UdxHeaderDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxHeaderDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxHeaderDeserializerState as S;
            match state {
                S::UdxEdxfVersion(Some(deserializer)) => {
                    self.store_udx_edxf_version(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_version(
            &mut self,
            value: super::TypeBmEcatEtimVersion,
        ) -> Result<(), Error> {
            if self.udx_edxf_version.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.VERSION",
                )))?;
            }
            self.udx_edxf_version = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TypeBmEcatEtimVersion>,
            fallback: &mut Option<UdxHeaderDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_version.is_some() {
                    fallback.get_or_insert(UdxHeaderDeserializerState::UdxEdxfVersion(None));
                    *self.state = UdxHeaderDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = UdxHeaderDeserializerState::UdxEdxfVersion(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_version(data)?;
                    *self.state = UdxHeaderDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxHeaderDeserializerState::UdxEdxfVersion(
                                Some(deserializer),
                            ));
                            *self.state = UdxHeaderDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxHeaderDeserializerState::UdxEdxfVersion(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxHeader> for UdxHeaderDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::UdxHeader>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxHeader>
        where
            R: DeserializeReader,
        {
            use UdxHeaderDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfVersion(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = UdxHeaderDeserializerState::UdxEdxfVersion(None);
                        event
                    }
                    (S::UdxEdxfVersion(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.VERSION",
                        ) {
                            let output = < super :: TypeBmEcatEtimVersion as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_version(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxHeader, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, UdxHeaderDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::UdxHeader {
                udx_edxf_version: self
                    .udx_edxf_version
                    .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.VERSION".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TNewCatalogProductElementTypeDeserializer {
        mode: super::TNewCatalogProductMode,
        supplier_pid: Option<String>,
        product_details: Option<super::ProductDetailsElementType>,
        product_features: Vec<super::ProductFeaturesElementType>,
        product_order_details: Option<super::ProductOrderDetailsElementType>,
        product_price_details: Vec<super::ProductPriceDetailsElementType>,
        user_defined_extensions: Option<super::UdxProduct>,
        product_reference: Vec<super::ProductReferenceElementType>,
        product_logistic_details: Option<super::ProductLogisticDetailsElementType>,
        state: Box<TNewCatalogProductElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TNewCatalogProductElementTypeDeserializerState {
        Init__,
        SupplierPid(Option<<String as WithDeserializer>::Deserializer>),
        ProductDetails(
            Option<<super::ProductDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductFeatures(
            Option<<super::ProductFeaturesElementType as WithDeserializer>::Deserializer>,
        ),
        ProductOrderDetails(
            Option<<super::ProductOrderDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductPriceDetails(
            Option<<super::ProductPriceDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        UserDefinedExtensions(Option<<super::UdxProduct as WithDeserializer>::Deserializer>),
        ProductReference(
            Option<<super::ProductReferenceElementType as WithDeserializer>::Deserializer>,
        ),
        ProductLogisticDetails(
            Option<<super::ProductLogisticDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TNewCatalogProductElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut mode: Option<super::TNewCatalogProductMode> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"mode")
                ) {
                    reader.read_attrib(&mut mode, b"mode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                mode: mode.unwrap_or_else(super::TNewCatalogProductElementType::default_mode),
                supplier_pid: None,
                product_details: None,
                product_features: Vec::new(),
                product_order_details: None,
                product_price_details: Vec::new(),
                user_defined_extensions: None,
                product_reference: Vec::new(),
                product_logistic_details: None,
                state: Box::new(TNewCatalogProductElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TNewCatalogProductElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TNewCatalogProductElementTypeDeserializerState as S;
            match state {
                S::SupplierPid(Some(deserializer)) => {
                    self.store_supplier_pid(deserializer.finish(reader)?)?
                }
                S::ProductDetails(Some(deserializer)) => {
                    self.store_product_details(deserializer.finish(reader)?)?
                }
                S::ProductFeatures(Some(deserializer)) => {
                    self.store_product_features(deserializer.finish(reader)?)?
                }
                S::ProductOrderDetails(Some(deserializer)) => {
                    self.store_product_order_details(deserializer.finish(reader)?)?
                }
                S::ProductPriceDetails(Some(deserializer)) => {
                    self.store_product_price_details(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                S::ProductReference(Some(deserializer)) => {
                    self.store_product_reference(deserializer.finish(reader)?)?
                }
                S::ProductLogisticDetails(Some(deserializer)) => {
                    self.store_product_logistic_details(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_pid(&mut self, value: String) -> Result<(), Error> {
            if self.supplier_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_PID",
                )))?;
            }
            self.supplier_pid = Some(value);
            Ok(())
        }
        fn store_product_details(
            &mut self,
            value: super::ProductDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_DETAILS",
                )))?;
            }
            self.product_details = Some(value);
            Ok(())
        }
        fn store_product_features(
            &mut self,
            value: super::ProductFeaturesElementType,
        ) -> Result<(), Error> {
            self.product_features.push(value);
            Ok(())
        }
        fn store_product_order_details(
            &mut self,
            value: super::ProductOrderDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_order_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_ORDER_DETAILS",
                )))?;
            }
            self.product_order_details = Some(value);
            Ok(())
        }
        fn store_product_price_details(
            &mut self,
            value: super::ProductPriceDetailsElementType,
        ) -> Result<(), Error> {
            self.product_price_details.push(value);
            Ok(())
        }
        fn store_user_defined_extensions(&mut self, value: super::UdxProduct) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn store_product_reference(
            &mut self,
            value: super::ProductReferenceElementType,
        ) -> Result<(), Error> {
            self.product_reference.push(value);
            Ok(())
        }
        fn store_product_logistic_details(
            &mut self,
            value: super::ProductLogisticDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_logistic_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_LOGISTIC_DETAILS",
                )))?;
            }
            self.product_logistic_details = Some(value);
            Ok(())
        }
        fn handle_supplier_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_pid.is_some() {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::SupplierPid(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = TNewCatalogProductElementTypeDeserializerState::SupplierPid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_pid(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::SupplierPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::SupplierPid(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductDetailsElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_details.is_some() {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::ProductDetails(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_details(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductFeatures(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_features<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductFeaturesElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_features.len() < 1usize {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_features(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                ),
                            );
                            if self.product_features.len().saturating_add(1) < 1usize {
                                *self.state =
                                    TNewCatalogProductElementTypeDeserializerState::ProductFeatures(
                                        None,
                                    );
                            } else {
                                * self . state = TNewCatalogProductElementTypeDeserializerState :: ProductOrderDetails (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_order_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductOrderDetailsElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_order_details.is_some() {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_order_details(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductOrderDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_price_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceDetailsElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_price_details.len() < 1usize {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::UserDefinedExtensions(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_price_details(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(
                                    Some(deserializer),
                                ),
                            );
                            if self.product_price_details.len().saturating_add(1) < 1usize {
                                * self . state = TNewCatalogProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                            } else {
                                * self . state = TNewCatalogProductElementTypeDeserializerState :: UserDefinedExtensions (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductPriceDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxProduct>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.user_defined_extensions.is_some() {
                    fallback.get_or_insert(
                        TNewCatalogProductElementTypeDeserializerState::UserDefinedExtensions(None),
                    );
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductReference(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::UserDefinedExtensions(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TNewCatalogProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer))) ;
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductReference(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TNewCatalogProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductReferenceElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TNewCatalogProductElementTypeDeserializerState::ProductReference(None),
                );
                *self.state =
                    TNewCatalogProductElementTypeDeserializerState::ProductLogisticDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_reference(data)?;
                    *self.state =
                        TNewCatalogProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewCatalogProductElementTypeDeserializerState::ProductReference(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductReference(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewCatalogProductElementTypeDeserializerState::ProductReference(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_logistic_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductLogisticDetailsElementType>,
            fallback: &mut Option<TNewCatalogProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TNewCatalogProductElementTypeDeserializerState::ProductLogisticDetails(None),
                );
                *self.state = TNewCatalogProductElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_logistic_details(data)?;
                    *self.state = TNewCatalogProductElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TNewCatalogProductElementTypeDeserializerState :: ProductLogisticDetails (Some (deserializer))) ;
                            *self.state = TNewCatalogProductElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TNewCatalogProductElementTypeDeserializerState :: ProductLogisticDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TNewCatalogProductElementType>
        for TNewCatalogProductElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewCatalogProductElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewCatalogProductElementType>
        where
            R: DeserializeReader,
        {
            use TNewCatalogProductElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductFeatures(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_features(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductOrderDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_order_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductPriceDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_price_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductReference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductLogisticDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_logistic_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TNewCatalogProductElementTypeDeserializerState::SupplierPid(None);
                        event
                    }
                    (S::SupplierPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_supplier_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductDetails(None);
                            event
                        }
                    }
                    (S::ProductDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_DETAILS",
                        ) {
                            let output = < super :: ProductDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_details(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductFeatures(None);
                            event
                        }
                    }
                    (S::ProductFeatures(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_FEATURES",
                        ) {
                            let output = < super :: ProductFeaturesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_features(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductOrderDetails(None);
                            event
                        }
                    }
                    (S::ProductOrderDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_ORDER_DETAILS",
                        ) {
                            let output = < super :: ProductOrderDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_order_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductPriceDetails(None);
                            event
                        }
                    }
                    (S::ProductPriceDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_PRICE_DETAILS",
                        ) {
                            let output = < super :: ProductPriceDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_price_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxProduct as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductReference(None);
                            event
                        }
                    }
                    (S::ProductReference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_REFERENCE",
                        ) {
                            let output = < super :: ProductReferenceElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_reference(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductLogisticDetails(None);
                            event
                        }
                    }
                    (
                        S::ProductLogisticDetails(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_LOGISTIC_DETAILS",
                        ) {
                            let output = < super :: ProductLogisticDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_logistic_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TNewCatalogProductElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TNewCatalogProductElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TNewCatalogProductElementType {
                mode: self.mode,
                supplier_pid: self
                    .supplier_pid
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_PID".into()))?,
                product_details: self
                    .product_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_DETAILS".into()))?,
                product_features: self.product_features,
                product_order_details: self
                    .product_order_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_ORDER_DETAILS".into()))?,
                product_price_details: self.product_price_details,
                user_defined_extensions: self
                    .user_defined_extensions
                    .ok_or_else(|| ErrorKind::MissingElement("USER_DEFINED_EXTENSIONS".into()))?,
                product_reference: self.product_reference,
                product_logistic_details: self.product_logistic_details,
            })
        }
    }
    #[derive(Debug)]
    pub struct TUpdateProductsProductElementTypeDeserializer {
        mode: super::TUpdateProductsProductMode,
        supplier_pid: Option<String>,
        product_details: Option<super::ProductDetailsElementType>,
        product_features: Vec<super::ProductFeaturesElementType>,
        product_order_details: Option<super::ProductOrderDetailsElementType>,
        product_price_details: Vec<super::ProductPriceDetailsElementType>,
        user_defined_extensions: Option<super::UdxProduct>,
        product_reference: Vec<super::ProductReferenceElementType>,
        product_logistic_details: Option<super::ProductLogisticDetailsElementType>,
        state: Box<TUpdateProductsProductElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TUpdateProductsProductElementTypeDeserializerState {
        Init__,
        SupplierPid(Option<<String as WithDeserializer>::Deserializer>),
        ProductDetails(
            Option<<super::ProductDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductFeatures(
            Option<<super::ProductFeaturesElementType as WithDeserializer>::Deserializer>,
        ),
        ProductOrderDetails(
            Option<<super::ProductOrderDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductPriceDetails(
            Option<<super::ProductPriceDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        UserDefinedExtensions(Option<<super::UdxProduct as WithDeserializer>::Deserializer>),
        ProductReference(
            Option<<super::ProductReferenceElementType as WithDeserializer>::Deserializer>,
        ),
        ProductLogisticDetails(
            Option<<super::ProductLogisticDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TUpdateProductsProductElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut mode: Option<super::TUpdateProductsProductMode> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"mode")
                ) {
                    reader.read_attrib(&mut mode, b"mode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                mode: mode
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("mode".into())))?,
                supplier_pid: None,
                product_details: None,
                product_features: Vec::new(),
                product_order_details: None,
                product_price_details: Vec::new(),
                user_defined_extensions: None,
                product_reference: Vec::new(),
                product_logistic_details: None,
                state: Box::new(TUpdateProductsProductElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TUpdateProductsProductElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TUpdateProductsProductElementTypeDeserializerState as S;
            match state {
                S::SupplierPid(Some(deserializer)) => {
                    self.store_supplier_pid(deserializer.finish(reader)?)?
                }
                S::ProductDetails(Some(deserializer)) => {
                    self.store_product_details(deserializer.finish(reader)?)?
                }
                S::ProductFeatures(Some(deserializer)) => {
                    self.store_product_features(deserializer.finish(reader)?)?
                }
                S::ProductOrderDetails(Some(deserializer)) => {
                    self.store_product_order_details(deserializer.finish(reader)?)?
                }
                S::ProductPriceDetails(Some(deserializer)) => {
                    self.store_product_price_details(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                S::ProductReference(Some(deserializer)) => {
                    self.store_product_reference(deserializer.finish(reader)?)?
                }
                S::ProductLogisticDetails(Some(deserializer)) => {
                    self.store_product_logistic_details(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_pid(&mut self, value: String) -> Result<(), Error> {
            if self.supplier_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_PID",
                )))?;
            }
            self.supplier_pid = Some(value);
            Ok(())
        }
        fn store_product_details(
            &mut self,
            value: super::ProductDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_DETAILS",
                )))?;
            }
            self.product_details = Some(value);
            Ok(())
        }
        fn store_product_features(
            &mut self,
            value: super::ProductFeaturesElementType,
        ) -> Result<(), Error> {
            self.product_features.push(value);
            Ok(())
        }
        fn store_product_order_details(
            &mut self,
            value: super::ProductOrderDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_order_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_ORDER_DETAILS",
                )))?;
            }
            self.product_order_details = Some(value);
            Ok(())
        }
        fn store_product_price_details(
            &mut self,
            value: super::ProductPriceDetailsElementType,
        ) -> Result<(), Error> {
            self.product_price_details.push(value);
            Ok(())
        }
        fn store_user_defined_extensions(&mut self, value: super::UdxProduct) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn store_product_reference(
            &mut self,
            value: super::ProductReferenceElementType,
        ) -> Result<(), Error> {
            self.product_reference.push(value);
            Ok(())
        }
        fn store_product_logistic_details(
            &mut self,
            value: super::ProductLogisticDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_logistic_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_LOGISTIC_DETAILS",
                )))?;
            }
            self.product_logistic_details = Some(value);
            Ok(())
        }
        fn handle_supplier_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_pid.is_some() {
                    fallback.get_or_insert(
                        TUpdateProductsProductElementTypeDeserializerState::SupplierPid(None),
                    );
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::SupplierPid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_pid(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductDetailsElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_details.is_some() {
                    fallback.get_or_insert(
                        TUpdateProductsProductElementTypeDeserializerState::ProductDetails(None),
                    );
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_details(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_features<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductFeaturesElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(None),
                );
                *self.state =
                    TUpdateProductsProductElementTypeDeserializerState::ProductOrderDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_features(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_order_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductOrderDetailsElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_order_details.is_some() {
                    fallback.get_or_insert(
                        TUpdateProductsProductElementTypeDeserializerState::ProductOrderDetails(
                            None,
                        ),
                    );
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductOrderDetails(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_order_details(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: ProductOrderDetails (Some (deserializer))) ;
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductOrderDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_price_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceDetailsElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_price_details.len() < 1usize {
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        ),
                    );
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::UserDefinedExtensions(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_price_details(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductPriceDetails(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: ProductPriceDetails (Some (deserializer))) ;
                            if self.product_price_details.len().saturating_add(1) < 1usize {
                                * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                            } else {
                                * self . state = TUpdateProductsProductElementTypeDeserializerState :: UserDefinedExtensions (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductPriceDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxProduct>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::UserDefinedExtensions(None),
                );
                *self.state =
                    TUpdateProductsProductElementTypeDeserializerState::ProductReference(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer))) ;
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductReference (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductReferenceElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::ProductReference(None),
                );
                *self.state =
                    TUpdateProductsProductElementTypeDeserializerState::ProductLogisticDetails(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_reference(data)?;
                    *self.state =
                        TUpdateProductsProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: ProductReference (Some (deserializer))) ;
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductReference (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductReference (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_logistic_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductLogisticDetailsElementType>,
            fallback: &mut Option<TUpdateProductsProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdateProductsProductElementTypeDeserializerState::ProductLogisticDetails(
                        None,
                    ),
                );
                *self.state = TUpdateProductsProductElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_logistic_details(data)?;
                    *self.state = TUpdateProductsProductElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdateProductsProductElementTypeDeserializerState :: ProductLogisticDetails (Some (deserializer))) ;
                            *self.state =
                                TUpdateProductsProductElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdateProductsProductElementTypeDeserializerState :: ProductLogisticDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TUpdateProductsProductElementType>
        for TUpdateProductsProductElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdateProductsProductElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdateProductsProductElementType>
        where
            R: DeserializeReader,
        {
            use TUpdateProductsProductElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductFeatures(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_features(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductOrderDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_order_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductPriceDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_price_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductReference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductLogisticDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_logistic_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TUpdateProductsProductElementTypeDeserializerState::SupplierPid(None);
                        event
                    }
                    (S::SupplierPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_supplier_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductDetails(None);
                            event
                        }
                    }
                    (S::ProductDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_DETAILS",
                        ) {
                            let output = < super :: ProductDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_details(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductFeatures(None);
                            event
                        }
                    }
                    (S::ProductFeatures(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_FEATURES",
                        ) {
                            let output = < super :: ProductFeaturesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_features(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductOrderDetails(None);
                            event
                        }
                    }
                    (S::ProductOrderDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_ORDER_DETAILS",
                        ) {
                            let output = < super :: ProductOrderDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_order_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductPriceDetails(None);
                            event
                        }
                    }
                    (S::ProductPriceDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_PRICE_DETAILS",
                        ) {
                            let output = < super :: ProductPriceDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_price_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxProduct as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductReference(None);
                            event
                        }
                    }
                    (S::ProductReference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_REFERENCE",
                        ) {
                            let output = < super :: ProductReferenceElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_reference(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductLogisticDetails(None);
                            event
                        }
                    }
                    (
                        S::ProductLogisticDetails(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_LOGISTIC_DETAILS",
                        ) {
                            let output = < super :: ProductLogisticDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_logistic_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::TUpdateProductsProductElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TUpdateProductsProductElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TUpdateProductsProductElementType {
                mode: self.mode,
                supplier_pid: self
                    .supplier_pid
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_PID".into()))?,
                product_details: self
                    .product_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_DETAILS".into()))?,
                product_features: self.product_features,
                product_order_details: self
                    .product_order_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_ORDER_DETAILS".into()))?,
                product_price_details: self.product_price_details,
                user_defined_extensions: self.user_defined_extensions,
                product_reference: self.product_reference,
                product_logistic_details: self.product_logistic_details,
            })
        }
    }
    #[derive(Debug)]
    pub struct TUpdatePricesProductElementTypeDeserializer {
        mode: super::TUpdatePricesProductMode,
        supplier_pid: Option<String>,
        product_price_details: Vec<super::ProductPriceDetailsElementType>,
        user_defined_extensions: Option<super::UdxProduct>,
        state: Box<TUpdatePricesProductElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TUpdatePricesProductElementTypeDeserializerState {
        Init__,
        SupplierPid(Option<<String as WithDeserializer>::Deserializer>),
        ProductPriceDetails(
            Option<<super::ProductPriceDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        UserDefinedExtensions(Option<<super::UdxProduct as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl TUpdatePricesProductElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut mode: Option<super::TUpdatePricesProductMode> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"mode")
                ) {
                    reader.read_attrib(&mut mode, b"mode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                mode: mode.unwrap_or_else(super::TUpdatePricesProductElementType::default_mode),
                supplier_pid: None,
                product_price_details: Vec::new(),
                user_defined_extensions: None,
                state: Box::new(TUpdatePricesProductElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TUpdatePricesProductElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TUpdatePricesProductElementTypeDeserializerState as S;
            match state {
                S::SupplierPid(Some(deserializer)) => {
                    self.store_supplier_pid(deserializer.finish(reader)?)?
                }
                S::ProductPriceDetails(Some(deserializer)) => {
                    self.store_product_price_details(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_pid(&mut self, value: String) -> Result<(), Error> {
            if self.supplier_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_PID",
                )))?;
            }
            self.supplier_pid = Some(value);
            Ok(())
        }
        fn store_product_price_details(
            &mut self,
            value: super::ProductPriceDetailsElementType,
        ) -> Result<(), Error> {
            self.product_price_details.push(value);
            Ok(())
        }
        fn store_user_defined_extensions(&mut self, value: super::UdxProduct) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn handle_supplier_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<TUpdatePricesProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_pid.is_some() {
                    fallback.get_or_insert(
                        TUpdatePricesProductElementTypeDeserializerState::SupplierPid(None),
                    );
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::SupplierPid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_pid(data)?;
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TUpdatePricesProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = TUpdatePricesProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TUpdatePricesProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_price_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceDetailsElementType>,
            fallback: &mut Option<TUpdatePricesProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_price_details.len() < 1usize {
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None),
                    );
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::UserDefinedExtensions(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_price_details(data)?;
                    *self.state =
                        TUpdatePricesProductElementTypeDeserializerState::ProductPriceDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdatePricesProductElementTypeDeserializerState :: ProductPriceDetails (Some (deserializer))) ;
                            if self.product_price_details.len().saturating_add(1) < 1usize {
                                * self . state = TUpdatePricesProductElementTypeDeserializerState :: ProductPriceDetails (None) ;
                            } else {
                                * self . state = TUpdatePricesProductElementTypeDeserializerState :: UserDefinedExtensions (None) ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdatePricesProductElementTypeDeserializerState :: ProductPriceDetails (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxProduct>,
            fallback: &mut Option<TUpdatePricesProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TUpdatePricesProductElementTypeDeserializerState::UserDefinedExtensions(None),
                );
                *self.state = TUpdatePricesProductElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state = TUpdatePricesProductElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TUpdatePricesProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer))) ;
                            *self.state = TUpdatePricesProductElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TUpdatePricesProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TUpdatePricesProductElementType>
        for TUpdatePricesProductElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdatePricesProductElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TUpdatePricesProductElementType>
        where
            R: DeserializeReader,
        {
            use TUpdatePricesProductElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductPriceDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_price_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TUpdatePricesProductElementTypeDeserializerState::SupplierPid(None);
                        event
                    }
                    (S::SupplierPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_supplier_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductPriceDetails(None);
                            event
                        }
                    }
                    (S::ProductPriceDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_PRICE_DETAILS",
                        ) {
                            let output = < super :: ProductPriceDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_price_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxProduct as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TUpdatePricesProductElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TUpdatePricesProductElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TUpdatePricesProductElementType {
                mode: self.mode,
                supplier_pid: self
                    .supplier_pid
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_PID".into()))?,
                product_price_details: self.product_price_details,
                user_defined_extensions: self.user_defined_extensions,
            })
        }
    }
    #[derive(Debug)]
    pub struct TNewProductdataProductElementTypeDeserializer {
        mode: super::TNewProductdataProductMode,
        supplier_pid: Option<String>,
        product_details: Option<super::ProductDetailsElementType>,
        product_features: Vec<super::ProductFeaturesElementType>,
        user_defined_extensions: Option<super::UdxProductdata>,
        product_reference: Vec<super::ProductReferenceElementType>,
        state: Box<TNewProductdataProductElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum TNewProductdataProductElementTypeDeserializerState {
        Init__,
        SupplierPid(Option<<String as WithDeserializer>::Deserializer>),
        ProductDetails(
            Option<<super::ProductDetailsElementType as WithDeserializer>::Deserializer>,
        ),
        ProductFeatures(
            Option<<super::ProductFeaturesElementType as WithDeserializer>::Deserializer>,
        ),
        UserDefinedExtensions(Option<<super::UdxProductdata as WithDeserializer>::Deserializer>),
        ProductReference(
            Option<<super::ProductReferenceElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl TNewProductdataProductElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut mode: Option<super::TNewProductdataProductMode> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"mode")
                ) {
                    reader.read_attrib(&mut mode, b"mode", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                mode: mode.unwrap_or_else(super::TNewProductdataProductElementType::default_mode),
                supplier_pid: None,
                product_details: None,
                product_features: Vec::new(),
                user_defined_extensions: None,
                product_reference: Vec::new(),
                state: Box::new(TNewProductdataProductElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TNewProductdataProductElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use TNewProductdataProductElementTypeDeserializerState as S;
            match state {
                S::SupplierPid(Some(deserializer)) => {
                    self.store_supplier_pid(deserializer.finish(reader)?)?
                }
                S::ProductDetails(Some(deserializer)) => {
                    self.store_product_details(deserializer.finish(reader)?)?
                }
                S::ProductFeatures(Some(deserializer)) => {
                    self.store_product_features(deserializer.finish(reader)?)?
                }
                S::UserDefinedExtensions(Some(deserializer)) => {
                    self.store_user_defined_extensions(deserializer.finish(reader)?)?
                }
                S::ProductReference(Some(deserializer)) => {
                    self.store_product_reference(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_supplier_pid(&mut self, value: String) -> Result<(), Error> {
            if self.supplier_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_PID",
                )))?;
            }
            self.supplier_pid = Some(value);
            Ok(())
        }
        fn store_product_details(
            &mut self,
            value: super::ProductDetailsElementType,
        ) -> Result<(), Error> {
            if self.product_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_DETAILS",
                )))?;
            }
            self.product_details = Some(value);
            Ok(())
        }
        fn store_product_features(
            &mut self,
            value: super::ProductFeaturesElementType,
        ) -> Result<(), Error> {
            self.product_features.push(value);
            Ok(())
        }
        fn store_user_defined_extensions(
            &mut self,
            value: super::UdxProductdata,
        ) -> Result<(), Error> {
            if self.user_defined_extensions.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"USER_DEFINED_EXTENSIONS",
                )))?;
            }
            self.user_defined_extensions = Some(value);
            Ok(())
        }
        fn store_product_reference(
            &mut self,
            value: super::ProductReferenceElementType,
        ) -> Result<(), Error> {
            self.product_reference.push(value);
            Ok(())
        }
        fn handle_supplier_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<TNewProductdataProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.supplier_pid.is_some() {
                    fallback.get_or_insert(
                        TNewProductdataProductElementTypeDeserializerState::SupplierPid(None),
                    );
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::SupplierPid(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_pid(data)?;
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::ProductDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewProductdataProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewProductdataProductElementTypeDeserializerState::ProductDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewProductdataProductElementTypeDeserializerState::SupplierPid(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductDetailsElementType>,
            fallback: &mut Option<TNewProductdataProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_details.is_some() {
                    fallback.get_or_insert(
                        TNewProductdataProductElementTypeDeserializerState::ProductDetails(None),
                    );
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::ProductFeatures(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::ProductDetails(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_details(data)?;
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewProductdataProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewProductdataProductElementTypeDeserializerState::ProductFeatures(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewProductdataProductElementTypeDeserializerState::ProductDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_features<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductFeaturesElementType>,
            fallback: &mut Option<TNewProductdataProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TNewProductdataProductElementTypeDeserializerState::ProductFeatures(None),
                );
                *self.state =
                    TNewProductdataProductElementTypeDeserializerState::UserDefinedExtensions(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_features(data)?;
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::ProductFeatures(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                TNewProductdataProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                TNewProductdataProductElementTypeDeserializerState::ProductFeatures(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                TNewProductdataProductElementTypeDeserializerState::ProductFeatures(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_user_defined_extensions<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxProductdata>,
            fallback: &mut Option<TNewProductdataProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TNewProductdataProductElementTypeDeserializerState::UserDefinedExtensions(None),
                );
                *self.state =
                    TNewProductdataProductElementTypeDeserializerState::ProductReference(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_user_defined_extensions(data)?;
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TNewProductdataProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer))) ;
                            * self . state = TNewProductdataProductElementTypeDeserializerState :: ProductReference (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TNewProductdataProductElementTypeDeserializerState :: UserDefinedExtensions (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_reference<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductReferenceElementType>,
            fallback: &mut Option<TNewProductdataProductElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    TNewProductdataProductElementTypeDeserializerState::ProductReference(None),
                );
                *self.state = TNewProductdataProductElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_reference(data)?;
                    *self.state =
                        TNewProductdataProductElementTypeDeserializerState::ProductReference(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (TNewProductdataProductElementTypeDeserializerState :: ProductReference (Some (deserializer))) ;
                            * self . state = TNewProductdataProductElementTypeDeserializerState :: ProductReference (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = TNewProductdataProductElementTypeDeserializerState :: ProductReference (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::TNewProductdataProductElementType>
        for TNewProductdataProductElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewProductdataProductElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TNewProductdataProductElementType>
        where
            R: DeserializeReader,
        {
            use TNewProductdataProductElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::SupplierPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductFeatures(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_features(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UserDefinedExtensions(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_user_defined_extensions(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductReference(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_reference(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            TNewProductdataProductElementTypeDeserializerState::SupplierPid(None);
                        event
                    }
                    (S::SupplierPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_supplier_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductDetails(None);
                            event
                        }
                    }
                    (S::ProductDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_DETAILS",
                        ) {
                            let output = < super :: ProductDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_details(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductFeatures(None);
                            event
                        }
                    }
                    (S::ProductFeatures(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_FEATURES",
                        ) {
                            let output = < super :: ProductFeaturesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_features(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UserDefinedExtensions(None);
                            event
                        }
                    }
                    (
                        S::UserDefinedExtensions(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"USER_DEFINED_EXTENSIONS",
                        ) {
                            let output =
                                <super::UdxProductdata as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_user_defined_extensions(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductReference(None);
                            event
                        }
                    }
                    (S::ProductReference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_REFERENCE",
                        ) {
                            let output = < super :: ProductReferenceElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_reference(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::TNewProductdataProductElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                TNewProductdataProductElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::TNewProductdataProductElementType {
                mode: self.mode,
                supplier_pid: self
                    .supplier_pid
                    .ok_or_else(|| ErrorKind::MissingElement("SUPPLIER_PID".into()))?,
                product_details: self
                    .product_details
                    .ok_or_else(|| ErrorKind::MissingElement("PRODUCT_DETAILS".into()))?,
                product_features: self.product_features,
                user_defined_extensions: self.user_defined_extensions,
                product_reference: self.product_reference,
            })
        }
    }
    #[derive(Debug)]
    pub struct LanguageElementTypeDeserializer {
        default: Option<String>,
        content: Option<super::DtLang>,
        state: Box<LanguageElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum LanguageElementTypeDeserializerState {
        Init__,
        Content__(<super::DtLang as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl LanguageElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut default: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"default")
                ) {
                    reader.read_attrib(&mut default, b"default", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                default: default,
                content: None,
                state: Box::new(LanguageElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: LanguageElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let LanguageElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: super::DtLang) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtLang>,
        ) -> DeserializerResult<'de, super::LanguageElementType>
        where
            R: DeserializeReader,
        {
            use LanguageElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::LanguageElementType> for LanguageElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LanguageElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::LanguageElementType>
        where
            R: DeserializeReader,
        {
            use LanguageElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::LanguageElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                LanguageElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::LanguageElementType {
                default: self.default,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct DtMlstringDeserializer {
        lang: Option<super::DtLang>,
        content: Option<String>,
        state: Box<DtMlstringDeserializerState>,
    }
    #[derive(Debug)]
    enum DtMlstringDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl DtMlstringDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut lang: Option<super::DtLang> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"lang")
                ) {
                    reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                lang: lang,
                content: None,
                state: Box::new(DtMlstringDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: DtMlstringDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let DtMlstringDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::DtMlstring>
        where
            R: DeserializeReader,
        {
            use DtMlstringDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::DtMlstring> for DtMlstringDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::DtMlstring>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::DtMlstring>
        where
            R: DeserializeReader,
        {
            use DtMlstringDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::DtMlstring, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, DtMlstringDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::DtMlstring {
                lang: self.lang,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct CatalogDatetimeElementTypeDeserializer {
        type_: super::CatalogDatetimeType,
        date: Option<String>,
        state: Box<CatalogDatetimeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CatalogDatetimeElementTypeDeserializerState {
        Init__,
        Date(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CatalogDatetimeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::CatalogDatetimeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                date: None,
                state: Box::new(CatalogDatetimeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CatalogDatetimeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CatalogDatetimeElementTypeDeserializerState as S;
            match state {
                S::Date(Some(deserializer)) => self.store_date(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_date(&mut self, value: String) -> Result<(), Error> {
            if self.date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"DATE")))?;
            }
            self.date = Some(value);
            Ok(())
        }
        fn handle_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CatalogDatetimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.date.is_some() {
                    fallback.get_or_insert(CatalogDatetimeElementTypeDeserializerState::Date(None));
                    *self.state = CatalogDatetimeElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = CatalogDatetimeElementTypeDeserializerState::Date(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_date(data)?;
                    *self.state = CatalogDatetimeElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CatalogDatetimeElementTypeDeserializerState::Date(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = CatalogDatetimeElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = CatalogDatetimeElementTypeDeserializerState::Date(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CatalogDatetimeElementType>
        for CatalogDatetimeElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CatalogDatetimeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CatalogDatetimeElementType>
        where
            R: DeserializeReader,
        {
            use CatalogDatetimeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Date(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = CatalogDatetimeElementTypeDeserializerState::Date(None);
                        event
                    }
                    (S::Date(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"DATE") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_date(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CatalogDatetimeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CatalogDatetimeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CatalogDatetimeElementType {
                type_: self.type_,
                date: self
                    .date
                    .ok_or_else(|| ErrorKind::MissingElement("DATE".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct TypePartyIdDeserializer {
        type_: String,
        content: Option<String>,
        state: Box<TypePartyIdDeserializerState>,
    }
    #[derive(Debug)]
    enum TypePartyIdDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl TypePartyIdDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                content: None,
                state: Box::new(TypePartyIdDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: TypePartyIdDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let TypePartyIdDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::TypePartyId>
        where
            R: DeserializeReader,
        {
            use TypePartyIdDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::TypePartyId> for TypePartyIdDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TypePartyId>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::TypePartyId>
        where
            R: DeserializeReader,
        {
            use TypePartyIdDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::TypePartyId, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, TypePartyIdDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::TypePartyId {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct SupplierAddressElementTypeDeserializer {
        type_: super::SupplierAddressType,
        contact: Vec<super::DtMlstring>,
        street: Vec<super::DtMlstring>,
        zip: Vec<super::DtMlstring>,
        city: Vec<super::DtMlstring>,
        country: Vec<super::DtMlstring>,
        vat_id: Option<String>,
        email: Option<String>,
        url: Option<String>,
        state: Box<SupplierAddressElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SupplierAddressElementTypeDeserializerState {
        Init__,
        Contact(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Street(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Zip(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        City(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Country(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        VatId(Option<<String as WithDeserializer>::Deserializer>),
        Email(Option<<String as WithDeserializer>::Deserializer>),
        Url(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl SupplierAddressElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::SupplierAddressType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                contact: Vec::new(),
                street: Vec::new(),
                zip: Vec::new(),
                city: Vec::new(),
                country: Vec::new(),
                vat_id: None,
                email: None,
                url: None,
                state: Box::new(SupplierAddressElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SupplierAddressElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use SupplierAddressElementTypeDeserializerState as S;
            match state {
                S::Contact(Some(deserializer)) => {
                    self.store_contact(deserializer.finish(reader)?)?
                }
                S::Street(Some(deserializer)) => self.store_street(deserializer.finish(reader)?)?,
                S::Zip(Some(deserializer)) => self.store_zip(deserializer.finish(reader)?)?,
                S::City(Some(deserializer)) => self.store_city(deserializer.finish(reader)?)?,
                S::Country(Some(deserializer)) => {
                    self.store_country(deserializer.finish(reader)?)?
                }
                S::VatId(Some(deserializer)) => self.store_vat_id(deserializer.finish(reader)?)?,
                S::Email(Some(deserializer)) => self.store_email(deserializer.finish(reader)?)?,
                S::Url(Some(deserializer)) => self.store_url(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_contact(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.contact.push(value);
            Ok(())
        }
        fn store_street(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.street.push(value);
            Ok(())
        }
        fn store_zip(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.zip.push(value);
            Ok(())
        }
        fn store_city(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.city.push(value);
            Ok(())
        }
        fn store_country(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.country.push(value);
            Ok(())
        }
        fn store_vat_id(&mut self, value: String) -> Result<(), Error> {
            if self.vat_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"VAT_ID",
                )))?;
            }
            self.vat_id = Some(value);
            Ok(())
        }
        fn store_email(&mut self, value: String) -> Result<(), Error> {
            if self.email.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"EMAIL",
                )))?;
            }
            self.email = Some(value);
            Ok(())
        }
        fn store_url(&mut self, value: String) -> Result<(), Error> {
            if self.url.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"URL")))?;
            }
            self.url = Some(value);
            Ok(())
        }
        fn handle_contact<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Contact(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Street(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_contact(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Contact(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Contact(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                SupplierAddressElementTypeDeserializerState::Contact(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Contact(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_street<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Street(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Zip(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_street(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Street(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Street(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Street(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Street(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_zip<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Zip(None));
                *self.state = SupplierAddressElementTypeDeserializerState::City(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_zip(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Zip(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Zip(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Zip(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Zip(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_city<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::City(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Country(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_city(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::City(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::City(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::City(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::City(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_country<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Country(None));
                *self.state = SupplierAddressElementTypeDeserializerState::VatId(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_country(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Country(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Country(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                SupplierAddressElementTypeDeserializerState::Country(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Country(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_vat_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::VatId(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Email(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_vat_id(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Email(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::VatId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Email(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::VatId(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_email<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.email.is_some() {
                    fallback
                        .get_or_insert(SupplierAddressElementTypeDeserializerState::Email(None));
                    *self.state = SupplierAddressElementTypeDeserializerState::Url(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = SupplierAddressElementTypeDeserializerState::Email(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_email(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Url(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Email(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Url(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Email(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_url<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<SupplierAddressElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(SupplierAddressElementTypeDeserializerState::Url(None));
                *self.state = SupplierAddressElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_url(data)?;
                    *self.state = SupplierAddressElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                SupplierAddressElementTypeDeserializerState::Url(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = SupplierAddressElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = SupplierAddressElementTypeDeserializerState::Url(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::SupplierAddressElementType>
        for SupplierAddressElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierAddressElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SupplierAddressElementType>
        where
            R: DeserializeReader,
        {
            use SupplierAddressElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Contact(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_contact(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Street(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_street(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Zip(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_zip(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::City(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_city(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Country(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_country(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::VatId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_vat_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Email(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_email(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Url(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_url(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = SupplierAddressElementTypeDeserializerState::Contact(None);
                        event
                    }
                    (S::Contact(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"CONTACT")
                        {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_contact(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Street(None);
                            event
                        }
                    }
                    (S::Street(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"STREET")
                        {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_street(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Zip(None);
                            event
                        }
                    }
                    (S::Zip(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"ZIP") {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_zip(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::City(None);
                            event
                        }
                    }
                    (S::City(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"CITY") {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_city(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Country(None);
                            event
                        }
                    }
                    (S::Country(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"COUNTRY")
                        {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_country(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::VatId(None);
                            event
                        }
                    }
                    (S::VatId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"VAT_ID")
                        {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_vat_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Email(None);
                            event
                        }
                    }
                    (S::Email(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"EMAIL") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_email(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Url(None);
                            event
                        }
                    }
                    (S::Url(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"URL") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_url(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SupplierAddressElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SupplierAddressElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SupplierAddressElementType {
                type_: self.type_,
                contact: self.contact,
                street: self.street,
                zip: self.zip,
                city: self.city,
                country: self.country,
                vat_id: self.vat_id,
                email: self
                    .email
                    .ok_or_else(|| ErrorKind::MissingElement("EMAIL".into()))?,
                url: self.url,
            })
        }
    }
    #[derive(Debug)]
    pub struct MimeInfoElementTypeDeserializer {
        mime: Vec<super::MimeElementType>,
        state: Box<MimeInfoElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum MimeInfoElementTypeDeserializerState {
        Init__,
        Mime(Option<<super::MimeElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl MimeInfoElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                mime: Vec::new(),
                state: Box::new(MimeInfoElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: MimeInfoElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use MimeInfoElementTypeDeserializerState as S;
            match state {
                S::Mime(Some(deserializer)) => self.store_mime(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_mime(&mut self, value: super::MimeElementType) -> Result<(), Error> {
            self.mime.push(value);
            Ok(())
        }
        fn handle_mime<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::MimeElementType>,
            fallback: &mut Option<MimeInfoElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.mime.len() < 1usize {
                    *self.state = MimeInfoElementTypeDeserializerState::Mime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(MimeInfoElementTypeDeserializerState::Mime(None));
                    *self.state = MimeInfoElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime(data)?;
                    *self.state = MimeInfoElementTypeDeserializerState::Mime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeInfoElementTypeDeserializerState::Mime(
                                Some(deserializer),
                            ));
                            if self.mime.len().saturating_add(1) < 1usize {
                                *self.state = MimeInfoElementTypeDeserializerState::Mime(None);
                            } else {
                                *self.state = MimeInfoElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeInfoElementTypeDeserializerState::Mime(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::MimeInfoElementType> for MimeInfoElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::MimeInfoElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::MimeInfoElementType>
        where
            R: DeserializeReader,
        {
            use MimeInfoElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Mime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = MimeInfoElementTypeDeserializerState::Mime(None);
                        event
                    }
                    (S::Mime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"MIME") {
                            let output =
                                <super::MimeElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::MimeInfoElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                MimeInfoElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::MimeInfoElementType { mime: self.mime })
        }
    }
    #[derive(Debug)]
    pub struct ProductDetailsElementTypeDeserializer {
        description_short: Vec<super::DtMlstring>,
        description_long: Vec<super::DtMlstring>,
        international_pid: Vec<super::InternationalPidElementType>,
        supplier_alt_pid: Option<String>,
        buyer_pid: Option<super::BuyerPidElementType>,
        manufacturer_pid: Option<String>,
        manufacturer_name: Option<String>,
        manufacturer_type_descr: Vec<super::DtMlstring>,
        delivery_time: Option<f64>,
        special_treatment_class: Vec<super::SpecialTreatmentClassElementType>,
        keyword: Vec<super::DtMlstring>,
        remarks: Vec<super::DtMlstring>,
        product_status: Vec<super::ProductStatusElementType>,
        product_type: Option<super::ProductTypeElementType>,
        state: Box<ProductDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductDetailsElementTypeDeserializerState {
        Init__,
        DescriptionShort(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        DescriptionLong(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        InternationalPid(
            Option<<super::InternationalPidElementType as WithDeserializer>::Deserializer>,
        ),
        SupplierAltPid(Option<<String as WithDeserializer>::Deserializer>),
        BuyerPid(Option<<super::BuyerPidElementType as WithDeserializer>::Deserializer>),
        ManufacturerPid(Option<<String as WithDeserializer>::Deserializer>),
        ManufacturerName(Option<<String as WithDeserializer>::Deserializer>),
        ManufacturerTypeDescr(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        DeliveryTime(Option<<f64 as WithDeserializer>::Deserializer>),
        SpecialTreatmentClass(
            Option<<super::SpecialTreatmentClassElementType as WithDeserializer>::Deserializer>,
        ),
        Keyword(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Remarks(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        ProductStatus(Option<<super::ProductStatusElementType as WithDeserializer>::Deserializer>),
        ProductType(Option<<super::ProductTypeElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                description_short: Vec::new(),
                description_long: Vec::new(),
                international_pid: Vec::new(),
                supplier_alt_pid: None,
                buyer_pid: None,
                manufacturer_pid: None,
                manufacturer_name: None,
                manufacturer_type_descr: Vec::new(),
                delivery_time: None,
                special_treatment_class: Vec::new(),
                keyword: Vec::new(),
                remarks: Vec::new(),
                product_status: Vec::new(),
                product_type: None,
                state: Box::new(ProductDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductDetailsElementTypeDeserializerState as S;
            match state {
                S::DescriptionShort(Some(deserializer)) => {
                    self.store_description_short(deserializer.finish(reader)?)?
                }
                S::DescriptionLong(Some(deserializer)) => {
                    self.store_description_long(deserializer.finish(reader)?)?
                }
                S::InternationalPid(Some(deserializer)) => {
                    self.store_international_pid(deserializer.finish(reader)?)?
                }
                S::SupplierAltPid(Some(deserializer)) => {
                    self.store_supplier_alt_pid(deserializer.finish(reader)?)?
                }
                S::BuyerPid(Some(deserializer)) => {
                    self.store_buyer_pid(deserializer.finish(reader)?)?
                }
                S::ManufacturerPid(Some(deserializer)) => {
                    self.store_manufacturer_pid(deserializer.finish(reader)?)?
                }
                S::ManufacturerName(Some(deserializer)) => {
                    self.store_manufacturer_name(deserializer.finish(reader)?)?
                }
                S::ManufacturerTypeDescr(Some(deserializer)) => {
                    self.store_manufacturer_type_descr(deserializer.finish(reader)?)?
                }
                S::DeliveryTime(Some(deserializer)) => {
                    self.store_delivery_time(deserializer.finish(reader)?)?
                }
                S::SpecialTreatmentClass(Some(deserializer)) => {
                    self.store_special_treatment_class(deserializer.finish(reader)?)?
                }
                S::Keyword(Some(deserializer)) => {
                    self.store_keyword(deserializer.finish(reader)?)?
                }
                S::Remarks(Some(deserializer)) => {
                    self.store_remarks(deserializer.finish(reader)?)?
                }
                S::ProductStatus(Some(deserializer)) => {
                    self.store_product_status(deserializer.finish(reader)?)?
                }
                S::ProductType(Some(deserializer)) => {
                    self.store_product_type(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_description_short(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.description_short.push(value);
            Ok(())
        }
        fn store_description_long(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.description_long.push(value);
            Ok(())
        }
        fn store_international_pid(
            &mut self,
            value: super::InternationalPidElementType,
        ) -> Result<(), Error> {
            self.international_pid.push(value);
            Ok(())
        }
        fn store_supplier_alt_pid(&mut self, value: String) -> Result<(), Error> {
            if self.supplier_alt_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"SUPPLIER_ALT_PID",
                )))?;
            }
            self.supplier_alt_pid = Some(value);
            Ok(())
        }
        fn store_buyer_pid(&mut self, value: super::BuyerPidElementType) -> Result<(), Error> {
            if self.buyer_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"BUYER_PID",
                )))?;
            }
            self.buyer_pid = Some(value);
            Ok(())
        }
        fn store_manufacturer_pid(&mut self, value: String) -> Result<(), Error> {
            if self.manufacturer_pid.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MANUFACTURER_PID",
                )))?;
            }
            self.manufacturer_pid = Some(value);
            Ok(())
        }
        fn store_manufacturer_name(&mut self, value: String) -> Result<(), Error> {
            if self.manufacturer_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"MANUFACTURER_NAME",
                )))?;
            }
            self.manufacturer_name = Some(value);
            Ok(())
        }
        fn store_manufacturer_type_descr(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.manufacturer_type_descr.push(value);
            Ok(())
        }
        fn store_delivery_time(&mut self, value: f64) -> Result<(), Error> {
            if self.delivery_time.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DELIVERY_TIME",
                )))?;
            }
            self.delivery_time = Some(value);
            Ok(())
        }
        fn store_special_treatment_class(
            &mut self,
            value: super::SpecialTreatmentClassElementType,
        ) -> Result<(), Error> {
            self.special_treatment_class.push(value);
            Ok(())
        }
        fn store_keyword(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.keyword.push(value);
            Ok(())
        }
        fn store_remarks(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.remarks.push(value);
            Ok(())
        }
        fn store_product_status(
            &mut self,
            value: super::ProductStatusElementType,
        ) -> Result<(), Error> {
            self.product_status.push(value);
            Ok(())
        }
        fn store_product_type(
            &mut self,
            value: super::ProductTypeElementType,
        ) -> Result<(), Error> {
            if self.product_type.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRODUCT_TYPE",
                )))?;
            }
            self.product_type = Some(value);
            Ok(())
        }
        fn handle_description_short<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.description_short.len() < 1usize {
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::DescriptionShort(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ProductDetailsElementTypeDeserializerState::DescriptionShort(None),
                    );
                    *self.state = ProductDetailsElementTypeDeserializerState::DescriptionLong(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description_short(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::DescriptionShort(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::DescriptionShort(Some(
                                    deserializer,
                                )),
                            );
                            if self.description_short.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ProductDetailsElementTypeDeserializerState::DescriptionShort(
                                        None,
                                    );
                            } else {
                                *self.state =
                                    ProductDetailsElementTypeDeserializerState::DescriptionLong(
                                        None,
                                    );
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::DescriptionShort(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_description_long<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::DescriptionLong(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::InternationalPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_description_long(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::DescriptionLong(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::DescriptionLong(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::DescriptionLong(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::DescriptionLong(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_international_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::InternationalPidElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::InternationalPid(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::SupplierAltPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_international_pid(data)?;
                    if self.international_pid.len() < 2usize {
                        *self.state =
                            ProductDetailsElementTypeDeserializerState::InternationalPid(None);
                    } else {
                        *self.state =
                            ProductDetailsElementTypeDeserializerState::SupplierAltPid(None);
                    }
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::InternationalPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::InternationalPid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::InternationalPid(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_supplier_alt_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::SupplierAltPid(
                    None,
                ));
                *self.state = ProductDetailsElementTypeDeserializerState::BuyerPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_supplier_alt_pid(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::BuyerPid(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::SupplierAltPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::BuyerPid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::SupplierAltPid(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_buyer_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::BuyerPidElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::BuyerPid(None));
                *self.state = ProductDetailsElementTypeDeserializerState::ManufacturerPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_buyer_pid(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::ManufacturerPid(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::BuyerPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerPid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::BuyerPid(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_manufacturer_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::ManufacturerPid(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::ManufacturerName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_manufacturer_pid(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::ManufacturerName(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ManufacturerPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerName(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerPid(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_manufacturer_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::ManufacturerName(None),
                );
                *self.state =
                    ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_manufacturer_name(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ManufacturerName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerName(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_manufacturer_type_descr<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::DeliveryTime(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_manufacturer_type_descr(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ManufacturerTypeDescr(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_delivery_time<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::DeliveryTime(
                    None,
                ));
                *self.state =
                    ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_delivery_time(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::DeliveryTime(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::DeliveryTime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_special_treatment_class<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::SpecialTreatmentClassElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(None),
                );
                *self.state = ProductDetailsElementTypeDeserializerState::Keyword(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_special_treatment_class(data)?;
                    *self.state =
                        ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::SpecialTreatmentClass(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_keyword<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::Keyword(None));
                *self.state = ProductDetailsElementTypeDeserializerState::Remarks(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_keyword(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::Keyword(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::Keyword(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductDetailsElementTypeDeserializerState::Keyword(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::Keyword(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_remarks<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::Remarks(None));
                *self.state = ProductDetailsElementTypeDeserializerState::ProductStatus(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_remarks(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::Remarks(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::Remarks(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductDetailsElementTypeDeserializerState::Remarks(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::Remarks(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_status<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductStatusElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::ProductStatus(
                    None,
                ));
                *self.state = ProductDetailsElementTypeDeserializerState::ProductType(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_status(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::ProductStatus(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ProductStatus(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductDetailsElementTypeDeserializerState::ProductStatus(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::ProductStatus(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_type<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductTypeElementType>,
            fallback: &mut Option<ProductDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductDetailsElementTypeDeserializerState::ProductType(
                    None,
                ));
                *self.state = ProductDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_type(data)?;
                    *self.state = ProductDetailsElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductDetailsElementTypeDeserializerState::ProductType(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductDetailsElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductDetailsElementTypeDeserializerState::ProductType(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductDetailsElementType>
        for ProductDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductDetailsElementType>
        where
            R: DeserializeReader,
        {
            use ProductDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::DescriptionShort(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description_short(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DescriptionLong(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_description_long(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::InternationalPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_international_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SupplierAltPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_supplier_alt_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::BuyerPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_buyer_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ManufacturerPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_manufacturer_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ManufacturerName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_manufacturer_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ManufacturerTypeDescr(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_manufacturer_type_descr(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DeliveryTime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_delivery_time(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::SpecialTreatmentClass(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_special_treatment_class(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Keyword(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_keyword(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Remarks(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_remarks(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductStatus(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_status(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductType(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_type(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductDetailsElementTypeDeserializerState::DescriptionShort(None);
                        event
                    }
                    (S::DescriptionShort(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DESCRIPTION_SHORT",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_description_short(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DescriptionLong(None);
                            event
                        }
                    }
                    (S::DescriptionLong(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DESCRIPTION_LONG",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_description_long(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::InternationalPid(None);
                            event
                        }
                    }
                    (S::InternationalPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"INTERNATIONAL_PID",
                        ) {
                            let output = < super :: InternationalPidElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_international_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SupplierAltPid(None);
                            event
                        }
                    }
                    (S::SupplierAltPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SUPPLIER_ALT_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_supplier_alt_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::BuyerPid(None);
                            event
                        }
                    }
                    (S::BuyerPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"BUYER_PID",
                        ) {
                            let output = < super :: BuyerPidElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_buyer_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ManufacturerPid(None);
                            event
                        }
                    }
                    (S::ManufacturerPid(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MANUFACTURER_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_manufacturer_pid(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ManufacturerName(None);
                            event
                        }
                    }
                    (S::ManufacturerName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MANUFACTURER_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_manufacturer_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ManufacturerTypeDescr(None);
                            event
                        }
                    }
                    (
                        S::ManufacturerTypeDescr(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MANUFACTURER_TYPE_DESCR",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_manufacturer_type_descr(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DeliveryTime(None);
                            event
                        }
                    }
                    (S::DeliveryTime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DELIVERY_TIME",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_delivery_time(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::SpecialTreatmentClass(None);
                            event
                        }
                    }
                    (
                        S::SpecialTreatmentClass(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"SPECIAL_TREATMENT_CLASS",
                        ) {
                            let output = < super :: SpecialTreatmentClassElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_special_treatment_class(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Keyword(None);
                            event
                        }
                    }
                    (S::Keyword(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"KEYWORD")
                        {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_keyword(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Remarks(None);
                            event
                        }
                    }
                    (S::Remarks(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"REMARKS")
                        {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_remarks(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductStatus(None);
                            event
                        }
                    }
                    (S::ProductStatus(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_STATUS",
                        ) {
                            let output = < super :: ProductStatusElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_status(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductType(None);
                            event
                        }
                    }
                    (S::ProductType(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_TYPE",
                        ) {
                            let output = < super :: ProductTypeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_type(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductDetailsElementType {
                description_short: self.description_short,
                description_long: self.description_long,
                international_pid: self.international_pid,
                supplier_alt_pid: self.supplier_alt_pid,
                buyer_pid: self.buyer_pid,
                manufacturer_pid: self.manufacturer_pid,
                manufacturer_name: self.manufacturer_name,
                manufacturer_type_descr: self.manufacturer_type_descr,
                delivery_time: self.delivery_time,
                special_treatment_class: self.special_treatment_class,
                keyword: self.keyword,
                remarks: self.remarks,
                product_status: self.product_status,
                product_type: self.product_type,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductFeaturesElementTypeDeserializer {
        reference_feature_system_name: Option<super::TypeClassificationSystemName>,
        reference_feature_group_id: Option<String>,
        feature: Vec<super::FeatureElementType>,
        state: Box<ProductFeaturesElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductFeaturesElementTypeDeserializerState {
        Init__,
        ReferenceFeatureSystemName(
            Option<<super::TypeClassificationSystemName as WithDeserializer>::Deserializer>,
        ),
        ReferenceFeatureGroupId(Option<<String as WithDeserializer>::Deserializer>),
        Feature(Option<<super::FeatureElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductFeaturesElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                reference_feature_system_name: None,
                reference_feature_group_id: None,
                feature: Vec::new(),
                state: Box::new(ProductFeaturesElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductFeaturesElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductFeaturesElementTypeDeserializerState as S;
            match state {
                S::ReferenceFeatureSystemName(Some(deserializer)) => {
                    self.store_reference_feature_system_name(deserializer.finish(reader)?)?
                }
                S::ReferenceFeatureGroupId(Some(deserializer)) => {
                    self.store_reference_feature_group_id(deserializer.finish(reader)?)?
                }
                S::Feature(Some(deserializer)) => {
                    self.store_feature(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_reference_feature_system_name(
            &mut self,
            value: super::TypeClassificationSystemName,
        ) -> Result<(), Error> {
            if self.reference_feature_system_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"REFERENCE_FEATURE_SYSTEM_NAME",
                )))?;
            }
            self.reference_feature_system_name = Some(value);
            Ok(())
        }
        fn store_reference_feature_group_id(&mut self, value: String) -> Result<(), Error> {
            if self.reference_feature_group_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"REFERENCE_FEATURE_GROUP_ID",
                )))?;
            }
            self.reference_feature_group_id = Some(value);
            Ok(())
        }
        fn store_feature(&mut self, value: super::FeatureElementType) -> Result<(), Error> {
            self.feature.push(value);
            Ok(())
        }
        fn handle_reference_feature_system_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::TypeClassificationSystemName>,
            fallback: &mut Option<ProductFeaturesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.reference_feature_system_name.is_some() {
                    fallback.get_or_insert(
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureSystemName(
                            None,
                        ),
                    );
                    *self.state =
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureGroupId(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureSystemName(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reference_feature_system_name(data)?;
                    *self.state =
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureGroupId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureSystemName (Some (deserializer))) ;
                            * self . state = ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureGroupId (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureSystemName (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_reference_feature_group_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductFeaturesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.reference_feature_group_id.is_some() {
                    fallback.get_or_insert(
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureGroupId(None),
                    );
                    *self.state = ProductFeaturesElementTypeDeserializerState::Feature(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ProductFeaturesElementTypeDeserializerState::ReferenceFeatureGroupId(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reference_feature_group_id(data)?;
                    *self.state = ProductFeaturesElementTypeDeserializerState::Feature(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureGroupId (Some (deserializer))) ;
                            *self.state =
                                ProductFeaturesElementTypeDeserializerState::Feature(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ProductFeaturesElementTypeDeserializerState :: ReferenceFeatureGroupId (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_feature<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::FeatureElementType>,
            fallback: &mut Option<ProductFeaturesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductFeaturesElementTypeDeserializerState::Feature(None));
                *self.state = ProductFeaturesElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_feature(data)?;
                    *self.state = ProductFeaturesElementTypeDeserializerState::Feature(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductFeaturesElementTypeDeserializerState::Feature(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductFeaturesElementTypeDeserializerState::Feature(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductFeaturesElementTypeDeserializerState::Feature(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductFeaturesElementType>
        for ProductFeaturesElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductFeaturesElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductFeaturesElementType>
        where
            R: DeserializeReader,
        {
            use ProductFeaturesElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ReferenceFeatureSystemName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reference_feature_system_name(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReferenceFeatureGroupId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reference_feature_group_id(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Feature(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_feature(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductFeaturesElementTypeDeserializerState::ReferenceFeatureSystemName(
                                None,
                            );
                        event
                    }
                    (
                        S::ReferenceFeatureSystemName(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"REFERENCE_FEATURE_SYSTEM_NAME",
                        ) {
                            let output = < super :: TypeClassificationSystemName as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_reference_feature_system_name(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReferenceFeatureGroupId(None);
                            event
                        }
                    }
                    (
                        S::ReferenceFeatureGroupId(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"REFERENCE_FEATURE_GROUP_ID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_reference_feature_group_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Feature(None);
                            event
                        }
                    }
                    (S::Feature(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"FEATURE")
                        {
                            let output = < super :: FeatureElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_feature(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductFeaturesElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductFeaturesElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductFeaturesElementType {
                reference_feature_system_name: self.reference_feature_system_name.ok_or_else(
                    || ErrorKind::MissingElement("REFERENCE_FEATURE_SYSTEM_NAME".into()),
                )?,
                reference_feature_group_id: self.reference_feature_group_id.ok_or_else(|| {
                    ErrorKind::MissingElement("REFERENCE_FEATURE_GROUP_ID".into())
                })?,
                feature: self.feature,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductOrderDetailsElementTypeDeserializer {
        order_unit: Option<super::DtUnit>,
        content_unit: Option<super::DtUnit>,
        no_cu_per_ou: Option<f64>,
        price_quantity: Option<f64>,
        quantity_min: Option<f32>,
        quantity_interval: Option<f32>,
        state: Box<ProductOrderDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductOrderDetailsElementTypeDeserializerState {
        Init__,
        OrderUnit(Option<<super::DtUnit as WithDeserializer>::Deserializer>),
        ContentUnit(Option<<super::DtUnit as WithDeserializer>::Deserializer>),
        NoCuPerOu(Option<<f64 as WithDeserializer>::Deserializer>),
        PriceQuantity(Option<<f64 as WithDeserializer>::Deserializer>),
        QuantityMin(Option<<f32 as WithDeserializer>::Deserializer>),
        QuantityInterval(Option<<f32 as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductOrderDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                order_unit: None,
                content_unit: None,
                no_cu_per_ou: None,
                price_quantity: None,
                quantity_min: None,
                quantity_interval: None,
                state: Box::new(ProductOrderDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductOrderDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductOrderDetailsElementTypeDeserializerState as S;
            match state {
                S::OrderUnit(Some(deserializer)) => {
                    self.store_order_unit(deserializer.finish(reader)?)?
                }
                S::ContentUnit(Some(deserializer)) => {
                    self.store_content_unit(deserializer.finish(reader)?)?
                }
                S::NoCuPerOu(Some(deserializer)) => {
                    self.store_no_cu_per_ou(deserializer.finish(reader)?)?
                }
                S::PriceQuantity(Some(deserializer)) => {
                    self.store_price_quantity(deserializer.finish(reader)?)?
                }
                S::QuantityMin(Some(deserializer)) => {
                    self.store_quantity_min(deserializer.finish(reader)?)?
                }
                S::QuantityInterval(Some(deserializer)) => {
                    self.store_quantity_interval(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_order_unit(&mut self, value: super::DtUnit) -> Result<(), Error> {
            if self.order_unit.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"ORDER_UNIT",
                )))?;
            }
            self.order_unit = Some(value);
            Ok(())
        }
        fn store_content_unit(&mut self, value: super::DtUnit) -> Result<(), Error> {
            if self.content_unit.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CONTENT_UNIT",
                )))?;
            }
            self.content_unit = Some(value);
            Ok(())
        }
        fn store_no_cu_per_ou(&mut self, value: f64) -> Result<(), Error> {
            if self.no_cu_per_ou.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"NO_CU_PER_OU",
                )))?;
            }
            self.no_cu_per_ou = Some(value);
            Ok(())
        }
        fn store_price_quantity(&mut self, value: f64) -> Result<(), Error> {
            if self.price_quantity.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_QUANTITY",
                )))?;
            }
            self.price_quantity = Some(value);
            Ok(())
        }
        fn store_quantity_min(&mut self, value: f32) -> Result<(), Error> {
            if self.quantity_min.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"QUANTITY_MIN",
                )))?;
            }
            self.quantity_min = Some(value);
            Ok(())
        }
        fn store_quantity_interval(&mut self, value: f32) -> Result<(), Error> {
            if self.quantity_interval.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"QUANTITY_INTERVAL",
                )))?;
            }
            self.quantity_interval = Some(value);
            Ok(())
        }
        fn handle_order_unit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtUnit>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.order_unit.is_some() {
                    fallback.get_or_insert(
                        ProductOrderDetailsElementTypeDeserializerState::OrderUnit(None),
                    );
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProductOrderDetailsElementTypeDeserializerState::OrderUnit(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_order_unit(data)?;
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::OrderUnit(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::OrderUnit(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_content_unit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtUnit>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.content_unit.is_some() {
                    fallback.get_or_insert(
                        ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None),
                    );
                    *self.state = ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::ContentUnit(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content_unit(data)?;
                    *self.state = ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::ContentUnit(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::ContentUnit(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_no_cu_per_ou<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(
                    None,
                ));
                *self.state = ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_no_cu_per_ou(data)?;
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::NoCuPerOu(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_price_quantity<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(None),
                );
                *self.state = ProductOrderDetailsElementTypeDeserializerState::QuantityMin(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_quantity(data)?;
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::QuantityMin(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::QuantityMin(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::PriceQuantity(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_quantity_min<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductOrderDetailsElementTypeDeserializerState::QuantityMin(None),
                );
                *self.state =
                    ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_quantity_min(data)?;
                    *self.state =
                        ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::QuantityMin(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::QuantityMin(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_quantity_interval<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<ProductOrderDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(None),
                );
                *self.state = ProductOrderDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_quantity_interval(data)?;
                    *self.state = ProductOrderDetailsElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = ProductOrderDetailsElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductOrderDetailsElementTypeDeserializerState::QuantityInterval(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductOrderDetailsElementType>
        for ProductOrderDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductOrderDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductOrderDetailsElementType>
        where
            R: DeserializeReader,
        {
            use ProductOrderDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::OrderUnit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_order_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ContentUnit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::NoCuPerOu(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_no_cu_per_ou(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PriceQuantity(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_quantity(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::QuantityMin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_quantity_min(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::QuantityInterval(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_quantity_interval(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductOrderDetailsElementTypeDeserializerState::OrderUnit(None);
                        event
                    }
                    (S::OrderUnit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"ORDER_UNIT",
                        ) {
                            let output = <super::DtUnit as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_order_unit(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ContentUnit(None);
                            event
                        }
                    }
                    (S::ContentUnit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CONTENT_UNIT",
                        ) {
                            let output = <super::DtUnit as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_content_unit(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::NoCuPerOu(None);
                            event
                        }
                    }
                    (S::NoCuPerOu(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"NO_CU_PER_OU",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_no_cu_per_ou(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PriceQuantity(None);
                            event
                        }
                    }
                    (S::PriceQuantity(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_QUANTITY",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_price_quantity(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::QuantityMin(None);
                            event
                        }
                    }
                    (S::QuantityMin(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"QUANTITY_MIN",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_quantity_min(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::QuantityInterval(None);
                            event
                        }
                    }
                    (S::QuantityInterval(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"QUANTITY_INTERVAL",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_quantity_interval(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductOrderDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductOrderDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductOrderDetailsElementType {
                order_unit: self
                    .order_unit
                    .ok_or_else(|| ErrorKind::MissingElement("ORDER_UNIT".into()))?,
                content_unit: self
                    .content_unit
                    .ok_or_else(|| ErrorKind::MissingElement("CONTENT_UNIT".into()))?,
                no_cu_per_ou: self.no_cu_per_ou,
                price_quantity: self.price_quantity,
                quantity_min: self.quantity_min,
                quantity_interval: self.quantity_interval,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceDetailsElementTypeDeserializer {
        datetime: Vec<super::ProductPriceDetailsDatetimeElementType>,
        daily_price: Option<String>,
        product_price: Vec<super::ProductPriceElementType>,
        price_base: Option<super::PriceBaseElementType>,
        state: Box<ProductPriceDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductPriceDetailsElementTypeDeserializerState {
        Init__,
        Datetime(
            Option<
                <super::ProductPriceDetailsDatetimeElementType as WithDeserializer>::Deserializer,
            >,
        ),
        DailyPrice(Option<<String as WithDeserializer>::Deserializer>),
        ProductPrice(Option<<super::ProductPriceElementType as WithDeserializer>::Deserializer>),
        PriceBase(Option<<super::PriceBaseElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductPriceDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                datetime: Vec::new(),
                daily_price: None,
                product_price: Vec::new(),
                price_base: None,
                state: Box::new(ProductPriceDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductPriceDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductPriceDetailsElementTypeDeserializerState as S;
            match state {
                S::Datetime(Some(deserializer)) => {
                    self.store_datetime(deserializer.finish(reader)?)?
                }
                S::DailyPrice(Some(deserializer)) => {
                    self.store_daily_price(deserializer.finish(reader)?)?
                }
                S::ProductPrice(Some(deserializer)) => {
                    self.store_product_price(deserializer.finish(reader)?)?
                }
                S::PriceBase(Some(deserializer)) => {
                    self.store_price_base(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_datetime(
            &mut self,
            value: super::ProductPriceDetailsDatetimeElementType,
        ) -> Result<(), Error> {
            self.datetime.push(value);
            Ok(())
        }
        fn store_daily_price(&mut self, value: String) -> Result<(), Error> {
            if self.daily_price.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"DAILY_PRICE",
                )))?;
            }
            self.daily_price = Some(value);
            Ok(())
        }
        fn store_product_price(
            &mut self,
            value: super::ProductPriceElementType,
        ) -> Result<(), Error> {
            self.product_price.push(value);
            Ok(())
        }
        fn store_price_base(&mut self, value: super::PriceBaseElementType) -> Result<(), Error> {
            if self.price_base.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_BASE",
                )))?;
            }
            self.price_base = Some(value);
            Ok(())
        }
        fn handle_datetime<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceDetailsDatetimeElementType>,
            fallback: &mut Option<ProductPriceDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.datetime.len() < 1usize {
                    *self.state = ProductPriceDetailsElementTypeDeserializerState::Datetime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ProductPriceDetailsElementTypeDeserializerState::Datetime(None),
                    );
                    *self.state = ProductPriceDetailsElementTypeDeserializerState::DailyPrice(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_datetime(data)?;
                    if self.datetime.len() < 2usize {
                        *self.state =
                            ProductPriceDetailsElementTypeDeserializerState::Datetime(None);
                    } else {
                        *self.state =
                            ProductPriceDetailsElementTypeDeserializerState::DailyPrice(None);
                    }
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsElementTypeDeserializerState::Datetime(Some(
                                    deserializer,
                                )),
                            );
                            if self.datetime.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ProductPriceDetailsElementTypeDeserializerState::Datetime(None);
                            } else {
                                *self.state =
                                    ProductPriceDetailsElementTypeDeserializerState::DailyPrice(
                                        None,
                                    );
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceDetailsElementTypeDeserializerState::Datetime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_daily_price<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductPriceDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductPriceDetailsElementTypeDeserializerState::DailyPrice(None),
                );
                *self.state = ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_daily_price(data)?;
                    *self.state =
                        ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsElementTypeDeserializerState::DailyPrice(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsElementTypeDeserializerState::DailyPrice(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_product_price<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::ProductPriceElementType>,
            fallback: &mut Option<ProductPriceDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.product_price.len() < 1usize {
                    *self.state =
                        ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None),
                    );
                    *self.state = ProductPriceDetailsElementTypeDeserializerState::PriceBase(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_product_price(data)?;
                    *self.state =
                        ProductPriceDetailsElementTypeDeserializerState::ProductPrice(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsElementTypeDeserializerState::ProductPrice(
                                    Some(deserializer),
                                ),
                            );
                            if self.product_price.len().saturating_add(1) < 1usize {
                                *self.state =
                                    ProductPriceDetailsElementTypeDeserializerState::ProductPrice(
                                        None,
                                    );
                            } else {
                                *self.state =
                                    ProductPriceDetailsElementTypeDeserializerState::PriceBase(
                                        None,
                                    );
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsElementTypeDeserializerState::ProductPrice(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_price_base<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::PriceBaseElementType>,
            fallback: &mut Option<ProductPriceDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceDetailsElementTypeDeserializerState::PriceBase(
                    None,
                ));
                *self.state = ProductPriceDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_base(data)?;
                    *self.state = ProductPriceDetailsElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsElementTypeDeserializerState::PriceBase(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductPriceDetailsElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsElementTypeDeserializerState::PriceBase(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductPriceDetailsElementType>
        for ProductPriceDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceDetailsElementType>
        where
            R: DeserializeReader,
        {
            use ProductPriceDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Datetime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_datetime(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::DailyPrice(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_daily_price(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ProductPrice(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_product_price(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PriceBase(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_base(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductPriceDetailsElementTypeDeserializerState::Datetime(None);
                        event
                    }
                    (S::Datetime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DATETIME",
                        ) {
                            let output = < super :: ProductPriceDetailsDatetimeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_datetime(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::DailyPrice(None);
                            event
                        }
                    }
                    (S::DailyPrice(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"DAILY_PRICE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_daily_price(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ProductPrice(None);
                            event
                        }
                    }
                    (S::ProductPrice(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRODUCT_PRICE",
                        ) {
                            let output = < super :: ProductPriceElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_product_price(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PriceBase(None);
                            event
                        }
                    }
                    (S::PriceBase(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_BASE",
                        ) {
                            let output = < super :: PriceBaseElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_price_base(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductPriceDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductPriceDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductPriceDetailsElementType {
                datetime: self.datetime,
                daily_price: self.daily_price,
                product_price: self.product_price,
                price_base: self.price_base,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxProductDeserializer {
        udx_edxf_mime_info: Option<super::UdxEdxfMimeInfoElementType>,
        udx_edxf_manufacturer_acronym: Option<String>,
        udx_edxf_description_very_short: Vec<super::DtMlstring>,
        udx_edxf_brand_name: Option<String>,
        udx_edxf_tender_text: Vec<super::DtMlstring>,
        udx_edxf_valid_from: Option<String>,
        udx_edxf_expiration_date: Option<String>,
        udx_edxf_discount_group: Option<super::UdxEdxfDiscountGroupElementType>,
        udx_edxf_bonus_group_supplier: Option<String>,
        udx_edxf_additional_factors: Option<super::UdxEdxfAdditionalFactorsElementType>,
        udx_edxf_product_to_stock: Option<String>,
        udx_edxf_product_series: Vec<super::DtMlstring>,
        udx_edxf_product_variation: Vec<super::DtMlstring>,
        udx_edxf_predecessor_pid: Vec<String>,
        udx_edxf_country_branch_numbers: Option<super::UdxEdxfCountryBranchNumbersElementType>,
        udx_edxf_country_branch_supplier_ids:
            Option<super::UdxEdxfCountryBranchSupplierIdsElementType>,
        udx_edxf_packing_units: Option<super::UdxEdxfPackingUnitsElementType>,
        udx_edxf_product_logistic_details: Option<super::UdxEdxfProductLogisticDetailsElementType>,
        udx_edxf_shelf_life_period: Option<i32>,
        udx_edxf_battery_contained: Option<String>,
        udx_edxf_rohs_indicator: Option<super::UdxEdxfRohsIndicatorElementType>,
        udx_edxf_ce_marking: Option<String>,
        udx_edxf_reach: Option<super::UdxEdxfReachElementType>,
        udx_edxf_special_treatment_class_details:
            Option<super::UdxEdxfSpecialTreatmentClassDetailsElementType>,
        udx_edxf_surcharge_list: Option<super::UdxEdxfSurchargeListElementType>,
        udx_edxf_warranty: Option<super::UdxEdxfWarrantyElementType>,
        udx_edxf_product_etim_dynamic: Option<super::UdxEdxfProductEtimDynamicElementType>,
        udx_edxf_product_features_mc: Option<super::UdxEdxfProductFeaturesMcElementType>,
        udx_edxf_product_characteristics: Option<super::UdxEdxfProductCharacteristicsElementType>,
        state: Box<UdxProductDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxProductDeserializerState {
        Init__ , UdxEdxfMimeInfo (Option << super :: UdxEdxfMimeInfoElementType as WithDeserializer > :: Deserializer >) , UdxEdxfManufacturerAcronym (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfDescriptionVeryShort (Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , UdxEdxfBrandName (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfTenderText (Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , UdxEdxfValidFrom (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfExpirationDate (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfDiscountGroup (Option << super :: UdxEdxfDiscountGroupElementType as WithDeserializer > :: Deserializer >) , UdxEdxfBonusGroupSupplier (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfAdditionalFactors (Option << super :: UdxEdxfAdditionalFactorsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductToStock (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfProductSeries (Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , UdxEdxfProductVariation (Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , UdxEdxfPredecessorPid (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfCountryBranchNumbers (Option << super :: UdxEdxfCountryBranchNumbersElementType as WithDeserializer > :: Deserializer >) , UdxEdxfCountryBranchSupplierIds (Option << super :: UdxEdxfCountryBranchSupplierIdsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfPackingUnits (Option << super :: UdxEdxfPackingUnitsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductLogisticDetails (Option << super :: UdxEdxfProductLogisticDetailsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfShelfLifePeriod (Option << i32 as WithDeserializer > :: Deserializer >) , UdxEdxfBatteryContained (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfRohsIndicator (Option << super :: UdxEdxfRohsIndicatorElementType as WithDeserializer > :: Deserializer >) , UdxEdxfCeMarking (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfReach (Option << super :: UdxEdxfReachElementType as WithDeserializer > :: Deserializer >) , UdxEdxfSpecialTreatmentClassDetails (Option << super :: UdxEdxfSpecialTreatmentClassDetailsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfSurchargeList (Option << super :: UdxEdxfSurchargeListElementType as WithDeserializer > :: Deserializer >) , UdxEdxfWarranty (Option << super :: UdxEdxfWarrantyElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductEtimDynamic (Option << super :: UdxEdxfProductEtimDynamicElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductFeaturesMc (Option << super :: UdxEdxfProductFeaturesMcElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductCharacteristics (Option << super :: UdxEdxfProductCharacteristicsElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl UdxProductDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_mime_info: None,
                udx_edxf_manufacturer_acronym: None,
                udx_edxf_description_very_short: Vec::new(),
                udx_edxf_brand_name: None,
                udx_edxf_tender_text: Vec::new(),
                udx_edxf_valid_from: None,
                udx_edxf_expiration_date: None,
                udx_edxf_discount_group: None,
                udx_edxf_bonus_group_supplier: None,
                udx_edxf_additional_factors: None,
                udx_edxf_product_to_stock: None,
                udx_edxf_product_series: Vec::new(),
                udx_edxf_product_variation: Vec::new(),
                udx_edxf_predecessor_pid: Vec::new(),
                udx_edxf_country_branch_numbers: None,
                udx_edxf_country_branch_supplier_ids: None,
                udx_edxf_packing_units: None,
                udx_edxf_product_logistic_details: None,
                udx_edxf_shelf_life_period: None,
                udx_edxf_battery_contained: None,
                udx_edxf_rohs_indicator: None,
                udx_edxf_ce_marking: None,
                udx_edxf_reach: None,
                udx_edxf_special_treatment_class_details: None,
                udx_edxf_surcharge_list: None,
                udx_edxf_warranty: None,
                udx_edxf_product_etim_dynamic: None,
                udx_edxf_product_features_mc: None,
                udx_edxf_product_characteristics: None,
                state: Box::new(UdxProductDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxProductDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxProductDeserializerState as S;
            match state {
                S::UdxEdxfMimeInfo(Some(deserializer)) => {
                    self.store_udx_edxf_mime_info(deserializer.finish(reader)?)?
                }
                S::UdxEdxfManufacturerAcronym(Some(deserializer)) => {
                    self.store_udx_edxf_manufacturer_acronym(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDescriptionVeryShort(Some(deserializer)) => {
                    self.store_udx_edxf_description_very_short(deserializer.finish(reader)?)?
                }
                S::UdxEdxfBrandName(Some(deserializer)) => {
                    self.store_udx_edxf_brand_name(deserializer.finish(reader)?)?
                }
                S::UdxEdxfTenderText(Some(deserializer)) => {
                    self.store_udx_edxf_tender_text(deserializer.finish(reader)?)?
                }
                S::UdxEdxfValidFrom(Some(deserializer)) => {
                    self.store_udx_edxf_valid_from(deserializer.finish(reader)?)?
                }
                S::UdxEdxfExpirationDate(Some(deserializer)) => {
                    self.store_udx_edxf_expiration_date(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDiscountGroup(Some(deserializer)) => {
                    self.store_udx_edxf_discount_group(deserializer.finish(reader)?)?
                }
                S::UdxEdxfBonusGroupSupplier(Some(deserializer)) => {
                    self.store_udx_edxf_bonus_group_supplier(deserializer.finish(reader)?)?
                }
                S::UdxEdxfAdditionalFactors(Some(deserializer)) => {
                    self.store_udx_edxf_additional_factors(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductToStock(Some(deserializer)) => {
                    self.store_udx_edxf_product_to_stock(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductSeries(Some(deserializer)) => {
                    self.store_udx_edxf_product_series(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductVariation(Some(deserializer)) => {
                    self.store_udx_edxf_product_variation(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPredecessorPid(Some(deserializer)) => {
                    self.store_udx_edxf_predecessor_pid(deserializer.finish(reader)?)?
                }
                S::UdxEdxfCountryBranchNumbers(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_numbers(deserializer.finish(reader)?)?
                }
                S::UdxEdxfCountryBranchSupplierIds(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_supplier_ids(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackingUnits(Some(deserializer)) => {
                    self.store_udx_edxf_packing_units(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductLogisticDetails(Some(deserializer)) => {
                    self.store_udx_edxf_product_logistic_details(deserializer.finish(reader)?)?
                }
                S::UdxEdxfShelfLifePeriod(Some(deserializer)) => {
                    self.store_udx_edxf_shelf_life_period(deserializer.finish(reader)?)?
                }
                S::UdxEdxfBatteryContained(Some(deserializer)) => {
                    self.store_udx_edxf_battery_contained(deserializer.finish(reader)?)?
                }
                S::UdxEdxfRohsIndicator(Some(deserializer)) => {
                    self.store_udx_edxf_rohs_indicator(deserializer.finish(reader)?)?
                }
                S::UdxEdxfCeMarking(Some(deserializer)) => {
                    self.store_udx_edxf_ce_marking(deserializer.finish(reader)?)?
                }
                S::UdxEdxfReach(Some(deserializer)) => {
                    self.store_udx_edxf_reach(deserializer.finish(reader)?)?
                }
                S::UdxEdxfSpecialTreatmentClassDetails(Some(deserializer)) => self
                    .store_udx_edxf_special_treatment_class_details(deserializer.finish(reader)?)?,
                S::UdxEdxfSurchargeList(Some(deserializer)) => {
                    self.store_udx_edxf_surcharge_list(deserializer.finish(reader)?)?
                }
                S::UdxEdxfWarranty(Some(deserializer)) => {
                    self.store_udx_edxf_warranty(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductEtimDynamic(Some(deserializer)) => {
                    self.store_udx_edxf_product_etim_dynamic(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductFeaturesMc(Some(deserializer)) => {
                    self.store_udx_edxf_product_features_mc(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductCharacteristics(Some(deserializer)) => {
                    self.store_udx_edxf_product_characteristics(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_mime_info(
            &mut self,
            value: super::UdxEdxfMimeInfoElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_mime_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MIME_INFO",
                )))?;
            }
            self.udx_edxf_mime_info = Some(value);
            Ok(())
        }
        fn store_udx_edxf_manufacturer_acronym(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_manufacturer_acronym.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MANUFACTURER_ACRONYM",
                )))?;
            }
            self.udx_edxf_manufacturer_acronym = Some(value);
            Ok(())
        }
        fn store_udx_edxf_description_very_short(
            &mut self,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            self.udx_edxf_description_very_short.push(value);
            Ok(())
        }
        fn store_udx_edxf_brand_name(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_brand_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.BRAND_NAME",
                )))?;
            }
            self.udx_edxf_brand_name = Some(value);
            Ok(())
        }
        fn store_udx_edxf_tender_text(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.udx_edxf_tender_text.push(value);
            Ok(())
        }
        fn store_udx_edxf_valid_from(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_valid_from.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.VALID_FROM",
                )))?;
            }
            self.udx_edxf_valid_from = Some(value);
            Ok(())
        }
        fn store_udx_edxf_expiration_date(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_expiration_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.EXPIRATION_DATE",
                )))?;
            }
            self.udx_edxf_expiration_date = Some(value);
            Ok(())
        }
        fn store_udx_edxf_discount_group(
            &mut self,
            value: super::UdxEdxfDiscountGroupElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_discount_group.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DISCOUNT_GROUP",
                )))?;
            }
            self.udx_edxf_discount_group = Some(value);
            Ok(())
        }
        fn store_udx_edxf_bonus_group_supplier(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_bonus_group_supplier.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.BONUS_GROUP_SUPPLIER",
                )))?;
            }
            self.udx_edxf_bonus_group_supplier = Some(value);
            Ok(())
        }
        fn store_udx_edxf_additional_factors(
            &mut self,
            value: super::UdxEdxfAdditionalFactorsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_additional_factors.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.ADDITIONAL_FACTORS",
                )))?;
            }
            self.udx_edxf_additional_factors = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_to_stock(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_product_to_stock.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_TO_STOCK",
                )))?;
            }
            self.udx_edxf_product_to_stock = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_series(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.udx_edxf_product_series.push(value);
            Ok(())
        }
        fn store_udx_edxf_product_variation(
            &mut self,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            self.udx_edxf_product_variation.push(value);
            Ok(())
        }
        fn store_udx_edxf_predecessor_pid(&mut self, value: String) -> Result<(), Error> {
            self.udx_edxf_predecessor_pid.push(value);
            Ok(())
        }
        fn store_udx_edxf_country_branch_numbers(
            &mut self,
            value: super::UdxEdxfCountryBranchNumbersElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_country_branch_numbers.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COUNTRY_BRANCH_NUMBERS",
                )))?;
            }
            self.udx_edxf_country_branch_numbers = Some(value);
            Ok(())
        }
        fn store_udx_edxf_country_branch_supplier_ids(
            &mut self,
            value: super::UdxEdxfCountryBranchSupplierIdsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_country_branch_supplier_ids.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS",
                )))?;
            }
            self.udx_edxf_country_branch_supplier_ids = Some(value);
            Ok(())
        }
        fn store_udx_edxf_packing_units(
            &mut self,
            value: super::UdxEdxfPackingUnitsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_packing_units.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PACKING_UNITS",
                )))?;
            }
            self.udx_edxf_packing_units = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_logistic_details(
            &mut self,
            value: super::UdxEdxfProductLogisticDetailsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_product_logistic_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_LOGISTIC_DETAILS",
                )))?;
            }
            self.udx_edxf_product_logistic_details = Some(value);
            Ok(())
        }
        fn store_udx_edxf_shelf_life_period(&mut self, value: i32) -> Result<(), Error> {
            if self.udx_edxf_shelf_life_period.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SHELF_LIFE_PERIOD",
                )))?;
            }
            self.udx_edxf_shelf_life_period = Some(value);
            Ok(())
        }
        fn store_udx_edxf_battery_contained(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_battery_contained.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.BATTERY_CONTAINED",
                )))?;
            }
            self.udx_edxf_battery_contained = Some(value);
            Ok(())
        }
        fn store_udx_edxf_rohs_indicator(
            &mut self,
            value: super::UdxEdxfRohsIndicatorElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_rohs_indicator.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.ROHS_INDICATOR",
                )))?;
            }
            self.udx_edxf_rohs_indicator = Some(value);
            Ok(())
        }
        fn store_udx_edxf_ce_marking(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_ce_marking.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.CE_MARKING",
                )))?;
            }
            self.udx_edxf_ce_marking = Some(value);
            Ok(())
        }
        fn store_udx_edxf_reach(
            &mut self,
            value: super::UdxEdxfReachElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_reach.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REACH",
                )))?;
            }
            self.udx_edxf_reach = Some(value);
            Ok(())
        }
        fn store_udx_edxf_special_treatment_class_details(
            &mut self,
            value: super::UdxEdxfSpecialTreatmentClassDetailsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_special_treatment_class_details.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SPECIAL_TREATMENT_CLASS_DETAILS",
                )))?;
            }
            self.udx_edxf_special_treatment_class_details = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_list(
            &mut self,
            value: super::UdxEdxfSurchargeListElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_surcharge_list.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_LIST",
                )))?;
            }
            self.udx_edxf_surcharge_list = Some(value);
            Ok(())
        }
        fn store_udx_edxf_warranty(
            &mut self,
            value: super::UdxEdxfWarrantyElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_warranty.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.WARRANTY",
                )))?;
            }
            self.udx_edxf_warranty = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_etim_dynamic(
            &mut self,
            value: super::UdxEdxfProductEtimDynamicElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_product_etim_dynamic.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_ETIM_DYNAMIC",
                )))?;
            }
            self.udx_edxf_product_etim_dynamic = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_features_mc(
            &mut self,
            value: super::UdxEdxfProductFeaturesMcElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_product_features_mc.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_FEATURES_MC",
                )))?;
            }
            self.udx_edxf_product_features_mc = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristics(
            &mut self,
            value: super::UdxEdxfProductCharacteristicsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_product_characteristics.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTICS",
                )))?;
            }
            self.udx_edxf_product_characteristics = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_mime_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfMimeInfoElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfMimeInfo(None));
                *self.state = UdxProductDeserializerState::UdxEdxfManufacturerAcronym(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_info(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfManufacturerAcronym(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfMimeInfo(
                                Some(deserializer),
                            ));
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfManufacturerAcronym(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfMimeInfo(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_manufacturer_acronym<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfManufacturerAcronym(
                    None,
                ));
                *self.state = UdxProductDeserializerState::UdxEdxfDescriptionVeryShort(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_manufacturer_acronym(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfDescriptionVeryShort(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfManufacturerAcronym(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfDescriptionVeryShort(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfManufacturerAcronym(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_description_very_short<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfDescriptionVeryShort(
                    None,
                ));
                *self.state = UdxProductDeserializerState::UdxEdxfBrandName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_description_very_short(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfDescriptionVeryShort(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfDescriptionVeryShort(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfDescriptionVeryShort(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfDescriptionVeryShort(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_brand_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfBrandName(None));
                *self.state = UdxProductDeserializerState::UdxEdxfTenderText(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_brand_name(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfTenderText(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfBrandName(
                                Some(deserializer),
                            ));
                            *self.state = UdxProductDeserializerState::UdxEdxfTenderText(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfBrandName(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_tender_text<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfTenderText(None));
                *self.state = UdxProductDeserializerState::UdxEdxfValidFrom(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_tender_text(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfTenderText(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfTenderText(
                                Some(deserializer),
                            ));
                            *self.state = UdxProductDeserializerState::UdxEdxfTenderText(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfTenderText(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_valid_from<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfValidFrom(None));
                *self.state = UdxProductDeserializerState::UdxEdxfExpirationDate(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_valid_from(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfExpirationDate(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfValidFrom(
                                Some(deserializer),
                            ));
                            *self.state = UdxProductDeserializerState::UdxEdxfExpirationDate(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfValidFrom(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_expiration_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfExpirationDate(None));
                *self.state = UdxProductDeserializerState::UdxEdxfDiscountGroup(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_expiration_date(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfDiscountGroup(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfExpirationDate(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfDiscountGroup(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfExpirationDate(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_discount_group<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfDiscountGroupElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfDiscountGroup(None));
                *self.state = UdxProductDeserializerState::UdxEdxfBonusGroupSupplier(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_discount_group(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfBonusGroupSupplier(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfDiscountGroup(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfBonusGroupSupplier(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfDiscountGroup(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_bonus_group_supplier<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(UdxProductDeserializerState::UdxEdxfBonusGroupSupplier(None));
                *self.state = UdxProductDeserializerState::UdxEdxfAdditionalFactors(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_bonus_group_supplier(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfAdditionalFactors(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfBonusGroupSupplier(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfAdditionalFactors(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfBonusGroupSupplier(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_additional_factors<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfAdditionalFactorsElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfAdditionalFactors(None));
                *self.state = UdxProductDeserializerState::UdxEdxfProductToStock(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_additional_factors(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfProductToStock(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfAdditionalFactors(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfProductToStock(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfAdditionalFactors(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_to_stock<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfProductToStock(None));
                *self.state = UdxProductDeserializerState::UdxEdxfProductSeries(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_to_stock(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfProductSeries(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfProductToStock(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfProductSeries(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfProductToStock(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_series<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfProductSeries(None));
                *self.state = UdxProductDeserializerState::UdxEdxfProductVariation(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_series(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfProductSeries(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfProductSeries(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfProductSeries(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfProductSeries(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_variation<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfProductVariation(None));
                *self.state = UdxProductDeserializerState::UdxEdxfPredecessorPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_variation(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfProductVariation(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfProductVariation(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfProductVariation(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfProductVariation(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_predecessor_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfPredecessorPid(None));
                *self.state = UdxProductDeserializerState::UdxEdxfCountryBranchNumbers(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_predecessor_pid(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfPredecessorPid(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfPredecessorPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfPredecessorPid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfPredecessorPid(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_country_branch_numbers<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfCountryBranchNumbersElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfCountryBranchNumbers(
                    None,
                ));
                *self.state = UdxProductDeserializerState::UdxEdxfCountryBranchSupplierIds(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_numbers(data)?;
                    *self.state =
                        UdxProductDeserializerState::UdxEdxfCountryBranchSupplierIds(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfCountryBranchNumbers(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfCountryBranchSupplierIds(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfCountryBranchNumbers(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_country_branch_supplier_ids<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductDeserializerState::UdxEdxfCountryBranchSupplierIds(None),
                );
                *self.state = UdxProductDeserializerState::UdxEdxfPackingUnits(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_supplier_ids(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfPackingUnits(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfCountryBranchSupplierIds(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfPackingUnits(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfCountryBranchSupplierIds(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_packing_units<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfPackingUnitsElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfPackingUnits(None));
                *self.state = UdxProductDeserializerState::UdxEdxfProductLogisticDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_units(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfProductLogisticDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfPackingUnits(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfProductLogisticDetails(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfPackingUnits(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_logistic_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductLogisticDetailsElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfProductLogisticDetails(
                    None,
                ));
                *self.state = UdxProductDeserializerState::UdxEdxfShelfLifePeriod(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_logistic_details(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfShelfLifePeriod(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfProductLogisticDetails(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfShelfLifePeriod(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfProductLogisticDetails(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_shelf_life_period<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfShelfLifePeriod(None));
                *self.state = UdxProductDeserializerState::UdxEdxfBatteryContained(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_shelf_life_period(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfBatteryContained(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfShelfLifePeriod(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfBatteryContained(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfShelfLifePeriod(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_battery_contained<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfBatteryContained(None));
                *self.state = UdxProductDeserializerState::UdxEdxfRohsIndicator(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_battery_contained(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfRohsIndicator(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfBatteryContained(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfRohsIndicator(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfBatteryContained(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_rohs_indicator<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfRohsIndicatorElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfRohsIndicator(None));
                *self.state = UdxProductDeserializerState::UdxEdxfCeMarking(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_rohs_indicator(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfCeMarking(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfRohsIndicator(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfCeMarking(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfRohsIndicator(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_ce_marking<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfCeMarking(None));
                *self.state = UdxProductDeserializerState::UdxEdxfReach(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_ce_marking(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfReach(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfCeMarking(
                                Some(deserializer),
                            ));
                            *self.state = UdxProductDeserializerState::UdxEdxfReach(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfCeMarking(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_reach<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfReachElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfReach(None));
                *self.state =
                    UdxProductDeserializerState::UdxEdxfSpecialTreatmentClassDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_reach(data)?;
                    *self.state =
                        UdxProductDeserializerState::UdxEdxfSpecialTreatmentClassDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfReach(
                                Some(deserializer),
                            ));
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfSpecialTreatmentClassDetails(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfReach(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_special_treatment_class_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfSpecialTreatmentClassDetailsElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductDeserializerState::UdxEdxfSpecialTreatmentClassDetails(None),
                );
                *self.state = UdxProductDeserializerState::UdxEdxfSurchargeList(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_special_treatment_class_details(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfSurchargeList(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfSpecialTreatmentClassDetails(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfSurchargeList(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfSpecialTreatmentClassDetails(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_surcharge_list<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfSurchargeListElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfSurchargeList(None));
                *self.state = UdxProductDeserializerState::UdxEdxfWarranty(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_surcharge_list(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfWarranty(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfSurchargeList(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::UdxEdxfWarranty(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfSurchargeList(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_warranty<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfWarrantyElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfWarranty(None));
                *self.state = UdxProductDeserializerState::UdxEdxfProductEtimDynamic(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_warranty(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfProductEtimDynamic(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfWarranty(
                                Some(deserializer),
                            ));
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfProductEtimDynamic(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfWarranty(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_etim_dynamic<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductEtimDynamicElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(UdxProductDeserializerState::UdxEdxfProductEtimDynamic(None));
                *self.state = UdxProductDeserializerState::UdxEdxfProductFeaturesMc(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_etim_dynamic(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfProductFeaturesMc(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfProductEtimDynamic(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfProductFeaturesMc(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfProductEtimDynamic(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_features_mc<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductFeaturesMcElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfProductFeaturesMc(None));
                *self.state = UdxProductDeserializerState::UdxEdxfProductCharacteristics(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_features_mc(data)?;
                    *self.state = UdxProductDeserializerState::UdxEdxfProductCharacteristics(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfProductFeaturesMc(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfProductCharacteristics(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductDeserializerState::UdxEdxfProductFeaturesMc(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_characteristics<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductCharacteristicsElementType>,
            fallback: &mut Option<UdxProductDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductDeserializerState::UdxEdxfProductCharacteristics(
                    None,
                ));
                *self.state = UdxProductDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_characteristics(data)?;
                    *self.state = UdxProductDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductDeserializerState::UdxEdxfProductCharacteristics(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductDeserializerState::UdxEdxfProductCharacteristics(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxProduct> for UdxProductDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::UdxProduct>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxProduct>
        where
            R: DeserializeReader,
        {
            use UdxProductDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfMimeInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfManufacturerAcronym(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_manufacturer_acronym(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDescriptionVeryShort(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_description_very_short(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfBrandName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_brand_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfTenderText(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_tender_text(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfValidFrom(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_valid_from(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfExpirationDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_expiration_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDiscountGroup(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_discount_group(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfBonusGroupSupplier(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_bonus_group_supplier(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfAdditionalFactors(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_additional_factors(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductToStock(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_to_stock(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductSeries(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_series(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductVariation(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_variation(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPredecessorPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_predecessor_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfCountryBranchNumbers(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_numbers(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfCountryBranchSupplierIds(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_supplier_ids(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackingUnits(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_units(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductLogisticDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_logistic_details(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfShelfLifePeriod(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_shelf_life_period(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfBatteryContained(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_battery_contained(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfRohsIndicator(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_rohs_indicator(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfCeMarking(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_ce_marking(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfReach(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_reach(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfSpecialTreatmentClassDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_special_treatment_class_details(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfSurchargeList(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_list(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfWarranty(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_warranty(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductEtimDynamic(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_etim_dynamic(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductFeaturesMc(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_features_mc(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductCharacteristics(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristics(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = UdxProductDeserializerState::UdxEdxfMimeInfo(None);
                        event
                    }
                    (S::UdxEdxfMimeInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_INFO",
                        ) {
                            let output = < super :: UdxEdxfMimeInfoElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_mime_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfManufacturerAcronym(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfManufacturerAcronym(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MANUFACTURER_ACRONYM",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_manufacturer_acronym(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDescriptionVeryShort(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfDescriptionVeryShort(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DESCRIPTION_VERY_SHORT",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_description_very_short(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfBrandName(None);
                            event
                        }
                    }
                    (S::UdxEdxfBrandName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.BRAND_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_brand_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfTenderText(None);
                            event
                        }
                    }
                    (S::UdxEdxfTenderText(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.TENDER_TEXT",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_tender_text(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfValidFrom(None);
                            event
                        }
                    }
                    (S::UdxEdxfValidFrom(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.VALID_FROM",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_valid_from(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfExpirationDate(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfExpirationDate(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.EXPIRATION_DATE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_expiration_date(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDiscountGroup(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfDiscountGroup(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DISCOUNT_GROUP",
                        ) {
                            let output = < super :: UdxEdxfDiscountGroupElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_discount_group(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfBonusGroupSupplier(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfBonusGroupSupplier(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.BONUS_GROUP_SUPPLIER",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_bonus_group_supplier(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfAdditionalFactors(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfAdditionalFactors(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.ADDITIONAL_FACTORS",
                        ) {
                            let output = < super :: UdxEdxfAdditionalFactorsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_additional_factors(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductToStock(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductToStock(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_TO_STOCK",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_product_to_stock(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductSeries(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductSeries(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_SERIES",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_product_series(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductVariation(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductVariation(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_VARIATION",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_product_variation(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPredecessorPid(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfPredecessorPid(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PREDECESSOR_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_predecessor_pid(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfCountryBranchNumbers(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfCountryBranchNumbers(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_NUMBERS",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchNumbersElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_numbers(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfCountryBranchSupplierIds(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfCountryBranchSupplierIds(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchSupplierIdsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_supplier_ids(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackingUnits(None);
                            event
                        }
                    }
                    (S::UdxEdxfPackingUnits(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_UNITS",
                        ) {
                            let output = < super :: UdxEdxfPackingUnitsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_packing_units(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductLogisticDetails(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductLogisticDetails(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_LOGISTIC_DETAILS",
                        ) {
                            let output = < super :: UdxEdxfProductLogisticDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_logistic_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfShelfLifePeriod(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfShelfLifePeriod(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SHELF_LIFE_PERIOD",
                        ) {
                            let output =
                                <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_shelf_life_period(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfBatteryContained(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfBatteryContained(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.BATTERY_CONTAINED",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_battery_contained(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfRohsIndicator(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfRohsIndicator(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.ROHS_INDICATOR",
                        ) {
                            let output = < super :: UdxEdxfRohsIndicatorElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_rohs_indicator(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfCeMarking(None);
                            event
                        }
                    }
                    (S::UdxEdxfCeMarking(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.CE_MARKING",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_ce_marking(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfReach(None);
                            event
                        }
                    }
                    (S::UdxEdxfReach(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REACH",
                        ) {
                            let output = < super :: UdxEdxfReachElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_reach(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfSpecialTreatmentClassDetails(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfSpecialTreatmentClassDetails(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SPECIAL_TREATMENT_CLASS_DETAILS",
                        ) {
                            let output = < super :: UdxEdxfSpecialTreatmentClassDetailsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_special_treatment_class_details(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfSurchargeList(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfSurchargeList(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SURCHARGE_LIST",
                        ) {
                            let output = < super :: UdxEdxfSurchargeListElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_surcharge_list(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfWarranty(None);
                            event
                        }
                    }
                    (S::UdxEdxfWarranty(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.WARRANTY",
                        ) {
                            let output = < super :: UdxEdxfWarrantyElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_warranty(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductEtimDynamic(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductEtimDynamic(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_ETIM_DYNAMIC",
                        ) {
                            let output = < super :: UdxEdxfProductEtimDynamicElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_etim_dynamic(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductFeaturesMc(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductFeaturesMc(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_FEATURES_MC",
                        ) {
                            let output = < super :: UdxEdxfProductFeaturesMcElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_features_mc(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductCharacteristics(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristics(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_CHARACTERISTICS",
                        ) {
                            let output = < super :: UdxEdxfProductCharacteristicsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_characteristics(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxProduct, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, UdxProductDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::UdxProduct {
                udx_edxf_mime_info: self.udx_edxf_mime_info,
                udx_edxf_manufacturer_acronym: self.udx_edxf_manufacturer_acronym,
                udx_edxf_description_very_short: self.udx_edxf_description_very_short,
                udx_edxf_brand_name: self.udx_edxf_brand_name,
                udx_edxf_tender_text: self.udx_edxf_tender_text,
                udx_edxf_valid_from: self.udx_edxf_valid_from,
                udx_edxf_expiration_date: self.udx_edxf_expiration_date,
                udx_edxf_discount_group: self.udx_edxf_discount_group,
                udx_edxf_bonus_group_supplier: self.udx_edxf_bonus_group_supplier,
                udx_edxf_additional_factors: self.udx_edxf_additional_factors,
                udx_edxf_product_to_stock: self.udx_edxf_product_to_stock,
                udx_edxf_product_series: self.udx_edxf_product_series,
                udx_edxf_product_variation: self.udx_edxf_product_variation,
                udx_edxf_predecessor_pid: self.udx_edxf_predecessor_pid,
                udx_edxf_country_branch_numbers: self.udx_edxf_country_branch_numbers,
                udx_edxf_country_branch_supplier_ids: self.udx_edxf_country_branch_supplier_ids,
                udx_edxf_packing_units: self.udx_edxf_packing_units,
                udx_edxf_product_logistic_details: self.udx_edxf_product_logistic_details,
                udx_edxf_shelf_life_period: self.udx_edxf_shelf_life_period,
                udx_edxf_battery_contained: self.udx_edxf_battery_contained,
                udx_edxf_rohs_indicator: self.udx_edxf_rohs_indicator,
                udx_edxf_ce_marking: self.udx_edxf_ce_marking,
                udx_edxf_reach: self.udx_edxf_reach,
                udx_edxf_special_treatment_class_details: self
                    .udx_edxf_special_treatment_class_details,
                udx_edxf_surcharge_list: self.udx_edxf_surcharge_list,
                udx_edxf_warranty: self.udx_edxf_warranty,
                udx_edxf_product_etim_dynamic: self.udx_edxf_product_etim_dynamic,
                udx_edxf_product_features_mc: self.udx_edxf_product_features_mc,
                udx_edxf_product_characteristics: self.udx_edxf_product_characteristics,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductReferenceElementTypeDeserializer {
        type_: super::ProductReferenceType,
        quantity: Option<i32>,
        prod_id_to: Option<String>,
        catalog_id: Option<String>,
        catalog_version: Option<String>,
        reference_descr: Vec<super::DtMlstring>,
        state: Box<ProductReferenceElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductReferenceElementTypeDeserializerState {
        Init__,
        ProdIdTo(Option<<String as WithDeserializer>::Deserializer>),
        CatalogId(Option<<String as WithDeserializer>::Deserializer>),
        CatalogVersion(Option<<String as WithDeserializer>::Deserializer>),
        ReferenceDescr(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductReferenceElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::ProductReferenceType> = None;
            let mut quantity: Option<i32> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"quantity")
                ) {
                    reader.read_attrib(&mut quantity, b"quantity", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                quantity: quantity,
                prod_id_to: None,
                catalog_id: None,
                catalog_version: None,
                reference_descr: Vec::new(),
                state: Box::new(ProductReferenceElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductReferenceElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductReferenceElementTypeDeserializerState as S;
            match state {
                S::ProdIdTo(Some(deserializer)) => {
                    self.store_prod_id_to(deserializer.finish(reader)?)?
                }
                S::CatalogId(Some(deserializer)) => {
                    self.store_catalog_id(deserializer.finish(reader)?)?
                }
                S::CatalogVersion(Some(deserializer)) => {
                    self.store_catalog_version(deserializer.finish(reader)?)?
                }
                S::ReferenceDescr(Some(deserializer)) => {
                    self.store_reference_descr(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_prod_id_to(&mut self, value: String) -> Result<(), Error> {
            if self.prod_id_to.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PROD_ID_TO",
                )))?;
            }
            self.prod_id_to = Some(value);
            Ok(())
        }
        fn store_catalog_id(&mut self, value: String) -> Result<(), Error> {
            if self.catalog_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG_ID",
                )))?;
            }
            self.catalog_id = Some(value);
            Ok(())
        }
        fn store_catalog_version(&mut self, value: String) -> Result<(), Error> {
            if self.catalog_version.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CATALOG_VERSION",
                )))?;
            }
            self.catalog_version = Some(value);
            Ok(())
        }
        fn store_reference_descr(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.reference_descr.push(value);
            Ok(())
        }
        fn handle_prod_id_to<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductReferenceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.prod_id_to.is_some() {
                    fallback.get_or_insert(ProductReferenceElementTypeDeserializerState::ProdIdTo(
                        None,
                    ));
                    *self.state = ProductReferenceElementTypeDeserializerState::CatalogId(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProductReferenceElementTypeDeserializerState::ProdIdTo(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_prod_id_to(data)?;
                    *self.state = ProductReferenceElementTypeDeserializerState::CatalogId(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductReferenceElementTypeDeserializerState::ProdIdTo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::CatalogId(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductReferenceElementTypeDeserializerState::ProdIdTo(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductReferenceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductReferenceElementTypeDeserializerState::CatalogId(
                    None,
                ));
                *self.state = ProductReferenceElementTypeDeserializerState::CatalogVersion(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_id(data)?;
                    *self.state =
                        ProductReferenceElementTypeDeserializerState::CatalogVersion(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductReferenceElementTypeDeserializerState::CatalogId(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::CatalogVersion(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductReferenceElementTypeDeserializerState::CatalogId(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_catalog_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductReferenceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductReferenceElementTypeDeserializerState::CatalogVersion(None),
                );
                *self.state = ProductReferenceElementTypeDeserializerState::ReferenceDescr(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_catalog_version(data)?;
                    *self.state =
                        ProductReferenceElementTypeDeserializerState::ReferenceDescr(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductReferenceElementTypeDeserializerState::CatalogVersion(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::ReferenceDescr(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::CatalogVersion(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_reference_descr<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<ProductReferenceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductReferenceElementTypeDeserializerState::ReferenceDescr(None),
                );
                *self.state = ProductReferenceElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_reference_descr(data)?;
                    *self.state =
                        ProductReferenceElementTypeDeserializerState::ReferenceDescr(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductReferenceElementTypeDeserializerState::ReferenceDescr(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::ReferenceDescr(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductReferenceElementTypeDeserializerState::ReferenceDescr(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductReferenceElementType>
        for ProductReferenceElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductReferenceElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductReferenceElementType>
        where
            R: DeserializeReader,
        {
            use ProductReferenceElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::ProdIdTo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_prod_id_to(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_id(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CatalogVersion(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_catalog_version(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::ReferenceDescr(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_reference_descr(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ProductReferenceElementTypeDeserializerState::ProdIdTo(None);
                        event
                    }
                    (S::ProdIdTo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PROD_ID_TO",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_prod_id_to(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogId(None);
                            event
                        }
                    }
                    (S::CatalogId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_ID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_catalog_id(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CatalogVersion(None);
                            event
                        }
                    }
                    (S::CatalogVersion(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CATALOG_VERSION",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_catalog_version(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::ReferenceDescr(None);
                            event
                        }
                    }
                    (S::ReferenceDescr(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"REFERENCE_DESCR",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_reference_descr(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductReferenceElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductReferenceElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductReferenceElementType {
                type_: self.type_,
                quantity: self.quantity,
                prod_id_to: self
                    .prod_id_to
                    .ok_or_else(|| ErrorKind::MissingElement("PROD_ID_TO".into()))?,
                catalog_id: self.catalog_id,
                catalog_version: self.catalog_version,
                reference_descr: self.reference_descr,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductLogisticDetailsElementTypeDeserializer {
        customs_tariff_number: Vec<super::CustomsTariffNumberElementType>,
        statistics_factor: Option<f64>,
        country_of_origin: Vec<String>,
        state: Box<ProductLogisticDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductLogisticDetailsElementTypeDeserializerState {
        Init__,
        CustomsTariffNumber(
            Option<<super::CustomsTariffNumberElementType as WithDeserializer>::Deserializer>,
        ),
        StatisticsFactor(Option<<f64 as WithDeserializer>::Deserializer>),
        CountryOfOrigin(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductLogisticDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                customs_tariff_number: Vec::new(),
                statistics_factor: None,
                country_of_origin: Vec::new(),
                state: Box::new(ProductLogisticDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductLogisticDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductLogisticDetailsElementTypeDeserializerState as S;
            match state {
                S::CustomsTariffNumber(Some(deserializer)) => {
                    self.store_customs_tariff_number(deserializer.finish(reader)?)?
                }
                S::StatisticsFactor(Some(deserializer)) => {
                    self.store_statistics_factor(deserializer.finish(reader)?)?
                }
                S::CountryOfOrigin(Some(deserializer)) => {
                    self.store_country_of_origin(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_customs_tariff_number(
            &mut self,
            value: super::CustomsTariffNumberElementType,
        ) -> Result<(), Error> {
            self.customs_tariff_number.push(value);
            Ok(())
        }
        fn store_statistics_factor(&mut self, value: f64) -> Result<(), Error> {
            if self.statistics_factor.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"STATISTICS_FACTOR",
                )))?;
            }
            self.statistics_factor = Some(value);
            Ok(())
        }
        fn store_country_of_origin(&mut self, value: String) -> Result<(), Error> {
            self.country_of_origin.push(value);
            Ok(())
        }
        fn handle_customs_tariff_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::CustomsTariffNumberElementType>,
            fallback: &mut Option<ProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductLogisticDetailsElementTypeDeserializerState::CustomsTariffNumber(None),
                );
                *self.state =
                    ProductLogisticDetailsElementTypeDeserializerState::StatisticsFactor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_customs_tariff_number(data)?;
                    *self.state =
                        ProductLogisticDetailsElementTypeDeserializerState::CustomsTariffNumber(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ProductLogisticDetailsElementTypeDeserializerState :: CustomsTariffNumber (Some (deserializer))) ;
                            * self . state = ProductLogisticDetailsElementTypeDeserializerState :: CustomsTariffNumber (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ProductLogisticDetailsElementTypeDeserializerState :: CustomsTariffNumber (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_statistics_factor<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductLogisticDetailsElementTypeDeserializerState::StatisticsFactor(None),
                );
                *self.state =
                    ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_statistics_factor(data)?;
                    *self.state =
                        ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (ProductLogisticDetailsElementTypeDeserializerState :: StatisticsFactor (Some (deserializer))) ;
                            *self.state =
                                ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = ProductLogisticDetailsElementTypeDeserializerState :: StatisticsFactor (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_country_of_origin<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(None),
                );
                *self.state = ProductLogisticDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_country_of_origin(data)?;
                    *self.state =
                        ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductLogisticDetailsElementTypeDeserializerState::CountryOfOrigin(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductLogisticDetailsElementType>
        for ProductLogisticDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductLogisticDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductLogisticDetailsElementType>
        where
            R: DeserializeReader,
        {
            use ProductLogisticDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CustomsTariffNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_customs_tariff_number(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::StatisticsFactor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_statistics_factor(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::CountryOfOrigin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_country_of_origin(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductLogisticDetailsElementTypeDeserializerState::CustomsTariffNumber(
                                None,
                            );
                        event
                    }
                    (S::CustomsTariffNumber(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CUSTOMS_TARIFF_NUMBER",
                        ) {
                            let output = < super :: CustomsTariffNumberElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_customs_tariff_number(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::StatisticsFactor(None);
                            event
                        }
                    }
                    (S::StatisticsFactor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"STATISTICS_FACTOR",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_statistics_factor(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::CountryOfOrigin(None);
                            event
                        }
                    }
                    (S::CountryOfOrigin(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"COUNTRY_OF_ORIGIN",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_country_of_origin(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ProductLogisticDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductLogisticDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductLogisticDetailsElementType {
                customs_tariff_number: self.customs_tariff_number,
                statistics_factor: self.statistics_factor,
                country_of_origin: self.country_of_origin,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxProductdataDeserializer {
        udx_edxf_mime_info: Option<super::UdxEdxfMimeInfoElementType>,
        udx_edxf_manufacturer_acronym: Option<String>,
        udx_edxf_description_very_short: Vec<super::DtMlstring>,
        udx_edxf_brand_name: Option<String>,
        udx_edxf_tender_text: Vec<super::DtMlstring>,
        udx_edxf_valid_from: Option<String>,
        udx_edxf_expiration_date: Option<String>,
        udx_edxf_product_series: Vec<super::DtMlstring>,
        udx_edxf_product_variation: Vec<super::DtMlstring>,
        udx_edxf_predecessor_pid: Vec<String>,
        udx_edxf_country_branch_numbers: Option<super::UdxEdxfCountryBranchNumbersElementType>,
        udx_edxf_country_branch_supplier_ids:
            Option<super::UdxEdxfCountryBranchSupplierIdsElementType>,
        udx_edxf_product_etim_dynamic: Option<super::UdxEdxfProductEtimDynamicElementType>,
        udx_edxf_product_features_mc: Option<super::UdxEdxfProductFeaturesMcElementType>,
        udx_edxf_product_characteristics: Option<super::UdxEdxfProductCharacteristicsElementType>,
        state: Box<UdxProductdataDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxProductdataDeserializerState {
        Init__ , UdxEdxfMimeInfo (Option << super :: UdxEdxfMimeInfoElementType as WithDeserializer > :: Deserializer >) , UdxEdxfManufacturerAcronym (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfDescriptionVeryShort (Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , UdxEdxfBrandName (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfTenderText (Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , UdxEdxfValidFrom (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfExpirationDate (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfProductSeries (Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , UdxEdxfProductVariation (Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , UdxEdxfPredecessorPid (Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfCountryBranchNumbers (Option << super :: UdxEdxfCountryBranchNumbersElementType as WithDeserializer > :: Deserializer >) , UdxEdxfCountryBranchSupplierIds (Option << super :: UdxEdxfCountryBranchSupplierIdsElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductEtimDynamic (Option << super :: UdxEdxfProductEtimDynamicElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductFeaturesMc (Option << super :: UdxEdxfProductFeaturesMcElementType as WithDeserializer > :: Deserializer >) , UdxEdxfProductCharacteristics (Option << super :: UdxEdxfProductCharacteristicsElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl UdxProductdataDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_mime_info: None,
                udx_edxf_manufacturer_acronym: None,
                udx_edxf_description_very_short: Vec::new(),
                udx_edxf_brand_name: None,
                udx_edxf_tender_text: Vec::new(),
                udx_edxf_valid_from: None,
                udx_edxf_expiration_date: None,
                udx_edxf_product_series: Vec::new(),
                udx_edxf_product_variation: Vec::new(),
                udx_edxf_predecessor_pid: Vec::new(),
                udx_edxf_country_branch_numbers: None,
                udx_edxf_country_branch_supplier_ids: None,
                udx_edxf_product_etim_dynamic: None,
                udx_edxf_product_features_mc: None,
                udx_edxf_product_characteristics: None,
                state: Box::new(UdxProductdataDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxProductdataDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxProductdataDeserializerState as S;
            match state {
                S::UdxEdxfMimeInfo(Some(deserializer)) => {
                    self.store_udx_edxf_mime_info(deserializer.finish(reader)?)?
                }
                S::UdxEdxfManufacturerAcronym(Some(deserializer)) => {
                    self.store_udx_edxf_manufacturer_acronym(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDescriptionVeryShort(Some(deserializer)) => {
                    self.store_udx_edxf_description_very_short(deserializer.finish(reader)?)?
                }
                S::UdxEdxfBrandName(Some(deserializer)) => {
                    self.store_udx_edxf_brand_name(deserializer.finish(reader)?)?
                }
                S::UdxEdxfTenderText(Some(deserializer)) => {
                    self.store_udx_edxf_tender_text(deserializer.finish(reader)?)?
                }
                S::UdxEdxfValidFrom(Some(deserializer)) => {
                    self.store_udx_edxf_valid_from(deserializer.finish(reader)?)?
                }
                S::UdxEdxfExpirationDate(Some(deserializer)) => {
                    self.store_udx_edxf_expiration_date(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductSeries(Some(deserializer)) => {
                    self.store_udx_edxf_product_series(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductVariation(Some(deserializer)) => {
                    self.store_udx_edxf_product_variation(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPredecessorPid(Some(deserializer)) => {
                    self.store_udx_edxf_predecessor_pid(deserializer.finish(reader)?)?
                }
                S::UdxEdxfCountryBranchNumbers(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_numbers(deserializer.finish(reader)?)?
                }
                S::UdxEdxfCountryBranchSupplierIds(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_supplier_ids(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductEtimDynamic(Some(deserializer)) => {
                    self.store_udx_edxf_product_etim_dynamic(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductFeaturesMc(Some(deserializer)) => {
                    self.store_udx_edxf_product_features_mc(deserializer.finish(reader)?)?
                }
                S::UdxEdxfProductCharacteristics(Some(deserializer)) => {
                    self.store_udx_edxf_product_characteristics(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_mime_info(
            &mut self,
            value: super::UdxEdxfMimeInfoElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_mime_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MIME_INFO",
                )))?;
            }
            self.udx_edxf_mime_info = Some(value);
            Ok(())
        }
        fn store_udx_edxf_manufacturer_acronym(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_manufacturer_acronym.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MANUFACTURER_ACRONYM",
                )))?;
            }
            self.udx_edxf_manufacturer_acronym = Some(value);
            Ok(())
        }
        fn store_udx_edxf_description_very_short(
            &mut self,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            self.udx_edxf_description_very_short.push(value);
            Ok(())
        }
        fn store_udx_edxf_brand_name(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_brand_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.BRAND_NAME",
                )))?;
            }
            self.udx_edxf_brand_name = Some(value);
            Ok(())
        }
        fn store_udx_edxf_tender_text(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.udx_edxf_tender_text.push(value);
            Ok(())
        }
        fn store_udx_edxf_valid_from(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_valid_from.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.VALID_FROM",
                )))?;
            }
            self.udx_edxf_valid_from = Some(value);
            Ok(())
        }
        fn store_udx_edxf_expiration_date(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_expiration_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.EXPIRATION_DATE",
                )))?;
            }
            self.udx_edxf_expiration_date = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_series(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.udx_edxf_product_series.push(value);
            Ok(())
        }
        fn store_udx_edxf_product_variation(
            &mut self,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            self.udx_edxf_product_variation.push(value);
            Ok(())
        }
        fn store_udx_edxf_predecessor_pid(&mut self, value: String) -> Result<(), Error> {
            self.udx_edxf_predecessor_pid.push(value);
            Ok(())
        }
        fn store_udx_edxf_country_branch_numbers(
            &mut self,
            value: super::UdxEdxfCountryBranchNumbersElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_country_branch_numbers.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COUNTRY_BRANCH_NUMBERS",
                )))?;
            }
            self.udx_edxf_country_branch_numbers = Some(value);
            Ok(())
        }
        fn store_udx_edxf_country_branch_supplier_ids(
            &mut self,
            value: super::UdxEdxfCountryBranchSupplierIdsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_country_branch_supplier_ids.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS",
                )))?;
            }
            self.udx_edxf_country_branch_supplier_ids = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_etim_dynamic(
            &mut self,
            value: super::UdxEdxfProductEtimDynamicElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_product_etim_dynamic.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_ETIM_DYNAMIC",
                )))?;
            }
            self.udx_edxf_product_etim_dynamic = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_features_mc(
            &mut self,
            value: super::UdxEdxfProductFeaturesMcElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_product_features_mc.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_FEATURES_MC",
                )))?;
            }
            self.udx_edxf_product_features_mc = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristics(
            &mut self,
            value: super::UdxEdxfProductCharacteristicsElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_product_characteristics.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTICS",
                )))?;
            }
            self.udx_edxf_product_characteristics = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_mime_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfMimeInfoElementType>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductdataDeserializerState::UdxEdxfMimeInfo(None));
                *self.state = UdxProductdataDeserializerState::UdxEdxfManufacturerAcronym(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_info(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfManufacturerAcronym(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfMimeInfo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfManufacturerAcronym(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfMimeInfo(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_manufacturer_acronym<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductdataDeserializerState::UdxEdxfManufacturerAcronym(None),
                );
                *self.state = UdxProductdataDeserializerState::UdxEdxfDescriptionVeryShort(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_manufacturer_acronym(data)?;
                    *self.state =
                        UdxProductdataDeserializerState::UdxEdxfDescriptionVeryShort(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfManufacturerAcronym(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfDescriptionVeryShort(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfManufacturerAcronym(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_description_very_short<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductdataDeserializerState::UdxEdxfDescriptionVeryShort(None),
                );
                *self.state = UdxProductdataDeserializerState::UdxEdxfBrandName(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_description_very_short(data)?;
                    *self.state =
                        UdxProductdataDeserializerState::UdxEdxfDescriptionVeryShort(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfDescriptionVeryShort(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfDescriptionVeryShort(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfDescriptionVeryShort(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_brand_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductdataDeserializerState::UdxEdxfBrandName(None));
                *self.state = UdxProductdataDeserializerState::UdxEdxfTenderText(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_brand_name(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfTenderText(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfBrandName(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductdataDeserializerState::UdxEdxfTenderText(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfBrandName(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_tender_text<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductdataDeserializerState::UdxEdxfTenderText(None));
                *self.state = UdxProductdataDeserializerState::UdxEdxfValidFrom(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_tender_text(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfTenderText(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfTenderText(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxProductdataDeserializerState::UdxEdxfTenderText(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfTenderText(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_valid_from<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductdataDeserializerState::UdxEdxfValidFrom(None));
                *self.state = UdxProductdataDeserializerState::UdxEdxfExpirationDate(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_valid_from(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfExpirationDate(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfValidFrom(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfExpirationDate(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfValidFrom(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_expiration_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(UdxProductdataDeserializerState::UdxEdxfExpirationDate(None));
                *self.state = UdxProductdataDeserializerState::UdxEdxfProductSeries(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_expiration_date(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfProductSeries(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfExpirationDate(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfProductSeries(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfExpirationDate(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_series<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductdataDeserializerState::UdxEdxfProductSeries(None));
                *self.state = UdxProductdataDeserializerState::UdxEdxfProductVariation(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_series(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfProductSeries(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfProductSeries(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfProductSeries(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfProductSeries(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_variation<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductdataDeserializerState::UdxEdxfProductVariation(
                    None,
                ));
                *self.state = UdxProductdataDeserializerState::UdxEdxfPredecessorPid(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_variation(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfProductVariation(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfProductVariation(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfProductVariation(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfProductVariation(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_predecessor_pid<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(UdxProductdataDeserializerState::UdxEdxfPredecessorPid(None));
                *self.state = UdxProductdataDeserializerState::UdxEdxfCountryBranchNumbers(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_predecessor_pid(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfPredecessorPid(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfPredecessorPid(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfPredecessorPid(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfPredecessorPid(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_country_branch_numbers<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfCountryBranchNumbersElementType>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductdataDeserializerState::UdxEdxfCountryBranchNumbers(None),
                );
                *self.state =
                    UdxProductdataDeserializerState::UdxEdxfCountryBranchSupplierIds(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_numbers(data)?;
                    *self.state =
                        UdxProductdataDeserializerState::UdxEdxfCountryBranchSupplierIds(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfCountryBranchNumbers(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfCountryBranchSupplierIds(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfCountryBranchNumbers(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_country_branch_supplier_ids<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductdataDeserializerState::UdxEdxfCountryBranchSupplierIds(None),
                );
                *self.state = UdxProductdataDeserializerState::UdxEdxfProductEtimDynamic(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_supplier_ids(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfProductEtimDynamic(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfCountryBranchSupplierIds(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfProductEtimDynamic(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfCountryBranchSupplierIds(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_etim_dynamic<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductEtimDynamicElementType>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductdataDeserializerState::UdxEdxfProductEtimDynamic(
                    None,
                ));
                *self.state = UdxProductdataDeserializerState::UdxEdxfProductFeaturesMc(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_etim_dynamic(data)?;
                    *self.state = UdxProductdataDeserializerState::UdxEdxfProductFeaturesMc(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfProductEtimDynamic(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfProductFeaturesMc(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfProductEtimDynamic(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_features_mc<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductFeaturesMcElementType>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxProductdataDeserializerState::UdxEdxfProductFeaturesMc(
                    None,
                ));
                *self.state = UdxProductdataDeserializerState::UdxEdxfProductCharacteristics(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_features_mc(data)?;
                    *self.state =
                        UdxProductdataDeserializerState::UdxEdxfProductCharacteristics(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfProductFeaturesMc(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfProductCharacteristics(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxProductdataDeserializerState::UdxEdxfProductFeaturesMc(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_product_characteristics<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductCharacteristicsElementType>,
            fallback: &mut Option<UdxProductdataDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxProductdataDeserializerState::UdxEdxfProductCharacteristics(None),
                );
                *self.state = UdxProductdataDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_characteristics(data)?;
                    *self.state = UdxProductdataDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxProductdataDeserializerState::UdxEdxfProductCharacteristics(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = UdxProductdataDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxProductdataDeserializerState::UdxEdxfProductCharacteristics(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxProductdata> for UdxProductdataDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::UdxProductdata>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxProductdata>
        where
            R: DeserializeReader,
        {
            use UdxProductdataDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfMimeInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfManufacturerAcronym(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_manufacturer_acronym(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDescriptionVeryShort(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_description_very_short(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfBrandName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_brand_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfTenderText(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_tender_text(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfValidFrom(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_valid_from(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfExpirationDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_expiration_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductSeries(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_series(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductVariation(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_variation(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPredecessorPid(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_predecessor_pid(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfCountryBranchNumbers(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_numbers(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfCountryBranchSupplierIds(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_supplier_ids(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductEtimDynamic(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_etim_dynamic(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductFeaturesMc(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_features_mc(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfProductCharacteristics(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristics(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = UdxProductdataDeserializerState::UdxEdxfMimeInfo(None);
                        event
                    }
                    (S::UdxEdxfMimeInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_INFO",
                        ) {
                            let output = < super :: UdxEdxfMimeInfoElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_mime_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfManufacturerAcronym(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfManufacturerAcronym(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MANUFACTURER_ACRONYM",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_manufacturer_acronym(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDescriptionVeryShort(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfDescriptionVeryShort(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DESCRIPTION_VERY_SHORT",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_description_very_short(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfBrandName(None);
                            event
                        }
                    }
                    (S::UdxEdxfBrandName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.BRAND_NAME",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_brand_name(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfTenderText(None);
                            event
                        }
                    }
                    (S::UdxEdxfTenderText(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.TENDER_TEXT",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_tender_text(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfValidFrom(None);
                            event
                        }
                    }
                    (S::UdxEdxfValidFrom(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.VALID_FROM",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_valid_from(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfExpirationDate(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfExpirationDate(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.EXPIRATION_DATE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_expiration_date(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductSeries(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductSeries(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_SERIES",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_product_series(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductVariation(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductVariation(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_VARIATION",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_product_variation(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPredecessorPid(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfPredecessorPid(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PREDECESSOR_PID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_predecessor_pid(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfCountryBranchNumbers(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfCountryBranchNumbers(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_NUMBERS",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchNumbersElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_numbers(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfCountryBranchSupplierIds(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfCountryBranchSupplierIds(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchSupplierIdsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_supplier_ids(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductEtimDynamic(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductEtimDynamic(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_ETIM_DYNAMIC",
                        ) {
                            let output = < super :: UdxEdxfProductEtimDynamicElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_etim_dynamic(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductFeaturesMc(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductFeaturesMc(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_FEATURES_MC",
                        ) {
                            let output = < super :: UdxEdxfProductFeaturesMcElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_features_mc(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfProductCharacteristics(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristics(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_CHARACTERISTICS",
                        ) {
                            let output = < super :: UdxEdxfProductCharacteristicsElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_characteristics(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxProductdata, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(&mut *self.state, UdxProductdataDeserializerState::Unknown__);
            self.finish_state(reader, state)?;
            Ok(super::UdxProductdata {
                udx_edxf_mime_info: self.udx_edxf_mime_info,
                udx_edxf_manufacturer_acronym: self.udx_edxf_manufacturer_acronym,
                udx_edxf_description_very_short: self.udx_edxf_description_very_short,
                udx_edxf_brand_name: self.udx_edxf_brand_name,
                udx_edxf_tender_text: self.udx_edxf_tender_text,
                udx_edxf_valid_from: self.udx_edxf_valid_from,
                udx_edxf_expiration_date: self.udx_edxf_expiration_date,
                udx_edxf_product_series: self.udx_edxf_product_series,
                udx_edxf_product_variation: self.udx_edxf_product_variation,
                udx_edxf_predecessor_pid: self.udx_edxf_predecessor_pid,
                udx_edxf_country_branch_numbers: self.udx_edxf_country_branch_numbers,
                udx_edxf_country_branch_supplier_ids: self.udx_edxf_country_branch_supplier_ids,
                udx_edxf_product_etim_dynamic: self.udx_edxf_product_etim_dynamic,
                udx_edxf_product_features_mc: self.udx_edxf_product_features_mc,
                udx_edxf_product_characteristics: self.udx_edxf_product_characteristics,
            })
        }
    }
    #[derive(Debug)]
    pub struct MimeElementTypeDeserializer {
        mime_source: Vec<super::DtMlstring>,
        mime_descr: Vec<super::DtMlstring>,
        mime_alt: Vec<super::DtMlstring>,
        state: Box<MimeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum MimeElementTypeDeserializerState {
        Init__,
        MimeSource(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        MimeDescr(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        MimeAlt(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl MimeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                mime_source: Vec::new(),
                mime_descr: Vec::new(),
                mime_alt: Vec::new(),
                state: Box::new(MimeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: MimeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use MimeElementTypeDeserializerState as S;
            match state {
                S::MimeSource(Some(deserializer)) => {
                    self.store_mime_source(deserializer.finish(reader)?)?
                }
                S::MimeDescr(Some(deserializer)) => {
                    self.store_mime_descr(deserializer.finish(reader)?)?
                }
                S::MimeAlt(Some(deserializer)) => {
                    self.store_mime_alt(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_mime_source(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.mime_source.push(value);
            Ok(())
        }
        fn store_mime_descr(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.mime_descr.push(value);
            Ok(())
        }
        fn store_mime_alt(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.mime_alt.push(value);
            Ok(())
        }
        fn handle_mime_source<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<MimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.mime_source.len() < 1usize {
                    *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(MimeElementTypeDeserializerState::MimeSource(None));
                    *self.state = MimeElementTypeDeserializerState::MimeDescr(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_source(data)?;
                    *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeElementTypeDeserializerState::MimeSource(
                                Some(deserializer),
                            ));
                            if self.mime_source.len().saturating_add(1) < 1usize {
                                *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                            } else {
                                *self.state = MimeElementTypeDeserializerState::MimeDescr(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeElementTypeDeserializerState::MimeSource(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_descr<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<MimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(MimeElementTypeDeserializerState::MimeDescr(None));
                *self.state = MimeElementTypeDeserializerState::MimeAlt(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_descr(data)?;
                    *self.state = MimeElementTypeDeserializerState::MimeDescr(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeElementTypeDeserializerState::MimeDescr(
                                Some(deserializer),
                            ));
                            *self.state = MimeElementTypeDeserializerState::MimeDescr(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeElementTypeDeserializerState::MimeDescr(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_mime_alt<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<MimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(MimeElementTypeDeserializerState::MimeAlt(None));
                *self.state = MimeElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_mime_alt(data)?;
                    *self.state = MimeElementTypeDeserializerState::MimeAlt(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(MimeElementTypeDeserializerState::MimeAlt(
                                Some(deserializer),
                            ));
                            *self.state = MimeElementTypeDeserializerState::MimeAlt(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                MimeElementTypeDeserializerState::MimeAlt(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::MimeElementType> for MimeElementTypeDeserializer {
        fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::MimeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::MimeElementType>
        where
            R: DeserializeReader,
        {
            use MimeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::MimeSource(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_source(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeDescr(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_descr(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::MimeAlt(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_mime_alt(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = MimeElementTypeDeserializerState::MimeSource(None);
                        event
                    }
                    (S::MimeSource(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_SOURCE",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime_source(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeDescr(None);
                            event
                        }
                    }
                    (S::MimeDescr(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_DESCR",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime_descr(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::MimeAlt(None);
                            event
                        }
                    }
                    (S::MimeAlt(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"MIME_ALT",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_mime_alt(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::MimeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                MimeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::MimeElementType {
                mime_source: self.mime_source,
                mime_descr: self.mime_descr,
                mime_alt: self.mime_alt,
            })
        }
    }
    #[derive(Debug)]
    pub struct InternationalPidElementTypeDeserializer {
        type_: Option<String>,
        content: Option<String>,
        state: Box<InternationalPidElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum InternationalPidElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl InternationalPidElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_,
                content: None,
                state: Box::new(InternationalPidElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: InternationalPidElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let InternationalPidElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::InternationalPidElementType>
        where
            R: DeserializeReader,
        {
            use InternationalPidElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::InternationalPidElementType>
        for InternationalPidElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::InternationalPidElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::InternationalPidElementType>
        where
            R: DeserializeReader,
        {
            use InternationalPidElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::InternationalPidElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                InternationalPidElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::InternationalPidElementType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct BuyerPidElementTypeDeserializer {
        type_: Option<String>,
        content: Option<String>,
        state: Box<BuyerPidElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum BuyerPidElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl BuyerPidElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_,
                content: None,
                state: Box::new(BuyerPidElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: BuyerPidElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let BuyerPidElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::BuyerPidElementType>
        where
            R: DeserializeReader,
        {
            use BuyerPidElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::BuyerPidElementType> for BuyerPidElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BuyerPidElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::BuyerPidElementType>
        where
            R: DeserializeReader,
        {
            use BuyerPidElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::BuyerPidElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                BuyerPidElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::BuyerPidElementType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct SpecialTreatmentClassElementTypeDeserializer {
        type_: String,
        content: Option<String>,
        state: Box<SpecialTreatmentClassElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum SpecialTreatmentClassElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl SpecialTreatmentClassElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                content: None,
                state: Box::new(SpecialTreatmentClassElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: SpecialTreatmentClassElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let SpecialTreatmentClassElementTypeDeserializerState::Content__(deserializer) =
                state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::SpecialTreatmentClassElementType>
        where
            R: DeserializeReader,
        {
            use SpecialTreatmentClassElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::SpecialTreatmentClassElementType>
        for SpecialTreatmentClassElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SpecialTreatmentClassElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::SpecialTreatmentClassElementType>
        where
            R: DeserializeReader,
        {
            use SpecialTreatmentClassElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::SpecialTreatmentClassElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                SpecialTreatmentClassElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::SpecialTreatmentClassElementType {
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductStatusElementTypeDeserializer {
        lang: Option<super::DtLang>,
        type_: super::ProductStatusType,
        content: Option<String>,
        state: Box<ProductStatusElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductStatusElementTypeDeserializerState {
        Init__,
        Content__(<String as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl ProductStatusElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut lang: Option<super::DtLang> = None;
            let mut type_: Option<super::ProductStatusType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"lang")
                ) {
                    reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                lang: lang,
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                content: None,
                state: Box::new(ProductStatusElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductStatusElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let ProductStatusElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(&mut self, value: String) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
        ) -> DeserializerResult<'de, super::ProductStatusElementType>
        where
            R: DeserializeReader,
        {
            use ProductStatusElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de> Deserializer<'de, super::ProductStatusElementType>
        for ProductStatusElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductStatusElementType>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductStatusElementType>
        where
            R: DeserializeReader,
        {
            use ProductStatusElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductStatusElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductStatusElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductStatusElementType {
                lang: self.lang,
                type_: self.type_,
                content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
            })
        }
    }
    #[derive(Debug)]
    pub struct FeatureElementTypeDeserializer {
        fname: Vec<super::DtMlstring>,
        fvalue: Vec<super::DtMlstring>,
        funit: Option<String>,
        fvalue_details: Vec<super::DtMlstring>,
        state: Box<FeatureElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum FeatureElementTypeDeserializerState {
        Init__,
        Fname(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Fvalue(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Funit(Option<<String as WithDeserializer>::Deserializer>),
        FvalueDetails(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl FeatureElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                fname: Vec::new(),
                fvalue: Vec::new(),
                funit: None,
                fvalue_details: Vec::new(),
                state: Box::new(FeatureElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: FeatureElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use FeatureElementTypeDeserializerState as S;
            match state {
                S::Fname(Some(deserializer)) => self.store_fname(deserializer.finish(reader)?)?,
                S::Fvalue(Some(deserializer)) => self.store_fvalue(deserializer.finish(reader)?)?,
                S::Funit(Some(deserializer)) => self.store_funit(deserializer.finish(reader)?)?,
                S::FvalueDetails(Some(deserializer)) => {
                    self.store_fvalue_details(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_fname(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.fname.push(value);
            Ok(())
        }
        fn store_fvalue(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.fvalue.push(value);
            Ok(())
        }
        fn store_funit(&mut self, value: String) -> Result<(), Error> {
            if self.funit.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"FUNIT",
                )))?;
            }
            self.funit = Some(value);
            Ok(())
        }
        fn store_fvalue_details(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.fvalue_details.push(value);
            Ok(())
        }
        fn handle_fname<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<FeatureElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.fname.len() < 1usize {
                    *self.state = FeatureElementTypeDeserializerState::Fname(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(FeatureElementTypeDeserializerState::Fname(None));
                    *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fname(data)?;
                    *self.state = FeatureElementTypeDeserializerState::Fname(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(FeatureElementTypeDeserializerState::Fname(
                                Some(deserializer),
                            ));
                            if self.fname.len().saturating_add(1) < 1usize {
                                *self.state = FeatureElementTypeDeserializerState::Fname(None);
                            } else {
                                *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                FeatureElementTypeDeserializerState::Fname(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_fvalue<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<FeatureElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.fvalue.len() < 1usize {
                    *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(FeatureElementTypeDeserializerState::Fvalue(None));
                    *self.state = FeatureElementTypeDeserializerState::Funit(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fvalue(data)?;
                    *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(FeatureElementTypeDeserializerState::Fvalue(
                                Some(deserializer),
                            ));
                            if self.fvalue.len().saturating_add(1) < 1usize {
                                *self.state = FeatureElementTypeDeserializerState::Fvalue(None);
                            } else {
                                *self.state = FeatureElementTypeDeserializerState::Funit(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                FeatureElementTypeDeserializerState::Fvalue(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_funit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<FeatureElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(FeatureElementTypeDeserializerState::Funit(None));
                *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_funit(data)?;
                    *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(FeatureElementTypeDeserializerState::Funit(
                                Some(deserializer),
                            ));
                            *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                FeatureElementTypeDeserializerState::Funit(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_fvalue_details<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<FeatureElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(FeatureElementTypeDeserializerState::FvalueDetails(None));
                *self.state = FeatureElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_fvalue_details(data)?;
                    *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                FeatureElementTypeDeserializerState::FvalueDetails(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = FeatureElementTypeDeserializerState::FvalueDetails(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = FeatureElementTypeDeserializerState::FvalueDetails(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::FeatureElementType> for FeatureElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::FeatureElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::FeatureElementType>
        where
            R: DeserializeReader,
        {
            use FeatureElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Fname(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fname(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Fvalue(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fvalue(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Funit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_funit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::FvalueDetails(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_fvalue_details(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = FeatureElementTypeDeserializerState::Fname(None);
                        event
                    }
                    (S::Fname(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"FNAME") {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_fname(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Fvalue(None);
                            event
                        }
                    }
                    (S::Fvalue(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"FVALUE")
                        {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_fvalue(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Funit(None);
                            event
                        }
                    }
                    (S::Funit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"FUNIT") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_funit(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::FvalueDetails(None);
                            event
                        }
                    }
                    (S::FvalueDetails(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"FVALUE_DETAILS",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_fvalue_details(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::FeatureElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                FeatureElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::FeatureElementType {
                fname: self.fname,
                fvalue: self.fvalue,
                funit: self.funit,
                fvalue_details: self.fvalue_details,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceDetailsDatetimeElementTypeDeserializer {
        type_: super::ProductPriceDetailsDatetimeType,
        date: Option<String>,
        state: Box<ProductPriceDetailsDatetimeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductPriceDetailsDatetimeElementTypeDeserializerState {
        Init__,
        Date(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductPriceDetailsDatetimeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<super::ProductPriceDetailsDatetimeType> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                type_: type_
                    .ok_or_else(|| reader.map_error(ErrorKind::MissingAttribute("type".into())))?,
                date: None,
                state: Box::new(ProductPriceDetailsDatetimeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductPriceDetailsDatetimeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductPriceDetailsDatetimeElementTypeDeserializerState as S;
            match state {
                S::Date(Some(deserializer)) => self.store_date(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_date(&mut self, value: String) -> Result<(), Error> {
            if self.date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"DATE")))?;
            }
            self.date = Some(value);
            Ok(())
        }
        fn handle_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductPriceDetailsDatetimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.date.is_some() {
                    fallback.get_or_insert(
                        ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(None),
                    );
                    *self.state = ProductPriceDetailsDatetimeElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_date(data)?;
                    *self.state = ProductPriceDetailsDatetimeElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductPriceDetailsDatetimeElementType>
        for ProductPriceDetailsDatetimeElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceDetailsDatetimeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceDetailsDatetimeElementType>
        where
            R: DeserializeReader,
        {
            use ProductPriceDetailsDatetimeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Date(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            ProductPriceDetailsDatetimeElementTypeDeserializerState::Date(None);
                        event
                    }
                    (S::Date(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"DATE") {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_date(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::ProductPriceDetailsDatetimeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductPriceDetailsDatetimeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductPriceDetailsDatetimeElementType {
                type_: self.type_,
                date: self
                    .date
                    .ok_or_else(|| ErrorKind::MissingElement("DATE".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceElementTypeDeserializer {
        price_type: String,
        price_amount: Option<f64>,
        price_currency: Option<super::DtCurrencies>,
        tax: Option<f64>,
        price_factor: Option<f64>,
        lower_bound: Option<f64>,
        territory: Vec<String>,
        state: Box<ProductPriceElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum ProductPriceElementTypeDeserializerState {
        Init__,
        PriceAmount(Option<<f64 as WithDeserializer>::Deserializer>),
        PriceCurrency(Option<<super::DtCurrencies as WithDeserializer>::Deserializer>),
        Tax(Option<<f64 as WithDeserializer>::Deserializer>),
        PriceFactor(Option<<f64 as WithDeserializer>::Deserializer>),
        LowerBound(Option<<f64 as WithDeserializer>::Deserializer>),
        Territory(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl ProductPriceElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut price_type: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"price_type")
                ) {
                    reader.read_attrib(&mut price_type, b"price_type", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok(Self {
                price_type: price_type.ok_or_else(|| {
                    reader.map_error(ErrorKind::MissingAttribute("price_type".into()))
                })?,
                price_amount: None,
                price_currency: None,
                tax: None,
                price_factor: None,
                lower_bound: None,
                territory: Vec::new(),
                state: Box::new(ProductPriceElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: ProductPriceElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use ProductPriceElementTypeDeserializerState as S;
            match state {
                S::PriceAmount(Some(deserializer)) => {
                    self.store_price_amount(deserializer.finish(reader)?)?
                }
                S::PriceCurrency(Some(deserializer)) => {
                    self.store_price_currency(deserializer.finish(reader)?)?
                }
                S::Tax(Some(deserializer)) => self.store_tax(deserializer.finish(reader)?)?,
                S::PriceFactor(Some(deserializer)) => {
                    self.store_price_factor(deserializer.finish(reader)?)?
                }
                S::LowerBound(Some(deserializer)) => {
                    self.store_lower_bound(deserializer.finish(reader)?)?
                }
                S::Territory(Some(deserializer)) => {
                    self.store_territory(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_price_amount(&mut self, value: f64) -> Result<(), Error> {
            if self.price_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_AMOUNT",
                )))?;
            }
            self.price_amount = Some(value);
            Ok(())
        }
        fn store_price_currency(&mut self, value: super::DtCurrencies) -> Result<(), Error> {
            if self.price_currency.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_CURRENCY",
                )))?;
            }
            self.price_currency = Some(value);
            Ok(())
        }
        fn store_tax(&mut self, value: f64) -> Result<(), Error> {
            if self.tax.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"TAX")))?;
            }
            self.tax = Some(value);
            Ok(())
        }
        fn store_price_factor(&mut self, value: f64) -> Result<(), Error> {
            if self.price_factor.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_FACTOR",
                )))?;
            }
            self.price_factor = Some(value);
            Ok(())
        }
        fn store_lower_bound(&mut self, value: f64) -> Result<(), Error> {
            if self.lower_bound.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"LOWER_BOUND",
                )))?;
            }
            self.lower_bound = Some(value);
            Ok(())
        }
        fn store_territory(&mut self, value: String) -> Result<(), Error> {
            self.territory.push(value);
            Ok(())
        }
        fn handle_price_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.price_amount.is_some() {
                    fallback
                        .get_or_insert(ProductPriceElementTypeDeserializerState::PriceAmount(None));
                    *self.state = ProductPriceElementTypeDeserializerState::PriceCurrency(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = ProductPriceElementTypeDeserializerState::PriceAmount(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_amount(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::PriceCurrency(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::PriceAmount(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductPriceElementTypeDeserializerState::PriceCurrency(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::PriceAmount(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_price_currency<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtCurrencies>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::PriceCurrency(
                    None,
                ));
                *self.state = ProductPriceElementTypeDeserializerState::Tax(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_currency(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::Tax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::PriceCurrency(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductPriceElementTypeDeserializerState::Tax(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::PriceCurrency(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_tax<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::Tax(None));
                *self.state = ProductPriceElementTypeDeserializerState::PriceFactor(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_tax(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::PriceFactor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(ProductPriceElementTypeDeserializerState::Tax(
                                Some(deserializer),
                            ));
                            *self.state =
                                ProductPriceElementTypeDeserializerState::PriceFactor(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                ProductPriceElementTypeDeserializerState::Tax(Some(deserializer));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_price_factor<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::PriceFactor(None));
                *self.state = ProductPriceElementTypeDeserializerState::LowerBound(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_factor(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::LowerBound(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::PriceFactor(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                ProductPriceElementTypeDeserializerState::LowerBound(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::PriceFactor(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_lower_bound<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::LowerBound(None));
                *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_lower_bound(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::LowerBound(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::LowerBound(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_territory<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<ProductPriceElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(ProductPriceElementTypeDeserializerState::Territory(None));
                *self.state = ProductPriceElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_territory(data)?;
                    *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                ProductPriceElementTypeDeserializerState::Territory(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = ProductPriceElementTypeDeserializerState::Territory(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = ProductPriceElementTypeDeserializerState::Territory(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::ProductPriceElementType>
        for ProductPriceElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::ProductPriceElementType>
        where
            R: DeserializeReader,
        {
            use ProductPriceElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::PriceAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PriceCurrency(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_currency(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Tax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_tax(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PriceFactor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_factor(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::LowerBound(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_lower_bound(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::Territory(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_territory(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = ProductPriceElementTypeDeserializerState::PriceAmount(None);
                        event
                    }
                    (S::PriceAmount(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_AMOUNT",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_price_amount(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PriceCurrency(None);
                            event
                        }
                    }
                    (S::PriceCurrency(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_CURRENCY",
                        ) {
                            let output =
                                <super::DtCurrencies as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_price_currency(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Tax(None);
                            event
                        }
                    }
                    (S::Tax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(&event, Some(&super::NS_DEFAULT), b"TAX") {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_tax(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PriceFactor(None);
                            event
                        }
                    }
                    (S::PriceFactor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_FACTOR",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_price_factor(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::LowerBound(None);
                            event
                        }
                    }
                    (S::LowerBound(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"LOWER_BOUND",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_lower_bound(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Territory(None);
                            event
                        }
                    }
                    (S::Territory(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"TERRITORY",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_territory(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::ProductPriceElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                ProductPriceElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::ProductPriceElementType {
                price_type: self.price_type,
                price_amount: self
                    .price_amount
                    .ok_or_else(|| ErrorKind::MissingElement("PRICE_AMOUNT".into()))?,
                price_currency: self.price_currency,
                tax: self.tax,
                price_factor: self.price_factor,
                lower_bound: self.lower_bound,
                territory: self.territory,
            })
        }
    }
    #[derive(Debug)]
    pub struct PriceBaseElementTypeDeserializer {
        price_unit: Option<super::DtUnit>,
        price_unit_factor: Option<f32>,
        state: Box<PriceBaseElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum PriceBaseElementTypeDeserializerState {
        Init__,
        PriceUnit(Option<<super::DtUnit as WithDeserializer>::Deserializer>),
        PriceUnitFactor(Option<<f32 as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl PriceBaseElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                price_unit: None,
                price_unit_factor: None,
                state: Box::new(PriceBaseElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: PriceBaseElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use PriceBaseElementTypeDeserializerState as S;
            match state {
                S::PriceUnit(Some(deserializer)) => {
                    self.store_price_unit(deserializer.finish(reader)?)?
                }
                S::PriceUnitFactor(Some(deserializer)) => {
                    self.store_price_unit_factor(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_price_unit(&mut self, value: super::DtUnit) -> Result<(), Error> {
            if self.price_unit.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_UNIT",
                )))?;
            }
            self.price_unit = Some(value);
            Ok(())
        }
        fn store_price_unit_factor(&mut self, value: f32) -> Result<(), Error> {
            if self.price_unit_factor.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"PRICE_UNIT_FACTOR",
                )))?;
            }
            self.price_unit_factor = Some(value);
            Ok(())
        }
        fn handle_price_unit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtUnit>,
            fallback: &mut Option<PriceBaseElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.price_unit.is_some() {
                    fallback.get_or_insert(PriceBaseElementTypeDeserializerState::PriceUnit(None));
                    *self.state = PriceBaseElementTypeDeserializerState::PriceUnitFactor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = PriceBaseElementTypeDeserializerState::PriceUnit(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_unit(data)?;
                    *self.state = PriceBaseElementTypeDeserializerState::PriceUnitFactor(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PriceBaseElementTypeDeserializerState::PriceUnit(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                PriceBaseElementTypeDeserializerState::PriceUnitFactor(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = PriceBaseElementTypeDeserializerState::PriceUnit(Some(
                                deserializer,
                            ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_price_unit_factor<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<PriceBaseElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback
                    .get_or_insert(PriceBaseElementTypeDeserializerState::PriceUnitFactor(None));
                *self.state = PriceBaseElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_price_unit_factor(data)?;
                    *self.state = PriceBaseElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                PriceBaseElementTypeDeserializerState::PriceUnitFactor(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = PriceBaseElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = PriceBaseElementTypeDeserializerState::PriceUnitFactor(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::PriceBaseElementType> for PriceBaseElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PriceBaseElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::PriceBaseElementType>
        where
            R: DeserializeReader,
        {
            use PriceBaseElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::PriceUnit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::PriceUnitFactor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_price_unit_factor(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state = PriceBaseElementTypeDeserializerState::PriceUnit(None);
                        event
                    }
                    (S::PriceUnit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_UNIT",
                        ) {
                            let output = <super::DtUnit as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_price_unit(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::PriceUnitFactor(None);
                            event
                        }
                    }
                    (S::PriceUnitFactor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"PRICE_UNIT_FACTOR",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_price_unit_factor(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::PriceBaseElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                PriceBaseElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::PriceBaseElementType {
                price_unit: self
                    .price_unit
                    .ok_or_else(|| ErrorKind::MissingElement("PRICE_UNIT".into()))?,
                price_unit_factor: self.price_unit_factor,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfMimeInfoElementTypeDeserializer {
        udx_edxf_mime: Vec<super::UdxEdxfMimeElementType>,
        state: Box<UdxEdxfMimeInfoElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfMimeInfoElementTypeDeserializerState {
        Init__,
        UdxEdxfMime(Option<<super::UdxEdxfMimeElementType as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfMimeInfoElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_mime: Vec::new(),
                state: Box::new(UdxEdxfMimeInfoElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfMimeInfoElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfMimeInfoElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfMime(Some(deserializer)) => {
                    self.store_udx_edxf_mime(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_mime(
            &mut self,
            value: super::UdxEdxfMimeElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_mime.push(value);
            Ok(())
        }
        fn handle_udx_edxf_mime<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfMimeElementType>,
            fallback: &mut Option<UdxEdxfMimeInfoElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_mime.len() < 1usize {
                    *self.state = UdxEdxfMimeInfoElementTypeDeserializerState::UdxEdxfMime(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        UdxEdxfMimeInfoElementTypeDeserializerState::UdxEdxfMime(None),
                    );
                    *self.state = UdxEdxfMimeInfoElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime(data)?;
                    *self.state = UdxEdxfMimeInfoElementTypeDeserializerState::UdxEdxfMime(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeInfoElementTypeDeserializerState::UdxEdxfMime(Some(
                                    deserializer,
                                )),
                            );
                            if self.udx_edxf_mime.len().saturating_add(1) < 1usize {
                                *self.state =
                                    UdxEdxfMimeInfoElementTypeDeserializerState::UdxEdxfMime(None);
                            } else {
                                *self.state = UdxEdxfMimeInfoElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxEdxfMimeInfoElementTypeDeserializerState::UdxEdxfMime(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfMimeInfoElementType>
        for UdxEdxfMimeInfoElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfMimeInfoElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfMimeInfoElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfMimeInfoElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfMime(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfMimeInfoElementTypeDeserializerState::UdxEdxfMime(None);
                        event
                    }
                    (S::UdxEdxfMime(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME",
                        ) {
                            let output = < super :: UdxEdxfMimeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_mime(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfMimeInfoElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfMimeInfoElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfMimeInfoElementType {
                udx_edxf_mime: self.udx_edxf_mime,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDiscountGroupElementTypeDeserializer {
        content: Vec<super::UdxEdxfDiscountGroupElementTypeContent>,
        state: Box<UdxEdxfDiscountGroupElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfDiscountGroupElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(
            <super::UdxEdxfDiscountGroupElementTypeContent as WithDeserializer>::Deserializer,
        ),
        Unknown__,
    }
    impl UdxEdxfDiscountGroupElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: Vec::new(),
                state: Box::new(UdxEdxfDiscountGroupElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfDiscountGroupElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfDiscountGroupElementTypeDeserializerState::Content__(deserializer) = state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::UdxEdxfDiscountGroupElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfDiscountGroupElementTypeContent>,
            fallback: &mut Option<UdxEdxfDiscountGroupElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfDiscountGroupElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = UdxEdxfDiscountGroupElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let can_have_more = self.content.len().saturating_add(1) < 2usize;
                    let ret = if can_have_more {
                        ElementHandlerOutput::from_event(event, allow_any)
                    } else {
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    };
                    match (can_have_more, &ret) {
                        (true, ElementHandlerOutput::Continue { .. }) => {
                            fallback.get_or_insert(
                                UdxEdxfDiscountGroupElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state = UdxEdxfDiscountGroupElementTypeDeserializerState::Next__;
                        }
                        (false, _) | (_, ElementHandlerOutput::Break { .. }) => {
                            *self.state =
                                UdxEdxfDiscountGroupElementTypeDeserializerState::Content__(
                                    deserializer,
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfDiscountGroupElementType>
        for UdxEdxfDiscountGroupElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDiscountGroupElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDiscountGroupElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfDiscountGroupElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: UdxEdxfDiscountGroupElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfDiscountGroupElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfDiscountGroupElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfDiscountGroupElementType {
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDiscountGroupElementTypeContentDeserializer {
        state: Box<UdxEdxfDiscountGroupElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum UdxEdxfDiscountGroupElementTypeContentDeserializerState {
        Init__,
        UdxEdxfDiscountGroupManufacturer(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfDiscountGroupSupplier(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        Done__(super::UdxEdxfDiscountGroupElementTypeContent),
        Unknown__,
    }
    impl UdxEdxfDiscountGroupElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<UdxEdxfDiscountGroupElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfDiscountGroupElementTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.DISCOUNT_GROUP_MANUFACTURER")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_discount_group_manufacturer(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.DISCOUNT_GROUP_SUPPLIER")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_discount_group_supplier(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(UdxEdxfDiscountGroupElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: UdxEdxfDiscountGroupElementTypeContentDeserializerState,
        ) -> Result<super::UdxEdxfDiscountGroupElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfDiscountGroupElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::UdxEdxfDiscountGroupManufacturer(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_discount_group_manufacturer(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfDiscountGroupElementTypeContent :: UdxEdxfDiscountGroupManufacturer (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.DISCOUNT_GROUP_MANUFACTURER" . into ())) ?))
                }
                S::UdxEdxfDiscountGroupSupplier(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_discount_group_supplier(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfDiscountGroupElementTypeContent::UdxEdxfDiscountGroupSupplier(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.DISCOUNT_GROUP_SUPPLIER".into())
                            })?,
                        ),
                    )
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_udx_edxf_discount_group_manufacturer(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DISCOUNT_GROUP_MANUFACTURER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_discount_group_supplier(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DISCOUNT_GROUP_SUPPLIER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_discount_group_manufacturer<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfDiscountGroupElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (values , None) , Some (UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (_ , Some (deserializer))) => UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_discount_group_manufacturer (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_discount_group_manufacturer(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (values , None)) ? ;
                    *self.state =
                        UdxEdxfDiscountGroupElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupManufacturer (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_discount_group_supplier<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfDiscountGroupElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (values , None) , Some (UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (_ , Some (deserializer))) => UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_discount_group_supplier (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_discount_group_supplier(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (values , None)) ? ;
                    *self.state =
                        UdxEdxfDiscountGroupElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfDiscountGroupElementTypeContentDeserializerState :: UdxEdxfDiscountGroupSupplier (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfDiscountGroupElementTypeContent>
        for UdxEdxfDiscountGroupElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDiscountGroupElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(UdxEdxfDiscountGroupElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        UdxEdxfDiscountGroupElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfDiscountGroupElementTypeContent>
        where
            R: DeserializeReader,
        {
            use UdxEdxfDiscountGroupElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfDiscountGroupManufacturer(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_discount_group_manufacturer(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfDiscountGroupSupplier(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_discount_group_supplier(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::UdxEdxfDiscountGroupManufacturer(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_discount_group_manufacturer(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfDiscountGroupSupplier(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_discount_group_supplier(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            self,
            reader: &R,
        ) -> Result<super::UdxEdxfDiscountGroupElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfAdditionalFactorsElementTypeDeserializer {
        udx_edxf_additional_price_factor: Option<f64>,
        udx_edxf_additional_factor_info: Vec<super::DtMlstring>,
        state: Box<UdxEdxfAdditionalFactorsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfAdditionalFactorsElementTypeDeserializerState {
        Init__,
        UdxEdxfAdditionalPriceFactor(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfAdditionalFactorInfo(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfAdditionalFactorsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_additional_price_factor: None,
                udx_edxf_additional_factor_info: Vec::new(),
                state: Box::new(UdxEdxfAdditionalFactorsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfAdditionalFactorsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfAdditionalFactorsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfAdditionalPriceFactor(Some(deserializer)) => {
                    self.store_udx_edxf_additional_price_factor(deserializer.finish(reader)?)?
                }
                S::UdxEdxfAdditionalFactorInfo(Some(deserializer)) => {
                    self.store_udx_edxf_additional_factor_info(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_additional_price_factor(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_additional_price_factor.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.ADDITIONAL_PRICE_FACTOR",
                )))?;
            }
            self.udx_edxf_additional_price_factor = Some(value);
            Ok(())
        }
        fn store_udx_edxf_additional_factor_info(
            &mut self,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            self.udx_edxf_additional_factor_info.push(value);
            Ok(())
        }
        fn handle_udx_edxf_additional_price_factor<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfAdditionalFactorsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_additional_price_factor.is_some() {
                    fallback . get_or_insert (UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (None)) ;
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_additional_price_factor(data)?;
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (Some (deserializer))) ;
                            * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_additional_factor_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfAdditionalFactorsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_additional_factor_info.len() < 1usize {
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback . get_or_insert (UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None)) ;
                    *self.state = UdxEdxfAdditionalFactorsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_additional_factor_info(data)?;
                    * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (Some (deserializer))) ;
                            if self.udx_edxf_additional_factor_info.len().saturating_add(1) < 1usize
                            {
                                * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfAdditionalFactorsElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalFactorInfo (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfAdditionalFactorsElementType>
        for UdxEdxfAdditionalFactorsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfAdditionalFactorsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfAdditionalFactorsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfAdditionalFactorsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfAdditionalPriceFactor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_additional_price_factor(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfAdditionalFactorInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_additional_factor_info(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfAdditionalFactorsElementTypeDeserializerState :: UdxEdxfAdditionalPriceFactor (None) ;
                        event
                    }
                    (
                        S::UdxEdxfAdditionalPriceFactor(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.ADDITIONAL_PRICE_FACTOR",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_additional_price_factor(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfAdditionalFactorInfo(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfAdditionalFactorInfo(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.ADDITIONAL_FACTOR_INFO",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_additional_factor_info(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfAdditionalFactorsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfAdditionalFactorsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfAdditionalFactorsElementType {
                udx_edxf_additional_price_factor: self
                    .udx_edxf_additional_price_factor
                    .ok_or_else(|| {
                        ErrorKind::MissingElement("UDX.EDXF.ADDITIONAL_PRICE_FACTOR".into())
                    })?,
                udx_edxf_additional_factor_info: self.udx_edxf_additional_factor_info,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchNumbersElementTypeDeserializer {
        udx_edxf_country_branch_number:
            Vec<super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType>,
        state: Box<UdxEdxfCountryBranchNumbersElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfCountryBranchNumbersElementTypeDeserializerState {
        Init__ , UdxEdxfCountryBranchNumber (Option << super :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl UdxEdxfCountryBranchNumbersElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_country_branch_number: Vec::new(),
                state: Box::new(UdxEdxfCountryBranchNumbersElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfCountryBranchNumbersElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchNumbersElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfCountryBranchNumber(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_number(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_country_branch_number(
            &mut self,
            value: super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_country_branch_number.push(value);
            Ok(())
        }
        fn handle_udx_edxf_country_branch_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<
                'de,
                super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
            >,
            fallback: &mut Option<UdxEdxfCountryBranchNumbersElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_country_branch_number.len() < 1usize {
                    * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback . get_or_insert (UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None)) ;
                    *self.state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_number(data)?;
                    * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (Some (deserializer))) ;
                            if self.udx_edxf_country_branch_number.len().saturating_add(1) < 1usize
                            {
                                * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfCountryBranchNumbersElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfCountryBranchNumbersElementType>
        for UdxEdxfCountryBranchNumbersElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfCountryBranchNumbersElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfCountryBranchNumbersElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchNumbersElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfCountryBranchNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_number(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfCountryBranchNumbersElementTypeDeserializerState :: UdxEdxfCountryBranchNumber (None) ;
                        event
                    }
                    (
                        S::UdxEdxfCountryBranchNumber(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_NUMBER",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_number(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfCountryBranchNumbersElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfCountryBranchNumbersElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfCountryBranchNumbersElementType {
                udx_edxf_country_branch_number: self.udx_edxf_country_branch_number,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchSupplierIdsElementTypeDeserializer {
        udx_edxf_country_branch_supplier_id:
            Vec<super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType>,
        state: Box<UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState {
        Init__ , UdxEdxfCountryBranchSupplierId (Option << super :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
    impl UdxEdxfCountryBranchSupplierIdsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_country_branch_supplier_id: Vec::new(),
                state: Box::new(
                    UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState::Init__,
                ),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfCountryBranchSupplierId(Some(deserializer)) => {
                    self.store_udx_edxf_country_branch_supplier_id(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_country_branch_supplier_id(
            &mut self,
            value: super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_country_branch_supplier_id.push(value);
            Ok(())
        }
        fn handle_udx_edxf_country_branch_supplier_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<
                'de,
                super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
            >,
            fallback: &mut Option<UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_country_branch_supplier_id.len() < 1usize {
                    * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback . get_or_insert (UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None)) ;
                    *self.state =
                        UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_country_branch_supplier_id(data)?;
                    * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (Some (deserializer))) ;
                            if self
                                .udx_edxf_country_branch_supplier_id
                                .len()
                                .saturating_add(1)
                                < 1usize
                            {
                                * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None) ;
                            } else {
                                * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: Done__ ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>
        for UdxEdxfCountryBranchSupplierIdsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfCountryBranchSupplierIdsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfCountryBranchSupplierId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_country_branch_supplier_id(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState :: UdxEdxfCountryBranchSupplierId (None) ;
                        event
                    }
                    (
                        S::UdxEdxfCountryBranchSupplierId(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_ID",
                        ) {
                            let output = < super :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_country_branch_supplier_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfCountryBranchSupplierIdsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfCountryBranchSupplierIdsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfCountryBranchSupplierIdsElementType {
                udx_edxf_country_branch_supplier_id: self.udx_edxf_country_branch_supplier_id,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfPackingUnitsElementTypeDeserializer {
        udx_edxf_packing_unit: Vec<super::UdxEdxfPackingUnitElementType>,
        state: Box<UdxEdxfPackingUnitsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfPackingUnitsElementTypeDeserializerState {
        Init__,
        UdxEdxfPackingUnit(
            Option<<super::UdxEdxfPackingUnitElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl UdxEdxfPackingUnitsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_packing_unit: Vec::new(),
                state: Box::new(UdxEdxfPackingUnitsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfPackingUnitsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfPackingUnitsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfPackingUnit(Some(deserializer)) => {
                    self.store_udx_edxf_packing_unit(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_packing_unit(
            &mut self,
            value: super::UdxEdxfPackingUnitElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_packing_unit.push(value);
            Ok(())
        }
        fn handle_udx_edxf_packing_unit<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfPackingUnitElementType>,
            fallback: &mut Option<UdxEdxfPackingUnitsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_packing_unit.len() < 1usize {
                    *self.state =
                        UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(None),
                    );
                    *self.state = UdxEdxfPackingUnitsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_unit(data)?;
                    *self.state =
                        UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(
                                    Some(deserializer),
                                ),
                            );
                            if self.udx_edxf_packing_unit.len().saturating_add(1) < 1usize {
                                * self . state = UdxEdxfPackingUnitsElementTypeDeserializerState :: UdxEdxfPackingUnit (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfPackingUnitsElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfPackingUnitsElementType>
        for UdxEdxfPackingUnitsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfPackingUnitsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfPackingUnitsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfPackingUnitsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfPackingUnit(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_unit(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfPackingUnitsElementTypeDeserializerState::UdxEdxfPackingUnit(
                                None,
                            );
                        event
                    }
                    (S::UdxEdxfPackingUnit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_UNIT",
                        ) {
                            let output = < super :: UdxEdxfPackingUnitElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_packing_unit(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfPackingUnitsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfPackingUnitsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfPackingUnitsElementType {
                udx_edxf_packing_unit: self.udx_edxf_packing_unit,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductLogisticDetailsElementTypeDeserializer {
        udx_edxf_netvolume: Option<f64>,
        udx_edxf_netweight: Option<f64>,
        udx_edxf_netlength: Option<f64>,
        udx_edxf_netwidth: Option<f64>,
        udx_edxf_netdepth: Option<f64>,
        udx_edxf_netdiameter: Option<f64>,
        udx_edxf_region_of_origin: Option<String>,
        state: Box<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfProductLogisticDetailsElementTypeDeserializerState {
        Init__,
        UdxEdxfNetvolume(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfNetweight(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfNetlength(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfNetwidth(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfNetdepth(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfNetdiameter(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfRegionOfOrigin(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfProductLogisticDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_netvolume: None,
                udx_edxf_netweight: None,
                udx_edxf_netlength: None,
                udx_edxf_netwidth: None,
                udx_edxf_netdepth: None,
                udx_edxf_netdiameter: None,
                udx_edxf_region_of_origin: None,
                state: Box::new(UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfProductLogisticDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductLogisticDetailsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfNetvolume(Some(deserializer)) => {
                    self.store_udx_edxf_netvolume(deserializer.finish(reader)?)?
                }
                S::UdxEdxfNetweight(Some(deserializer)) => {
                    self.store_udx_edxf_netweight(deserializer.finish(reader)?)?
                }
                S::UdxEdxfNetlength(Some(deserializer)) => {
                    self.store_udx_edxf_netlength(deserializer.finish(reader)?)?
                }
                S::UdxEdxfNetwidth(Some(deserializer)) => {
                    self.store_udx_edxf_netwidth(deserializer.finish(reader)?)?
                }
                S::UdxEdxfNetdepth(Some(deserializer)) => {
                    self.store_udx_edxf_netdepth(deserializer.finish(reader)?)?
                }
                S::UdxEdxfNetdiameter(Some(deserializer)) => {
                    self.store_udx_edxf_netdiameter(deserializer.finish(reader)?)?
                }
                S::UdxEdxfRegionOfOrigin(Some(deserializer)) => {
                    self.store_udx_edxf_region_of_origin(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_netvolume(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_netvolume.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NETVOLUME",
                )))?;
            }
            self.udx_edxf_netvolume = Some(value);
            Ok(())
        }
        fn store_udx_edxf_netweight(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_netweight.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NETWEIGHT",
                )))?;
            }
            self.udx_edxf_netweight = Some(value);
            Ok(())
        }
        fn store_udx_edxf_netlength(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_netlength.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NETLENGTH",
                )))?;
            }
            self.udx_edxf_netlength = Some(value);
            Ok(())
        }
        fn store_udx_edxf_netwidth(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_netwidth.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NETWIDTH",
                )))?;
            }
            self.udx_edxf_netwidth = Some(value);
            Ok(())
        }
        fn store_udx_edxf_netdepth(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_netdepth.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NETDEPTH",
                )))?;
            }
            self.udx_edxf_netdepth = Some(value);
            Ok(())
        }
        fn store_udx_edxf_netdiameter(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_netdiameter.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NETDIAMETER",
                )))?;
            }
            self.udx_edxf_netdiameter = Some(value);
            Ok(())
        }
        fn store_udx_edxf_region_of_origin(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_region_of_origin.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REGION_OF_ORIGIN",
                )))?;
            }
            self.udx_edxf_region_of_origin = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_netvolume<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetvolume(
                        None,
                    ),
                );
                *self.state =
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetweight(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_netvolume(data)?;
                    *self.state =
                        UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetweight(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetvolume (Some (deserializer))) ;
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetweight (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetvolume (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_netweight<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetweight(
                        None,
                    ),
                );
                *self.state =
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetlength(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_netweight(data)?;
                    *self.state =
                        UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetlength(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetweight (Some (deserializer))) ;
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetlength (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetweight (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_netlength<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetlength(
                        None,
                    ),
                );
                *self.state =
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetwidth(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_netlength(data)?;
                    *self.state =
                        UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetwidth(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetlength (Some (deserializer))) ;
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetwidth (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetlength (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_netwidth<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetwidth(
                        None,
                    ),
                );
                *self.state =
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetdepth(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_netwidth(data)?;
                    *self.state =
                        UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetdepth(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetwidth (Some (deserializer))) ;
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetdepth (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetwidth (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_netdepth<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetdepth(
                        None,
                    ),
                );
                *self.state =
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetdiameter(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_netdepth(data)?;
                    * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetdiameter (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetdepth (Some (deserializer))) ;
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetdiameter (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetdepth (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_netdiameter<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfProductLogisticDetailsElementTypeDeserializerState::UdxEdxfNetdiameter(
                        None,
                    ),
                );
                * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_netdiameter(data)?;
                    * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetdiameter (Some (deserializer))) ;
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetdiameter (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_region_of_origin<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductLogisticDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (None)) ;
                *self.state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_region_of_origin(data)?;
                    *self.state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (Some (deserializer))) ;
                            *self.state =
                                UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfRegionOfOrigin (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfProductLogisticDetailsElementType>
        for UdxEdxfProductLogisticDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductLogisticDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductLogisticDetailsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductLogisticDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfNetvolume(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_netvolume(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfNetweight(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_netweight(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfNetlength(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_netlength(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfNetwidth(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_netwidth(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfNetdepth(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_netdepth(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfNetdiameter(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_netdiameter(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfRegionOfOrigin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_region_of_origin(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfProductLogisticDetailsElementTypeDeserializerState :: UdxEdxfNetvolume (None) ;
                        event
                    }
                    (S::UdxEdxfNetvolume(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NETVOLUME",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_netvolume(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfNetweight(None);
                            event
                        }
                    }
                    (S::UdxEdxfNetweight(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NETWEIGHT",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_netweight(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfNetlength(None);
                            event
                        }
                    }
                    (S::UdxEdxfNetlength(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NETLENGTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_netlength(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfNetwidth(None);
                            event
                        }
                    }
                    (S::UdxEdxfNetwidth(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NETWIDTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_netwidth(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfNetdepth(None);
                            event
                        }
                    }
                    (S::UdxEdxfNetdepth(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NETDEPTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_netdepth(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfNetdiameter(None);
                            event
                        }
                    }
                    (S::UdxEdxfNetdiameter(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NETDIAMETER",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_netdiameter(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfRegionOfOrigin(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfRegionOfOrigin(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REGION_OF_ORIGIN",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_region_of_origin(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfProductLogisticDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfProductLogisticDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfProductLogisticDetailsElementType {
                udx_edxf_netvolume: self.udx_edxf_netvolume,
                udx_edxf_netweight: self.udx_edxf_netweight,
                udx_edxf_netlength: self.udx_edxf_netlength,
                udx_edxf_netwidth: self.udx_edxf_netwidth,
                udx_edxf_netdepth: self.udx_edxf_netdepth,
                udx_edxf_netdiameter: self.udx_edxf_netdiameter,
                udx_edxf_region_of_origin: self.udx_edxf_region_of_origin,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfReachElementTypeDeserializer {
        udx_edxf_reach_listdate: Option<String>,
        udx_edxf_reach_info: Option<super::UdxEdxfReachInfoElementType>,
        udx_edxf_scip_number: Option<String>,
        udx_edxf_ufi_code: Option<String>,
        state: Box<UdxEdxfReachElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfReachElementTypeDeserializerState {
        Init__,
        UdxEdxfReachListdate(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfReachInfo(
            Option<<super::UdxEdxfReachInfoElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfScipNumber(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfUfiCode(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfReachElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_reach_listdate: None,
                udx_edxf_reach_info: None,
                udx_edxf_scip_number: None,
                udx_edxf_ufi_code: None,
                state: Box::new(UdxEdxfReachElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfReachElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfReachElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfReachListdate(Some(deserializer)) => {
                    self.store_udx_edxf_reach_listdate(deserializer.finish(reader)?)?
                }
                S::UdxEdxfReachInfo(Some(deserializer)) => {
                    self.store_udx_edxf_reach_info(deserializer.finish(reader)?)?
                }
                S::UdxEdxfScipNumber(Some(deserializer)) => {
                    self.store_udx_edxf_scip_number(deserializer.finish(reader)?)?
                }
                S::UdxEdxfUfiCode(Some(deserializer)) => {
                    self.store_udx_edxf_ufi_code(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_reach_listdate(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_reach_listdate.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REACH.LISTDATE",
                )))?;
            }
            self.udx_edxf_reach_listdate = Some(value);
            Ok(())
        }
        fn store_udx_edxf_reach_info(
            &mut self,
            value: super::UdxEdxfReachInfoElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_reach_info.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REACH.INFO",
                )))?;
            }
            self.udx_edxf_reach_info = Some(value);
            Ok(())
        }
        fn store_udx_edxf_scip_number(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_scip_number.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SCIP_NUMBER",
                )))?;
            }
            self.udx_edxf_scip_number = Some(value);
            Ok(())
        }
        fn store_udx_edxf_ufi_code(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_ufi_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.UFI_CODE",
                )))?;
            }
            self.udx_edxf_ufi_code = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_reach_listdate<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfReachElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachListdate(None),
                );
                *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_reach_listdate(data)?;
                    *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachListdate(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachListdate(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_reach_info<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfReachInfoElementType>,
            fallback: &mut Option<UdxEdxfReachElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_reach_info.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None),
                    );
                    *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfScipNumber(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_reach_info(data)?;
                    *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfScipNumber(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfScipNumber(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachInfo(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_scip_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfReachElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfReachElementTypeDeserializerState::UdxEdxfScipNumber(None),
                );
                *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfUfiCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_scip_number(data)?;
                    *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfUfiCode(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfScipNumber(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfUfiCode(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfScipNumber(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_ufi_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfReachElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxEdxfReachElementTypeDeserializerState::UdxEdxfUfiCode(
                    None,
                ));
                *self.state = UdxEdxfReachElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_ufi_code(data)?;
                    *self.state = UdxEdxfReachElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfReachElementTypeDeserializerState::UdxEdxfUfiCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxEdxfReachElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxEdxfReachElementTypeDeserializerState::UdxEdxfUfiCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfReachElementType>
        for UdxEdxfReachElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfReachElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfReachElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfReachElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfReachListdate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_reach_listdate(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfReachInfo(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_reach_info(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfScipNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_scip_number(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfUfiCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_ufi_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfReachElementTypeDeserializerState::UdxEdxfReachListdate(None);
                        event
                    }
                    (
                        S::UdxEdxfReachListdate(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REACH.LISTDATE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_reach_listdate(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfReachInfo(None);
                            event
                        }
                    }
                    (S::UdxEdxfReachInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REACH.INFO",
                        ) {
                            let output = < super :: UdxEdxfReachInfoElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_reach_info(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfScipNumber(None);
                            event
                        }
                    }
                    (S::UdxEdxfScipNumber(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SCIP_NUMBER",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_scip_number(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfUfiCode(None);
                            event
                        }
                    }
                    (S::UdxEdxfUfiCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.UFI_CODE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_ufi_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfReachElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfReachElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfReachElementType {
                udx_edxf_reach_listdate: self.udx_edxf_reach_listdate,
                udx_edxf_reach_info: self
                    .udx_edxf_reach_info
                    .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.REACH.INFO".into()))?,
                udx_edxf_scip_number: self.udx_edxf_scip_number,
                udx_edxf_ufi_code: self.udx_edxf_ufi_code,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializer {
        udx_edxf_hazardous_substances: Vec<super::UdxEdxfHazardousSubstancesElementType>,
        udx_edxf_shipping_name: Option<super::DtMlstring>,
        udx_edxf_packing_group: Option<super::UdxEdxfPackingGroupElementType>,
        udx_edxf_transport_category: Option<i32>,
        udx_edxf_multiplication_factor: Option<i32>,
        udx_edxf_limited_quantities: Option<String>,
        udx_edxf_excepted_quantities: Option<String>,
        udx_edxf_aggregation_state: Option<super::UdxEdxfAggregationStateElementType>,
        udx_edxf_special_provision_id: Vec<String>,
        udx_edxf_hazard_class: Vec<super::UdxEdxfHazardClassElementType>,
        udx_edxf_classification_code: Option<String>,
        udx_edxf_hazard_label: Vec<String>,
        udx_edxf_environmental_hazards: Option<String>,
        udx_edxf_tunnel_code: Option<super::UdxEdxfTunnelCodeElementType>,
        udx_edxf_ghs_label_code: Vec<super::UdxEdxfGhsLabelCodeElementType>,
        udx_edxf_ghs_signal_word: Option<super::UdxEdxfGhsSignalWordElementType>,
        udx_edxf_hazard_statement: Vec<String>,
        udx_edxf_precautionary_statement: Vec<String>,
        udx_edxf_li_ion_tested: Option<String>,
        udx_edxf_lithium_amount: Option<f64>,
        udx_edxf_battery_energy: Option<f64>,
        udx_edxf_nos_274: Option<String>,
        udx_edxf_hazard_trigger: Vec<String>,
        state: Box<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState {
        Init__,
        UdxEdxfHazardousSubstances(
            Option<
                <super::UdxEdxfHazardousSubstancesElementType as WithDeserializer>::Deserializer,
            >,
        ),
        UdxEdxfShippingName(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        UdxEdxfPackingGroup(
            Option<<super::UdxEdxfPackingGroupElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfTransportCategory(Option<<i32 as WithDeserializer>::Deserializer>),
        UdxEdxfMultiplicationFactor(Option<<i32 as WithDeserializer>::Deserializer>),
        UdxEdxfLimitedQuantities(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfExceptedQuantities(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfAggregationState(
            Option<<super::UdxEdxfAggregationStateElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfSpecialProvisionId(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfHazardClass(
            Option<<super::UdxEdxfHazardClassElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfClassificationCode(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfHazardLabel(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfEnvironmentalHazards(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfTunnelCode(
            Option<<super::UdxEdxfTunnelCodeElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfGhsLabelCode(
            Option<<super::UdxEdxfGhsLabelCodeElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfGhsSignalWord(
            Option<<super::UdxEdxfGhsSignalWordElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfHazardStatement(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfPrecautionaryStatement(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfLiIonTested(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfLithiumAmount(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfBatteryEnergy(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfNos274(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfHazardTrigger(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_hazardous_substances: Vec::new(),
                udx_edxf_shipping_name: None,
                udx_edxf_packing_group: None,
                udx_edxf_transport_category: None,
                udx_edxf_multiplication_factor: None,
                udx_edxf_limited_quantities: None,
                udx_edxf_excepted_quantities: None,
                udx_edxf_aggregation_state: None,
                udx_edxf_special_provision_id: Vec::new(),
                udx_edxf_hazard_class: Vec::new(),
                udx_edxf_classification_code: None,
                udx_edxf_hazard_label: Vec::new(),
                udx_edxf_environmental_hazards: None,
                udx_edxf_tunnel_code: None,
                udx_edxf_ghs_label_code: Vec::new(),
                udx_edxf_ghs_signal_word: None,
                udx_edxf_hazard_statement: Vec::new(),
                udx_edxf_precautionary_statement: Vec::new(),
                udx_edxf_li_ion_tested: None,
                udx_edxf_lithium_amount: None,
                udx_edxf_battery_energy: None,
                udx_edxf_nos_274: None,
                udx_edxf_hazard_trigger: Vec::new(),
                state: Box::new(
                    UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState::Init__,
                ),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfHazardousSubstances(Some(deserializer)) => {
                    self.store_udx_edxf_hazardous_substances(deserializer.finish(reader)?)?
                }
                S::UdxEdxfShippingName(Some(deserializer)) => {
                    self.store_udx_edxf_shipping_name(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackingGroup(Some(deserializer)) => {
                    self.store_udx_edxf_packing_group(deserializer.finish(reader)?)?
                }
                S::UdxEdxfTransportCategory(Some(deserializer)) => {
                    self.store_udx_edxf_transport_category(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMultiplicationFactor(Some(deserializer)) => {
                    self.store_udx_edxf_multiplication_factor(deserializer.finish(reader)?)?
                }
                S::UdxEdxfLimitedQuantities(Some(deserializer)) => {
                    self.store_udx_edxf_limited_quantities(deserializer.finish(reader)?)?
                }
                S::UdxEdxfExceptedQuantities(Some(deserializer)) => {
                    self.store_udx_edxf_excepted_quantities(deserializer.finish(reader)?)?
                }
                S::UdxEdxfAggregationState(Some(deserializer)) => {
                    self.store_udx_edxf_aggregation_state(deserializer.finish(reader)?)?
                }
                S::UdxEdxfSpecialProvisionId(Some(deserializer)) => {
                    self.store_udx_edxf_special_provision_id(deserializer.finish(reader)?)?
                }
                S::UdxEdxfHazardClass(Some(deserializer)) => {
                    self.store_udx_edxf_hazard_class(deserializer.finish(reader)?)?
                }
                S::UdxEdxfClassificationCode(Some(deserializer)) => {
                    self.store_udx_edxf_classification_code(deserializer.finish(reader)?)?
                }
                S::UdxEdxfHazardLabel(Some(deserializer)) => {
                    self.store_udx_edxf_hazard_label(deserializer.finish(reader)?)?
                }
                S::UdxEdxfEnvironmentalHazards(Some(deserializer)) => {
                    self.store_udx_edxf_environmental_hazards(deserializer.finish(reader)?)?
                }
                S::UdxEdxfTunnelCode(Some(deserializer)) => {
                    self.store_udx_edxf_tunnel_code(deserializer.finish(reader)?)?
                }
                S::UdxEdxfGhsLabelCode(Some(deserializer)) => {
                    self.store_udx_edxf_ghs_label_code(deserializer.finish(reader)?)?
                }
                S::UdxEdxfGhsSignalWord(Some(deserializer)) => {
                    self.store_udx_edxf_ghs_signal_word(deserializer.finish(reader)?)?
                }
                S::UdxEdxfHazardStatement(Some(deserializer)) => {
                    self.store_udx_edxf_hazard_statement(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPrecautionaryStatement(Some(deserializer)) => {
                    self.store_udx_edxf_precautionary_statement(deserializer.finish(reader)?)?
                }
                S::UdxEdxfLiIonTested(Some(deserializer)) => {
                    self.store_udx_edxf_li_ion_tested(deserializer.finish(reader)?)?
                }
                S::UdxEdxfLithiumAmount(Some(deserializer)) => {
                    self.store_udx_edxf_lithium_amount(deserializer.finish(reader)?)?
                }
                S::UdxEdxfBatteryEnergy(Some(deserializer)) => {
                    self.store_udx_edxf_battery_energy(deserializer.finish(reader)?)?
                }
                S::UdxEdxfNos274(Some(deserializer)) => {
                    self.store_udx_edxf_nos_274(deserializer.finish(reader)?)?
                }
                S::UdxEdxfHazardTrigger(Some(deserializer)) => {
                    self.store_udx_edxf_hazard_trigger(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_hazardous_substances(
            &mut self,
            value: super::UdxEdxfHazardousSubstancesElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_hazardous_substances.push(value);
            Ok(())
        }
        fn store_udx_edxf_shipping_name(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            if self.udx_edxf_shipping_name.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SHIPPING_NAME",
                )))?;
            }
            self.udx_edxf_shipping_name = Some(value);
            Ok(())
        }
        fn store_udx_edxf_packing_group(
            &mut self,
            value: super::UdxEdxfPackingGroupElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_packing_group.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PACKING_GROUP",
                )))?;
            }
            self.udx_edxf_packing_group = Some(value);
            Ok(())
        }
        fn store_udx_edxf_transport_category(&mut self, value: i32) -> Result<(), Error> {
            if self.udx_edxf_transport_category.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.TRANSPORT_CATEGORY",
                )))?;
            }
            self.udx_edxf_transport_category = Some(value);
            Ok(())
        }
        fn store_udx_edxf_multiplication_factor(&mut self, value: i32) -> Result<(), Error> {
            if self.udx_edxf_multiplication_factor.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MULTIPLICATION_FACTOR",
                )))?;
            }
            self.udx_edxf_multiplication_factor = Some(value);
            Ok(())
        }
        fn store_udx_edxf_limited_quantities(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_limited_quantities.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.LIMITED_QUANTITIES",
                )))?;
            }
            self.udx_edxf_limited_quantities = Some(value);
            Ok(())
        }
        fn store_udx_edxf_excepted_quantities(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_excepted_quantities.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.EXCEPTED_QUANTITIES",
                )))?;
            }
            self.udx_edxf_excepted_quantities = Some(value);
            Ok(())
        }
        fn store_udx_edxf_aggregation_state(
            &mut self,
            value: super::UdxEdxfAggregationStateElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_aggregation_state.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.AGGREGATION_STATE",
                )))?;
            }
            self.udx_edxf_aggregation_state = Some(value);
            Ok(())
        }
        fn store_udx_edxf_special_provision_id(&mut self, value: String) -> Result<(), Error> {
            self.udx_edxf_special_provision_id.push(value);
            Ok(())
        }
        fn store_udx_edxf_hazard_class(
            &mut self,
            value: super::UdxEdxfHazardClassElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_hazard_class.push(value);
            Ok(())
        }
        fn store_udx_edxf_classification_code(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_classification_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.CLASSIFICATION_CODE",
                )))?;
            }
            self.udx_edxf_classification_code = Some(value);
            Ok(())
        }
        fn store_udx_edxf_hazard_label(&mut self, value: String) -> Result<(), Error> {
            self.udx_edxf_hazard_label.push(value);
            Ok(())
        }
        fn store_udx_edxf_environmental_hazards(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_environmental_hazards.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.ENVIRONMENTAL_HAZARDS",
                )))?;
            }
            self.udx_edxf_environmental_hazards = Some(value);
            Ok(())
        }
        fn store_udx_edxf_tunnel_code(
            &mut self,
            value: super::UdxEdxfTunnelCodeElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_tunnel_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.TUNNEL_CODE",
                )))?;
            }
            self.udx_edxf_tunnel_code = Some(value);
            Ok(())
        }
        fn store_udx_edxf_ghs_label_code(
            &mut self,
            value: super::UdxEdxfGhsLabelCodeElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_ghs_label_code.push(value);
            Ok(())
        }
        fn store_udx_edxf_ghs_signal_word(
            &mut self,
            value: super::UdxEdxfGhsSignalWordElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_ghs_signal_word.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.GHS_SIGNAL_WORD",
                )))?;
            }
            self.udx_edxf_ghs_signal_word = Some(value);
            Ok(())
        }
        fn store_udx_edxf_hazard_statement(&mut self, value: String) -> Result<(), Error> {
            self.udx_edxf_hazard_statement.push(value);
            Ok(())
        }
        fn store_udx_edxf_precautionary_statement(&mut self, value: String) -> Result<(), Error> {
            self.udx_edxf_precautionary_statement.push(value);
            Ok(())
        }
        fn store_udx_edxf_li_ion_tested(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_li_ion_tested.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.LI-ION_TESTED",
                )))?;
            }
            self.udx_edxf_li_ion_tested = Some(value);
            Ok(())
        }
        fn store_udx_edxf_lithium_amount(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_lithium_amount.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.LITHIUM_AMOUNT",
                )))?;
            }
            self.udx_edxf_lithium_amount = Some(value);
            Ok(())
        }
        fn store_udx_edxf_battery_energy(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_battery_energy.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.BATTERY_ENERGY",
                )))?;
            }
            self.udx_edxf_battery_energy = Some(value);
            Ok(())
        }
        fn store_udx_edxf_nos_274(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_nos_274.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NOS_274",
                )))?;
            }
            self.udx_edxf_nos_274 = Some(value);
            Ok(())
        }
        fn store_udx_edxf_hazard_trigger(&mut self, value: String) -> Result<(), Error> {
            self.udx_edxf_hazard_trigger.push(value);
            Ok(())
        }
        fn handle_udx_edxf_hazardous_substances<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfHazardousSubstancesElementType>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardousSubstances (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfShippingName (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_hazardous_substances(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardousSubstances (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardousSubstances (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardousSubstances (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardousSubstances (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_shipping_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfShippingName (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPackingGroup (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_shipping_name(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPackingGroup (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfShippingName (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPackingGroup (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfShippingName (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_packing_group<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfPackingGroupElementType>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPackingGroup (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTransportCategory (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_group(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTransportCategory (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPackingGroup (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTransportCategory (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPackingGroup (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_transport_category<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTransportCategory (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfMultiplicationFactor (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_transport_category(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfMultiplicationFactor (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTransportCategory (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfMultiplicationFactor (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTransportCategory (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_multiplication_factor<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfMultiplicationFactor (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLimitedQuantities (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_multiplication_factor(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLimitedQuantities (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfMultiplicationFactor (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLimitedQuantities (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfMultiplicationFactor (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_limited_quantities<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLimitedQuantities (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfExceptedQuantities (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_limited_quantities(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfExceptedQuantities (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLimitedQuantities (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfExceptedQuantities (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLimitedQuantities (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_excepted_quantities<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfExceptedQuantities (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfAggregationState (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_excepted_quantities(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfAggregationState (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfExceptedQuantities (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfAggregationState (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfExceptedQuantities (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_aggregation_state<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfAggregationStateElementType>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfAggregationState (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfSpecialProvisionId (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_aggregation_state(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfSpecialProvisionId (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfAggregationState (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfSpecialProvisionId (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfAggregationState (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_special_provision_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfSpecialProvisionId (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardClass (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_special_provision_id(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfSpecialProvisionId (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfSpecialProvisionId (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfSpecialProvisionId (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfSpecialProvisionId (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_hazard_class<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfHazardClassElementType>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardClass (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfClassificationCode (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_hazard_class(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardClass (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardClass (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardClass (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardClass (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_classification_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfClassificationCode (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardLabel (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_classification_code(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardLabel (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfClassificationCode (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardLabel (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfClassificationCode (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_hazard_label<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardLabel (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfEnvironmentalHazards (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_hazard_label(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardLabel (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardLabel (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardLabel (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardLabel (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_environmental_hazards<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfEnvironmentalHazards (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTunnelCode (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_environmental_hazards(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTunnelCode (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfEnvironmentalHazards (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTunnelCode (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfEnvironmentalHazards (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_tunnel_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfTunnelCodeElementType>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTunnelCode (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsLabelCode (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_tunnel_code(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsLabelCode (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTunnelCode (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsLabelCode (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfTunnelCode (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_ghs_label_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfGhsLabelCodeElementType>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsLabelCode (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsSignalWord (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_ghs_label_code(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsLabelCode (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsLabelCode (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsLabelCode (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsLabelCode (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_ghs_signal_word<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfGhsSignalWordElementType>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsSignalWord (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardStatement (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_ghs_signal_word(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardStatement (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsSignalWord (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardStatement (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfGhsSignalWord (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_hazard_statement<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardStatement (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPrecautionaryStatement (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_hazard_statement(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardStatement (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardStatement (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardStatement (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardStatement (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_precautionary_statement<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPrecautionaryStatement (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLiIonTested (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_precautionary_statement(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPrecautionaryStatement (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPrecautionaryStatement (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPrecautionaryStatement (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfPrecautionaryStatement (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_li_ion_tested<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLiIonTested (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLithiumAmount (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_li_ion_tested(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLithiumAmount (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLiIonTested (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLithiumAmount (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLiIonTested (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_lithium_amount<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLithiumAmount (None)) ;
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfBatteryEnergy (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_lithium_amount(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfBatteryEnergy (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLithiumAmount (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfBatteryEnergy (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfLithiumAmount (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_battery_energy<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfBatteryEnergy (None)) ;
                *self.state =
                    UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState::UdxEdxfNos274(
                        None,
                    );
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_battery_energy(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfNos274 (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfBatteryEnergy (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfNos274 (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfBatteryEnergy (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_nos_274<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState::UdxEdxfNos274(
                        None,
                    ),
                );
                * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardTrigger (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_nos_274(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardTrigger (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfNos274 (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardTrigger (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfNos274 (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_hazard_trigger<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardTrigger (None)) ;
                *self.state =
                    UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_hazard_trigger(data)?;
                    * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardTrigger (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardTrigger (Some (deserializer))) ;
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardTrigger (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardTrigger (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfSpecialTreatmentClassDetailsElementType>
        for UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSpecialTreatmentClassDetailsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSpecialTreatmentClassDetailsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfHazardousSubstances(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_hazardous_substances(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfShippingName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_shipping_name(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackingGroup(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_group(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfTransportCategory(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_transport_category(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMultiplicationFactor(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_multiplication_factor(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfLimitedQuantities(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_limited_quantities(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfExceptedQuantities(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_excepted_quantities(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfAggregationState(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_aggregation_state(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfSpecialProvisionId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_special_provision_id(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfHazardClass(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_hazard_class(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfClassificationCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_classification_code(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfHazardLabel(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_hazard_label(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfEnvironmentalHazards(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_environmental_hazards(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfTunnelCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_tunnel_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfGhsLabelCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_ghs_label_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfGhsSignalWord(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_ghs_signal_word(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfHazardStatement(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_hazard_statement(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPrecautionaryStatement(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_precautionary_statement(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfLiIonTested(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_li_ion_tested(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfLithiumAmount(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_lithium_amount(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfBatteryEnergy(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_battery_energy(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfNos274(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_nos_274(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfHazardTrigger(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_hazard_trigger(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState :: UdxEdxfHazardousSubstances (None) ;
                        event
                    }
                    (
                        S::UdxEdxfHazardousSubstances(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.HAZARDOUS_SUBSTANCES",
                        ) {
                            let output = < super :: UdxEdxfHazardousSubstancesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_hazardous_substances(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfShippingName(None);
                            event
                        }
                    }
                    (S::UdxEdxfShippingName(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SHIPPING_NAME",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_shipping_name(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackingGroup(None);
                            event
                        }
                    }
                    (S::UdxEdxfPackingGroup(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_GROUP",
                        ) {
                            let output = < super :: UdxEdxfPackingGroupElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_packing_group(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfTransportCategory(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfTransportCategory(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.TRANSPORT_CATEGORY",
                        ) {
                            let output =
                                <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_transport_category(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMultiplicationFactor(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfMultiplicationFactor(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MULTIPLICATION_FACTOR",
                        ) {
                            let output =
                                <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_multiplication_factor(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfLimitedQuantities(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfLimitedQuantities(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.LIMITED_QUANTITIES",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_limited_quantities(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfExceptedQuantities(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfExceptedQuantities(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.EXCEPTED_QUANTITIES",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_excepted_quantities(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfAggregationState(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfAggregationState(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.AGGREGATION_STATE",
                        ) {
                            let output = < super :: UdxEdxfAggregationStateElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_aggregation_state(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfSpecialProvisionId(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfSpecialProvisionId(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SPECIAL_PROVISION_ID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_special_provision_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfHazardClass(None);
                            event
                        }
                    }
                    (S::UdxEdxfHazardClass(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.HAZARD_CLASS",
                        ) {
                            let output = < super :: UdxEdxfHazardClassElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_hazard_class(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfClassificationCode(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfClassificationCode(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.CLASSIFICATION_CODE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_classification_code(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfHazardLabel(None);
                            event
                        }
                    }
                    (S::UdxEdxfHazardLabel(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.HAZARD_LABEL",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_hazard_label(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfEnvironmentalHazards(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfEnvironmentalHazards(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.ENVIRONMENTAL_HAZARDS",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_environmental_hazards(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfTunnelCode(None);
                            event
                        }
                    }
                    (S::UdxEdxfTunnelCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.TUNNEL_CODE",
                        ) {
                            let output = < super :: UdxEdxfTunnelCodeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_tunnel_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfGhsLabelCode(None);
                            event
                        }
                    }
                    (S::UdxEdxfGhsLabelCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.GHS_LABEL_CODE",
                        ) {
                            let output = < super :: UdxEdxfGhsLabelCodeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_ghs_label_code(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfGhsSignalWord(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfGhsSignalWord(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.GHS_SIGNAL_WORD",
                        ) {
                            let output = < super :: UdxEdxfGhsSignalWordElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_ghs_signal_word(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfHazardStatement(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfHazardStatement(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.HAZARD_STATEMENT",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_hazard_statement(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPrecautionaryStatement(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfPrecautionaryStatement(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRECAUTIONARY_STATEMENT",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_precautionary_statement(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfLiIonTested(None);
                            event
                        }
                    }
                    (S::UdxEdxfLiIonTested(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.LI-ION_TESTED",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_li_ion_tested(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfLithiumAmount(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfLithiumAmount(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.LITHIUM_AMOUNT",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_lithium_amount(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfBatteryEnergy(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfBatteryEnergy(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.BATTERY_ENERGY",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_battery_energy(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfNos274(None);
                            event
                        }
                    }
                    (S::UdxEdxfNos274(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NOS_274",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_nos_274(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfHazardTrigger(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfHazardTrigger(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.HAZARD_TRIGGER",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_hazard_trigger(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfSpecialTreatmentClassDetailsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfSpecialTreatmentClassDetailsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfSpecialTreatmentClassDetailsElementType {
                udx_edxf_hazardous_substances: self.udx_edxf_hazardous_substances,
                udx_edxf_shipping_name: self.udx_edxf_shipping_name,
                udx_edxf_packing_group: self.udx_edxf_packing_group,
                udx_edxf_transport_category: self.udx_edxf_transport_category,
                udx_edxf_multiplication_factor: self.udx_edxf_multiplication_factor,
                udx_edxf_limited_quantities: self.udx_edxf_limited_quantities,
                udx_edxf_excepted_quantities: self.udx_edxf_excepted_quantities,
                udx_edxf_aggregation_state: self.udx_edxf_aggregation_state,
                udx_edxf_special_provision_id: self.udx_edxf_special_provision_id,
                udx_edxf_hazard_class: self.udx_edxf_hazard_class,
                udx_edxf_classification_code: self.udx_edxf_classification_code,
                udx_edxf_hazard_label: self.udx_edxf_hazard_label,
                udx_edxf_environmental_hazards: self.udx_edxf_environmental_hazards,
                udx_edxf_tunnel_code: self.udx_edxf_tunnel_code,
                udx_edxf_ghs_label_code: self.udx_edxf_ghs_label_code,
                udx_edxf_ghs_signal_word: self.udx_edxf_ghs_signal_word,
                udx_edxf_hazard_statement: self.udx_edxf_hazard_statement,
                udx_edxf_precautionary_statement: self.udx_edxf_precautionary_statement,
                udx_edxf_li_ion_tested: self.udx_edxf_li_ion_tested,
                udx_edxf_lithium_amount: self.udx_edxf_lithium_amount,
                udx_edxf_battery_energy: self.udx_edxf_battery_energy,
                udx_edxf_nos_274: self.udx_edxf_nos_274,
                udx_edxf_hazard_trigger: self.udx_edxf_hazard_trigger,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeListElementTypeDeserializer {
        udx_edxf_surcharge: Vec<super::UdxEdxfSurchargeElementType>,
        state: Box<UdxEdxfSurchargeListElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfSurchargeListElementTypeDeserializerState {
        Init__,
        UdxEdxfSurcharge(
            Option<<super::UdxEdxfSurchargeElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl UdxEdxfSurchargeListElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_surcharge: Vec::new(),
                state: Box::new(UdxEdxfSurchargeListElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfSurchargeListElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeListElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfSurcharge(Some(deserializer)) => {
                    self.store_udx_edxf_surcharge(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_surcharge(
            &mut self,
            value: super::UdxEdxfSurchargeElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_surcharge.push(value);
            Ok(())
        }
        fn handle_udx_edxf_surcharge<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfSurchargeElementType>,
            fallback: &mut Option<UdxEdxfSurchargeListElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_surcharge.len() < 1usize {
                    *self.state =
                        UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(None),
                    );
                    *self.state = UdxEdxfSurchargeListElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_surcharge(data)?;
                    *self.state =
                        UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(
                                    Some(deserializer),
                                ),
                            );
                            if self.udx_edxf_surcharge.len().saturating_add(1) < 1usize {
                                * self . state = UdxEdxfSurchargeListElementTypeDeserializerState :: UdxEdxfSurcharge (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfSurchargeListElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfSurchargeListElementType>
        for UdxEdxfSurchargeListElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeListElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeListElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeListElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfSurcharge(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfSurchargeListElementTypeDeserializerState::UdxEdxfSurcharge(
                                None,
                            );
                        event
                    }
                    (S::UdxEdxfSurcharge(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.SURCHARGE",
                        ) {
                            let output = < super :: UdxEdxfSurchargeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_surcharge(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfSurchargeListElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfSurchargeListElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfSurchargeListElementType {
                udx_edxf_surcharge: self.udx_edxf_surcharge,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfWarrantyElementTypeDeserializer {
        udx_edxf_warranty_business: Option<i32>,
        udx_edxf_warranty_consumer: Option<i32>,
        state: Box<UdxEdxfWarrantyElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfWarrantyElementTypeDeserializerState {
        Init__,
        UdxEdxfWarrantyBusiness(Option<<i32 as WithDeserializer>::Deserializer>),
        UdxEdxfWarrantyConsumer(Option<<i32 as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfWarrantyElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_warranty_business: None,
                udx_edxf_warranty_consumer: None,
                state: Box::new(UdxEdxfWarrantyElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfWarrantyElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfWarrantyElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfWarrantyBusiness(Some(deserializer)) => {
                    self.store_udx_edxf_warranty_business(deserializer.finish(reader)?)?
                }
                S::UdxEdxfWarrantyConsumer(Some(deserializer)) => {
                    self.store_udx_edxf_warranty_consumer(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_warranty_business(&mut self, value: i32) -> Result<(), Error> {
            if self.udx_edxf_warranty_business.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.WARRANTY_BUSINESS",
                )))?;
            }
            self.udx_edxf_warranty_business = Some(value);
            Ok(())
        }
        fn store_udx_edxf_warranty_consumer(&mut self, value: i32) -> Result<(), Error> {
            if self.udx_edxf_warranty_consumer.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.WARRANTY_CONSUMER",
                )))?;
            }
            self.udx_edxf_warranty_consumer = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_warranty_business<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfWarrantyElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfWarrantyElementTypeDeserializerState::UdxEdxfWarrantyBusiness(None),
                );
                *self.state =
                    UdxEdxfWarrantyElementTypeDeserializerState::UdxEdxfWarrantyConsumer(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_warranty_business(data)?;
                    *self.state =
                        UdxEdxfWarrantyElementTypeDeserializerState::UdxEdxfWarrantyConsumer(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfWarrantyElementTypeDeserializerState :: UdxEdxfWarrantyBusiness (Some (deserializer))) ;
                            * self . state = UdxEdxfWarrantyElementTypeDeserializerState :: UdxEdxfWarrantyConsumer (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfWarrantyElementTypeDeserializerState :: UdxEdxfWarrantyBusiness (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_warranty_consumer<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfWarrantyElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfWarrantyElementTypeDeserializerState::UdxEdxfWarrantyConsumer(None),
                );
                *self.state = UdxEdxfWarrantyElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_warranty_consumer(data)?;
                    *self.state = UdxEdxfWarrantyElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfWarrantyElementTypeDeserializerState :: UdxEdxfWarrantyConsumer (Some (deserializer))) ;
                            *self.state = UdxEdxfWarrantyElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfWarrantyElementTypeDeserializerState :: UdxEdxfWarrantyConsumer (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfWarrantyElementType>
        for UdxEdxfWarrantyElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfWarrantyElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfWarrantyElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfWarrantyElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfWarrantyBusiness(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_warranty_business(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfWarrantyConsumer(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_warranty_consumer(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfWarrantyElementTypeDeserializerState::UdxEdxfWarrantyBusiness(
                                None,
                            );
                        event
                    }
                    (
                        S::UdxEdxfWarrantyBusiness(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.WARRANTY_BUSINESS",
                        ) {
                            let output =
                                <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_warranty_business(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfWarrantyConsumer(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfWarrantyConsumer(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.WARRANTY_CONSUMER",
                        ) {
                            let output =
                                <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_warranty_consumer(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfWarrantyElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfWarrantyElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfWarrantyElementType {
                udx_edxf_warranty_business: self.udx_edxf_warranty_business,
                udx_edxf_warranty_consumer: self.udx_edxf_warranty_consumer,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductEtimDynamicElementTypeDeserializer {
        udx_edxf_product_etim_release_date: Option<String>,
        state: Box<UdxEdxfProductEtimDynamicElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfProductEtimDynamicElementTypeDeserializerState {
        Init__,
        UdxEdxfProductEtimReleaseDate(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfProductEtimDynamicElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_product_etim_release_date: None,
                state: Box::new(UdxEdxfProductEtimDynamicElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfProductEtimDynamicElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductEtimDynamicElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfProductEtimReleaseDate(Some(deserializer)) => {
                    self.store_udx_edxf_product_etim_release_date(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_product_etim_release_date(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_product_etim_release_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_ETIM_RELEASE_DATE",
                )))?;
            }
            self.udx_edxf_product_etim_release_date = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_product_etim_release_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductEtimDynamicElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_product_etim_release_date.is_some() {
                    fallback . get_or_insert (UdxEdxfProductEtimDynamicElementTypeDeserializerState :: UdxEdxfProductEtimReleaseDate (None)) ;
                    *self.state = UdxEdxfProductEtimDynamicElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = UdxEdxfProductEtimDynamicElementTypeDeserializerState :: UdxEdxfProductEtimReleaseDate (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_etim_release_date(data)?;
                    *self.state = UdxEdxfProductEtimDynamicElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductEtimDynamicElementTypeDeserializerState :: UdxEdxfProductEtimReleaseDate (Some (deserializer))) ;
                            *self.state =
                                UdxEdxfProductEtimDynamicElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductEtimDynamicElementTypeDeserializerState :: UdxEdxfProductEtimReleaseDate (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfProductEtimDynamicElementType>
        for UdxEdxfProductEtimDynamicElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductEtimDynamicElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductEtimDynamicElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductEtimDynamicElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfProductEtimReleaseDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_etim_release_date(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfProductEtimDynamicElementTypeDeserializerState :: UdxEdxfProductEtimReleaseDate (None) ;
                        event
                    }
                    (
                        S::UdxEdxfProductEtimReleaseDate(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_ETIM_RELEASE_DATE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_product_etim_release_date(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfProductEtimDynamicElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfProductEtimDynamicElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfProductEtimDynamicElementType {
                udx_edxf_product_etim_release_date: self
                    .udx_edxf_product_etim_release_date
                    .ok_or_else(|| {
                        ErrorKind::MissingElement("UDX.EDXF.PRODUCT_ETIM_RELEASE_DATE".into())
                    })?,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductFeaturesMcElementTypeDeserializer {
        udx_edxf_reference_feature_mc_id: Option<String>,
        udx_edxf_reference_feature_mc_version: Option<i32>,
        udx_edxf_bim_status: Option<super::UdxEdxfBimStatusElementType>,
        udx_edxf_feature_mc: Vec<super::UdxEdxfFeatureMcElementType>,
        state: Box<UdxEdxfProductFeaturesMcElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfProductFeaturesMcElementTypeDeserializerState {
        Init__,
        UdxEdxfReferenceFeatureMcId(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfReferenceFeatureMcVersion(Option<<i32 as WithDeserializer>::Deserializer>),
        UdxEdxfBimStatus(
            Option<<super::UdxEdxfBimStatusElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfFeatureMc(
            Option<<super::UdxEdxfFeatureMcElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl UdxEdxfProductFeaturesMcElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_reference_feature_mc_id: None,
                udx_edxf_reference_feature_mc_version: None,
                udx_edxf_bim_status: None,
                udx_edxf_feature_mc: Vec::new(),
                state: Box::new(UdxEdxfProductFeaturesMcElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfProductFeaturesMcElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductFeaturesMcElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfReferenceFeatureMcId(Some(deserializer)) => {
                    self.store_udx_edxf_reference_feature_mc_id(deserializer.finish(reader)?)?
                }
                S::UdxEdxfReferenceFeatureMcVersion(Some(deserializer)) => {
                    self.store_udx_edxf_reference_feature_mc_version(deserializer.finish(reader)?)?
                }
                S::UdxEdxfBimStatus(Some(deserializer)) => {
                    self.store_udx_edxf_bim_status(deserializer.finish(reader)?)?
                }
                S::UdxEdxfFeatureMc(Some(deserializer)) => {
                    self.store_udx_edxf_feature_mc(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_reference_feature_mc_id(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_reference_feature_mc_id.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REFERENCE_FEATURE_MC_ID",
                )))?;
            }
            self.udx_edxf_reference_feature_mc_id = Some(value);
            Ok(())
        }
        fn store_udx_edxf_reference_feature_mc_version(&mut self, value: i32) -> Result<(), Error> {
            if self.udx_edxf_reference_feature_mc_version.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.REFERENCE_FEATURE_MC_VERSION",
                )))?;
            }
            self.udx_edxf_reference_feature_mc_version = Some(value);
            Ok(())
        }
        fn store_udx_edxf_bim_status(
            &mut self,
            value: super::UdxEdxfBimStatusElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_bim_status.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.BIM_STATUS",
                )))?;
            }
            self.udx_edxf_bim_status = Some(value);
            Ok(())
        }
        fn store_udx_edxf_feature_mc(
            &mut self,
            value: super::UdxEdxfFeatureMcElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_feature_mc.push(value);
            Ok(())
        }
        fn handle_udx_edxf_reference_feature_mc_id<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductFeaturesMcElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_reference_feature_mc_id.is_some() {
                    fallback . get_or_insert (UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcId (None)) ;
                    * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcVersion (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcId (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_reference_feature_mc_id(data)?;
                    * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcVersion (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcId (Some (deserializer))) ;
                            * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcVersion (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcId (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_reference_feature_mc_version<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfProductFeaturesMcElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_reference_feature_mc_version.is_some() {
                    fallback . get_or_insert (UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcVersion (None)) ;
                    *self.state =
                        UdxEdxfProductFeaturesMcElementTypeDeserializerState::UdxEdxfBimStatus(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcVersion (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_reference_feature_mc_version(data)?;
                    *self.state =
                        UdxEdxfProductFeaturesMcElementTypeDeserializerState::UdxEdxfBimStatus(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcVersion (Some (deserializer))) ;
                            * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfBimStatus (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcVersion (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_bim_status<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfBimStatusElementType>,
            fallback: &mut Option<UdxEdxfProductFeaturesMcElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfProductFeaturesMcElementTypeDeserializerState::UdxEdxfBimStatus(None),
                );
                *self.state =
                    UdxEdxfProductFeaturesMcElementTypeDeserializerState::UdxEdxfFeatureMc(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_bim_status(data)?;
                    *self.state =
                        UdxEdxfProductFeaturesMcElementTypeDeserializerState::UdxEdxfFeatureMc(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfBimStatus (Some (deserializer))) ;
                            * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfFeatureMc (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfBimStatus (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_feature_mc<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfFeatureMcElementType>,
            fallback: &mut Option<UdxEdxfProductFeaturesMcElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_feature_mc.len() < 1usize {
                    *self.state =
                        UdxEdxfProductFeaturesMcElementTypeDeserializerState::UdxEdxfFeatureMc(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        UdxEdxfProductFeaturesMcElementTypeDeserializerState::UdxEdxfFeatureMc(
                            None,
                        ),
                    );
                    *self.state = UdxEdxfProductFeaturesMcElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_feature_mc(data)?;
                    *self.state =
                        UdxEdxfProductFeaturesMcElementTypeDeserializerState::UdxEdxfFeatureMc(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfFeatureMc (Some (deserializer))) ;
                            if self.udx_edxf_feature_mc.len().saturating_add(1) < 1usize {
                                * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfFeatureMc (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfProductFeaturesMcElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfFeatureMc (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfProductFeaturesMcElementType>
        for UdxEdxfProductFeaturesMcElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductFeaturesMcElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductFeaturesMcElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductFeaturesMcElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfReferenceFeatureMcId(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_reference_feature_mc_id(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfReferenceFeatureMcVersion(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_reference_feature_mc_version(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfBimStatus(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_bim_status(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfFeatureMc(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_feature_mc(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfProductFeaturesMcElementTypeDeserializerState :: UdxEdxfReferenceFeatureMcId (None) ;
                        event
                    }
                    (
                        S::UdxEdxfReferenceFeatureMcId(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REFERENCE_FEATURE_MC_ID",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_reference_feature_mc_id(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfReferenceFeatureMcVersion(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfReferenceFeatureMcVersion(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.REFERENCE_FEATURE_MC_VERSION",
                        ) {
                            let output =
                                <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_reference_feature_mc_version(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfBimStatus(None);
                            event
                        }
                    }
                    (S::UdxEdxfBimStatus(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.BIM_STATUS",
                        ) {
                            let output = < super :: UdxEdxfBimStatusElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_bim_status(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfFeatureMc(None);
                            event
                        }
                    }
                    (S::UdxEdxfFeatureMc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.FEATURE_MC",
                        ) {
                            let output = < super :: UdxEdxfFeatureMcElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_feature_mc(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfProductFeaturesMcElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfProductFeaturesMcElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfProductFeaturesMcElementType {
                udx_edxf_reference_feature_mc_id: self
                    .udx_edxf_reference_feature_mc_id
                    .ok_or_else(|| {
                        ErrorKind::MissingElement("UDX.EDXF.REFERENCE_FEATURE_MC_ID".into())
                    })?,
                udx_edxf_reference_feature_mc_version: self
                    .udx_edxf_reference_feature_mc_version
                    .ok_or_else(|| {
                    ErrorKind::MissingElement("UDX.EDXF.REFERENCE_FEATURE_MC_VERSION".into())
                })?,
                udx_edxf_bim_status: self.udx_edxf_bim_status,
                udx_edxf_feature_mc: self.udx_edxf_feature_mc,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductCharacteristicsElementTypeDeserializer {
        udx_edxf_product_characteristic: Vec<super::UdxEdxfProductCharacteristicElementType>,
        state: Box<UdxEdxfProductCharacteristicsElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfProductCharacteristicsElementTypeDeserializerState {
        Init__,
        UdxEdxfProductCharacteristic(
            Option<
                <super::UdxEdxfProductCharacteristicElementType as WithDeserializer>::Deserializer,
            >,
        ),
        Done__,
        Unknown__,
    }
    impl UdxEdxfProductCharacteristicsElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_product_characteristic: Vec::new(),
                state: Box::new(UdxEdxfProductCharacteristicsElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfProductCharacteristicsElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductCharacteristicsElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfProductCharacteristic(Some(deserializer)) => {
                    self.store_udx_edxf_product_characteristic(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_product_characteristic(
            &mut self,
            value: super::UdxEdxfProductCharacteristicElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_product_characteristic.push(value);
            Ok(())
        }
        fn handle_udx_edxf_product_characteristic<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductCharacteristicElementType>,
            fallback: &mut Option<UdxEdxfProductCharacteristicsElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_product_characteristic.len() < 1usize {
                    * self . state = UdxEdxfProductCharacteristicsElementTypeDeserializerState :: UdxEdxfProductCharacteristic (None) ;
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback . get_or_insert (UdxEdxfProductCharacteristicsElementTypeDeserializerState :: UdxEdxfProductCharacteristic (None)) ;
                    *self.state = UdxEdxfProductCharacteristicsElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_product_characteristic(data)?;
                    * self . state = UdxEdxfProductCharacteristicsElementTypeDeserializerState :: UdxEdxfProductCharacteristic (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfProductCharacteristicsElementTypeDeserializerState :: UdxEdxfProductCharacteristic (Some (deserializer))) ;
                            if self.udx_edxf_product_characteristic.len().saturating_add(1) < 1usize
                            {
                                * self . state = UdxEdxfProductCharacteristicsElementTypeDeserializerState :: UdxEdxfProductCharacteristic (None) ;
                            } else {
                                * self . state = UdxEdxfProductCharacteristicsElementTypeDeserializerState :: Done__ ;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfProductCharacteristicsElementTypeDeserializerState :: UdxEdxfProductCharacteristic (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfProductCharacteristicsElementType>
        for UdxEdxfProductCharacteristicsElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductCharacteristicsElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductCharacteristicsElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductCharacteristicsElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfProductCharacteristic(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfProductCharacteristicsElementTypeDeserializerState :: UdxEdxfProductCharacteristic (None) ;
                        event
                    }
                    (
                        S::UdxEdxfProductCharacteristic(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PRODUCT_CHARACTERISTIC",
                        ) {
                            let output = < super :: UdxEdxfProductCharacteristicElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_product_characteristic(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfProductCharacteristicsElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfProductCharacteristicsElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfProductCharacteristicsElementType {
                udx_edxf_product_characteristic: self.udx_edxf_product_characteristic,
            })
        }
    }
    #[derive(Debug)]
    pub struct CustomsTariffNumberElementTypeDeserializer {
        customs_number: Option<String>,
        state: Box<CustomsTariffNumberElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum CustomsTariffNumberElementTypeDeserializerState {
        Init__,
        CustomsNumber(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl CustomsTariffNumberElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                customs_number: None,
                state: Box::new(CustomsTariffNumberElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: CustomsTariffNumberElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use CustomsTariffNumberElementTypeDeserializerState as S;
            match state {
                S::CustomsNumber(Some(deserializer)) => {
                    self.store_customs_number(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_customs_number(&mut self, value: String) -> Result<(), Error> {
            if self.customs_number.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"CUSTOMS_NUMBER",
                )))?;
            }
            self.customs_number = Some(value);
            Ok(())
        }
        fn handle_customs_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<CustomsTariffNumberElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.customs_number.is_some() {
                    fallback.get_or_insert(
                        CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(None),
                    );
                    *self.state = CustomsTariffNumberElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_customs_number(data)?;
                    *self.state = CustomsTariffNumberElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = CustomsTariffNumberElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::CustomsTariffNumberElementType>
        for CustomsTariffNumberElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CustomsTariffNumberElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::CustomsTariffNumberElementType>
        where
            R: DeserializeReader,
        {
            use CustomsTariffNumberElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::CustomsNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_customs_number(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            CustomsTariffNumberElementTypeDeserializerState::CustomsNumber(None);
                        event
                    }
                    (S::CustomsNumber(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"CUSTOMS_NUMBER",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_customs_number(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::CustomsTariffNumberElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                CustomsTariffNumberElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::CustomsTariffNumberElementType {
                customs_number: self
                    .customs_number
                    .ok_or_else(|| ErrorKind::MissingElement("CUSTOMS_NUMBER".into()))?,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfMimeElementTypeDeserializer {
        udx_edxf_mime_source: Vec<super::DtMlstring>,
        udx_edxf_mime_code: Option<super::UdxEdxfMimeCodeElementType>,
        udx_edxf_mime_filename: Vec<super::DtMlstring>,
        udx_edxf_mime_designation: Vec<super::DtMlstring>,
        udx_edxf_mime_alt: Vec<super::DtMlstring>,
        udx_edxf_mime_issue_date: Option<String>,
        udx_edxf_mime_expiry_date: Option<String>,
        udx_edxf_mime_order: Option<i32>,
        state: Box<UdxEdxfMimeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfMimeElementTypeDeserializerState {
        Init__,
        UdxEdxfMimeSource(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        UdxEdxfMimeCode(
            Option<<super::UdxEdxfMimeCodeElementType as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfMimeFilename(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        UdxEdxfMimeDesignation(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        UdxEdxfMimeAlt(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        UdxEdxfMimeIssueDate(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfMimeExpiryDate(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfMimeOrder(Option<<i32 as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfMimeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_mime_source: Vec::new(),
                udx_edxf_mime_code: None,
                udx_edxf_mime_filename: Vec::new(),
                udx_edxf_mime_designation: Vec::new(),
                udx_edxf_mime_alt: Vec::new(),
                udx_edxf_mime_issue_date: None,
                udx_edxf_mime_expiry_date: None,
                udx_edxf_mime_order: None,
                state: Box::new(UdxEdxfMimeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfMimeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfMimeElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfMimeSource(Some(deserializer)) => {
                    self.store_udx_edxf_mime_source(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMimeCode(Some(deserializer)) => {
                    self.store_udx_edxf_mime_code(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMimeFilename(Some(deserializer)) => {
                    self.store_udx_edxf_mime_filename(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMimeDesignation(Some(deserializer)) => {
                    self.store_udx_edxf_mime_designation(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMimeAlt(Some(deserializer)) => {
                    self.store_udx_edxf_mime_alt(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMimeIssueDate(Some(deserializer)) => {
                    self.store_udx_edxf_mime_issue_date(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMimeExpiryDate(Some(deserializer)) => {
                    self.store_udx_edxf_mime_expiry_date(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMimeOrder(Some(deserializer)) => {
                    self.store_udx_edxf_mime_order(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_mime_source(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.udx_edxf_mime_source.push(value);
            Ok(())
        }
        fn store_udx_edxf_mime_code(
            &mut self,
            value: super::UdxEdxfMimeCodeElementType,
        ) -> Result<(), Error> {
            if self.udx_edxf_mime_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MIME_CODE",
                )))?;
            }
            self.udx_edxf_mime_code = Some(value);
            Ok(())
        }
        fn store_udx_edxf_mime_filename(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.udx_edxf_mime_filename.push(value);
            Ok(())
        }
        fn store_udx_edxf_mime_designation(
            &mut self,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            self.udx_edxf_mime_designation.push(value);
            Ok(())
        }
        fn store_udx_edxf_mime_alt(&mut self, value: super::DtMlstring) -> Result<(), Error> {
            self.udx_edxf_mime_alt.push(value);
            Ok(())
        }
        fn store_udx_edxf_mime_issue_date(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_mime_issue_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MIME_ISSUE_DATE",
                )))?;
            }
            self.udx_edxf_mime_issue_date = Some(value);
            Ok(())
        }
        fn store_udx_edxf_mime_expiry_date(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_mime_expiry_date.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MIME_EXPIRY_DATE",
                )))?;
            }
            self.udx_edxf_mime_expiry_date = Some(value);
            Ok(())
        }
        fn store_udx_edxf_mime_order(&mut self, value: i32) -> Result<(), Error> {
            if self.udx_edxf_mime_order.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MIME_ORDER",
                )))?;
            }
            self.udx_edxf_mime_order = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_mime_source<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfMimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_mime_source.len() < 1usize {
                    *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeSource(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeSource(None),
                    );
                    *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeCode(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_source(data)?;
                    *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeSource(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeSource(Some(
                                    deserializer,
                                )),
                            );
                            if self.udx_edxf_mime_source.len().saturating_add(1) < 1usize {
                                *self.state =
                                    UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeSource(
                                        None,
                                    );
                            } else {
                                *self.state =
                                    UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeCode(None);
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeSource(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_mime_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfMimeCodeElementType>,
            fallback: &mut Option<UdxEdxfMimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_mime_code.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeCode(None),
                    );
                    *self.state =
                        UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeFilename(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeCode(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_code(data)?;
                    *self.state =
                        UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeFilename(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeCode(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeFilename(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeCode(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_mime_filename<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfMimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeFilename(None),
                );
                *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeDesignation(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_filename(data)?;
                    *self.state =
                        UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeFilename(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeFilename(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeFilename(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeFilename(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_mime_designation<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfMimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeDesignation(None),
                );
                *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeAlt(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_designation(data)?;
                    *self.state =
                        UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeDesignation(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeDesignation(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeDesignation(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeDesignation(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_mime_alt<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfMimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeAlt(
                    None,
                ));
                *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeIssueDate(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_alt(data)?;
                    *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeAlt(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeAlt(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeAlt(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeAlt(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_mime_issue_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfMimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeIssueDate(None),
                );
                *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeExpiryDate(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_issue_date(data)?;
                    *self.state =
                        UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeExpiryDate(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeIssueDate(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeExpiryDate(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeIssueDate(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_mime_expiry_date<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfMimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeExpiryDate(None),
                );
                *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeOrder(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_expiry_date(data)?;
                    *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeOrder(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeExpiryDate(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeOrder(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeExpiryDate(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_mime_order<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfMimeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeOrder(
                    None,
                ));
                *self.state = UdxEdxfMimeElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_mime_order(data)?;
                    *self.state = UdxEdxfMimeElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeOrder(Some(
                                    deserializer,
                                )),
                            );
                            *self.state = UdxEdxfMimeElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeOrder(
                                Some(deserializer),
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfMimeElementType> for UdxEdxfMimeElementTypeDeserializer {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfMimeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfMimeElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfMimeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfMimeSource(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_source(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMimeCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_code(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMimeFilename(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_filename(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMimeDesignation(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_designation(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMimeAlt(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_alt(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMimeIssueDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_issue_date(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMimeExpiryDate(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_expiry_date(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMimeOrder(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_mime_order(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfMimeElementTypeDeserializerState::UdxEdxfMimeSource(None);
                        event
                    }
                    (S::UdxEdxfMimeSource(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_SOURCE",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_mime_source(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMimeCode(None);
                            event
                        }
                    }
                    (S::UdxEdxfMimeCode(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_CODE",
                        ) {
                            let output = < super :: UdxEdxfMimeCodeElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_mime_code(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMimeFilename(None);
                            event
                        }
                    }
                    (S::UdxEdxfMimeFilename(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_FILENAME",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_mime_filename(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMimeDesignation(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfMimeDesignation(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_DESIGNATION",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_mime_designation(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMimeAlt(None);
                            event
                        }
                    }
                    (S::UdxEdxfMimeAlt(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_ALT",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_mime_alt(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMimeIssueDate(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfMimeIssueDate(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_ISSUE_DATE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_mime_issue_date(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMimeExpiryDate(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfMimeExpiryDate(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_EXPIRY_DATE",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_mime_expiry_date(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMimeOrder(None);
                            event
                        }
                    }
                    (S::UdxEdxfMimeOrder(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MIME_ORDER",
                        ) {
                            let output =
                                <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_mime_order(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfMimeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfMimeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfMimeElementType {
                udx_edxf_mime_source: self.udx_edxf_mime_source,
                udx_edxf_mime_code: self
                    .udx_edxf_mime_code
                    .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.MIME_CODE".into()))?,
                udx_edxf_mime_filename: self.udx_edxf_mime_filename,
                udx_edxf_mime_designation: self.udx_edxf_mime_designation,
                udx_edxf_mime_alt: self.udx_edxf_mime_alt,
                udx_edxf_mime_issue_date: self.udx_edxf_mime_issue_date,
                udx_edxf_mime_expiry_date: self.udx_edxf_mime_expiry_date,
                udx_edxf_mime_order: self.udx_edxf_mime_order,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializer {
        type_: String,
        country: String,
        content: Option<i32>,
        state:
            Box<UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState {
        Init__,
        Content__(<i32 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            let mut country: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"country")
                ) {
                    reader.read_attrib(&mut country, b"country", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok (Self { type_ : type_ . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("type" . into ()))) ? , country : country . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("country" . into ()))) ? , content : None , state : Box :: new (UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState :: Init__) , })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state : UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState :: Content__ (deserializer) = state { self . store_content (deserializer . finish (reader) ?) ? ; }
            Ok(())
        }
        fn store_content(&mut self, value: i32) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        >
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de>
        Deserializer<'de, super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType>
        for UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        >
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        >
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace (& mut * self . state , UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeDeserializerState :: Unknown__) ;
            self.finish_state(reader, state)?;
            Ok(
                super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType {
                    type_: self.type_,
                    country: self.country,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                },
            )
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializer { type_ : String , country : String , content : Option < i32 > , state : Box < UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState > , }
    #[derive(Debug)]
    enum UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState {
        Init__,
        Content__(<i32 as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            let mut type_: Option<String> = None;
            let mut country: Option<String> = None;
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"type")
                ) {
                    reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                } else if matches!(
                    reader.resolve_local_name(attrib.key, &super::NS_DEFAULT),
                    Some(b"country")
                ) {
                    reader.read_attrib(&mut country, b"country", &attrib.value)?;
                } else {
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
            }
            Ok (Self { type_ : type_ . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("type" . into ()))) ? , country : country . ok_or_else (|| reader . map_error (ErrorKind :: MissingAttribute ("country" . into ()))) ? , content : None , state : Box :: new (UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState :: Init__) , })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state : UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState :: Content__ (deserializer) = state { self . store_content (deserializer . finish (reader) ?) ? ; }
            Ok(())
        }
        fn store_content(&mut self, value: i32) -> Result<(), Error> {
            if self.content.is_some() {
                Err(ErrorKind::DuplicateContent)?;
            }
            self.content = Some(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        >
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState as S;
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            match artifact {
                DeserializerArtifact::None => Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event,
                    allow_any,
                }),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    let data = self.finish(reader)?;
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(data),
                        event,
                        allow_any,
                    })
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = S::Content__(deserializer);
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event,
                        allow_any,
                    })
                }
            }
        }
    }
    impl<'de>
        Deserializer<
            'de,
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        > for UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        >
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                return Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::None,
                    event: DeserializerEvent::Break(event),
                    allow_any: false,
                });
            };
            Self::from_bytes_start(reader, x)?.next(reader, event)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<
            'de,
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        >
        where
            R: DeserializeReader,
        {
            use UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState as S;
            match replace(&mut *self.state, S::Unknown__) {
                S::Init__ => {
                    let output = ContentDeserializer::init(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Content__(deserializer) => {
                    let output = deserializer.next(reader, event)?;
                    self.handle_content(reader, output)
                }
                S::Unknown__ => unreachable!(),
            }
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<
            super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
            Error,
        >
        where
            R: DeserializeReader,
        {
            let state = replace (& mut * self . state , UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeDeserializerState :: Unknown__) ;
            self.finish_state(reader, state)?;
            Ok(
                super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType {
                    type_: self.type_,
                    country: self.country,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                },
            )
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfPackingUnitElementTypeDeserializer {
        udx_edxf_quantity_min: Option<f32>,
        udx_edxf_quantity_max: Option<f32>,
        udx_edxf_packing_unit_code: Option<super::DtPunit>,
        udx_edxf_packing_unit_name: Vec<super::DtMlstring>,
        udx_edxf_package_break: Option<String>,
        udx_edxf_packing_parts: Option<i32>,
        udx_edxf_volume: Option<f64>,
        udx_edxf_weight: Option<f64>,
        udx_edxf_length: Option<f64>,
        udx_edxf_width: Option<f64>,
        udx_edxf_depth: Option<f64>,
        udx_edxf_diameter: Option<f64>,
        udx_edxf_gtin: Option<String>,
        udx_edxf_gs_1128: Option<String>,
        state: Box<UdxEdxfPackingUnitElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfPackingUnitElementTypeDeserializerState {
        Init__,
        UdxEdxfQuantityMin(Option<<f32 as WithDeserializer>::Deserializer>),
        UdxEdxfQuantityMax(Option<<f32 as WithDeserializer>::Deserializer>),
        UdxEdxfPackingUnitCode(Option<<super::DtPunit as WithDeserializer>::Deserializer>),
        UdxEdxfPackingUnitName(Option<<super::DtMlstring as WithDeserializer>::Deserializer>),
        UdxEdxfPackageBreak(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfPackingParts(Option<<i32 as WithDeserializer>::Deserializer>),
        UdxEdxfVolume(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfWeight(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfLength(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfWidth(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfDepth(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfDiameter(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfGtin(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfGs1128(Option<<String as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfPackingUnitElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_quantity_min: None,
                udx_edxf_quantity_max: None,
                udx_edxf_packing_unit_code: None,
                udx_edxf_packing_unit_name: Vec::new(),
                udx_edxf_package_break: None,
                udx_edxf_packing_parts: None,
                udx_edxf_volume: None,
                udx_edxf_weight: None,
                udx_edxf_length: None,
                udx_edxf_width: None,
                udx_edxf_depth: None,
                udx_edxf_diameter: None,
                udx_edxf_gtin: None,
                udx_edxf_gs_1128: None,
                state: Box::new(UdxEdxfPackingUnitElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfPackingUnitElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfPackingUnitElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfQuantityMin(Some(deserializer)) => {
                    self.store_udx_edxf_quantity_min(deserializer.finish(reader)?)?
                }
                S::UdxEdxfQuantityMax(Some(deserializer)) => {
                    self.store_udx_edxf_quantity_max(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackingUnitCode(Some(deserializer)) => {
                    self.store_udx_edxf_packing_unit_code(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackingUnitName(Some(deserializer)) => {
                    self.store_udx_edxf_packing_unit_name(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackageBreak(Some(deserializer)) => {
                    self.store_udx_edxf_package_break(deserializer.finish(reader)?)?
                }
                S::UdxEdxfPackingParts(Some(deserializer)) => {
                    self.store_udx_edxf_packing_parts(deserializer.finish(reader)?)?
                }
                S::UdxEdxfVolume(Some(deserializer)) => {
                    self.store_udx_edxf_volume(deserializer.finish(reader)?)?
                }
                S::UdxEdxfWeight(Some(deserializer)) => {
                    self.store_udx_edxf_weight(deserializer.finish(reader)?)?
                }
                S::UdxEdxfLength(Some(deserializer)) => {
                    self.store_udx_edxf_length(deserializer.finish(reader)?)?
                }
                S::UdxEdxfWidth(Some(deserializer)) => {
                    self.store_udx_edxf_width(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDepth(Some(deserializer)) => {
                    self.store_udx_edxf_depth(deserializer.finish(reader)?)?
                }
                S::UdxEdxfDiameter(Some(deserializer)) => {
                    self.store_udx_edxf_diameter(deserializer.finish(reader)?)?
                }
                S::UdxEdxfGtin(Some(deserializer)) => {
                    self.store_udx_edxf_gtin(deserializer.finish(reader)?)?
                }
                S::UdxEdxfGs1128(Some(deserializer)) => {
                    self.store_udx_edxf_gs_1128(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_quantity_min(&mut self, value: f32) -> Result<(), Error> {
            if self.udx_edxf_quantity_min.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.QUANTITY_MIN",
                )))?;
            }
            self.udx_edxf_quantity_min = Some(value);
            Ok(())
        }
        fn store_udx_edxf_quantity_max(&mut self, value: f32) -> Result<(), Error> {
            if self.udx_edxf_quantity_max.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.QUANTITY_MAX",
                )))?;
            }
            self.udx_edxf_quantity_max = Some(value);
            Ok(())
        }
        fn store_udx_edxf_packing_unit_code(&mut self, value: super::DtPunit) -> Result<(), Error> {
            if self.udx_edxf_packing_unit_code.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PACKING_UNIT_CODE",
                )))?;
            }
            self.udx_edxf_packing_unit_code = Some(value);
            Ok(())
        }
        fn store_udx_edxf_packing_unit_name(
            &mut self,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            self.udx_edxf_packing_unit_name.push(value);
            Ok(())
        }
        fn store_udx_edxf_package_break(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_package_break.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PACKAGE_BREAK",
                )))?;
            }
            self.udx_edxf_package_break = Some(value);
            Ok(())
        }
        fn store_udx_edxf_packing_parts(&mut self, value: i32) -> Result<(), Error> {
            if self.udx_edxf_packing_parts.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PACKING_PARTS",
                )))?;
            }
            self.udx_edxf_packing_parts = Some(value);
            Ok(())
        }
        fn store_udx_edxf_volume(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_volume.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.VOLUME",
                )))?;
            }
            self.udx_edxf_volume = Some(value);
            Ok(())
        }
        fn store_udx_edxf_weight(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_weight.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.WEIGHT",
                )))?;
            }
            self.udx_edxf_weight = Some(value);
            Ok(())
        }
        fn store_udx_edxf_length(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_length.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.LENGTH",
                )))?;
            }
            self.udx_edxf_length = Some(value);
            Ok(())
        }
        fn store_udx_edxf_width(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_width.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.WIDTH",
                )))?;
            }
            self.udx_edxf_width = Some(value);
            Ok(())
        }
        fn store_udx_edxf_depth(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_depth.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DEPTH",
                )))?;
            }
            self.udx_edxf_depth = Some(value);
            Ok(())
        }
        fn store_udx_edxf_diameter(&mut self, value: f64) -> Result<(), Error> {
            if self.udx_edxf_diameter.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.DIAMETER",
                )))?;
            }
            self.udx_edxf_diameter = Some(value);
            Ok(())
        }
        fn store_udx_edxf_gtin(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_gtin.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.GTIN",
                )))?;
            }
            self.udx_edxf_gtin = Some(value);
            Ok(())
        }
        fn store_udx_edxf_gs_1128(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_gs_1128.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.GS1_128",
                )))?;
            }
            self.udx_edxf_gs_1128 = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_quantity_min<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_quantity_min.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(None),
                    );
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_quantity_min(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_quantity_max<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(None),
                );
                *self.state =
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitCode(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_quantity_max(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitCode(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(
                                    Some(deserializer),
                                ),
                            );
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitCode (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMax(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_packing_unit_code<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtPunit>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_packing_unit_code.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitCode(
                            None,
                        ),
                    );
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitName(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitCode(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_unit_code(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitName(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitCode (Some (deserializer))) ;
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitName (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitCode (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_packing_unit_name<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitName(None),
                );
                *self.state =
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackageBreak(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_unit_name(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingUnitName(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitName (Some (deserializer))) ;
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitName (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfPackingUnitElementTypeDeserializerState :: UdxEdxfPackingUnitName (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_package_break<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackageBreak(None),
                );
                *self.state =
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingParts(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_package_break(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingParts(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackageBreak(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingParts(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackageBreak(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_packing_parts<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingParts(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_packing_parts(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingParts(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfPackingParts(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_volume<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_volume(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfVolume(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_weight<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_weight(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWeight(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_length<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_length(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfLength(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_width<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_width(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfWidth(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_depth<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_depth(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(
                                    None,
                                );
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDepth(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_diameter<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_diameter(data)?;
                    *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(
                                    Some(deserializer),
                                ),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfDiameter(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_gtin<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(None);
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_gtin(data)?;
                    *self.state =
                        UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(Some(
                                    deserializer,
                                )),
                            );
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(None);
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGtin(Some(
                                    deserializer,
                                ));
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_gs_1128<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfPackingUnitElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback.get_or_insert(
                    UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(None),
                );
                *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_gs_1128(data)?;
                    *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(
                                    Some(deserializer),
                                ),
                            );
                            *self.state = UdxEdxfPackingUnitElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfGs1128(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfPackingUnitElementType>
        for UdxEdxfPackingUnitElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfPackingUnitElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfPackingUnitElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfPackingUnitElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfQuantityMin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_quantity_min(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfQuantityMax(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_quantity_max(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackingUnitCode(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_unit_code(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackingUnitName(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_unit_name(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackageBreak(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_package_break(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfPackingParts(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_packing_parts(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfVolume(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_volume(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfWeight(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_weight(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfLength(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_length(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfWidth(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_width(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDepth(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_depth(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfDiameter(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_diameter(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfGtin(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_gtin(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfGs1128(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_gs_1128(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfPackingUnitElementTypeDeserializerState::UdxEdxfQuantityMin(
                                None,
                            );
                        event
                    }
                    (S::UdxEdxfQuantityMin(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.QUANTITY_MIN",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_quantity_min(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfQuantityMax(None);
                            event
                        }
                    }
                    (S::UdxEdxfQuantityMax(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.QUANTITY_MAX",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_quantity_max(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackingUnitCode(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfPackingUnitCode(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_UNIT_CODE",
                        ) {
                            let output = <super::DtPunit as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_udx_edxf_packing_unit_code(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackingUnitName(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfPackingUnitName(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_UNIT_NAME",
                        ) {
                            let output =
                                <super::DtMlstring as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_udx_edxf_packing_unit_name(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackageBreak(None);
                            event
                        }
                    }
                    (S::UdxEdxfPackageBreak(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKAGE_BREAK",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_package_break(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfPackingParts(None);
                            event
                        }
                    }
                    (S::UdxEdxfPackingParts(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.PACKING_PARTS",
                        ) {
                            let output =
                                <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_packing_parts(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfVolume(None);
                            event
                        }
                    }
                    (S::UdxEdxfVolume(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.VOLUME",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_volume(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfWeight(None);
                            event
                        }
                    }
                    (S::UdxEdxfWeight(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.WEIGHT",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_weight(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfLength(None);
                            event
                        }
                    }
                    (S::UdxEdxfLength(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.LENGTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_length(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfWidth(None);
                            event
                        }
                    }
                    (S::UdxEdxfWidth(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.WIDTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_width(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDepth(None);
                            event
                        }
                    }
                    (S::UdxEdxfDepth(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DEPTH",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_depth(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfDiameter(None);
                            event
                        }
                    }
                    (S::UdxEdxfDiameter(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.DIAMETER",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_diameter(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfGtin(None);
                            event
                        }
                    }
                    (S::UdxEdxfGtin(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.GTIN",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_gtin(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfGs1128(None);
                            event
                        }
                    }
                    (S::UdxEdxfGs1128(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.GS1_128",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_gs_1128(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfPackingUnitElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfPackingUnitElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfPackingUnitElementType {
                udx_edxf_quantity_min: self
                    .udx_edxf_quantity_min
                    .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.QUANTITY_MIN".into()))?,
                udx_edxf_quantity_max: self.udx_edxf_quantity_max,
                udx_edxf_packing_unit_code: self.udx_edxf_packing_unit_code.ok_or_else(|| {
                    ErrorKind::MissingElement("UDX.EDXF.PACKING_UNIT_CODE".into())
                })?,
                udx_edxf_packing_unit_name: self.udx_edxf_packing_unit_name,
                udx_edxf_package_break: self.udx_edxf_package_break,
                udx_edxf_packing_parts: self.udx_edxf_packing_parts,
                udx_edxf_volume: self.udx_edxf_volume,
                udx_edxf_weight: self.udx_edxf_weight,
                udx_edxf_length: self.udx_edxf_length,
                udx_edxf_width: self.udx_edxf_width,
                udx_edxf_depth: self.udx_edxf_depth,
                udx_edxf_diameter: self.udx_edxf_diameter,
                udx_edxf_gtin: self.udx_edxf_gtin,
                udx_edxf_gs_1128: self.udx_edxf_gs_1128,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfHazardousSubstancesElementTypeDeserializer {
        udx_edxf_un_number: Option<String>,
        udx_edxf_net_weight_of_hazardous_substance: Option<f64>,
        udx_edxf_volume_of_hazardous_substances: Option<f64>,
        state: Box<UdxEdxfHazardousSubstancesElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfHazardousSubstancesElementTypeDeserializerState {
        Init__,
        UdxEdxfUnNumber(Option<<String as WithDeserializer>::Deserializer>),
        UdxEdxfNetWeightOfHazardousSubstance(Option<<f64 as WithDeserializer>::Deserializer>),
        UdxEdxfVolumeOfHazardousSubstances(Option<<f64 as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfHazardousSubstancesElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_un_number: None,
                udx_edxf_net_weight_of_hazardous_substance: None,
                udx_edxf_volume_of_hazardous_substances: None,
                state: Box::new(UdxEdxfHazardousSubstancesElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfHazardousSubstancesElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfHazardousSubstancesElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfUnNumber(Some(deserializer)) => {
                    self.store_udx_edxf_un_number(deserializer.finish(reader)?)?
                }
                S::UdxEdxfNetWeightOfHazardousSubstance(Some(deserializer)) => self
                    .store_udx_edxf_net_weight_of_hazardous_substance(
                        deserializer.finish(reader)?,
                    )?,
                S::UdxEdxfVolumeOfHazardousSubstances(Some(deserializer)) => self
                    .store_udx_edxf_volume_of_hazardous_substances(deserializer.finish(reader)?)?,
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_un_number(&mut self, value: String) -> Result<(), Error> {
            if self.udx_edxf_un_number.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.UN_NUMBER",
                )))?;
            }
            self.udx_edxf_un_number = Some(value);
            Ok(())
        }
        fn store_udx_edxf_net_weight_of_hazardous_substance(
            &mut self,
            value: f64,
        ) -> Result<(), Error> {
            if self.udx_edxf_net_weight_of_hazardous_substance.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.NET_WEIGHT_OF_HAZARDOUS_SUBSTANCE",
                )))?;
            }
            self.udx_edxf_net_weight_of_hazardous_substance = Some(value);
            Ok(())
        }
        fn store_udx_edxf_volume_of_hazardous_substances(
            &mut self,
            value: f64,
        ) -> Result<(), Error> {
            if self.udx_edxf_volume_of_hazardous_substances.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.VOLUME_OF_HAZARDOUS_SUBSTANCES",
                )))?;
            }
            self.udx_edxf_volume_of_hazardous_substances = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_un_number<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfHazardousSubstancesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_un_number.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfHazardousSubstancesElementTypeDeserializerState::UdxEdxfUnNumber(
                            None,
                        ),
                    );
                    * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfNetWeightOfHazardousSubstance (None) ;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        UdxEdxfHazardousSubstancesElementTypeDeserializerState::UdxEdxfUnNumber(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_un_number(data)?;
                    * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfNetWeightOfHazardousSubstance (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfUnNumber (Some (deserializer))) ;
                            * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfNetWeightOfHazardousSubstance (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfUnNumber (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_net_weight_of_hazardous_substance<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfHazardousSubstancesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfNetWeightOfHazardousSubstance (None)) ;
                * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfVolumeOfHazardousSubstances (None) ;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_net_weight_of_hazardous_substance(data)?;
                    * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfVolumeOfHazardousSubstances (None) ;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfNetWeightOfHazardousSubstance (Some (deserializer))) ;
                            * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfVolumeOfHazardousSubstances (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfNetWeightOfHazardousSubstance (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_volume_of_hazardous_substances<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfHazardousSubstancesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                fallback . get_or_insert (UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfVolumeOfHazardousSubstances (None)) ;
                *self.state = UdxEdxfHazardousSubstancesElementTypeDeserializerState::Done__;
                return Ok(ElementHandlerOutput::from_event(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_volume_of_hazardous_substances(data)?;
                    *self.state = UdxEdxfHazardousSubstancesElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfVolumeOfHazardousSubstances (Some (deserializer))) ;
                            *self.state =
                                UdxEdxfHazardousSubstancesElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfHazardousSubstancesElementTypeDeserializerState :: UdxEdxfVolumeOfHazardousSubstances (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfHazardousSubstancesElementType>
        for UdxEdxfHazardousSubstancesElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfHazardousSubstancesElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfHazardousSubstancesElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfHazardousSubstancesElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfUnNumber(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_un_number(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfNetWeightOfHazardousSubstance(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_net_weight_of_hazardous_substance(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfVolumeOfHazardousSubstances(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_volume_of_hazardous_substances(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfHazardousSubstancesElementTypeDeserializerState::UdxEdxfUnNumber(
                                None,
                            );
                        event
                    }
                    (S::UdxEdxfUnNumber(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.UN_NUMBER",
                        ) {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_un_number(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfNetWeightOfHazardousSubstance(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfNetWeightOfHazardousSubstance(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.NET_WEIGHT_OF_HAZARDOUS_SUBSTANCE",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_net_weight_of_hazardous_substance(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfVolumeOfHazardousSubstances(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfVolumeOfHazardousSubstances(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.VOLUME_OF_HAZARDOUS_SUBSTANCES",
                        ) {
                            let output =
                                <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_volume_of_hazardous_substances(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfHazardousSubstancesElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfHazardousSubstancesElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfHazardousSubstancesElementType {
                udx_edxf_un_number: self
                    .udx_edxf_un_number
                    .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.UN_NUMBER".into()))?,
                udx_edxf_net_weight_of_hazardous_substance: self
                    .udx_edxf_net_weight_of_hazardous_substance,
                udx_edxf_volume_of_hazardous_substances: self
                    .udx_edxf_volume_of_hazardous_substances,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeElementTypeDeserializer {
        content: Vec<super::UdxEdxfSurchargeElementTypeContent>,
        state: Box<UdxEdxfSurchargeElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfSurchargeElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::UdxEdxfSurchargeElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl UdxEdxfSurchargeElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: Vec::new(),
                state: Box::new(UdxEdxfSurchargeElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfSurchargeElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfSurchargeElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::UdxEdxfSurchargeElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfSurchargeElementTypeContent>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfSurchargeElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = UdxEdxfSurchargeElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state = UdxEdxfSurchargeElementTypeDeserializerState::Content__(
                                deserializer,
                            );
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfSurchargeElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state = UdxEdxfSurchargeElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfSurchargeElementType>
        for UdxEdxfSurchargeElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: UdxEdxfSurchargeElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfSurchargeElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfSurchargeElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfSurchargeElementType {
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeElementTypeContentDeserializer {
        state: Box<UdxEdxfSurchargeElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum UdxEdxfSurchargeElementTypeContentDeserializerState {
        Init__ , UdxEdxfSurchargeType (Option < String > , Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfSurchargeClass (Option < String > , Option << String as WithDeserializer > :: Deserializer >) , UdxEdxfSurchargeManner (Option < super :: UdxEdxfSurchargeMannerElementType > , Option << super :: UdxEdxfSurchargeMannerElementType as WithDeserializer > :: Deserializer >) , UdxEdxfSurchargePercentage (Option < f64 > , Option << f64 as WithDeserializer > :: Deserializer >) , UdxEdxfSurchargePriceAmount (Option < f64 > , Option << f64 as WithDeserializer > :: Deserializer >) , UdxEdxfSurchargeCalculation (Option < super :: UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType > , Option << super :: UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType as WithDeserializer > :: Deserializer >) , UdxEdxfMaterialBasis (Option < f64 > , Option << f64 as WithDeserializer > :: Deserializer >) , UdxEdxfMaterialBasisWeight (Option < f64 > , Option << f64 as WithDeserializer > :: Deserializer >) , UdxEdxfMaterialBasisSurchargeThreshold (Option < f64 > , Option << f64 as WithDeserializer > :: Deserializer >) , UdxEdxfMaterialBasisSurchargeShutter (Option < super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType > , Option << super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType as WithDeserializer > :: Deserializer >) , UdxEdxfMaterialBasisSurchargeCredit (Option < super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType > , Option << super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType as WithDeserializer > :: Deserializer >) , UdxEdxfMaterialBasisSurchargeTable (Option < super :: DtMlstring > , Option << super :: DtMlstring as WithDeserializer > :: Deserializer >) , Done__ (super :: UdxEdxfSurchargeElementTypeContent) , Unknown__ , }
    impl UdxEdxfSurchargeElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfSurchargeElementTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_TYPE")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_type(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_CLASS")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_class(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_MANNER")
            ) {
                let output = < super :: UdxEdxfSurchargeMannerElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                return self.handle_udx_edxf_surcharge_manner(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_PERCENTAGE")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_percentage(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_PRICE_AMOUNT")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_surcharge_price_amount(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.SURCHARGE_CALCULATION")
            ) {
                let output = < super :: UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                return self.handle_udx_edxf_surcharge_calculation(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_WEIGHT")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis_weight(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_THRESHOLD")
            ) {
                let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis_surcharge_threshold(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_SHUTTER")
            ) {
                let output = < super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                return self.handle_udx_edxf_material_basis_surcharge_shutter(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_CREDIT")
            ) {
                let output = < super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                return self.handle_udx_edxf_material_basis_surcharge_credit(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_TABLE")
            ) {
                let output =
                    <super::DtMlstring as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_material_basis_surcharge_table(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(UdxEdxfSurchargeElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: UdxEdxfSurchargeElementTypeContentDeserializerState,
        ) -> Result<super::UdxEdxfSurchargeElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::UdxEdxfSurchargeType(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_type(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargeType(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_TYPE".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargeClass(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_class(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargeClass(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_CLASS".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargeManner(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_manner(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargeManner(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_MANNER".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargePercentage(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_percentage(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargePercentage(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_PERCENTAGE".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargePriceAmount(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_price_amount(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargePriceAmount(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_PRICE_AMOUNT".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfSurchargeCalculation(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_surcharge_calculation(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfSurchargeCalculation(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.SURCHARGE_CALCULATION".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfMaterialBasis(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfMaterialBasis(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.MATERIAL_BASIS".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfMaterialBasisWeight(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_weight(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfSurchargeElementTypeContent::UdxEdxfMaterialBasisWeight(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.MATERIAL_BASIS_WEIGHT".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfMaterialBasisSurchargeThreshold(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_surcharge_threshold(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeThreshold (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_THRESHOLD" . into ())) ?))
                }
                S::UdxEdxfMaterialBasisSurchargeShutter(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_surcharge_shutter(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeShutter (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_SHUTTER" . into ())) ?))
                }
                S::UdxEdxfMaterialBasisSurchargeCredit(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_surcharge_credit(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeCredit (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_CREDIT" . into ())) ?))
                }
                S::UdxEdxfMaterialBasisSurchargeTable(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_material_basis_surcharge_table(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeTable (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_TABLE" . into ())) ?))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_udx_edxf_surcharge_type(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_TYPE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_class(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_CLASS",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_manner(
            values: &mut Option<super::UdxEdxfSurchargeMannerElementType>,
            value: super::UdxEdxfSurchargeMannerElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_MANNER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_percentage(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_PERCENTAGE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_price_amount(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_PRICE_AMOUNT",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_surcharge_calculation(
            values: &mut Option<super::UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType>,
            value: super::UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.SURCHARGE_CALCULATION",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_weight(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_WEIGHT",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_surcharge_threshold(
            values: &mut Option<f64>,
            value: f64,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_THRESHOLD",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_surcharge_shutter(
            values: &mut Option<
                super::UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType,
            >,
            value: super::UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_SHUTTER",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_surcharge_credit(
            values: &mut Option<
                super::UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType,
            >,
            value: super::UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_CREDIT",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_material_basis_surcharge_table(
            values: &mut Option<super::DtMlstring>,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATERIAL_BASIS_SURCHARGE_TABLE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_surcharge_type<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                            values, None,
                        )
                    }
                    Some(
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                            _,
                            Some(deserializer),
                        ),
                    ) => UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_surcharge_type(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_type(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeType(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_class<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeClass(
                            values, None,
                        )
                    }
                    Some(
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeClass(
                            _,
                            Some(deserializer),
                        ),
                    ) => {
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeClass(
                            values,
                            Some(deserializer),
                        )
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeClass(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_surcharge_class(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_class(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeClass(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeClass(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_manner<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::UdxEdxfSurchargeMannerElementType>,
            output: DeserializerOutput<'de, super::UdxEdxfSurchargeMannerElementType>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            values, None,
                        )
                    }
                    Some(
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            _,
                            Some(deserializer),
                        ),
                    ) => {
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            values,
                            Some(deserializer),
                        )
                    }
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_surcharge_manner(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_manner(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargeManner(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_percentage<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (values , None) , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfSurchargePercentage(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_surcharge_percentage(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_percentage(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePercentage (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_price_amount<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (values , None) , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_surcharge_price_amount (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_price_amount(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargePriceAmount (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_surcharge_calculation<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType>,
            output: DeserializerOutput<
                'de,
                super::UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType,
            >,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (values , None) , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_surcharge_calculation (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_surcharge_calculation(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfSurchargeCalculation (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                            values, None,
                        )
                    }
                    Some(
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                            _,
                            Some(deserializer),
                        ),
                    ) => UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_material_basis(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasis(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_weight<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (values , None) , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(
                    UdxEdxfSurchargeElementTypeContentDeserializerState::UdxEdxfMaterialBasisWeight(
                        _,
                        Some(deserializer),
                    ),
                ) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_material_basis_weight(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_weight(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisWeight (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_surcharge_threshold<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f64>,
            output: DeserializerOutput<'de, f64>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (values , None) , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_material_basis_surcharge_threshold (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_surcharge_threshold(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeThreshold (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_surcharge_shutter<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<
                super::UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType,
            >,
            output: DeserializerOutput<
                'de,
                super::UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType,
            >,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (values , None) , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_material_basis_surcharge_shutter (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_surcharge_shutter(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeShutter (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_surcharge_credit<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<
                super::UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType,
            >,
            output: DeserializerOutput<
                'de,
                super::UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType,
            >,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (values , None) , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_material_basis_surcharge_credit (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_surcharge_credit(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeCredit (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_material_basis_surcharge_table<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::DtMlstring>,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfSurchargeElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (values , None) , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (_ , Some (deserializer))) => UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_material_basis_surcharge_table (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_material_basis_surcharge_table(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (values , None)) ? ;
                    *self.state = UdxEdxfSurchargeElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfSurchargeElementTypeContentDeserializerState :: UdxEdxfMaterialBasisSurchargeTable (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfSurchargeElementTypeContent>
        for UdxEdxfSurchargeElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(UdxEdxfSurchargeElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        UdxEdxfSurchargeElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfSurchargeElementTypeContent>
        where
            R: DeserializeReader,
        {
            use UdxEdxfSurchargeElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfSurchargeType(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_type(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeClass(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_class(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeManner(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_manner(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargePercentage(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_percentage(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargePriceAmount(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_price_amount(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeCalculation(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_surcharge_calculation(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasis(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisWeight(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_weight(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfMaterialBasisSurchargeThreshold(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_threshold(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfMaterialBasisSurchargeShutter(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_shutter(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeCredit(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_credit(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeTable(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_table(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::UdxEdxfSurchargeType(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_type(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeClass(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_class(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeManner(values, None), event) => {
                        let output = < super :: UdxEdxfSurchargeMannerElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_udx_edxf_surcharge_manner(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargePercentage(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_percentage(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargePriceAmount(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_surcharge_price_amount(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfSurchargeCalculation(values, None), event) => {
                        let output = < super :: UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_udx_edxf_surcharge_calculation(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasis(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_material_basis(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisWeight(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_material_basis_weight(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeThreshold(values, None), event) => {
                        let output = <f64 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_material_basis_surcharge_threshold(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeShutter(values, None), event) => {
                        let output = < super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_udx_edxf_material_basis_surcharge_shutter(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeCredit(values, None), event) => {
                        let output = < super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_udx_edxf_material_basis_surcharge_credit(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMaterialBasisSurchargeTable(values, None), event) => {
                        let output = <super::DtMlstring as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        match self.handle_udx_edxf_material_basis_surcharge_table(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::UdxEdxfSurchargeElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfFeatureMcElementTypeDeserializer {
        content: Vec<super::UdxEdxfFeatureMcElementTypeContent>,
        state: Box<UdxEdxfFeatureMcElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfFeatureMcElementTypeDeserializerState {
        Init__,
        Next__,
        Content__(<super::UdxEdxfFeatureMcElementTypeContent as WithDeserializer>::Deserializer),
        Unknown__,
    }
    impl UdxEdxfFeatureMcElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: Vec::new(),
                state: Box::new(UdxEdxfFeatureMcElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfFeatureMcElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfFeatureMcElementTypeDeserializerState::Content__(deserializer) = state {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::UdxEdxfFeatureMcElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfFeatureMcElementTypeContent>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfFeatureMcElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = UdxEdxfFeatureMcElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let can_have_more = self.content.len().saturating_add(1) < 7usize;
                    let ret = if can_have_more {
                        ElementHandlerOutput::from_event(event, allow_any)
                    } else {
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    };
                    match (can_have_more, &ret) {
                        (true, ElementHandlerOutput::Continue { .. }) => {
                            fallback.get_or_insert(
                                UdxEdxfFeatureMcElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state = UdxEdxfFeatureMcElementTypeDeserializerState::Next__;
                        }
                        (false, _) | (_, ElementHandlerOutput::Break { .. }) => {
                            *self.state = UdxEdxfFeatureMcElementTypeDeserializerState::Content__(
                                deserializer,
                            );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfFeatureMcElementType>
        for UdxEdxfFeatureMcElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfFeatureMcElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfFeatureMcElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfFeatureMcElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: UdxEdxfFeatureMcElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfFeatureMcElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfFeatureMcElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfFeatureMcElementType {
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfFeatureMcElementTypeContentDeserializer {
        state: Box<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum UdxEdxfFeatureMcElementTypeContentDeserializerState {
        Init__,
        UdxEdxfPortcode(Option<i32>, Option<<i32 as WithDeserializer>::Deserializer>),
        UdxEdxfFname(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfFvalue(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfCoordinateX(Option<f32>, Option<<f32 as WithDeserializer>::Deserializer>),
        UdxEdxfCoordinateY(Option<f32>, Option<<f32 as WithDeserializer>::Deserializer>),
        UdxEdxfCoordinateZ(Option<f32>, Option<<f32 as WithDeserializer>::Deserializer>),
        UdxEdxfMatrixValues(
            Option<super::UdxEdxfMatrixValuesElementType>,
            Option<<super::UdxEdxfMatrixValuesElementType as WithDeserializer>::Deserializer>,
        ),
        Done__(super::UdxEdxfFeatureMcElementTypeContent),
        Unknown__,
    }
    impl UdxEdxfFeatureMcElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfFeatureMcElementTypeContentDeserializerState::Init__);
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PORTCODE")
            ) {
                let output = <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_portcode(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.FNAME")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_fname(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.FVALUE")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_fvalue(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.COORDINATE_X")
            ) {
                let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_coordinate_x(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.COORDINATE_Y")
            ) {
                let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_coordinate_y(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.COORDINATE_Z")
            ) {
                let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_coordinate_z(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.MATRIX_VALUES")
            ) {
                let output = < super :: UdxEdxfMatrixValuesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                return self.handle_udx_edxf_matrix_values(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(UdxEdxfFeatureMcElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: UdxEdxfFeatureMcElementTypeContentDeserializerState,
        ) -> Result<super::UdxEdxfFeatureMcElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfFeatureMcElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::UdxEdxfPortcode(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_portcode(&mut values, value)?;
                    }
                    Ok(super::UdxEdxfFeatureMcElementTypeContent::UdxEdxfPortcode(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.PORTCODE".into()))?,
                    ))
                }
                S::UdxEdxfFname(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_fname(&mut values, value)?;
                    }
                    Ok(super::UdxEdxfFeatureMcElementTypeContent::UdxEdxfFname(
                        values.ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.FNAME".into()))?,
                    ))
                }
                S::UdxEdxfFvalue(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_fvalue(&mut values, value)?;
                    }
                    Ok(super::UdxEdxfFeatureMcElementTypeContent::UdxEdxfFvalue(
                        values
                            .ok_or_else(|| ErrorKind::MissingElement("UDX.EDXF.FVALUE".into()))?,
                    ))
                }
                S::UdxEdxfCoordinateX(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_coordinate_x(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfFeatureMcElementTypeContent::UdxEdxfCoordinateX(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.COORDINATE_X".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfCoordinateY(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_coordinate_y(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfFeatureMcElementTypeContent::UdxEdxfCoordinateY(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.COORDINATE_Y".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfCoordinateZ(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_coordinate_z(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfFeatureMcElementTypeContent::UdxEdxfCoordinateZ(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.COORDINATE_Z".into())
                            })?,
                        ),
                    )
                }
                S::UdxEdxfMatrixValues(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_matrix_values(&mut values, value)?;
                    }
                    Ok(
                        super::UdxEdxfFeatureMcElementTypeContent::UdxEdxfMatrixValues(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("UDX.EDXF.MATRIX_VALUES".into())
                            })?,
                        ),
                    )
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_udx_edxf_portcode(values: &mut Option<i32>, value: i32) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PORTCODE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_fname(values: &mut Option<String>, value: String) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.FNAME",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_fvalue(values: &mut Option<String>, value: String) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.FVALUE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_coordinate_x(values: &mut Option<f32>, value: f32) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COORDINATE_X",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_coordinate_y(values: &mut Option<f32>, value: f32) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COORDINATE_Y",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_coordinate_z(values: &mut Option<f32>, value: f32) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.COORDINATE_Z",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_matrix_values(
            values: &mut Option<super::UdxEdxfMatrixValuesElementType>,
            value: super::UdxEdxfMatrixValuesElementType,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATRIX_VALUES",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_portcode<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<i32>,
            output: DeserializerOutput<'de, i32>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfPortcode(
                        values, None,
                    ),
                    Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfPortcode(
                        _,
                        Some(deserializer),
                    )) => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfPortcode(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfPortcode(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_portcode(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_portcode(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfPortcode(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfFeatureMcElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfPortcode(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_fname<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFname(
                        values, None,
                    ),
                    Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFname(
                        _,
                        Some(deserializer),
                    )) => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFname(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFname(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_fname(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_fname(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFname(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfFeatureMcElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state = UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFname(
                        values,
                        Some(deserializer),
                    );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_fvalue<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFvalue(
                        values, None,
                    ),
                    Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFvalue(
                        _,
                        Some(deserializer),
                    )) => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFvalue(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFvalue(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_fvalue(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_fvalue(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFvalue(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfFeatureMcElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfFvalue(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_coordinate_x<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f32>,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateX(
                            values, None,
                        )
                    }
                    Some(
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateX(
                            _,
                            Some(deserializer),
                        ),
                    ) => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateX(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateX(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_coordinate_x(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_coordinate_x(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateX(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfFeatureMcElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateX(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_coordinate_y<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f32>,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateY(
                            values, None,
                        )
                    }
                    Some(
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateY(
                            _,
                            Some(deserializer),
                        ),
                    ) => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateY(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateY(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_coordinate_y(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_coordinate_y(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateY(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfFeatureMcElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateY(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_coordinate_z<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f32>,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateZ(
                            values, None,
                        )
                    }
                    Some(
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateZ(
                            _,
                            Some(deserializer),
                        ),
                    ) => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateZ(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateZ(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_coordinate_z(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_coordinate_z(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateZ(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfFeatureMcElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfCoordinateZ(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_matrix_values<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::UdxEdxfMatrixValuesElementType>,
            output: DeserializerOutput<'de, super::UdxEdxfMatrixValuesElementType>,
            fallback: &mut Option<UdxEdxfFeatureMcElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = match fallback.take() {
                    None => {
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfMatrixValues(
                            values, None,
                        )
                    }
                    Some(
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfMatrixValues(
                            _,
                            Some(deserializer),
                        ),
                    ) => UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfMatrixValues(
                        values,
                        Some(deserializer),
                    ),
                    _ => unreachable!(),
                };
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback.take() {
                None => (),
                Some(UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfMatrixValues(
                    _,
                    Some(deserializer),
                )) => {
                    let data = deserializer.finish(reader)?;
                    Self::store_udx_edxf_matrix_values(&mut values, data)?;
                }
                Some(_) => unreachable!(),
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_matrix_values(&mut values, data)?;
                    let data = Self::finish_state(
                        reader,
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfMatrixValues(
                            values, None,
                        ),
                    )?;
                    *self.state = UdxEdxfFeatureMcElementTypeContentDeserializerState::Done__(data);
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    *self.state =
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::UdxEdxfMatrixValues(
                            values,
                            Some(deserializer),
                        );
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfFeatureMcElementTypeContent>
        for UdxEdxfFeatureMcElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfFeatureMcElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(UdxEdxfFeatureMcElementTypeContentDeserializerState::Init__),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        UdxEdxfFeatureMcElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfFeatureMcElementTypeContent>
        where
            R: DeserializeReader,
        {
            use UdxEdxfFeatureMcElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfPortcode(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_portcode(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfFname(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_fname(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfFvalue(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_fvalue(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfCoordinateX(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_coordinate_x(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfCoordinateY(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_coordinate_y(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfCoordinateZ(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_coordinate_z(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMatrixValues(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_matrix_values(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::UdxEdxfPortcode(values, None), event) => {
                        let output = <i32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_portcode(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfFname(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_fname(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfFvalue(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_fvalue(reader, values, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfCoordinateX(values, None), event) => {
                        let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_coordinate_x(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfCoordinateY(values, None), event) => {
                        let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_coordinate_y(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfCoordinateZ(values, None), event) => {
                        let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_coordinate_z(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfMatrixValues(values, None), event) => {
                        let output = < super :: UdxEdxfMatrixValuesElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_udx_edxf_matrix_values(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(self, reader: &R) -> Result<super::UdxEdxfFeatureMcElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductCharacteristicElementTypeDeserializer {
        content: Vec<super::UdxEdxfProductCharacteristicElementTypeContent>,
        state: Box<UdxEdxfProductCharacteristicElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfProductCharacteristicElementTypeDeserializerState {
        Init__ , Next__ , Content__ (< super :: UdxEdxfProductCharacteristicElementTypeContent as WithDeserializer > :: Deserializer) , Unknown__ , }
    impl UdxEdxfProductCharacteristicElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                content: Vec::new(),
                state: Box::new(UdxEdxfProductCharacteristicElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfProductCharacteristicElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            if let UdxEdxfProductCharacteristicElementTypeDeserializerState::Content__(
                deserializer,
            ) = state
            {
                self.store_content(deserializer.finish(reader)?)?;
            }
            Ok(())
        }
        fn store_content(
            &mut self,
            value: super::UdxEdxfProductCharacteristicElementTypeContent,
        ) -> Result<(), Error> {
            self.content.push(value);
            Ok(())
        }
        fn handle_content<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfProductCharacteristicElementTypeContent>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                *self.state = fallback
                    .take()
                    .unwrap_or(UdxEdxfProductCharacteristicElementTypeDeserializerState::Next__);
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_content(data)?;
                    *self.state = UdxEdxfProductCharacteristicElementTypeDeserializerState::Next__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfProductCharacteristicElementTypeDeserializerState::Content__(
                                    deserializer,
                                );
                        }
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfProductCharacteristicElementTypeDeserializerState::Content__(
                                    deserializer,
                                ),
                            );
                            *self.state =
                                UdxEdxfProductCharacteristicElementTypeDeserializerState::Next__;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfProductCharacteristicElementType>
        for UdxEdxfProductCharacteristicElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductCharacteristicElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductCharacteristicElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductCharacteristicElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::Content__(deserializer), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (_, Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (state @ (S::Init__ | S::Next__), event) => {
                        fallback.get_or_insert(state);
                        let output = < super :: UdxEdxfProductCharacteristicElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        match self.handle_content(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = DeserializerArtifact::Deserializer(self);
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            mut self,
            reader: &R,
        ) -> Result<super::UdxEdxfProductCharacteristicElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfProductCharacteristicElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfProductCharacteristicElementType {
                content: self.content,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductCharacteristicElementTypeContentDeserializer {
        state: Box<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
    }
    #[derive(Debug)]
    pub enum UdxEdxfProductCharacteristicElementTypeContentDeserializerState {
        Init__,
        UdxEdxfProductCharacteristicCode(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicName(
            Option<super::DtMlstring>,
            Option<<super::DtMlstring as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicValueBoolean(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicValueNumeric(
            Option<f32>,
            Option<<f32 as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicValueRangeFrom(
            Option<f32>,
            Option<<f32 as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicValueRangeTo(
            Option<f32>,
            Option<<f32 as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicValueString(
            Option<super::DtMlstring>,
            Option<<super::DtMlstring as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicValueSet(
            Option<super::DtMlstring>,
            Option<<super::DtMlstring as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicValueSelect(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicValueUnitCode(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        UdxEdxfProductCharacteristicReferenceGtin(
            Option<String>,
            Option<<String as WithDeserializer>::Deserializer>,
        ),
        Done__(super::UdxEdxfProductCharacteristicElementTypeContent),
        Unknown__,
    }
    impl UdxEdxfProductCharacteristicElementTypeContentDeserializer {
        fn find_suitable<'de, R>(
            &mut self,
            reader: &R,
            event: Event<'de>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let (Event::Start(x) | Event::Empty(x)) = &event else {
                *self.state = fallback.take().unwrap_or(
                    UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Init__,
                );
                return Ok(ElementHandlerOutput::return_to_parent(event, false));
            };
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_CODE")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_code(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_NAME")
            ) {
                let output =
                    <super::DtMlstring as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_name(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_BOOLEAN")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_value_boolean(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_NUMERIC")
            ) {
                let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_value_numeric(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_RANGE_FROM")
            ) {
                let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_value_range_from(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_RANGE_TO")
            ) {
                let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_value_range_to(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_STRING")
            ) {
                let output =
                    <super::DtMlstring as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_value_string(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_SET")
            ) {
                let output =
                    <super::DtMlstring as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_value_set(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_SELECT")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_value_select(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_UNIT_CODE")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_value_unit_code(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            if matches!(
                reader.resolve_local_name(x.name(), &super::NS_DEFAULT),
                Some(b"UDX.EDXF.PRODUCT_CHARACTERISTIC_REFERENCE_GTIN")
            ) {
                let output = <String as WithDeserializer>::Deserializer::init(reader, event)?;
                return self.handle_udx_edxf_product_characteristic_reference_gtin(
                    reader,
                    Default::default(),
                    output,
                    &mut *fallback,
                );
            }
            *self.state = fallback
                .take()
                .unwrap_or(UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Init__);
            Ok(ElementHandlerOutput::return_to_parent(event, false))
        }
        fn finish_state<R>(
            reader: &R,
            state: UdxEdxfProductCharacteristicElementTypeContentDeserializerState,
        ) -> Result<super::UdxEdxfProductCharacteristicElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductCharacteristicElementTypeContentDeserializerState as S;
            match state {
                S::Init__ => Err(ErrorKind::MissingContent.into()),
                S::UdxEdxfProductCharacteristicCode(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_code(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicCode (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_CODE" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicName(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_name(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicName (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_NAME" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicValueBoolean(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_value_boolean(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueBoolean (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_BOOLEAN" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicValueNumeric(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_value_numeric(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueNumeric (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_NUMERIC" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicValueRangeFrom(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_value_range_from(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueRangeFrom (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_RANGE_FROM" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicValueRangeTo(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_value_range_to(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueRangeTo (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_RANGE_TO" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicValueString(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_value_string(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueString (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_STRING" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicValueSet(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_value_set(&mut values, value)?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueSet (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_SET" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicValueSelect(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_value_select(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueSelect (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_SELECT" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicValueUnitCode(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_value_unit_code(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueUnitCode (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_UNIT_CODE" . into ())) ?))
                }
                S::UdxEdxfProductCharacteristicReferenceGtin(mut values, deserializer) => {
                    if let Some(deserializer) = deserializer {
                        let value = deserializer.finish(reader)?;
                        Self::store_udx_edxf_product_characteristic_reference_gtin(
                            &mut values,
                            value,
                        )?;
                    }
                    Ok (super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicReferenceGtin (values . ok_or_else (|| ErrorKind :: MissingElement ("UDX.EDXF.PRODUCT_CHARACTERISTIC_REFERENCE_GTIN" . into ())) ?))
                }
                S::Done__(data) => Ok(data),
                S::Unknown__ => unreachable!(),
            }
        }
        fn store_udx_edxf_product_characteristic_code(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_CODE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_name(
            values: &mut Option<super::DtMlstring>,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_NAME",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_value_boolean(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_BOOLEAN",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_value_numeric(
            values: &mut Option<f32>,
            value: f32,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_NUMERIC",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_value_range_from(
            values: &mut Option<f32>,
            value: f32,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_RANGE_FROM",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_value_range_to(
            values: &mut Option<f32>,
            value: f32,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_RANGE_TO",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_value_string(
            values: &mut Option<super::DtMlstring>,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_STRING",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_value_set(
            values: &mut Option<super::DtMlstring>,
            value: super::DtMlstring,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_SET",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_value_select(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_SELECT",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_value_unit_code(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_UNIT_CODE",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn store_udx_edxf_product_characteristic_reference_gtin(
            values: &mut Option<String>,
            value: String,
        ) -> Result<(), Error> {
            if values.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.PRODUCT_CHARACTERISTIC_REFERENCE_GTIN",
                )))?;
            }
            *values = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_product_characteristic_code<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicCode (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicCode (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicCode (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicCode (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_code (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_code(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicCode (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicCode (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_name<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::DtMlstring>,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicName (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicName (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicName (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicName (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_name (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_name(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicName (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicName (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_value_boolean<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueBoolean (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueBoolean (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueBoolean (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueBoolean (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_value_boolean (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_value_boolean(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueBoolean (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueBoolean (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_value_numeric<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f32>,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueNumeric (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueNumeric (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueNumeric (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueNumeric (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_value_numeric (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_value_numeric(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueNumeric (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueNumeric (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_value_range_from<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f32>,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeFrom (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeFrom (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeFrom (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeFrom (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_value_range_from (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_value_range_from(
                        &mut values,
                        data,
                    )?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeFrom (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeFrom (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_value_range_to<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<f32>,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeTo (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeTo (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeTo (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeTo (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_value_range_to (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_value_range_to(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeTo (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueRangeTo (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_value_string<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::DtMlstring>,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueString (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueString (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueString (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueString (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_value_string (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_value_string(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueString (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueString (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_value_set<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<super::DtMlstring>,
            output: DeserializerOutput<'de, super::DtMlstring>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSet (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSet (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSet (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSet (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_value_set (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_value_set(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSet (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSet (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_value_select<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSelect (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSelect (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSelect (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSelect (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_value_select (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_value_select(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSelect (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueSelect (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_value_unit_code<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueUnitCode (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueUnitCode (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueUnitCode (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueUnitCode (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_value_unit_code (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_value_unit_code(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueUnitCode (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicValueUnitCode (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
        fn handle_udx_edxf_product_characteristic_reference_gtin<'de, R>(
            &mut self,
            reader: &R,
            mut values: Option<String>,
            output: DeserializerOutput<'de, String>,
            fallback: &mut Option<UdxEdxfProductCharacteristicElementTypeContentDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                * self . state = match fallback . take () { None => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicReferenceGtin (values , None) , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicReferenceGtin (_ , Some (deserializer))) => UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicReferenceGtin (values , Some (deserializer)) , _ => unreachable ! () , } ;
                return Ok(ElementHandlerOutput::break_(event, allow_any));
            }
            match fallback . take () { None => () , Some (UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicReferenceGtin (_ , Some (deserializer))) => { let data = deserializer . finish (reader) ? ; Self :: store_udx_edxf_product_characteristic_reference_gtin (& mut values , data) ? ; } Some (_) => unreachable ! () , }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    Self::store_udx_edxf_product_characteristic_reference_gtin(&mut values, data)?;
                    let data = Self :: finish_state (reader , UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicReferenceGtin (values , None)) ? ;
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Done__(
                            data,
                        );
                    ElementHandlerOutput::Break { event, allow_any }
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    * self . state = UdxEdxfProductCharacteristicElementTypeContentDeserializerState :: UdxEdxfProductCharacteristicReferenceGtin (values , Some (deserializer)) ;
                    ElementHandlerOutput::from_event_end(event, allow_any)
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfProductCharacteristicElementTypeContent>
        for UdxEdxfProductCharacteristicElementTypeContentDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductCharacteristicElementTypeContent>
        where
            R: DeserializeReader,
        {
            let deserializer = Self {
                state: Box::new(
                    UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Init__,
                ),
            };
            let mut output = deserializer.next(reader, event)?;
            output.artifact = match output.artifact {
                DeserializerArtifact::Deserializer(x)
                    if matches!(
                        &*x.state,
                        UdxEdxfProductCharacteristicElementTypeContentDeserializerState::Init__
                    ) =>
                {
                    DeserializerArtifact::None
                }
                artifact => artifact,
            };
            Ok(output)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfProductCharacteristicElementTypeContent>
        where
            R: DeserializeReader,
        {
            use UdxEdxfProductCharacteristicElementTypeContentDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfProductCharacteristicCode(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_code(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicName(values, Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_name(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicValueBoolean(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_boolean(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicValueNumeric(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_numeric(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicValueRangeFrom(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_range_from(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicValueRangeTo(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_range_to(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicValueString(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_string(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicValueSet(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_set(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicValueSelect(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_select(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicValueUnitCode(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_unit_code(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (
                        S::UdxEdxfProductCharacteristicReferenceGtin(values, Some(deserializer)),
                        event,
                    ) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_reference_gtin(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (state, event @ Event::End(_)) => {
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(Self::finish_state(
                                reader, state,
                            )?),
                            event: DeserializerEvent::Continue(event),
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => match self.find_suitable(reader, event, &mut fallback)? {
                        ElementHandlerOutput::Break { event, allow_any } => {
                            break (event, allow_any)
                        }
                        ElementHandlerOutput::Continue { event, .. } => event,
                    },
                    (S::UdxEdxfProductCharacteristicCode(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_code(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicName(values, None), event) => {
                        let output = <super::DtMlstring as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        match self.handle_udx_edxf_product_characteristic_name(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicValueBoolean(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_boolean(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicValueNumeric(values, None), event) => {
                        let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_numeric(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicValueRangeFrom(values, None), event) => {
                        let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_range_from(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicValueRangeTo(values, None), event) => {
                        let output = <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_range_to(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicValueString(values, None), event) => {
                        let output = <super::DtMlstring as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        match self.handle_udx_edxf_product_characteristic_value_string(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicValueSet(values, None), event) => {
                        let output = <super::DtMlstring as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        match self.handle_udx_edxf_product_characteristic_value_set(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicValueSelect(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_select(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicValueUnitCode(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_value_unit_code(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (S::UdxEdxfProductCharacteristicReferenceGtin(values, None), event) => {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_udx_edxf_product_characteristic_reference_gtin(
                            reader,
                            values,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        }
                    }
                    (s @ S::Done__(_), event) => {
                        *self.state = s;
                        break (DeserializerEvent::Continue(event), false);
                    }
                    (S::Unknown__, _) => unreachable!(),
                }
            };
            let artifact = if matches!(&*self.state, S::Done__(_)) {
                DeserializerArtifact::Data(self.finish(reader)?)
            } else {
                DeserializerArtifact::Deserializer(self)
            };
            Ok(DeserializerOutput {
                artifact,
                event,
                allow_any,
            })
        }
        fn finish<R>(
            self,
            reader: &R,
        ) -> Result<super::UdxEdxfProductCharacteristicElementTypeContent, Error>
        where
            R: DeserializeReader,
        {
            Self::finish_state(reader, *self.state)
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfMatrixValuesElementTypeDeserializer {
        udx_edxf_matrix_value: Vec<super::UdxEdxfMatrixValueElementType>,
        state: Box<UdxEdxfMatrixValuesElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfMatrixValuesElementTypeDeserializerState {
        Init__,
        UdxEdxfMatrixValue(
            Option<<super::UdxEdxfMatrixValueElementType as WithDeserializer>::Deserializer>,
        ),
        Done__,
        Unknown__,
    }
    impl UdxEdxfMatrixValuesElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_matrix_value: Vec::new(),
                state: Box::new(UdxEdxfMatrixValuesElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfMatrixValuesElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfMatrixValuesElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfMatrixValue(Some(deserializer)) => {
                    self.store_udx_edxf_matrix_value(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_matrix_value(
            &mut self,
            value: super::UdxEdxfMatrixValueElementType,
        ) -> Result<(), Error> {
            self.udx_edxf_matrix_value.push(value);
            Ok(())
        }
        fn handle_udx_edxf_matrix_value<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, super::UdxEdxfMatrixValueElementType>,
            fallback: &mut Option<UdxEdxfMatrixValuesElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_matrix_value.len() < 1usize {
                    *self.state =
                        UdxEdxfMatrixValuesElementTypeDeserializerState::UdxEdxfMatrixValue(None);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                } else {
                    fallback.get_or_insert(
                        UdxEdxfMatrixValuesElementTypeDeserializerState::UdxEdxfMatrixValue(None),
                    );
                    *self.state = UdxEdxfMatrixValuesElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_matrix_value(data)?;
                    *self.state =
                        UdxEdxfMatrixValuesElementTypeDeserializerState::UdxEdxfMatrixValue(None);
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback.get_or_insert(
                                UdxEdxfMatrixValuesElementTypeDeserializerState::UdxEdxfMatrixValue(
                                    Some(deserializer),
                                ),
                            );
                            if self.udx_edxf_matrix_value.len().saturating_add(1) < 1usize {
                                * self . state = UdxEdxfMatrixValuesElementTypeDeserializerState :: UdxEdxfMatrixValue (None) ;
                            } else {
                                *self.state =
                                    UdxEdxfMatrixValuesElementTypeDeserializerState::Done__;
                            }
                        }
                        ElementHandlerOutput::Break { .. } => {
                            *self.state =
                                UdxEdxfMatrixValuesElementTypeDeserializerState::UdxEdxfMatrixValue(
                                    Some(deserializer),
                                );
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfMatrixValuesElementType>
        for UdxEdxfMatrixValuesElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfMatrixValuesElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfMatrixValuesElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfMatrixValuesElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfMatrixValue(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_matrix_value(reader, output, &mut fallback)? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        *self.state =
                            UdxEdxfMatrixValuesElementTypeDeserializerState::UdxEdxfMatrixValue(
                                None,
                            );
                        event
                    }
                    (S::UdxEdxfMatrixValue(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MATRIX_VALUE",
                        ) {
                            let output = < super :: UdxEdxfMatrixValueElementType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_udx_edxf_matrix_value(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfMatrixValuesElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfMatrixValuesElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfMatrixValuesElementType {
                udx_edxf_matrix_value: self.udx_edxf_matrix_value,
            })
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfMatrixValueElementTypeDeserializer {
        udx_edxf_matrix_source_value: Option<f32>,
        udx_edxf_matrix_result_value: Option<f32>,
        state: Box<UdxEdxfMatrixValueElementTypeDeserializerState>,
    }
    #[derive(Debug)]
    enum UdxEdxfMatrixValueElementTypeDeserializerState {
        Init__,
        UdxEdxfMatrixSourceValue(Option<<f32 as WithDeserializer>::Deserializer>),
        UdxEdxfMatrixResultValue(Option<<f32 as WithDeserializer>::Deserializer>),
        Done__,
        Unknown__,
    }
    impl UdxEdxfMatrixValueElementTypeDeserializer {
        fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            for attrib in filter_xmlns_attributes(bytes_start) {
                let attrib = attrib?;
                reader.raise_unexpected_attrib_checked(attrib)?;
            }
            Ok(Self {
                udx_edxf_matrix_source_value: None,
                udx_edxf_matrix_result_value: None,
                state: Box::new(UdxEdxfMatrixValueElementTypeDeserializerState::Init__),
            })
        }
        fn finish_state<R>(
            &mut self,
            reader: &R,
            state: UdxEdxfMatrixValueElementTypeDeserializerState,
        ) -> Result<(), Error>
        where
            R: DeserializeReader,
        {
            use UdxEdxfMatrixValueElementTypeDeserializerState as S;
            match state {
                S::UdxEdxfMatrixSourceValue(Some(deserializer)) => {
                    self.store_udx_edxf_matrix_source_value(deserializer.finish(reader)?)?
                }
                S::UdxEdxfMatrixResultValue(Some(deserializer)) => {
                    self.store_udx_edxf_matrix_result_value(deserializer.finish(reader)?)?
                }
                _ => (),
            }
            Ok(())
        }
        fn store_udx_edxf_matrix_source_value(&mut self, value: f32) -> Result<(), Error> {
            if self.udx_edxf_matrix_source_value.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATRIX_SOURCE_VALUE",
                )))?;
            }
            self.udx_edxf_matrix_source_value = Some(value);
            Ok(())
        }
        fn store_udx_edxf_matrix_result_value(&mut self, value: f32) -> Result<(), Error> {
            if self.udx_edxf_matrix_result_value.is_some() {
                Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                    b"UDX.EDXF.MATRIX_RESULT_VALUE",
                )))?;
            }
            self.udx_edxf_matrix_result_value = Some(value);
            Ok(())
        }
        fn handle_udx_edxf_matrix_source_value<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfMatrixValueElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_matrix_source_value.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfMatrixValueElementTypeDeserializerState::UdxEdxfMatrixSourceValue(
                            None,
                        ),
                    );
                    *self.state =
                        UdxEdxfMatrixValueElementTypeDeserializerState::UdxEdxfMatrixResultValue(
                            None,
                        );
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        UdxEdxfMatrixValueElementTypeDeserializerState::UdxEdxfMatrixSourceValue(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_matrix_source_value(data)?;
                    *self.state =
                        UdxEdxfMatrixValueElementTypeDeserializerState::UdxEdxfMatrixResultValue(
                            None,
                        );
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfMatrixValueElementTypeDeserializerState :: UdxEdxfMatrixSourceValue (Some (deserializer))) ;
                            * self . state = UdxEdxfMatrixValueElementTypeDeserializerState :: UdxEdxfMatrixResultValue (None) ;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfMatrixValueElementTypeDeserializerState :: UdxEdxfMatrixSourceValue (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
        fn handle_udx_edxf_matrix_result_value<'de, R>(
            &mut self,
            reader: &R,
            output: DeserializerOutput<'de, f32>,
            fallback: &mut Option<UdxEdxfMatrixValueElementTypeDeserializerState>,
        ) -> Result<ElementHandlerOutput<'de>, Error>
        where
            R: DeserializeReader,
        {
            let DeserializerOutput {
                artifact,
                event,
                allow_any,
            } = output;
            if artifact.is_none() {
                if self.udx_edxf_matrix_result_value.is_some() {
                    fallback.get_or_insert(
                        UdxEdxfMatrixValueElementTypeDeserializerState::UdxEdxfMatrixResultValue(
                            None,
                        ),
                    );
                    *self.state = UdxEdxfMatrixValueElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                } else {
                    *self.state =
                        UdxEdxfMatrixValueElementTypeDeserializerState::UdxEdxfMatrixResultValue(
                            None,
                        );
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
            }
            if let Some(fallback) = fallback.take() {
                self.finish_state(reader, fallback)?;
            }
            Ok(match artifact {
                DeserializerArtifact::None => unreachable!(),
                DeserializerArtifact::Data(data) => {
                    self.store_udx_edxf_matrix_result_value(data)?;
                    *self.state = UdxEdxfMatrixValueElementTypeDeserializerState::Done__;
                    ElementHandlerOutput::from_event(event, allow_any)
                }
                DeserializerArtifact::Deserializer(deserializer) => {
                    let ret = ElementHandlerOutput::from_event(event, allow_any);
                    match &ret {
                        ElementHandlerOutput::Continue { .. } => {
                            fallback . get_or_insert (UdxEdxfMatrixValueElementTypeDeserializerState :: UdxEdxfMatrixResultValue (Some (deserializer))) ;
                            *self.state = UdxEdxfMatrixValueElementTypeDeserializerState::Done__;
                        }
                        ElementHandlerOutput::Break { .. } => {
                            * self . state = UdxEdxfMatrixValueElementTypeDeserializerState :: UdxEdxfMatrixResultValue (Some (deserializer)) ;
                        }
                    }
                    ret
                }
            })
        }
    }
    impl<'de> Deserializer<'de, super::UdxEdxfMatrixValueElementType>
        for UdxEdxfMatrixValueElementTypeDeserializer
    {
        fn init<R>(
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfMatrixValueElementType>
        where
            R: DeserializeReader,
        {
            reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
        }
        fn next<R>(
            mut self,
            reader: &R,
            event: Event<'de>,
        ) -> DeserializerResult<'de, super::UdxEdxfMatrixValueElementType>
        where
            R: DeserializeReader,
        {
            use UdxEdxfMatrixValueElementTypeDeserializerState as S;
            let mut event = event;
            let mut fallback = None;
            let mut allow_any_element = false;
            let (event, allow_any) = loop {
                let state = replace(&mut *self.state, S::Unknown__);
                event = match (state, event) {
                    (S::UdxEdxfMatrixSourceValue(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_matrix_source_value(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (S::UdxEdxfMatrixResultValue(Some(deserializer)), event) => {
                        let output = deserializer.next(reader, event)?;
                        match self.handle_udx_edxf_matrix_result_value(
                            reader,
                            output,
                            &mut fallback,
                        )? {
                            ElementHandlerOutput::Continue { event, allow_any } => {
                                allow_any_element = allow_any_element || allow_any;
                                event
                            }
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                        }
                    }
                    (_, Event::End(_)) => {
                        if let Some(fallback) = fallback.take() {
                            self.finish_state(reader, fallback)?;
                        }
                        return Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(self.finish(reader)?),
                            event: DeserializerEvent::None,
                            allow_any: false,
                        });
                    }
                    (S::Init__, event) => {
                        fallback.get_or_insert(S::Init__);
                        * self . state = UdxEdxfMatrixValueElementTypeDeserializerState :: UdxEdxfMatrixSourceValue (None) ;
                        event
                    }
                    (
                        S::UdxEdxfMatrixSourceValue(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MATRIX_SOURCE_VALUE",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_matrix_source_value(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::UdxEdxfMatrixResultValue(None);
                            event
                        }
                    }
                    (
                        S::UdxEdxfMatrixResultValue(None),
                        event @ (Event::Start(_) | Event::Empty(_)),
                    ) => {
                        if reader.check_start_tag_name(
                            &event,
                            Some(&super::NS_DEFAULT),
                            b"UDX.EDXF.MATRIX_RESULT_VALUE",
                        ) {
                            let output =
                                <f32 as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_udx_edxf_matrix_result_value(
                                reader,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        } else {
                            *self.state = S::Done__;
                            event
                        }
                    }
                    (S::Done__, event) => {
                        fallback.get_or_insert(S::Done__);
                        break (DeserializerEvent::Continue(event), allow_any_element);
                    }
                    (S::Unknown__, _) => unreachable!(),
                    (state, event) => {
                        *self.state = state;
                        break (DeserializerEvent::Break(event), false);
                    }
                }
            };
            if let Some(fallback) = fallback {
                *self.state = fallback;
            }
            Ok(DeserializerOutput {
                artifact: DeserializerArtifact::Deserializer(self),
                event,
                allow_any,
            })
        }
        fn finish<R>(mut self, reader: &R) -> Result<super::UdxEdxfMatrixValueElementType, Error>
        where
            R: DeserializeReader,
        {
            let state = replace(
                &mut *self.state,
                UdxEdxfMatrixValueElementTypeDeserializerState::Unknown__,
            );
            self.finish_state(reader, state)?;
            Ok(super::UdxEdxfMatrixValueElementType {
                udx_edxf_matrix_source_value: self.udx_edxf_matrix_source_value.ok_or_else(
                    || ErrorKind::MissingElement("UDX.EDXF.MATRIX_SOURCE_VALUE".into()),
                )?,
                udx_edxf_matrix_result_value: self.udx_edxf_matrix_result_value.ok_or_else(
                    || ErrorKind::MissingElement("UDX.EDXF.MATRIX_RESULT_VALUE".into()),
                )?,
            })
        }
    }
}
pub mod quick_xml_serialize {
    use core::iter::Iterator;
    use xsd_parser::quick_xml::{
        write_attrib, write_attrib_opt, BytesEnd, BytesStart, Error, Event, IterSerializer,
        WithSerializer,
    };
    #[derive(Debug)]
    pub struct BmecatElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::BmecatElementType,
        pub(super) state: Box<BmecatElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum BmecatElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::BmecatElementTypeContent],
                super::BmecatElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BmecatElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BmecatElementTypeSerializerState::Init__ => {
                        *self.state = BmecatElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "version", &self.value.version)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    BmecatElementTypeSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = BmecatElementTypeSerializerState::End__,
                    },
                    BmecatElementTypeSerializerState::End__ => {
                        *self.state = BmecatElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    BmecatElementTypeSerializerState::Done__ => return Ok(None),
                    BmecatElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BmecatElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BmecatElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct BmecatElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::BmecatElementTypeContent,
        pub(super) state: Box<BmecatElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum BmecatElementTypeContentSerializerState<'ser> {
        Init__,
        Header(<super::HeaderElementType as WithSerializer>::Serializer<'ser>),
        TNewCatalog(<super::TNewCatalogElementType as WithSerializer>::Serializer<'ser>),
        TUpdateProducts(<super::TUpdateProductsElementType as WithSerializer>::Serializer<'ser>),
        TUpdatePrices(<super::TUpdatePricesElementType as WithSerializer>::Serializer<'ser>),
        TNewProductdata(<super::TNewProductdataElementType as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BmecatElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BmecatElementTypeContentSerializerState::Init__ => match self.value {
                        super::BmecatElementTypeContent::Header(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::Header(
                                WithSerializer::serializer(x, Some("HEADER"), false)?,
                            )
                        }
                        super::BmecatElementTypeContent::TNewCatalog(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::TNewCatalog(
                                WithSerializer::serializer(x, Some("T_NEW_CATALOG"), false)?,
                            )
                        }
                        super::BmecatElementTypeContent::TUpdateProducts(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::TUpdateProducts(
                                WithSerializer::serializer(x, Some("T_UPDATE_PRODUCTS"), false)?,
                            )
                        }
                        super::BmecatElementTypeContent::TUpdatePrices(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::TUpdatePrices(
                                WithSerializer::serializer(x, Some("T_UPDATE_PRICES"), false)?,
                            )
                        }
                        super::BmecatElementTypeContent::TNewProductdata(x) => {
                            *self.state = BmecatElementTypeContentSerializerState::TNewProductdata(
                                WithSerializer::serializer(x, Some("T_NEW_PRODUCTDATA"), false)?,
                            )
                        }
                    },
                    BmecatElementTypeContentSerializerState::Header(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::TNewCatalog(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::TUpdateProducts(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::TUpdatePrices(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::TNewProductdata(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BmecatElementTypeContentSerializerState::Done__,
                        }
                    }
                    BmecatElementTypeContentSerializerState::Done__ => return Ok(None),
                    BmecatElementTypeContentSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BmecatElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BmecatElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct HeaderElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::HeaderElementType,
        pub(super) state: Box<HeaderElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum HeaderElementTypeSerializerState<'ser> {
        Init__,
        GeneratorInfo(IterSerializer<'ser, Option<&'ser String>, String>),
        Catalog(<super::CatalogElementType as WithSerializer>::Serializer<'ser>),
        Buyer(<super::BuyerElementType as WithSerializer>::Serializer<'ser>),
        Supplier(<super::SupplierElementType as WithSerializer>::Serializer<'ser>),
        UserDefinedExtensions(<super::UdxHeader as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> HeaderElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    HeaderElementTypeSerializerState::Init__ => {
                        *self.state =
                            HeaderElementTypeSerializerState::GeneratorInfo(IterSerializer::new(
                                self.value.generator_info.as_ref(),
                                Some("GENERATOR_INFO"),
                                false,
                            ));
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    HeaderElementTypeSerializerState::GeneratorInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = HeaderElementTypeSerializerState::Catalog(
                                    WithSerializer::serializer(
                                        &self.value.catalog,
                                        Some("CATALOG"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    HeaderElementTypeSerializerState::Catalog(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                HeaderElementTypeSerializerState::Buyer(WithSerializer::serializer(
                                    &self.value.buyer,
                                    Some("BUYER"),
                                    false,
                                )?)
                        }
                    },
                    HeaderElementTypeSerializerState::Buyer(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = HeaderElementTypeSerializerState::Supplier(
                                WithSerializer::serializer(
                                    &self.value.supplier,
                                    Some("SUPPLIER"),
                                    false,
                                )?,
                            )
                        }
                    },
                    HeaderElementTypeSerializerState::Supplier(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = HeaderElementTypeSerializerState::UserDefinedExtensions(
                                WithSerializer::serializer(
                                    &self.value.user_defined_extensions,
                                    Some("USER_DEFINED_EXTENSIONS"),
                                    false,
                                )?,
                            )
                        }
                    },
                    HeaderElementTypeSerializerState::UserDefinedExtensions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = HeaderElementTypeSerializerState::End__,
                        }
                    }
                    HeaderElementTypeSerializerState::End__ => {
                        *self.state = HeaderElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    HeaderElementTypeSerializerState::Done__ => return Ok(None),
                    HeaderElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for HeaderElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = HeaderElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TNewCatalogElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TNewCatalogElementType,
        pub(super) state: Box<TNewCatalogElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TNewCatalogElementTypeSerializerState<'ser> {
        Init__,
        Product(
            IterSerializer<
                'ser,
                &'ser [super::TNewCatalogProductElementType],
                super::TNewCatalogProductElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TNewCatalogElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TNewCatalogElementTypeSerializerState::Init__ => {
                        *self.state = TNewCatalogElementTypeSerializerState::Product(
                            IterSerializer::new(&self.value.product[..], Some("PRODUCT"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TNewCatalogElementTypeSerializerState::Product(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TNewCatalogElementTypeSerializerState::End__,
                        }
                    }
                    TNewCatalogElementTypeSerializerState::End__ => {
                        *self.state = TNewCatalogElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TNewCatalogElementTypeSerializerState::Done__ => return Ok(None),
                    TNewCatalogElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TNewCatalogElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TNewCatalogElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TUpdateProductsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TUpdateProductsElementType,
        pub(super) state: Box<TUpdateProductsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TUpdateProductsElementTypeSerializerState<'ser> {
        Init__,
        Product(
            IterSerializer<
                'ser,
                &'ser [super::TUpdateProductsProductElementType],
                super::TUpdateProductsProductElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TUpdateProductsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TUpdateProductsElementTypeSerializerState::Init__ => {
                        *self.state = TUpdateProductsElementTypeSerializerState::Product(
                            IterSerializer::new(&self.value.product[..], Some("PRODUCT"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "prev_version", &self.value.prev_version)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TUpdateProductsElementTypeSerializerState::Product(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TUpdateProductsElementTypeSerializerState::End__,
                        }
                    }
                    TUpdateProductsElementTypeSerializerState::End__ => {
                        *self.state = TUpdateProductsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TUpdateProductsElementTypeSerializerState::Done__ => return Ok(None),
                    TUpdateProductsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TUpdateProductsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TUpdateProductsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TUpdatePricesElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TUpdatePricesElementType,
        pub(super) state: Box<TUpdatePricesElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TUpdatePricesElementTypeSerializerState<'ser> {
        Init__,
        Product(
            IterSerializer<
                'ser,
                &'ser [super::TUpdatePricesProductElementType],
                super::TUpdatePricesProductElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TUpdatePricesElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TUpdatePricesElementTypeSerializerState::Init__ => {
                        *self.state = TUpdatePricesElementTypeSerializerState::Product(
                            IterSerializer::new(&self.value.product[..], Some("PRODUCT"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "prev_version", &self.value.prev_version)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TUpdatePricesElementTypeSerializerState::Product(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TUpdatePricesElementTypeSerializerState::End__,
                        }
                    }
                    TUpdatePricesElementTypeSerializerState::End__ => {
                        *self.state = TUpdatePricesElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TUpdatePricesElementTypeSerializerState::Done__ => return Ok(None),
                    TUpdatePricesElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TUpdatePricesElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TUpdatePricesElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TNewProductdataElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TNewProductdataElementType,
        pub(super) state: Box<TNewProductdataElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TNewProductdataElementTypeSerializerState<'ser> {
        Init__,
        Product(
            IterSerializer<
                'ser,
                &'ser [super::TNewProductdataProductElementType],
                super::TNewProductdataProductElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TNewProductdataElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TNewProductdataElementTypeSerializerState::Init__ => {
                        *self.state = TNewProductdataElementTypeSerializerState::Product(
                            IterSerializer::new(&self.value.product[..], Some("PRODUCT"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TNewProductdataElementTypeSerializerState::Product(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TNewProductdataElementTypeSerializerState::End__,
                        }
                    }
                    TNewProductdataElementTypeSerializerState::End__ => {
                        *self.state = TNewProductdataElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TNewProductdataElementTypeSerializerState::Done__ => return Ok(None),
                    TNewProductdataElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TNewProductdataElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TNewProductdataElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CatalogElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CatalogElementType,
        pub(super) state: Box<CatalogElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CatalogElementTypeSerializerState<'ser> {
        Init__,
        Language(
            IterSerializer<'ser, &'ser [super::LanguageElementType], super::LanguageElementType>,
        ),
        CatalogId(<String as WithSerializer>::Serializer<'ser>),
        CatalogVersion(<String as WithSerializer>::Serializer<'ser>),
        CatalogName(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        Datetime(<super::CatalogDatetimeElementType as WithSerializer>::Serializer<'ser>),
        Territory(IterSerializer<'ser, &'ser [String], String>),
        Currency(IterSerializer<'ser, Option<&'ser super::DtCurrencies>, super::DtCurrencies>),
        MimeRoot(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CatalogElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CatalogElementTypeSerializerState::Init__ => {
                        *self.state = CatalogElementTypeSerializerState::Language(
                            IterSerializer::new(&self.value.language[..], Some("LANGUAGE"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CatalogElementTypeSerializerState::Language(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = CatalogElementTypeSerializerState::CatalogId(
                                WithSerializer::serializer(
                                    &self.value.catalog_id,
                                    Some("CATALOG_ID"),
                                    false,
                                )?,
                            )
                        }
                    },
                    CatalogElementTypeSerializerState::CatalogId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogElementTypeSerializerState::CatalogVersion(
                                    WithSerializer::serializer(
                                        &self.value.catalog_version,
                                        Some("CATALOG_VERSION"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    CatalogElementTypeSerializerState::CatalogVersion(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogElementTypeSerializerState::CatalogName(
                                    IterSerializer::new(
                                        &self.value.catalog_name[..],
                                        Some("CATALOG_NAME"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    CatalogElementTypeSerializerState::CatalogName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogElementTypeSerializerState::Datetime(
                                    WithSerializer::serializer(
                                        &self.value.datetime,
                                        Some("DATETIME"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    CatalogElementTypeSerializerState::Datetime(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CatalogElementTypeSerializerState::Territory(IterSerializer::new(
                                    &self.value.territory[..],
                                    Some("TERRITORY"),
                                    false,
                                ))
                        }
                    },
                    CatalogElementTypeSerializerState::Territory(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CatalogElementTypeSerializerState::Currency(
                                    IterSerializer::new(
                                        self.value.currency.as_ref(),
                                        Some("CURRENCY"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    CatalogElementTypeSerializerState::Currency(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                CatalogElementTypeSerializerState::MimeRoot(IterSerializer::new(
                                    &self.value.mime_root[..],
                                    Some("MIME_ROOT"),
                                    false,
                                ))
                        }
                    },
                    CatalogElementTypeSerializerState::MimeRoot(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CatalogElementTypeSerializerState::End__,
                    },
                    CatalogElementTypeSerializerState::End__ => {
                        *self.state = CatalogElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CatalogElementTypeSerializerState::Done__ => return Ok(None),
                    CatalogElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CatalogElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CatalogElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct BuyerElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::BuyerElementType,
        pub(super) state: Box<BuyerElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum BuyerElementTypeSerializerState<'ser> {
        Init__,
        BuyerId(IterSerializer<'ser, &'ser [super::TypePartyId], super::TypePartyId>),
        BuyerName(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BuyerElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BuyerElementTypeSerializerState::Init__ => {
                        *self.state = BuyerElementTypeSerializerState::BuyerId(
                            IterSerializer::new(&self.value.buyer_id[..], Some("BUYER_ID"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    BuyerElementTypeSerializerState::BuyerId(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = BuyerElementTypeSerializerState::BuyerName(
                                WithSerializer::serializer(
                                    &self.value.buyer_name,
                                    Some("BUYER_NAME"),
                                    false,
                                )?,
                            )
                        }
                    },
                    BuyerElementTypeSerializerState::BuyerName(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = BuyerElementTypeSerializerState::End__,
                    },
                    BuyerElementTypeSerializerState::End__ => {
                        *self.state = BuyerElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    BuyerElementTypeSerializerState::Done__ => return Ok(None),
                    BuyerElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BuyerElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BuyerElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplierElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplierElementType,
        pub(super) state: Box<SupplierElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplierElementTypeSerializerState<'ser> {
        Init__,
        SupplierId(IterSerializer<'ser, &'ser [super::TypePartyId], super::TypePartyId>),
        SupplierName(<String as WithSerializer>::Serializer<'ser>),
        Address(
            IterSerializer<
                'ser,
                Option<&'ser super::SupplierAddressElementType>,
                super::SupplierAddressElementType,
            >,
        ),
        MimeInfo(
            IterSerializer<
                'ser,
                Option<&'ser super::MimeInfoElementType>,
                super::MimeInfoElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplierElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SupplierElementTypeSerializerState::Init__ => {
                        *self.state =
                            SupplierElementTypeSerializerState::SupplierId(IterSerializer::new(
                                &self.value.supplier_id[..],
                                Some("SUPPLIER_ID"),
                                false,
                            ));
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SupplierElementTypeSerializerState::SupplierId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierElementTypeSerializerState::SupplierName(
                                    WithSerializer::serializer(
                                        &self.value.supplier_name,
                                        Some("SUPPLIER_NAME"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    SupplierElementTypeSerializerState::SupplierName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierElementTypeSerializerState::Address(
                                    IterSerializer::new(
                                        self.value.address.as_ref(),
                                        Some("ADDRESS"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SupplierElementTypeSerializerState::Address(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                SupplierElementTypeSerializerState::MimeInfo(IterSerializer::new(
                                    self.value.mime_info.as_ref(),
                                    Some("MIME_INFO"),
                                    false,
                                ))
                        }
                    },
                    SupplierElementTypeSerializerState::MimeInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SupplierElementTypeSerializerState::End__,
                        }
                    }
                    SupplierElementTypeSerializerState::End__ => {
                        *self.state = SupplierElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SupplierElementTypeSerializerState::Done__ => return Ok(None),
                    SupplierElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SupplierElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplierElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxHeaderSerializer<'ser> {
        pub(super) value: &'ser super::UdxHeader,
        pub(super) state: Box<UdxHeaderSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxHeaderSerializerState<'ser> {
        Init__,
        UdxEdxfVersion(<super::TypeBmEcatEtimVersion as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxHeaderSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxHeaderSerializerState::Init__ => {
                        *self.state =
                            UdxHeaderSerializerState::UdxEdxfVersion(WithSerializer::serializer(
                                &self.value.udx_edxf_version,
                                Some("UDX.EDXF.VERSION"),
                                false,
                            )?);
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxHeaderSerializerState::UdxEdxfVersion(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxHeaderSerializerState::End__,
                    },
                    UdxHeaderSerializerState::End__ => {
                        *self.state = UdxHeaderSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxHeaderSerializerState::Done__ => return Ok(None),
                    UdxHeaderSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxHeaderSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxHeaderSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TNewCatalogProductElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TNewCatalogProductElementType,
        pub(super) state: Box<TNewCatalogProductElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TNewCatalogProductElementTypeSerializerState<'ser> {
        Init__,
        SupplierPid(<String as WithSerializer>::Serializer<'ser>),
        ProductDetails(<super::ProductDetailsElementType as WithSerializer>::Serializer<'ser>),
        ProductFeatures(
            IterSerializer<
                'ser,
                &'ser [super::ProductFeaturesElementType],
                super::ProductFeaturesElementType,
            >,
        ),
        ProductOrderDetails(
            <super::ProductOrderDetailsElementType as WithSerializer>::Serializer<'ser>,
        ),
        ProductPriceDetails(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceDetailsElementType],
                super::ProductPriceDetailsElementType,
            >,
        ),
        UserDefinedExtensions(<super::UdxProduct as WithSerializer>::Serializer<'ser>),
        ProductReference(
            IterSerializer<
                'ser,
                &'ser [super::ProductReferenceElementType],
                super::ProductReferenceElementType,
            >,
        ),
        ProductLogisticDetails(
            IterSerializer<
                'ser,
                Option<&'ser super::ProductLogisticDetailsElementType>,
                super::ProductLogisticDetailsElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TNewCatalogProductElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TNewCatalogProductElementTypeSerializerState::Init__ => {
                        *self.state = TNewCatalogProductElementTypeSerializerState::SupplierPid(
                            WithSerializer::serializer(
                                &self.value.supplier_pid,
                                Some("SUPPLIER_PID"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "mode", &self.value.mode)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TNewCatalogProductElementTypeSerializerState::SupplierPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TNewCatalogProductElementTypeSerializerState::ProductDetails(
                                        WithSerializer::serializer(
                                            &self.value.product_details,
                                            Some("PRODUCT_DETAILS"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TNewCatalogProductElementTypeSerializerState::ProductFeatures(
                                        IterSerializer::new(
                                            &self.value.product_features[..],
                                            Some("PRODUCT_FEATURES"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductFeatures(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TNewCatalogProductElementTypeSerializerState::ProductOrderDetails(
                                    WithSerializer::serializer(
                                        &self.value.product_order_details,
                                        Some("PRODUCT_ORDER_DETAILS"),
                                        false,
                                    )?,
                                ),
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductOrderDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TNewCatalogProductElementTypeSerializerState::ProductPriceDetails(
                                    IterSerializer::new(
                                        &self.value.product_price_details[..],
                                        Some("PRODUCT_PRICE_DETAILS"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductPriceDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TNewCatalogProductElementTypeSerializerState::UserDefinedExtensions(
                                    WithSerializer::serializer(
                                        &self.value.user_defined_extensions,
                                        Some("USER_DEFINED_EXTENSIONS"),
                                        false,
                                    )?,
                                ),
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::UserDefinedExtensions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TNewCatalogProductElementTypeSerializerState::ProductReference(
                                        IterSerializer::new(
                                            &self.value.product_reference[..],
                                            Some("PRODUCT_REFERENCE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::ProductReference(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                TNewCatalogProductElementTypeSerializerState::ProductLogisticDetails(
                                    IterSerializer::new(
                                        self.value.product_logistic_details.as_ref(),
                                        Some("PRODUCT_LOGISTIC_DETAILS"),
                                        false,
                                    ),
                                )
                        }
                    },
                    TNewCatalogProductElementTypeSerializerState::ProductLogisticDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = TNewCatalogProductElementTypeSerializerState::End__
                            }
                        }
                    }
                    TNewCatalogProductElementTypeSerializerState::End__ => {
                        *self.state = TNewCatalogProductElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TNewCatalogProductElementTypeSerializerState::Done__ => return Ok(None),
                    TNewCatalogProductElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TNewCatalogProductElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TNewCatalogProductElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TUpdateProductsProductElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TUpdateProductsProductElementType,
        pub(super) state: Box<TUpdateProductsProductElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TUpdateProductsProductElementTypeSerializerState<'ser> {
        Init__,
        SupplierPid(<String as WithSerializer>::Serializer<'ser>),
        ProductDetails(<super::ProductDetailsElementType as WithSerializer>::Serializer<'ser>),
        ProductFeatures(
            IterSerializer<
                'ser,
                &'ser [super::ProductFeaturesElementType],
                super::ProductFeaturesElementType,
            >,
        ),
        ProductOrderDetails(
            <super::ProductOrderDetailsElementType as WithSerializer>::Serializer<'ser>,
        ),
        ProductPriceDetails(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceDetailsElementType],
                super::ProductPriceDetailsElementType,
            >,
        ),
        UserDefinedExtensions(
            IterSerializer<'ser, Option<&'ser super::UdxProduct>, super::UdxProduct>,
        ),
        ProductReference(
            IterSerializer<
                'ser,
                &'ser [super::ProductReferenceElementType],
                super::ProductReferenceElementType,
            >,
        ),
        ProductLogisticDetails(
            IterSerializer<
                'ser,
                Option<&'ser super::ProductLogisticDetailsElementType>,
                super::ProductLogisticDetailsElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TUpdateProductsProductElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { TUpdateProductsProductElementTypeSerializerState :: Init__ => { * self . state = TUpdateProductsProductElementTypeSerializerState :: SupplierPid (WithSerializer :: serializer (& self . value . supplier_pid , Some ("SUPPLIER_PID") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; write_attrib (& mut bytes , "mode" , & self . value . mode) ? ; return Ok (Some (Event :: Start (bytes))) } TUpdateProductsProductElementTypeSerializerState :: SupplierPid (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductDetails (WithSerializer :: serializer (& self . value . product_details , Some ("PRODUCT_DETAILS") , false) ?) , } TUpdateProductsProductElementTypeSerializerState :: ProductDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductFeatures (IterSerializer :: new (& self . value . product_features [..] , Some ("PRODUCT_FEATURES") , false)) , } TUpdateProductsProductElementTypeSerializerState :: ProductFeatures (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductOrderDetails (WithSerializer :: serializer (& self . value . product_order_details , Some ("PRODUCT_ORDER_DETAILS") , false) ?) , } TUpdateProductsProductElementTypeSerializerState :: ProductOrderDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductPriceDetails (IterSerializer :: new (& self . value . product_price_details [..] , Some ("PRODUCT_PRICE_DETAILS") , false)) , } TUpdateProductsProductElementTypeSerializerState :: ProductPriceDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: UserDefinedExtensions (IterSerializer :: new (self . value . user_defined_extensions . as_ref () , Some ("USER_DEFINED_EXTENSIONS") , false)) , } TUpdateProductsProductElementTypeSerializerState :: UserDefinedExtensions (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductReference (IterSerializer :: new (& self . value . product_reference [..] , Some ("PRODUCT_REFERENCE") , false)) , } TUpdateProductsProductElementTypeSerializerState :: ProductReference (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: ProductLogisticDetails (IterSerializer :: new (self . value . product_logistic_details . as_ref () , Some ("PRODUCT_LOGISTIC_DETAILS") , false)) , } TUpdateProductsProductElementTypeSerializerState :: ProductLogisticDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdateProductsProductElementTypeSerializerState :: End__ , } TUpdateProductsProductElementTypeSerializerState :: End__ => { * self . state = TUpdateProductsProductElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } TUpdateProductsProductElementTypeSerializerState :: Done__ => return Ok (None) , TUpdateProductsProductElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for TUpdateProductsProductElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TUpdateProductsProductElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TUpdatePricesProductElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TUpdatePricesProductElementType,
        pub(super) state: Box<TUpdatePricesProductElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TUpdatePricesProductElementTypeSerializerState<'ser> {
        Init__,
        SupplierPid(<String as WithSerializer>::Serializer<'ser>),
        ProductPriceDetails(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceDetailsElementType],
                super::ProductPriceDetailsElementType,
            >,
        ),
        UserDefinedExtensions(
            IterSerializer<'ser, Option<&'ser super::UdxProduct>, super::UdxProduct>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TUpdatePricesProductElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { TUpdatePricesProductElementTypeSerializerState :: Init__ => { * self . state = TUpdatePricesProductElementTypeSerializerState :: SupplierPid (WithSerializer :: serializer (& self . value . supplier_pid , Some ("SUPPLIER_PID") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; write_attrib (& mut bytes , "mode" , & self . value . mode) ? ; return Ok (Some (Event :: Start (bytes))) } TUpdatePricesProductElementTypeSerializerState :: SupplierPid (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdatePricesProductElementTypeSerializerState :: ProductPriceDetails (IterSerializer :: new (& self . value . product_price_details [..] , Some ("PRODUCT_PRICE_DETAILS") , false)) , } TUpdatePricesProductElementTypeSerializerState :: ProductPriceDetails (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdatePricesProductElementTypeSerializerState :: UserDefinedExtensions (IterSerializer :: new (self . value . user_defined_extensions . as_ref () , Some ("USER_DEFINED_EXTENSIONS") , false)) , } TUpdatePricesProductElementTypeSerializerState :: UserDefinedExtensions (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = TUpdatePricesProductElementTypeSerializerState :: End__ , } TUpdatePricesProductElementTypeSerializerState :: End__ => { * self . state = TUpdatePricesProductElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } TUpdatePricesProductElementTypeSerializerState :: Done__ => return Ok (None) , TUpdatePricesProductElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for TUpdatePricesProductElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TUpdatePricesProductElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TNewProductdataProductElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::TNewProductdataProductElementType,
        pub(super) state: Box<TNewProductdataProductElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TNewProductdataProductElementTypeSerializerState<'ser> {
        Init__,
        SupplierPid(<String as WithSerializer>::Serializer<'ser>),
        ProductDetails(<super::ProductDetailsElementType as WithSerializer>::Serializer<'ser>),
        ProductFeatures(
            IterSerializer<
                'ser,
                &'ser [super::ProductFeaturesElementType],
                super::ProductFeaturesElementType,
            >,
        ),
        UserDefinedExtensions(
            IterSerializer<'ser, Option<&'ser super::UdxProductdata>, super::UdxProductdata>,
        ),
        ProductReference(
            IterSerializer<
                'ser,
                &'ser [super::ProductReferenceElementType],
                super::ProductReferenceElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TNewProductdataProductElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TNewProductdataProductElementTypeSerializerState::Init__ => {
                        *self.state = TNewProductdataProductElementTypeSerializerState::SupplierPid(
                            WithSerializer::serializer(
                                &self.value.supplier_pid,
                                Some("SUPPLIER_PID"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "mode", &self.value.mode)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TNewProductdataProductElementTypeSerializerState::SupplierPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TNewProductdataProductElementTypeSerializerState::ProductDetails(
                                        WithSerializer::serializer(
                                            &self.value.product_details,
                                            Some("PRODUCT_DETAILS"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    TNewProductdataProductElementTypeSerializerState::ProductDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TNewProductdataProductElementTypeSerializerState::ProductFeatures(
                                    IterSerializer::new(
                                        &self.value.product_features[..],
                                        Some("PRODUCT_FEATURES"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    TNewProductdataProductElementTypeSerializerState::ProductFeatures(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state =
                            TNewProductdataProductElementTypeSerializerState::UserDefinedExtensions(
                                IterSerializer::new(
                                    self.value.user_defined_extensions.as_ref(),
                                    Some("USER_DEFINED_EXTENSIONS"),
                                    false,
                                ),
                            ),
                    },
                    TNewProductdataProductElementTypeSerializerState::UserDefinedExtensions(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                TNewProductdataProductElementTypeSerializerState::ProductReference(
                                    IterSerializer::new(
                                        &self.value.product_reference[..],
                                        Some("PRODUCT_REFERENCE"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    TNewProductdataProductElementTypeSerializerState::ProductReference(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    TNewProductdataProductElementTypeSerializerState::End__
                            }
                        }
                    }
                    TNewProductdataProductElementTypeSerializerState::End__ => {
                        *self.state = TNewProductdataProductElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TNewProductdataProductElementTypeSerializerState::Done__ => return Ok(None),
                    TNewProductdataProductElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for TNewProductdataProductElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TNewProductdataProductElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct LanguageElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::LanguageElementType,
        pub(super) state: Box<LanguageElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum LanguageElementTypeSerializerState<'ser> {
        Init__,
        Content__(<super::DtLang as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> LanguageElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    LanguageElementTypeSerializerState::Init__ => {
                        *self.state = LanguageElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "default", &self.value.default)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    LanguageElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = LanguageElementTypeSerializerState::End__,
                        }
                    }
                    LanguageElementTypeSerializerState::End__ => {
                        *self.state = LanguageElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    LanguageElementTypeSerializerState::Done__ => return Ok(None),
                    LanguageElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for LanguageElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = LanguageElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct DtMlstringSerializer<'ser> {
        pub(super) value: &'ser super::DtMlstring,
        pub(super) state: Box<DtMlstringSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum DtMlstringSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> DtMlstringSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    DtMlstringSerializerState::Init__ => {
                        *self.state = DtMlstringSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    DtMlstringSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = DtMlstringSerializerState::End__,
                    },
                    DtMlstringSerializerState::End__ => {
                        *self.state = DtMlstringSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    DtMlstringSerializerState::Done__ => return Ok(None),
                    DtMlstringSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for DtMlstringSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = DtMlstringSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CatalogDatetimeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CatalogDatetimeElementType,
        pub(super) state: Box<CatalogDatetimeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CatalogDatetimeElementTypeSerializerState<'ser> {
        Init__,
        Date(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CatalogDatetimeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CatalogDatetimeElementTypeSerializerState::Init__ => {
                        *self.state = CatalogDatetimeElementTypeSerializerState::Date(
                            WithSerializer::serializer(&self.value.date, Some("DATE"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CatalogDatetimeElementTypeSerializerState::Date(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CatalogDatetimeElementTypeSerializerState::End__,
                        }
                    }
                    CatalogDatetimeElementTypeSerializerState::End__ => {
                        *self.state = CatalogDatetimeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CatalogDatetimeElementTypeSerializerState::Done__ => return Ok(None),
                    CatalogDatetimeElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CatalogDatetimeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CatalogDatetimeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct TypePartyIdSerializer<'ser> {
        pub(super) value: &'ser super::TypePartyId,
        pub(super) state: Box<TypePartyIdSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum TypePartyIdSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> TypePartyIdSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    TypePartyIdSerializerState::Init__ => {
                        *self.state = TypePartyIdSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    TypePartyIdSerializerState::Content__(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = TypePartyIdSerializerState::End__,
                    },
                    TypePartyIdSerializerState::End__ => {
                        *self.state = TypePartyIdSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    TypePartyIdSerializerState::Done__ => return Ok(None),
                    TypePartyIdSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for TypePartyIdSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = TypePartyIdSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SupplierAddressElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SupplierAddressElementType,
        pub(super) state: Box<SupplierAddressElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SupplierAddressElementTypeSerializerState<'ser> {
        Init__,
        Contact(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        Street(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        Zip(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        City(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        Country(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        VatId(IterSerializer<'ser, Option<&'ser String>, String>),
        Email(<String as WithSerializer>::Serializer<'ser>),
        Url(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SupplierAddressElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SupplierAddressElementTypeSerializerState::Init__ => {
                        *self.state = SupplierAddressElementTypeSerializerState::Contact(
                            IterSerializer::new(&self.value.contact[..], Some("CONTACT"), false),
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SupplierAddressElementTypeSerializerState::Contact(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = SupplierAddressElementTypeSerializerState::Street(
                                IterSerializer::new(&self.value.street[..], Some("STREET"), false),
                            )
                        }
                    },
                    SupplierAddressElementTypeSerializerState::Street(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::Zip(
                                    IterSerializer::new(&self.value.zip[..], Some("ZIP"), false),
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::Zip(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::City(
                                    IterSerializer::new(&self.value.city[..], Some("CITY"), false),
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::City(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::Country(
                                    IterSerializer::new(
                                        &self.value.country[..],
                                        Some("COUNTRY"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::Country(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::VatId(
                                    IterSerializer::new(
                                        self.value.vat_id.as_ref(),
                                        Some("VAT_ID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::VatId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SupplierAddressElementTypeSerializerState::Email(
                                    WithSerializer::serializer(
                                        &self.value.email,
                                        Some("EMAIL"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    SupplierAddressElementTypeSerializerState::Email(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = SupplierAddressElementTypeSerializerState::Url(
                                IterSerializer::new(self.value.url.as_ref(), Some("URL"), false),
                            )
                        }
                    },
                    SupplierAddressElementTypeSerializerState::Url(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SupplierAddressElementTypeSerializerState::End__,
                        }
                    }
                    SupplierAddressElementTypeSerializerState::End__ => {
                        *self.state = SupplierAddressElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SupplierAddressElementTypeSerializerState::Done__ => return Ok(None),
                    SupplierAddressElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SupplierAddressElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SupplierAddressElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct MimeInfoElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::MimeInfoElementType,
        pub(super) state: Box<MimeInfoElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum MimeInfoElementTypeSerializerState<'ser> {
        Init__,
        Mime(IterSerializer<'ser, &'ser [super::MimeElementType], super::MimeElementType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> MimeInfoElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    MimeInfoElementTypeSerializerState::Init__ => {
                        *self.state = MimeInfoElementTypeSerializerState::Mime(
                            IterSerializer::new(&self.value.mime[..], Some("MIME"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    MimeInfoElementTypeSerializerState::Mime(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = MimeInfoElementTypeSerializerState::End__,
                    },
                    MimeInfoElementTypeSerializerState::End__ => {
                        *self.state = MimeInfoElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    MimeInfoElementTypeSerializerState::Done__ => return Ok(None),
                    MimeInfoElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for MimeInfoElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = MimeInfoElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductDetailsElementType,
        pub(super) state: Box<ProductDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductDetailsElementTypeSerializerState<'ser> {
        Init__,
        DescriptionShort(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        DescriptionLong(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        InternationalPid(
            IterSerializer<
                'ser,
                &'ser [super::InternationalPidElementType],
                super::InternationalPidElementType,
            >,
        ),
        SupplierAltPid(IterSerializer<'ser, Option<&'ser String>, String>),
        BuyerPid(
            IterSerializer<
                'ser,
                Option<&'ser super::BuyerPidElementType>,
                super::BuyerPidElementType,
            >,
        ),
        ManufacturerPid(IterSerializer<'ser, Option<&'ser String>, String>),
        ManufacturerName(IterSerializer<'ser, Option<&'ser String>, String>),
        ManufacturerTypeDescr(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        DeliveryTime(IterSerializer<'ser, Option<&'ser f64>, f64>),
        SpecialTreatmentClass(
            IterSerializer<
                'ser,
                &'ser [super::SpecialTreatmentClassElementType],
                super::SpecialTreatmentClassElementType,
            >,
        ),
        Keyword(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        Remarks(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        ProductStatus(
            IterSerializer<
                'ser,
                &'ser [super::ProductStatusElementType],
                super::ProductStatusElementType,
            >,
        ),
        ProductType(
            IterSerializer<
                'ser,
                Option<&'ser super::ProductTypeElementType>,
                super::ProductTypeElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductDetailsElementTypeSerializerState::Init__ => {
                        *self.state = ProductDetailsElementTypeSerializerState::DescriptionShort(
                            IterSerializer::new(
                                &self.value.description_short[..],
                                Some("DESCRIPTION_SHORT"),
                                false,
                            ),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductDetailsElementTypeSerializerState::DescriptionShort(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::DescriptionLong(
                                        IterSerializer::new(
                                            &self.value.description_long[..],
                                            Some("DESCRIPTION_LONG"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::DescriptionLong(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::InternationalPid(
                                        IterSerializer::new(
                                            &self.value.international_pid[..],
                                            Some("INTERNATIONAL_PID"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::InternationalPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::SupplierAltPid(
                                        IterSerializer::new(
                                            self.value.supplier_alt_pid.as_ref(),
                                            Some("SUPPLIER_ALT_PID"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::SupplierAltPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductDetailsElementTypeSerializerState::BuyerPid(
                                    IterSerializer::new(
                                        self.value.buyer_pid.as_ref(),
                                        Some("BUYER_PID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::BuyerPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::ManufacturerPid(
                                        IterSerializer::new(
                                            self.value.manufacturer_pid.as_ref(),
                                            Some("MANUFACTURER_PID"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ManufacturerPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::ManufacturerName(
                                        IterSerializer::new(
                                            self.value.manufacturer_name.as_ref(),
                                            Some("MANUFACTURER_NAME"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ManufacturerName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::ManufacturerTypeDescr(
                                        IterSerializer::new(
                                            &self.value.manufacturer_type_descr[..],
                                            Some("MANUFACTURER_TYPE_DESCR"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ManufacturerTypeDescr(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductDetailsElementTypeSerializerState::DeliveryTime(
                                    IterSerializer::new(
                                        self.value.delivery_time.as_ref(),
                                        Some("DELIVERY_TIME"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::DeliveryTime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::SpecialTreatmentClass(
                                        IterSerializer::new(
                                            &self.value.special_treatment_class[..],
                                            Some("SPECIAL_TREATMENT_CLASS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::SpecialTreatmentClass(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductDetailsElementTypeSerializerState::Keyword(
                                    IterSerializer::new(
                                        &self.value.keyword[..],
                                        Some("KEYWORD"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::Keyword(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductDetailsElementTypeSerializerState::Remarks(
                                    IterSerializer::new(
                                        &self.value.remarks[..],
                                        Some("REMARKS"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::Remarks(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductDetailsElementTypeSerializerState::ProductStatus(
                                        IterSerializer::new(
                                            &self.value.product_status[..],
                                            Some("PRODUCT_STATUS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ProductStatus(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductDetailsElementTypeSerializerState::ProductType(
                                    IterSerializer::new(
                                        self.value.product_type.as_ref(),
                                        Some("PRODUCT_TYPE"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductDetailsElementTypeSerializerState::ProductType(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductDetailsElementTypeSerializerState::End__,
                        }
                    }
                    ProductDetailsElementTypeSerializerState::End__ => {
                        *self.state = ProductDetailsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductDetailsElementTypeSerializerState::Done__ => return Ok(None),
                    ProductDetailsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductFeaturesElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductFeaturesElementType,
        pub(super) state: Box<ProductFeaturesElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductFeaturesElementTypeSerializerState<'ser> {
        Init__,
        ReferenceFeatureSystemName(
            <super::TypeClassificationSystemName as WithSerializer>::Serializer<'ser>,
        ),
        ReferenceFeatureGroupId(<String as WithSerializer>::Serializer<'ser>),
        Feature(IterSerializer<'ser, &'ser [super::FeatureElementType], super::FeatureElementType>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductFeaturesElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductFeaturesElementTypeSerializerState::Init__ => {
                        *self.state =
                            ProductFeaturesElementTypeSerializerState::ReferenceFeatureSystemName(
                                WithSerializer::serializer(
                                    &self.value.reference_feature_system_name,
                                    Some("REFERENCE_FEATURE_SYSTEM_NAME"),
                                    false,
                                )?,
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductFeaturesElementTypeSerializerState::ReferenceFeatureSystemName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                ProductFeaturesElementTypeSerializerState::ReferenceFeatureGroupId(
                                    WithSerializer::serializer(
                                        &self.value.reference_feature_group_id,
                                        Some("REFERENCE_FEATURE_GROUP_ID"),
                                        false,
                                    )?,
                                ),
                        }
                    }
                    ProductFeaturesElementTypeSerializerState::ReferenceFeatureGroupId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductFeaturesElementTypeSerializerState::Feature(
                                    IterSerializer::new(
                                        &self.value.feature[..],
                                        Some("FEATURE"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductFeaturesElementTypeSerializerState::Feature(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductFeaturesElementTypeSerializerState::End__,
                        }
                    }
                    ProductFeaturesElementTypeSerializerState::End__ => {
                        *self.state = ProductFeaturesElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductFeaturesElementTypeSerializerState::Done__ => return Ok(None),
                    ProductFeaturesElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductFeaturesElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductFeaturesElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductOrderDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductOrderDetailsElementType,
        pub(super) state: Box<ProductOrderDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductOrderDetailsElementTypeSerializerState<'ser> {
        Init__,
        OrderUnit(<super::DtUnit as WithSerializer>::Serializer<'ser>),
        ContentUnit(<super::DtUnit as WithSerializer>::Serializer<'ser>),
        NoCuPerOu(IterSerializer<'ser, Option<&'ser f64>, f64>),
        PriceQuantity(IterSerializer<'ser, Option<&'ser f64>, f64>),
        QuantityMin(IterSerializer<'ser, Option<&'ser f32>, f32>),
        QuantityInterval(IterSerializer<'ser, Option<&'ser f32>, f32>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductOrderDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductOrderDetailsElementTypeSerializerState::Init__ => {
                        *self.state = ProductOrderDetailsElementTypeSerializerState::OrderUnit(
                            WithSerializer::serializer(
                                &self.value.order_unit,
                                Some("ORDER_UNIT"),
                                false,
                            )?,
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductOrderDetailsElementTypeSerializerState::OrderUnit(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::ContentUnit(
                                        WithSerializer::serializer(
                                            &self.value.content_unit,
                                            Some("CONTENT_UNIT"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::ContentUnit(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::NoCuPerOu(
                                        IterSerializer::new(
                                            self.value.no_cu_per_ou.as_ref(),
                                            Some("NO_CU_PER_OU"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::NoCuPerOu(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::PriceQuantity(
                                        IterSerializer::new(
                                            self.value.price_quantity.as_ref(),
                                            Some("PRICE_QUANTITY"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::PriceQuantity(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::QuantityMin(
                                        IterSerializer::new(
                                            self.value.quantity_min.as_ref(),
                                            Some("QUANTITY_MIN"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::QuantityMin(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductOrderDetailsElementTypeSerializerState::QuantityInterval(
                                        IterSerializer::new(
                                            self.value.quantity_interval.as_ref(),
                                            Some("QUANTITY_INTERVAL"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductOrderDetailsElementTypeSerializerState::QuantityInterval(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = ProductOrderDetailsElementTypeSerializerState::End__,
                    },
                    ProductOrderDetailsElementTypeSerializerState::End__ => {
                        *self.state = ProductOrderDetailsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductOrderDetailsElementTypeSerializerState::Done__ => return Ok(None),
                    ProductOrderDetailsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductOrderDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductOrderDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductPriceDetailsElementType,
        pub(super) state: Box<ProductPriceDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductPriceDetailsElementTypeSerializerState<'ser> {
        Init__,
        Datetime(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceDetailsDatetimeElementType],
                super::ProductPriceDetailsDatetimeElementType,
            >,
        ),
        DailyPrice(IterSerializer<'ser, Option<&'ser String>, String>),
        ProductPrice(
            IterSerializer<
                'ser,
                &'ser [super::ProductPriceElementType],
                super::ProductPriceElementType,
            >,
        ),
        PriceBase(
            IterSerializer<
                'ser,
                Option<&'ser super::PriceBaseElementType>,
                super::PriceBaseElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductPriceDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductPriceDetailsElementTypeSerializerState::Init__ => {
                        *self.state = ProductPriceDetailsElementTypeSerializerState::Datetime(
                            IterSerializer::new(&self.value.datetime[..], Some("DATETIME"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductPriceDetailsElementTypeSerializerState::Datetime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsElementTypeSerializerState::DailyPrice(
                                        IterSerializer::new(
                                            self.value.daily_price.as_ref(),
                                            Some("DAILY_PRICE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductPriceDetailsElementTypeSerializerState::DailyPrice(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsElementTypeSerializerState::ProductPrice(
                                        IterSerializer::new(
                                            &self.value.product_price[..],
                                            Some("PRODUCT_PRICE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductPriceDetailsElementTypeSerializerState::ProductPrice(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsElementTypeSerializerState::PriceBase(
                                        IterSerializer::new(
                                            self.value.price_base.as_ref(),
                                            Some("PRICE_BASE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductPriceDetailsElementTypeSerializerState::PriceBase(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = ProductPriceDetailsElementTypeSerializerState::End__,
                    },
                    ProductPriceDetailsElementTypeSerializerState::End__ => {
                        *self.state = ProductPriceDetailsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductPriceDetailsElementTypeSerializerState::Done__ => return Ok(None),
                    ProductPriceDetailsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductPriceDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductPriceDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxProductSerializer<'ser> {
        pub(super) value: &'ser super::UdxProduct,
        pub(super) state: Box<UdxProductSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxProductSerializerState<'ser> {
        Init__,
        UdxEdxfMimeInfo(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfMimeInfoElementType>,
                super::UdxEdxfMimeInfoElementType,
            >,
        ),
        UdxEdxfManufacturerAcronym(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfDescriptionVeryShort(
            IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>,
        ),
        UdxEdxfBrandName(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfTenderText(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfValidFrom(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfExpirationDate(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfDiscountGroup(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfDiscountGroupElementType>,
                super::UdxEdxfDiscountGroupElementType,
            >,
        ),
        UdxEdxfBonusGroupSupplier(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfAdditionalFactors(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfAdditionalFactorsElementType>,
                super::UdxEdxfAdditionalFactorsElementType,
            >,
        ),
        UdxEdxfProductToStock(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfProductSeries(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfProductVariation(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfPredecessorPid(IterSerializer<'ser, &'ser [String], String>),
        UdxEdxfCountryBranchNumbers(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfCountryBranchNumbersElementType>,
                super::UdxEdxfCountryBranchNumbersElementType,
            >,
        ),
        UdxEdxfCountryBranchSupplierIds(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfCountryBranchSupplierIdsElementType>,
                super::UdxEdxfCountryBranchSupplierIdsElementType,
            >,
        ),
        UdxEdxfPackingUnits(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfPackingUnitsElementType>,
                super::UdxEdxfPackingUnitsElementType,
            >,
        ),
        UdxEdxfProductLogisticDetails(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfProductLogisticDetailsElementType>,
                super::UdxEdxfProductLogisticDetailsElementType,
            >,
        ),
        UdxEdxfShelfLifePeriod(IterSerializer<'ser, Option<&'ser i32>, i32>),
        UdxEdxfBatteryContained(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfRohsIndicator(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfRohsIndicatorElementType>,
                super::UdxEdxfRohsIndicatorElementType,
            >,
        ),
        UdxEdxfCeMarking(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfReach(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfReachElementType>,
                super::UdxEdxfReachElementType,
            >,
        ),
        UdxEdxfSpecialTreatmentClassDetails(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfSpecialTreatmentClassDetailsElementType>,
                super::UdxEdxfSpecialTreatmentClassDetailsElementType,
            >,
        ),
        UdxEdxfSurchargeList(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfSurchargeListElementType>,
                super::UdxEdxfSurchargeListElementType,
            >,
        ),
        UdxEdxfWarranty(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfWarrantyElementType>,
                super::UdxEdxfWarrantyElementType,
            >,
        ),
        UdxEdxfProductEtimDynamic(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfProductEtimDynamicElementType>,
                super::UdxEdxfProductEtimDynamicElementType,
            >,
        ),
        UdxEdxfProductFeaturesMc(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfProductFeaturesMcElementType>,
                super::UdxEdxfProductFeaturesMcElementType,
            >,
        ),
        UdxEdxfProductCharacteristics(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfProductCharacteristicsElementType>,
                super::UdxEdxfProductCharacteristicsElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxProductSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxProductSerializerState::Init__ => {
                        *self.state =
                            UdxProductSerializerState::UdxEdxfMimeInfo(IterSerializer::new(
                                self.value.udx_edxf_mime_info.as_ref(),
                                Some("UDX.EDXF.MIME_INFO"),
                                false,
                            ));
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxProductSerializerState::UdxEdxfMimeInfo(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = UdxProductSerializerState::UdxEdxfManufacturerAcronym(
                                IterSerializer::new(
                                    self.value.udx_edxf_manufacturer_acronym.as_ref(),
                                    Some("UDX.EDXF.MANUFACTURER_ACRONYM"),
                                    false,
                                ),
                            )
                        }
                    },
                    UdxProductSerializerState::UdxEdxfManufacturerAcronym(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfDescriptionVeryShort(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_description_very_short[..],
                                        Some("UDX.EDXF.DESCRIPTION_VERY_SHORT"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfDescriptionVeryShort(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfBrandName(
                                    IterSerializer::new(
                                        self.value.udx_edxf_brand_name.as_ref(),
                                        Some("UDX.EDXF.BRAND_NAME"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfBrandName(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                UdxProductSerializerState::UdxEdxfTenderText(IterSerializer::new(
                                    &self.value.udx_edxf_tender_text[..],
                                    Some("UDX.EDXF.TENDER_TEXT"),
                                    false,
                                ))
                        }
                    },
                    UdxProductSerializerState::UdxEdxfTenderText(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfValidFrom(
                                    IterSerializer::new(
                                        self.value.udx_edxf_valid_from.as_ref(),
                                        Some("UDX.EDXF.VALID_FROM"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfValidFrom(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = UdxProductSerializerState::UdxEdxfExpirationDate(
                                IterSerializer::new(
                                    self.value.udx_edxf_expiration_date.as_ref(),
                                    Some("UDX.EDXF.EXPIRATION_DATE"),
                                    false,
                                ),
                            )
                        }
                    },
                    UdxProductSerializerState::UdxEdxfExpirationDate(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfDiscountGroup(
                                    IterSerializer::new(
                                        self.value.udx_edxf_discount_group.as_ref(),
                                        Some("UDX.EDXF.DISCOUNT_GROUP"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfDiscountGroup(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfBonusGroupSupplier(
                                    IterSerializer::new(
                                        self.value.udx_edxf_bonus_group_supplier.as_ref(),
                                        Some("UDX.EDXF.BONUS_GROUP_SUPPLIER"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfBonusGroupSupplier(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfAdditionalFactors(
                                    IterSerializer::new(
                                        self.value.udx_edxf_additional_factors.as_ref(),
                                        Some("UDX.EDXF.ADDITIONAL_FACTORS"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfAdditionalFactors(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfProductToStock(
                                    IterSerializer::new(
                                        self.value.udx_edxf_product_to_stock.as_ref(),
                                        Some("UDX.EDXF.PRODUCT_TO_STOCK"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfProductToStock(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfProductSeries(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_product_series[..],
                                        Some("UDX.EDXF.PRODUCT_SERIES"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfProductSeries(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfProductVariation(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_product_variation[..],
                                        Some("UDX.EDXF.PRODUCT_VARIATION"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfProductVariation(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfPredecessorPid(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_predecessor_pid[..],
                                        Some("UDX.EDXF.PREDECESSOR_PID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfPredecessorPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfCountryBranchNumbers(
                                    IterSerializer::new(
                                        self.value.udx_edxf_country_branch_numbers.as_ref(),
                                        Some("UDX.EDXF.COUNTRY_BRANCH_NUMBERS"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfCountryBranchNumbers(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = UdxProductSerializerState::UdxEdxfCountryBranchSupplierIds(
                                IterSerializer::new(
                                    self.value.udx_edxf_country_branch_supplier_ids.as_ref(),
                                    Some("UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS"),
                                    false,
                                ),
                            )
                        }
                    },
                    UdxProductSerializerState::UdxEdxfCountryBranchSupplierIds(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfPackingUnits(
                                    IterSerializer::new(
                                        self.value.udx_edxf_packing_units.as_ref(),
                                        Some("UDX.EDXF.PACKING_UNITS"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfPackingUnits(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductSerializerState::UdxEdxfProductLogisticDetails(
                                        IterSerializer::new(
                                            self.value.udx_edxf_product_logistic_details.as_ref(),
                                            Some("UDX.EDXF.PRODUCT_LOGISTIC_DETAILS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfProductLogisticDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfShelfLifePeriod(
                                    IterSerializer::new(
                                        self.value.udx_edxf_shelf_life_period.as_ref(),
                                        Some("UDX.EDXF.SHELF_LIFE_PERIOD"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfShelfLifePeriod(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfBatteryContained(
                                    IterSerializer::new(
                                        self.value.udx_edxf_battery_contained.as_ref(),
                                        Some("UDX.EDXF.BATTERY_CONTAINED"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfBatteryContained(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfRohsIndicator(
                                    IterSerializer::new(
                                        self.value.udx_edxf_rohs_indicator.as_ref(),
                                        Some("UDX.EDXF.ROHS_INDICATOR"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfRohsIndicator(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfCeMarking(
                                    IterSerializer::new(
                                        self.value.udx_edxf_ce_marking.as_ref(),
                                        Some("UDX.EDXF.CE_MARKING"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfCeMarking(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                UdxProductSerializerState::UdxEdxfReach(IterSerializer::new(
                                    self.value.udx_edxf_reach.as_ref(),
                                    Some("UDX.EDXF.REACH"),
                                    false,
                                ))
                        }
                    },
                    UdxProductSerializerState::UdxEdxfReach(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                UdxProductSerializerState::UdxEdxfSpecialTreatmentClassDetails(
                                    IterSerializer::new(
                                        self.value
                                            .udx_edxf_special_treatment_class_details
                                            .as_ref(),
                                        Some("UDX.EDXF.SPECIAL_TREATMENT_CLASS_DETAILS"),
                                        false,
                                    ),
                                )
                        }
                    },
                    UdxProductSerializerState::UdxEdxfSpecialTreatmentClassDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfSurchargeList(
                                    IterSerializer::new(
                                        self.value.udx_edxf_surcharge_list.as_ref(),
                                        Some("UDX.EDXF.SURCHARGE_LIST"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfSurchargeList(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductSerializerState::UdxEdxfWarranty(IterSerializer::new(
                                        self.value.udx_edxf_warranty.as_ref(),
                                        Some("UDX.EDXF.WARRANTY"),
                                        false,
                                    ))
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfWarranty(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = UdxProductSerializerState::UdxEdxfProductEtimDynamic(
                                IterSerializer::new(
                                    self.value.udx_edxf_product_etim_dynamic.as_ref(),
                                    Some("UDX.EDXF.PRODUCT_ETIM_DYNAMIC"),
                                    false,
                                ),
                            )
                        }
                    },
                    UdxProductSerializerState::UdxEdxfProductEtimDynamic(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductSerializerState::UdxEdxfProductFeaturesMc(
                                    IterSerializer::new(
                                        self.value.udx_edxf_product_features_mc.as_ref(),
                                        Some("UDX.EDXF.PRODUCT_FEATURES_MC"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfProductFeaturesMc(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductSerializerState::UdxEdxfProductCharacteristics(
                                        IterSerializer::new(
                                            self.value.udx_edxf_product_characteristics.as_ref(),
                                            Some("UDX.EDXF.PRODUCT_CHARACTERISTICS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductSerializerState::UdxEdxfProductCharacteristics(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxProductSerializerState::End__,
                        }
                    }
                    UdxProductSerializerState::End__ => {
                        *self.state = UdxProductSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxProductSerializerState::Done__ => return Ok(None),
                    UdxProductSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxProductSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxProductSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductReferenceElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductReferenceElementType,
        pub(super) state: Box<ProductReferenceElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductReferenceElementTypeSerializerState<'ser> {
        Init__,
        ProdIdTo(<String as WithSerializer>::Serializer<'ser>),
        CatalogId(IterSerializer<'ser, Option<&'ser String>, String>),
        CatalogVersion(IterSerializer<'ser, Option<&'ser String>, String>),
        ReferenceDescr(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductReferenceElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductReferenceElementTypeSerializerState::Init__ => {
                        *self.state = ProductReferenceElementTypeSerializerState::ProdIdTo(
                            WithSerializer::serializer(
                                &self.value.prod_id_to,
                                Some("PROD_ID_TO"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        write_attrib_opt(&mut bytes, "quantity", &self.value.quantity)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductReferenceElementTypeSerializerState::ProdIdTo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductReferenceElementTypeSerializerState::CatalogId(
                                    IterSerializer::new(
                                        self.value.catalog_id.as_ref(),
                                        Some("CATALOG_ID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductReferenceElementTypeSerializerState::CatalogId(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductReferenceElementTypeSerializerState::CatalogVersion(
                                        IterSerializer::new(
                                            self.value.catalog_version.as_ref(),
                                            Some("CATALOG_VERSION"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductReferenceElementTypeSerializerState::CatalogVersion(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductReferenceElementTypeSerializerState::ReferenceDescr(
                                        IterSerializer::new(
                                            &self.value.reference_descr[..],
                                            Some("REFERENCE_DESCR"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    ProductReferenceElementTypeSerializerState::ReferenceDescr(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductReferenceElementTypeSerializerState::End__,
                        }
                    }
                    ProductReferenceElementTypeSerializerState::End__ => {
                        *self.state = ProductReferenceElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductReferenceElementTypeSerializerState::Done__ => return Ok(None),
                    ProductReferenceElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductReferenceElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductReferenceElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductLogisticDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductLogisticDetailsElementType,
        pub(super) state: Box<ProductLogisticDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductLogisticDetailsElementTypeSerializerState<'ser> {
        Init__,
        CustomsTariffNumber(
            IterSerializer<
                'ser,
                &'ser [super::CustomsTariffNumberElementType],
                super::CustomsTariffNumberElementType,
            >,
        ),
        StatisticsFactor(IterSerializer<'ser, Option<&'ser f64>, f64>),
        CountryOfOrigin(IterSerializer<'ser, &'ser [String], String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductLogisticDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductLogisticDetailsElementTypeSerializerState::Init__ => {
                        *self.state =
                            ProductLogisticDetailsElementTypeSerializerState::CustomsTariffNumber(
                                IterSerializer::new(
                                    &self.value.customs_tariff_number[..],
                                    Some("CUSTOMS_TARIFF_NUMBER"),
                                    false,
                                ),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductLogisticDetailsElementTypeSerializerState::CustomsTariffNumber(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                ProductLogisticDetailsElementTypeSerializerState::StatisticsFactor(
                                    IterSerializer::new(
                                        self.value.statistics_factor.as_ref(),
                                        Some("STATISTICS_FACTOR"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    ProductLogisticDetailsElementTypeSerializerState::StatisticsFactor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                ProductLogisticDetailsElementTypeSerializerState::CountryOfOrigin(
                                    IterSerializer::new(
                                        &self.value.country_of_origin[..],
                                        Some("COUNTRY_OF_ORIGIN"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    ProductLogisticDetailsElementTypeSerializerState::CountryOfOrigin(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductLogisticDetailsElementTypeSerializerState::End__
                            }
                        }
                    }
                    ProductLogisticDetailsElementTypeSerializerState::End__ => {
                        *self.state = ProductLogisticDetailsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductLogisticDetailsElementTypeSerializerState::Done__ => return Ok(None),
                    ProductLogisticDetailsElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for ProductLogisticDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductLogisticDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxProductdataSerializer<'ser> {
        pub(super) value: &'ser super::UdxProductdata,
        pub(super) state: Box<UdxProductdataSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxProductdataSerializerState<'ser> {
        Init__,
        UdxEdxfMimeInfo(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfMimeInfoElementType>,
                super::UdxEdxfMimeInfoElementType,
            >,
        ),
        UdxEdxfManufacturerAcronym(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfDescriptionVeryShort(
            IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>,
        ),
        UdxEdxfBrandName(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfTenderText(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfValidFrom(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfExpirationDate(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfProductSeries(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfProductVariation(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfPredecessorPid(IterSerializer<'ser, &'ser [String], String>),
        UdxEdxfCountryBranchNumbers(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfCountryBranchNumbersElementType>,
                super::UdxEdxfCountryBranchNumbersElementType,
            >,
        ),
        UdxEdxfCountryBranchSupplierIds(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfCountryBranchSupplierIdsElementType>,
                super::UdxEdxfCountryBranchSupplierIdsElementType,
            >,
        ),
        UdxEdxfProductEtimDynamic(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfProductEtimDynamicElementType>,
                super::UdxEdxfProductEtimDynamicElementType,
            >,
        ),
        UdxEdxfProductFeaturesMc(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfProductFeaturesMcElementType>,
                super::UdxEdxfProductFeaturesMcElementType,
            >,
        ),
        UdxEdxfProductCharacteristics(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfProductCharacteristicsElementType>,
                super::UdxEdxfProductCharacteristicsElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxProductdataSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxProductdataSerializerState::Init__ => {
                        *self.state =
                            UdxProductdataSerializerState::UdxEdxfMimeInfo(IterSerializer::new(
                                self.value.udx_edxf_mime_info.as_ref(),
                                Some("UDX.EDXF.MIME_INFO"),
                                false,
                            ));
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxProductdataSerializerState::UdxEdxfMimeInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductdataSerializerState::UdxEdxfManufacturerAcronym(
                                        IterSerializer::new(
                                            self.value.udx_edxf_manufacturer_acronym.as_ref(),
                                            Some("UDX.EDXF.MANUFACTURER_ACRONYM"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfManufacturerAcronym(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductdataSerializerState::UdxEdxfDescriptionVeryShort(
                                        IterSerializer::new(
                                            &self.value.udx_edxf_description_very_short[..],
                                            Some("UDX.EDXF.DESCRIPTION_VERY_SHORT"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfDescriptionVeryShort(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductdataSerializerState::UdxEdxfBrandName(
                                    IterSerializer::new(
                                        self.value.udx_edxf_brand_name.as_ref(),
                                        Some("UDX.EDXF.BRAND_NAME"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfBrandName(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductdataSerializerState::UdxEdxfTenderText(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_tender_text[..],
                                        Some("UDX.EDXF.TENDER_TEXT"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfTenderText(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductdataSerializerState::UdxEdxfValidFrom(
                                    IterSerializer::new(
                                        self.value.udx_edxf_valid_from.as_ref(),
                                        Some("UDX.EDXF.VALID_FROM"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfValidFrom(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductdataSerializerState::UdxEdxfExpirationDate(
                                    IterSerializer::new(
                                        self.value.udx_edxf_expiration_date.as_ref(),
                                        Some("UDX.EDXF.EXPIRATION_DATE"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfExpirationDate(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductdataSerializerState::UdxEdxfProductSeries(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_product_series[..],
                                        Some("UDX.EDXF.PRODUCT_SERIES"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfProductSeries(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductdataSerializerState::UdxEdxfProductVariation(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_product_variation[..],
                                        Some("UDX.EDXF.PRODUCT_VARIATION"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfProductVariation(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxProductdataSerializerState::UdxEdxfPredecessorPid(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_predecessor_pid[..],
                                        Some("UDX.EDXF.PREDECESSOR_PID"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfPredecessorPid(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductdataSerializerState::UdxEdxfCountryBranchNumbers(
                                        IterSerializer::new(
                                            self.value.udx_edxf_country_branch_numbers.as_ref(),
                                            Some("UDX.EDXF.COUNTRY_BRANCH_NUMBERS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfCountryBranchNumbers(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                UdxProductdataSerializerState::UdxEdxfCountryBranchSupplierIds(
                                    IterSerializer::new(
                                        self.value.udx_edxf_country_branch_supplier_ids.as_ref(),
                                        Some("UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_IDS"),
                                        false,
                                    ),
                                )
                        }
                    },
                    UdxProductdataSerializerState::UdxEdxfCountryBranchSupplierIds(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductdataSerializerState::UdxEdxfProductEtimDynamic(
                                        IterSerializer::new(
                                            self.value.udx_edxf_product_etim_dynamic.as_ref(),
                                            Some("UDX.EDXF.PRODUCT_ETIM_DYNAMIC"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfProductEtimDynamic(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductdataSerializerState::UdxEdxfProductFeaturesMc(
                                        IterSerializer::new(
                                            self.value.udx_edxf_product_features_mc.as_ref(),
                                            Some("UDX.EDXF.PRODUCT_FEATURES_MC"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfProductFeaturesMc(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxProductdataSerializerState::UdxEdxfProductCharacteristics(
                                        IterSerializer::new(
                                            self.value.udx_edxf_product_characteristics.as_ref(),
                                            Some("UDX.EDXF.PRODUCT_CHARACTERISTICS"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxProductdataSerializerState::UdxEdxfProductCharacteristics(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxProductdataSerializerState::End__,
                        }
                    }
                    UdxProductdataSerializerState::End__ => {
                        *self.state = UdxProductdataSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxProductdataSerializerState::Done__ => return Ok(None),
                    UdxProductdataSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxProductdataSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxProductdataSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct MimeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::MimeElementType,
        pub(super) state: Box<MimeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum MimeElementTypeSerializerState<'ser> {
        Init__,
        MimeSource(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        MimeDescr(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        MimeAlt(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> MimeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    MimeElementTypeSerializerState::Init__ => {
                        *self.state =
                            MimeElementTypeSerializerState::MimeSource(IterSerializer::new(
                                &self.value.mime_source[..],
                                Some("MIME_SOURCE"),
                                false,
                            ));
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    MimeElementTypeSerializerState::MimeSource(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                MimeElementTypeSerializerState::MimeDescr(IterSerializer::new(
                                    &self.value.mime_descr[..],
                                    Some("MIME_DESCR"),
                                    false,
                                ))
                        }
                    },
                    MimeElementTypeSerializerState::MimeDescr(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                MimeElementTypeSerializerState::MimeAlt(IterSerializer::new(
                                    &self.value.mime_alt[..],
                                    Some("MIME_ALT"),
                                    false,
                                ))
                        }
                    },
                    MimeElementTypeSerializerState::MimeAlt(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = MimeElementTypeSerializerState::End__,
                    },
                    MimeElementTypeSerializerState::End__ => {
                        *self.state = MimeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    MimeElementTypeSerializerState::Done__ => return Ok(None),
                    MimeElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for MimeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = MimeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct InternationalPidElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::InternationalPidElementType,
        pub(super) state: Box<InternationalPidElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum InternationalPidElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> InternationalPidElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    InternationalPidElementTypeSerializerState::Init__ => {
                        *self.state = InternationalPidElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    InternationalPidElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = InternationalPidElementTypeSerializerState::End__,
                        }
                    }
                    InternationalPidElementTypeSerializerState::End__ => {
                        *self.state = InternationalPidElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    InternationalPidElementTypeSerializerState::Done__ => return Ok(None),
                    InternationalPidElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for InternationalPidElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = InternationalPidElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct BuyerPidElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::BuyerPidElementType,
        pub(super) state: Box<BuyerPidElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum BuyerPidElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> BuyerPidElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    BuyerPidElementTypeSerializerState::Init__ => {
                        *self.state = BuyerPidElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    BuyerPidElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = BuyerPidElementTypeSerializerState::End__,
                        }
                    }
                    BuyerPidElementTypeSerializerState::End__ => {
                        *self.state = BuyerPidElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    BuyerPidElementTypeSerializerState::Done__ => return Ok(None),
                    BuyerPidElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for BuyerPidElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = BuyerPidElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct SpecialTreatmentClassElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::SpecialTreatmentClassElementType,
        pub(super) state: Box<SpecialTreatmentClassElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum SpecialTreatmentClassElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> SpecialTreatmentClassElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    SpecialTreatmentClassElementTypeSerializerState::Init__ => {
                        *self.state = SpecialTreatmentClassElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    SpecialTreatmentClassElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = SpecialTreatmentClassElementTypeSerializerState::End__
                            }
                        }
                    }
                    SpecialTreatmentClassElementTypeSerializerState::End__ => {
                        *self.state = SpecialTreatmentClassElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    SpecialTreatmentClassElementTypeSerializerState::Done__ => return Ok(None),
                    SpecialTreatmentClassElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for SpecialTreatmentClassElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = SpecialTreatmentClassElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductStatusElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductStatusElementType,
        pub(super) state: Box<ProductStatusElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductStatusElementTypeSerializerState<'ser> {
        Init__,
        Content__(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductStatusElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductStatusElementTypeSerializerState::Init__ => {
                        *self.state = ProductStatusElementTypeSerializerState::Content__(
                            WithSerializer::serializer(&self.value.content, None, false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductStatusElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductStatusElementTypeSerializerState::End__,
                        }
                    }
                    ProductStatusElementTypeSerializerState::End__ => {
                        *self.state = ProductStatusElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductStatusElementTypeSerializerState::Done__ => return Ok(None),
                    ProductStatusElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductStatusElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductStatusElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct FeatureElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::FeatureElementType,
        pub(super) state: Box<FeatureElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum FeatureElementTypeSerializerState<'ser> {
        Init__,
        Fname(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        Fvalue(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        Funit(IterSerializer<'ser, Option<&'ser String>, String>),
        FvalueDetails(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> FeatureElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    FeatureElementTypeSerializerState::Init__ => {
                        *self.state = FeatureElementTypeSerializerState::Fname(
                            IterSerializer::new(&self.value.fname[..], Some("FNAME"), false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    FeatureElementTypeSerializerState::Fname(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = FeatureElementTypeSerializerState::Fvalue(
                                IterSerializer::new(&self.value.fvalue[..], Some("FVALUE"), false),
                            )
                        }
                    },
                    FeatureElementTypeSerializerState::Fvalue(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state =
                                FeatureElementTypeSerializerState::Funit(IterSerializer::new(
                                    self.value.funit.as_ref(),
                                    Some("FUNIT"),
                                    false,
                                ))
                        }
                    },
                    FeatureElementTypeSerializerState::Funit(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = FeatureElementTypeSerializerState::FvalueDetails(
                                IterSerializer::new(
                                    &self.value.fvalue_details[..],
                                    Some("FVALUE_DETAILS"),
                                    false,
                                ),
                            )
                        }
                    },
                    FeatureElementTypeSerializerState::FvalueDetails(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FeatureElementTypeSerializerState::End__,
                        }
                    }
                    FeatureElementTypeSerializerState::End__ => {
                        *self.state = FeatureElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    FeatureElementTypeSerializerState::Done__ => return Ok(None),
                    FeatureElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for FeatureElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = FeatureElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceDetailsDatetimeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductPriceDetailsDatetimeElementType,
        pub(super) state: Box<ProductPriceDetailsDatetimeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductPriceDetailsDatetimeElementTypeSerializerState<'ser> {
        Init__,
        Date(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductPriceDetailsDatetimeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Init__ => {
                        *self.state = ProductPriceDetailsDatetimeElementTypeSerializerState::Date(
                            WithSerializer::serializer(&self.value.date, Some("DATE"), false)?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "type", &self.value.type_)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Date(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    ProductPriceDetailsDatetimeElementTypeSerializerState::End__
                            }
                        }
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::End__ => {
                        *self.state = ProductPriceDetailsDatetimeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    ProductPriceDetailsDatetimeElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for ProductPriceDetailsDatetimeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductPriceDetailsDatetimeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct ProductPriceElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::ProductPriceElementType,
        pub(super) state: Box<ProductPriceElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum ProductPriceElementTypeSerializerState<'ser> {
        Init__,
        PriceAmount(<f64 as WithSerializer>::Serializer<'ser>),
        PriceCurrency(IterSerializer<'ser, Option<&'ser super::DtCurrencies>, super::DtCurrencies>),
        Tax(IterSerializer<'ser, Option<&'ser f64>, f64>),
        PriceFactor(IterSerializer<'ser, Option<&'ser f64>, f64>),
        LowerBound(IterSerializer<'ser, Option<&'ser f64>, f64>),
        Territory(IterSerializer<'ser, &'ser [String], String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> ProductPriceElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    ProductPriceElementTypeSerializerState::Init__ => {
                        *self.state = ProductPriceElementTypeSerializerState::PriceAmount(
                            WithSerializer::serializer(
                                &self.value.price_amount,
                                Some("PRICE_AMOUNT"),
                                false,
                            )?,
                        );
                        let mut bytes = BytesStart::new(self.name);
                        write_attrib(&mut bytes, "price_type", &self.value.price_type)?;
                        return Ok(Some(Event::Start(bytes)));
                    }
                    ProductPriceElementTypeSerializerState::PriceAmount(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductPriceElementTypeSerializerState::PriceCurrency(
                                    IterSerializer::new(
                                        self.value.price_currency.as_ref(),
                                        Some("PRICE_CURRENCY"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductPriceElementTypeSerializerState::PriceCurrency(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = ProductPriceElementTypeSerializerState::Tax(
                                IterSerializer::new(self.value.tax.as_ref(), Some("TAX"), false),
                            )
                        }
                    },
                    ProductPriceElementTypeSerializerState::Tax(x) => match x.next().transpose()? {
                        Some(event) => return Ok(Some(event)),
                        None => {
                            *self.state = ProductPriceElementTypeSerializerState::PriceFactor(
                                IterSerializer::new(
                                    self.value.price_factor.as_ref(),
                                    Some("PRICE_FACTOR"),
                                    false,
                                ),
                            )
                        }
                    },
                    ProductPriceElementTypeSerializerState::PriceFactor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductPriceElementTypeSerializerState::LowerBound(
                                    IterSerializer::new(
                                        self.value.lower_bound.as_ref(),
                                        Some("LOWER_BOUND"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductPriceElementTypeSerializerState::LowerBound(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = ProductPriceElementTypeSerializerState::Territory(
                                    IterSerializer::new(
                                        &self.value.territory[..],
                                        Some("TERRITORY"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    ProductPriceElementTypeSerializerState::Territory(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProductPriceElementTypeSerializerState::End__,
                        }
                    }
                    ProductPriceElementTypeSerializerState::End__ => {
                        *self.state = ProductPriceElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    ProductPriceElementTypeSerializerState::Done__ => return Ok(None),
                    ProductPriceElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for ProductPriceElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = ProductPriceElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct PriceBaseElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::PriceBaseElementType,
        pub(super) state: Box<PriceBaseElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum PriceBaseElementTypeSerializerState<'ser> {
        Init__,
        PriceUnit(<super::DtUnit as WithSerializer>::Serializer<'ser>),
        PriceUnitFactor(IterSerializer<'ser, Option<&'ser f32>, f32>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> PriceBaseElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    PriceBaseElementTypeSerializerState::Init__ => {
                        *self.state = PriceBaseElementTypeSerializerState::PriceUnit(
                            WithSerializer::serializer(
                                &self.value.price_unit,
                                Some("PRICE_UNIT"),
                                false,
                            )?,
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    PriceBaseElementTypeSerializerState::PriceUnit(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = PriceBaseElementTypeSerializerState::PriceUnitFactor(
                                    IterSerializer::new(
                                        self.value.price_unit_factor.as_ref(),
                                        Some("PRICE_UNIT_FACTOR"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    PriceBaseElementTypeSerializerState::PriceUnitFactor(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = PriceBaseElementTypeSerializerState::End__,
                        }
                    }
                    PriceBaseElementTypeSerializerState::End__ => {
                        *self.state = PriceBaseElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    PriceBaseElementTypeSerializerState::Done__ => return Ok(None),
                    PriceBaseElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for PriceBaseElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = PriceBaseElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfMimeInfoElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfMimeInfoElementType,
        pub(super) state: Box<UdxEdxfMimeInfoElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfMimeInfoElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfMime(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfMimeElementType],
                super::UdxEdxfMimeElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfMimeInfoElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfMimeInfoElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfMimeInfoElementTypeSerializerState::UdxEdxfMime(
                            IterSerializer::new(
                                &self.value.udx_edxf_mime[..],
                                Some("UDX.EDXF.MIME"),
                                false,
                            ),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfMimeInfoElementTypeSerializerState::UdxEdxfMime(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxEdxfMimeInfoElementTypeSerializerState::End__,
                        }
                    }
                    UdxEdxfMimeInfoElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfMimeInfoElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfMimeInfoElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfMimeInfoElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfMimeInfoElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfMimeInfoElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDiscountGroupElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfDiscountGroupElementType,
        pub(super) state: Box<UdxEdxfDiscountGroupElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfDiscountGroupElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfDiscountGroupElementTypeContent],
                super::UdxEdxfDiscountGroupElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfDiscountGroupElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfDiscountGroupElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfDiscountGroupElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfDiscountGroupElementTypeSerializerState::Content__(x) => match x
                        .next()
                        .transpose(
                    )? {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxEdxfDiscountGroupElementTypeSerializerState::End__,
                    },
                    UdxEdxfDiscountGroupElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfDiscountGroupElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfDiscountGroupElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfDiscountGroupElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfDiscountGroupElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfDiscountGroupElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfDiscountGroupElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfDiscountGroupElementTypeContent,
        pub(super) state: Box<UdxEdxfDiscountGroupElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfDiscountGroupElementTypeContentSerializerState<'ser> {
        Init__,
        UdxEdxfDiscountGroupManufacturer(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfDiscountGroupSupplier(<String as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfDiscountGroupElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfDiscountGroupElementTypeContentSerializerState :: Init__ => { match self . value { super :: UdxEdxfDiscountGroupElementTypeContent :: UdxEdxfDiscountGroupManufacturer (x) => * self . state = UdxEdxfDiscountGroupElementTypeContentSerializerState :: UdxEdxfDiscountGroupManufacturer (WithSerializer :: serializer (x , Some ("UDX.EDXF.DISCOUNT_GROUP_MANUFACTURER") , false) ?) , super :: UdxEdxfDiscountGroupElementTypeContent :: UdxEdxfDiscountGroupSupplier (x) => * self . state = UdxEdxfDiscountGroupElementTypeContentSerializerState :: UdxEdxfDiscountGroupSupplier (WithSerializer :: serializer (x , Some ("UDX.EDXF.DISCOUNT_GROUP_SUPPLIER") , false) ?) , } } UdxEdxfDiscountGroupElementTypeContentSerializerState :: UdxEdxfDiscountGroupManufacturer (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfDiscountGroupElementTypeContentSerializerState :: Done__ , } } UdxEdxfDiscountGroupElementTypeContentSerializerState :: UdxEdxfDiscountGroupSupplier (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfDiscountGroupElementTypeContentSerializerState :: Done__ , } } UdxEdxfDiscountGroupElementTypeContentSerializerState :: Done__ => return Ok (None) , UdxEdxfDiscountGroupElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfDiscountGroupElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfDiscountGroupElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfAdditionalFactorsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfAdditionalFactorsElementType,
        pub(super) state: Box<UdxEdxfAdditionalFactorsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfAdditionalFactorsElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfAdditionalPriceFactor(<f64 as WithSerializer>::Serializer<'ser>),
        UdxEdxfAdditionalFactorInfo(
            IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfAdditionalFactorsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfAdditionalFactorsElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfAdditionalFactorsElementTypeSerializerState :: UdxEdxfAdditionalPriceFactor (WithSerializer :: serializer (& self . value . udx_edxf_additional_price_factor , Some ("UDX.EDXF.ADDITIONAL_PRICE_FACTOR") , false) ?) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfAdditionalFactorsElementTypeSerializerState :: UdxEdxfAdditionalPriceFactor (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfAdditionalFactorsElementTypeSerializerState :: UdxEdxfAdditionalFactorInfo (IterSerializer :: new (& self . value . udx_edxf_additional_factor_info [..] , Some ("UDX.EDXF.ADDITIONAL_FACTOR_INFO") , false)) , } UdxEdxfAdditionalFactorsElementTypeSerializerState :: UdxEdxfAdditionalFactorInfo (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfAdditionalFactorsElementTypeSerializerState :: End__ , } UdxEdxfAdditionalFactorsElementTypeSerializerState :: End__ => { * self . state = UdxEdxfAdditionalFactorsElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfAdditionalFactorsElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfAdditionalFactorsElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfAdditionalFactorsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfAdditionalFactorsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchNumbersElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfCountryBranchNumbersElementType,
        pub(super) state: Box<UdxEdxfCountryBranchNumbersElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfCountryBranchNumbersElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfCountryBranchNumber(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType],
                super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfCountryBranchNumbersElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfCountryBranchNumbersElementTypeSerializerState :: UdxEdxfCountryBranchNumber (IterSerializer :: new (& self . value . udx_edxf_country_branch_number [..] , Some ("UDX.EDXF.COUNTRY_BRANCH_NUMBER") , false)) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfCountryBranchNumbersElementTypeSerializerState :: UdxEdxfCountryBranchNumber (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfCountryBranchNumbersElementTypeSerializerState :: End__ , } UdxEdxfCountryBranchNumbersElementTypeSerializerState :: End__ => { * self . state = UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfCountryBranchNumbersElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfCountryBranchNumbersElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfCountryBranchNumbersElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchSupplierIdsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfCountryBranchSupplierIdsElementType,
        pub(super) state: Box<UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState<'ser> {
        Init__ , UdxEdxfCountryBranchSupplierId (IterSerializer < 'ser , & 'ser [super :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType] , super :: UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType >) , End__ , Done__ , Phantom__ (& 'ser ()) , }
    impl<'ser> UdxEdxfCountryBranchSupplierIdsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: UdxEdxfCountryBranchSupplierId (IterSerializer :: new (& self . value . udx_edxf_country_branch_supplier_id [..] , Some ("UDX.EDXF.COUNTRY_BRANCH_SUPPLIER_ID") , false)) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: UdxEdxfCountryBranchSupplierId (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: End__ , } UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: End__ => { * self . state = UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfCountryBranchSupplierIdsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfCountryBranchSupplierIdsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfPackingUnitsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfPackingUnitsElementType,
        pub(super) state: Box<UdxEdxfPackingUnitsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfPackingUnitsElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfPackingUnit(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfPackingUnitElementType],
                super::UdxEdxfPackingUnitElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfPackingUnitsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfPackingUnitsElementTypeSerializerState::Init__ => {
                        *self.state =
                            UdxEdxfPackingUnitsElementTypeSerializerState::UdxEdxfPackingUnit(
                                IterSerializer::new(
                                    &self.value.udx_edxf_packing_unit[..],
                                    Some("UDX.EDXF.PACKING_UNIT"),
                                    false,
                                ),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfPackingUnitsElementTypeSerializerState::UdxEdxfPackingUnit(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxEdxfPackingUnitsElementTypeSerializerState::End__,
                    },
                    UdxEdxfPackingUnitsElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfPackingUnitsElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfPackingUnitsElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfPackingUnitsElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfPackingUnitsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfPackingUnitsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductLogisticDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfProductLogisticDetailsElementType,
        pub(super) state: Box<UdxEdxfProductLogisticDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfProductLogisticDetailsElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfNetvolume(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfNetweight(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfNetlength(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfNetwidth(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfNetdepth(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfNetdiameter(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfRegionOfOrigin(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfProductLogisticDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetvolume (IterSerializer :: new (self . value . udx_edxf_netvolume . as_ref () , Some ("UDX.EDXF.NETVOLUME") , false)) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetvolume (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetweight (IterSerializer :: new (self . value . udx_edxf_netweight . as_ref () , Some ("UDX.EDXF.NETWEIGHT") , false)) , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetweight (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetlength (IterSerializer :: new (self . value . udx_edxf_netlength . as_ref () , Some ("UDX.EDXF.NETLENGTH") , false)) , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetlength (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetwidth (IterSerializer :: new (self . value . udx_edxf_netwidth . as_ref () , Some ("UDX.EDXF.NETWIDTH") , false)) , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetwidth (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetdepth (IterSerializer :: new (self . value . udx_edxf_netdepth . as_ref () , Some ("UDX.EDXF.NETDEPTH") , false)) , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetdepth (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetdiameter (IterSerializer :: new (self . value . udx_edxf_netdiameter . as_ref () , Some ("UDX.EDXF.NETDIAMETER") , false)) , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfNetdiameter (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfRegionOfOrigin (IterSerializer :: new (self . value . udx_edxf_region_of_origin . as_ref () , Some ("UDX.EDXF.REGION_OF_ORIGIN") , false)) , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: UdxEdxfRegionOfOrigin (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: End__ , } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: End__ => { * self . state = UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfProductLogisticDetailsElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfProductLogisticDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfProductLogisticDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfReachElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfReachElementType,
        pub(super) state: Box<UdxEdxfReachElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfReachElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfReachListdate(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfReachInfo(<super::UdxEdxfReachInfoElementType as WithSerializer>::Serializer<'ser>),
        UdxEdxfScipNumber(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfUfiCode(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfReachElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfReachElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfReachElementTypeSerializerState::UdxEdxfReachListdate(
                            IterSerializer::new(
                                self.value.udx_edxf_reach_listdate.as_ref(),
                                Some("UDX.EDXF.REACH.LISTDATE"),
                                false,
                            ),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfReachElementTypeSerializerState::UdxEdxfReachListdate(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfReachElementTypeSerializerState::UdxEdxfReachInfo(
                                        WithSerializer::serializer(
                                            &self.value.udx_edxf_reach_info,
                                            Some("UDX.EDXF.REACH.INFO"),
                                            false,
                                        )?,
                                    )
                            }
                        }
                    }
                    UdxEdxfReachElementTypeSerializerState::UdxEdxfReachInfo(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfReachElementTypeSerializerState::UdxEdxfScipNumber(
                                        IterSerializer::new(
                                            self.value.udx_edxf_scip_number.as_ref(),
                                            Some("UDX.EDXF.SCIP_NUMBER"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxEdxfReachElementTypeSerializerState::UdxEdxfScipNumber(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxEdxfReachElementTypeSerializerState::UdxEdxfUfiCode(
                                    IterSerializer::new(
                                        self.value.udx_edxf_ufi_code.as_ref(),
                                        Some("UDX.EDXF.UFI_CODE"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxEdxfReachElementTypeSerializerState::UdxEdxfUfiCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxEdxfReachElementTypeSerializerState::End__,
                        }
                    }
                    UdxEdxfReachElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfReachElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfReachElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfReachElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfReachElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfReachElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfSpecialTreatmentClassDetailsElementType,
        pub(super) state: Box<UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfHazardousSubstances(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfHazardousSubstancesElementType],
                super::UdxEdxfHazardousSubstancesElementType,
            >,
        ),
        UdxEdxfShippingName(
            IterSerializer<'ser, Option<&'ser super::DtMlstring>, super::DtMlstring>,
        ),
        UdxEdxfPackingGroup(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfPackingGroupElementType>,
                super::UdxEdxfPackingGroupElementType,
            >,
        ),
        UdxEdxfTransportCategory(IterSerializer<'ser, Option<&'ser i32>, i32>),
        UdxEdxfMultiplicationFactor(IterSerializer<'ser, Option<&'ser i32>, i32>),
        UdxEdxfLimitedQuantities(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfExceptedQuantities(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfAggregationState(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfAggregationStateElementType>,
                super::UdxEdxfAggregationStateElementType,
            >,
        ),
        UdxEdxfSpecialProvisionId(IterSerializer<'ser, &'ser [String], String>),
        UdxEdxfHazardClass(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfHazardClassElementType],
                super::UdxEdxfHazardClassElementType,
            >,
        ),
        UdxEdxfClassificationCode(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfHazardLabel(IterSerializer<'ser, &'ser [String], String>),
        UdxEdxfEnvironmentalHazards(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfTunnelCode(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfTunnelCodeElementType>,
                super::UdxEdxfTunnelCodeElementType,
            >,
        ),
        UdxEdxfGhsLabelCode(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfGhsLabelCodeElementType],
                super::UdxEdxfGhsLabelCodeElementType,
            >,
        ),
        UdxEdxfGhsSignalWord(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfGhsSignalWordElementType>,
                super::UdxEdxfGhsSignalWordElementType,
            >,
        ),
        UdxEdxfHazardStatement(IterSerializer<'ser, &'ser [String], String>),
        UdxEdxfPrecautionaryStatement(IterSerializer<'ser, &'ser [String], String>),
        UdxEdxfLiIonTested(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfLithiumAmount(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfBatteryEnergy(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfNos274(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfHazardTrigger(IterSerializer<'ser, &'ser [String], String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardousSubstances (IterSerializer :: new (& self . value . udx_edxf_hazardous_substances [..] , Some ("UDX.EDXF.HAZARDOUS_SUBSTANCES") , false)) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardousSubstances (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfShippingName (IterSerializer :: new (self . value . udx_edxf_shipping_name . as_ref () , Some ("UDX.EDXF.SHIPPING_NAME") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfShippingName (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfPackingGroup (IterSerializer :: new (self . value . udx_edxf_packing_group . as_ref () , Some ("UDX.EDXF.PACKING_GROUP") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfPackingGroup (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfTransportCategory (IterSerializer :: new (self . value . udx_edxf_transport_category . as_ref () , Some ("UDX.EDXF.TRANSPORT_CATEGORY") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfTransportCategory (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfMultiplicationFactor (IterSerializer :: new (self . value . udx_edxf_multiplication_factor . as_ref () , Some ("UDX.EDXF.MULTIPLICATION_FACTOR") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfMultiplicationFactor (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfLimitedQuantities (IterSerializer :: new (self . value . udx_edxf_limited_quantities . as_ref () , Some ("UDX.EDXF.LIMITED_QUANTITIES") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfLimitedQuantities (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfExceptedQuantities (IterSerializer :: new (self . value . udx_edxf_excepted_quantities . as_ref () , Some ("UDX.EDXF.EXCEPTED_QUANTITIES") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfExceptedQuantities (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfAggregationState (IterSerializer :: new (self . value . udx_edxf_aggregation_state . as_ref () , Some ("UDX.EDXF.AGGREGATION_STATE") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfAggregationState (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfSpecialProvisionId (IterSerializer :: new (& self . value . udx_edxf_special_provision_id [..] , Some ("UDX.EDXF.SPECIAL_PROVISION_ID") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfSpecialProvisionId (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardClass (IterSerializer :: new (& self . value . udx_edxf_hazard_class [..] , Some ("UDX.EDXF.HAZARD_CLASS") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardClass (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfClassificationCode (IterSerializer :: new (self . value . udx_edxf_classification_code . as_ref () , Some ("UDX.EDXF.CLASSIFICATION_CODE") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfClassificationCode (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardLabel (IterSerializer :: new (& self . value . udx_edxf_hazard_label [..] , Some ("UDX.EDXF.HAZARD_LABEL") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardLabel (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfEnvironmentalHazards (IterSerializer :: new (self . value . udx_edxf_environmental_hazards . as_ref () , Some ("UDX.EDXF.ENVIRONMENTAL_HAZARDS") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfEnvironmentalHazards (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfTunnelCode (IterSerializer :: new (self . value . udx_edxf_tunnel_code . as_ref () , Some ("UDX.EDXF.TUNNEL_CODE") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfTunnelCode (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfGhsLabelCode (IterSerializer :: new (& self . value . udx_edxf_ghs_label_code [..] , Some ("UDX.EDXF.GHS_LABEL_CODE") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfGhsLabelCode (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfGhsSignalWord (IterSerializer :: new (self . value . udx_edxf_ghs_signal_word . as_ref () , Some ("UDX.EDXF.GHS_SIGNAL_WORD") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfGhsSignalWord (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardStatement (IterSerializer :: new (& self . value . udx_edxf_hazard_statement [..] , Some ("UDX.EDXF.HAZARD_STATEMENT") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardStatement (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfPrecautionaryStatement (IterSerializer :: new (& self . value . udx_edxf_precautionary_statement [..] , Some ("UDX.EDXF.PRECAUTIONARY_STATEMENT") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfPrecautionaryStatement (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfLiIonTested (IterSerializer :: new (self . value . udx_edxf_li_ion_tested . as_ref () , Some ("UDX.EDXF.LI-ION_TESTED") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfLiIonTested (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfLithiumAmount (IterSerializer :: new (self . value . udx_edxf_lithium_amount . as_ref () , Some ("UDX.EDXF.LITHIUM_AMOUNT") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfLithiumAmount (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfBatteryEnergy (IterSerializer :: new (self . value . udx_edxf_battery_energy . as_ref () , Some ("UDX.EDXF.BATTERY_ENERGY") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfBatteryEnergy (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfNos274 (IterSerializer :: new (self . value . udx_edxf_nos_274 . as_ref () , Some ("UDX.EDXF.NOS_274") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfNos274 (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardTrigger (IterSerializer :: new (& self . value . udx_edxf_hazard_trigger [..] , Some ("UDX.EDXF.HAZARD_TRIGGER") , false)) , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: UdxEdxfHazardTrigger (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: End__ , } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: End__ => { * self . state = UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state =
                        UdxEdxfSpecialTreatmentClassDetailsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeListElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfSurchargeListElementType,
        pub(super) state: Box<UdxEdxfSurchargeListElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfSurchargeListElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfSurcharge(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfSurchargeElementType],
                super::UdxEdxfSurchargeElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfSurchargeListElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfSurchargeListElementTypeSerializerState::Init__ => {
                        *self.state =
                            UdxEdxfSurchargeListElementTypeSerializerState::UdxEdxfSurcharge(
                                IterSerializer::new(
                                    &self.value.udx_edxf_surcharge[..],
                                    Some("UDX.EDXF.SURCHARGE"),
                                    false,
                                ),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfSurchargeListElementTypeSerializerState::UdxEdxfSurcharge(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxEdxfSurchargeListElementTypeSerializerState::End__,
                    },
                    UdxEdxfSurchargeListElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfSurchargeListElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfSurchargeListElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfSurchargeListElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfSurchargeListElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfSurchargeListElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfWarrantyElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfWarrantyElementType,
        pub(super) state: Box<UdxEdxfWarrantyElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfWarrantyElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfWarrantyBusiness(IterSerializer<'ser, Option<&'ser i32>, i32>),
        UdxEdxfWarrantyConsumer(IterSerializer<'ser, Option<&'ser i32>, i32>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfWarrantyElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfWarrantyElementTypeSerializerState::Init__ => {
                        *self.state =
                            UdxEdxfWarrantyElementTypeSerializerState::UdxEdxfWarrantyBusiness(
                                IterSerializer::new(
                                    self.value.udx_edxf_warranty_business.as_ref(),
                                    Some("UDX.EDXF.WARRANTY_BUSINESS"),
                                    false,
                                ),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfWarrantyElementTypeSerializerState::UdxEdxfWarrantyBusiness(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                UdxEdxfWarrantyElementTypeSerializerState::UdxEdxfWarrantyConsumer(
                                    IterSerializer::new(
                                        self.value.udx_edxf_warranty_consumer.as_ref(),
                                        Some("UDX.EDXF.WARRANTY_CONSUMER"),
                                        false,
                                    ),
                                ),
                        }
                    }
                    UdxEdxfWarrantyElementTypeSerializerState::UdxEdxfWarrantyConsumer(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxEdxfWarrantyElementTypeSerializerState::End__,
                        }
                    }
                    UdxEdxfWarrantyElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfWarrantyElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfWarrantyElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfWarrantyElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfWarrantyElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfWarrantyElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductEtimDynamicElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfProductEtimDynamicElementType,
        pub(super) state: Box<UdxEdxfProductEtimDynamicElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfProductEtimDynamicElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfProductEtimReleaseDate(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfProductEtimDynamicElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfProductEtimDynamicElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfProductEtimDynamicElementTypeSerializerState :: UdxEdxfProductEtimReleaseDate (WithSerializer :: serializer (& self . value . udx_edxf_product_etim_release_date , Some ("UDX.EDXF.PRODUCT_ETIM_RELEASE_DATE") , false) ?) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfProductEtimDynamicElementTypeSerializerState :: UdxEdxfProductEtimReleaseDate (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductEtimDynamicElementTypeSerializerState :: End__ , } UdxEdxfProductEtimDynamicElementTypeSerializerState :: End__ => { * self . state = UdxEdxfProductEtimDynamicElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfProductEtimDynamicElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfProductEtimDynamicElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfProductEtimDynamicElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfProductEtimDynamicElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductFeaturesMcElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfProductFeaturesMcElementType,
        pub(super) state: Box<UdxEdxfProductFeaturesMcElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfProductFeaturesMcElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfReferenceFeatureMcId(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfReferenceFeatureMcVersion(<i32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfBimStatus(
            IterSerializer<
                'ser,
                Option<&'ser super::UdxEdxfBimStatusElementType>,
                super::UdxEdxfBimStatusElementType,
            >,
        ),
        UdxEdxfFeatureMc(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfFeatureMcElementType],
                super::UdxEdxfFeatureMcElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfProductFeaturesMcElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfProductFeaturesMcElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfProductFeaturesMcElementTypeSerializerState :: UdxEdxfReferenceFeatureMcId (WithSerializer :: serializer (& self . value . udx_edxf_reference_feature_mc_id , Some ("UDX.EDXF.REFERENCE_FEATURE_MC_ID") , false) ?) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfProductFeaturesMcElementTypeSerializerState :: UdxEdxfReferenceFeatureMcId (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductFeaturesMcElementTypeSerializerState :: UdxEdxfReferenceFeatureMcVersion (WithSerializer :: serializer (& self . value . udx_edxf_reference_feature_mc_version , Some ("UDX.EDXF.REFERENCE_FEATURE_MC_VERSION") , false) ?) , } UdxEdxfProductFeaturesMcElementTypeSerializerState :: UdxEdxfReferenceFeatureMcVersion (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductFeaturesMcElementTypeSerializerState :: UdxEdxfBimStatus (IterSerializer :: new (self . value . udx_edxf_bim_status . as_ref () , Some ("UDX.EDXF.BIM_STATUS") , false)) , } UdxEdxfProductFeaturesMcElementTypeSerializerState :: UdxEdxfBimStatus (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductFeaturesMcElementTypeSerializerState :: UdxEdxfFeatureMc (IterSerializer :: new (& self . value . udx_edxf_feature_mc [..] , Some ("UDX.EDXF.FEATURE_MC") , false)) , } UdxEdxfProductFeaturesMcElementTypeSerializerState :: UdxEdxfFeatureMc (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductFeaturesMcElementTypeSerializerState :: End__ , } UdxEdxfProductFeaturesMcElementTypeSerializerState :: End__ => { * self . state = UdxEdxfProductFeaturesMcElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfProductFeaturesMcElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfProductFeaturesMcElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfProductFeaturesMcElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfProductFeaturesMcElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductCharacteristicsElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfProductCharacteristicsElementType,
        pub(super) state: Box<UdxEdxfProductCharacteristicsElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfProductCharacteristicsElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfProductCharacteristic(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfProductCharacteristicElementType],
                super::UdxEdxfProductCharacteristicElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfProductCharacteristicsElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfProductCharacteristicsElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfProductCharacteristicsElementTypeSerializerState :: UdxEdxfProductCharacteristic (IterSerializer :: new (& self . value . udx_edxf_product_characteristic [..] , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC") , false)) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfProductCharacteristicsElementTypeSerializerState :: UdxEdxfProductCharacteristic (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicsElementTypeSerializerState :: End__ , } UdxEdxfProductCharacteristicsElementTypeSerializerState :: End__ => { * self . state = UdxEdxfProductCharacteristicsElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfProductCharacteristicsElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfProductCharacteristicsElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfProductCharacteristicsElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfProductCharacteristicsElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct CustomsTariffNumberElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::CustomsTariffNumberElementType,
        pub(super) state: Box<CustomsTariffNumberElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum CustomsTariffNumberElementTypeSerializerState<'ser> {
        Init__,
        CustomsNumber(<String as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> CustomsTariffNumberElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    CustomsTariffNumberElementTypeSerializerState::Init__ => {
                        *self.state = CustomsTariffNumberElementTypeSerializerState::CustomsNumber(
                            WithSerializer::serializer(
                                &self.value.customs_number,
                                Some("CUSTOMS_NUMBER"),
                                false,
                            )?,
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    CustomsTariffNumberElementTypeSerializerState::CustomsNumber(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = CustomsTariffNumberElementTypeSerializerState::End__,
                    },
                    CustomsTariffNumberElementTypeSerializerState::End__ => {
                        *self.state = CustomsTariffNumberElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    CustomsTariffNumberElementTypeSerializerState::Done__ => return Ok(None),
                    CustomsTariffNumberElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for CustomsTariffNumberElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = CustomsTariffNumberElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfMimeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfMimeElementType,
        pub(super) state: Box<UdxEdxfMimeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfMimeElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfMimeSource(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfMimeCode(<super::UdxEdxfMimeCodeElementType as WithSerializer>::Serializer<'ser>),
        UdxEdxfMimeFilename(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfMimeDesignation(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfMimeAlt(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfMimeIssueDate(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfMimeExpiryDate(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfMimeOrder(IterSerializer<'ser, Option<&'ser i32>, i32>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfMimeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfMimeElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeSource(
                            IterSerializer::new(
                                &self.value.udx_edxf_mime_source[..],
                                Some("UDX.EDXF.MIME_SOURCE"),
                                false,
                            ),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeSource(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeCode(
                                    WithSerializer::serializer(
                                        &self.value.udx_edxf_mime_code,
                                        Some("UDX.EDXF.MIME_CODE"),
                                        false,
                                    )?,
                                )
                            }
                        }
                    }
                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeCode(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeFilename(
                                        IterSerializer::new(
                                            &self.value.udx_edxf_mime_filename[..],
                                            Some("UDX.EDXF.MIME_FILENAME"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeFilename(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeDesignation(
                                        IterSerializer::new(
                                            &self.value.udx_edxf_mime_designation[..],
                                            Some("UDX.EDXF.MIME_DESIGNATION"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeDesignation(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeAlt(
                                    IterSerializer::new(
                                        &self.value.udx_edxf_mime_alt[..],
                                        Some("UDX.EDXF.MIME_ALT"),
                                        false,
                                    ),
                                )
                            }
                        }
                    }
                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeAlt(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeIssueDate(
                                        IterSerializer::new(
                                            self.value.udx_edxf_mime_issue_date.as_ref(),
                                            Some("UDX.EDXF.MIME_ISSUE_DATE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeIssueDate(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeExpiryDate(
                                        IterSerializer::new(
                                            self.value.udx_edxf_mime_expiry_date.as_ref(),
                                            Some("UDX.EDXF.MIME_EXPIRY_DATE"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeExpiryDate(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeOrder(
                                        IterSerializer::new(
                                            self.value.udx_edxf_mime_order.as_ref(),
                                            Some("UDX.EDXF.MIME_ORDER"),
                                            false,
                                        ),
                                    )
                            }
                        }
                    }
                    UdxEdxfMimeElementTypeSerializerState::UdxEdxfMimeOrder(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxEdxfMimeElementTypeSerializerState::End__,
                        }
                    }
                    UdxEdxfMimeElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfMimeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfMimeElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfMimeElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfMimeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfMimeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer<'ser> {
        pub(super) value:
            &'ser super::UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementType,
        pub(super) state: Box<
            UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState<'ser>,
        >,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState<
        'ser,
    > {
        Init__,
        Content__(<i32 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Content__ (WithSerializer :: serializer (& self . value . content , None , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; write_attrib (& mut bytes , "type" , & self . value . type_) ? ; write_attrib (& mut bytes , "country" , & self . value . country) ? ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Content__ (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: End__ , } UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: End__ => { * self . state = UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator
        for UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializer<'ser>
    {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    * self . state = UdxEdxfCountryBranchNumbersUdxEdxfCountryBranchNumberElementTypeSerializerState :: Done__ ;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer<
        'ser,
    > {
        pub(super) value:
            &'ser super::UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementType,
        pub(super) state: Box<
            UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState<
                'ser,
            >,
        >,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState<
        'ser,
    > {
        Init__,
        Content__(<i32 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser>
        UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer<'ser>
    {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Content__ (WithSerializer :: serializer (& self . value . content , None , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; write_attrib (& mut bytes , "type" , & self . value . type_) ? ; write_attrib (& mut bytes , "country" , & self . value . country) ? ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Content__ (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: End__ , } UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: End__ => { * self . state = UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator
        for UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializer<'ser>
    {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    * self . state = UdxEdxfCountryBranchSupplierIdsUdxEdxfCountryBranchSupplierIdElementTypeSerializerState :: Done__ ;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfPackingUnitElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfPackingUnitElementType,
        pub(super) state: Box<UdxEdxfPackingUnitElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfPackingUnitElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfQuantityMin(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfQuantityMax(IterSerializer<'ser, Option<&'ser f32>, f32>),
        UdxEdxfPackingUnitCode(<super::DtPunit as WithSerializer>::Serializer<'ser>),
        UdxEdxfPackingUnitName(IterSerializer<'ser, &'ser [super::DtMlstring], super::DtMlstring>),
        UdxEdxfPackageBreak(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfPackingParts(IterSerializer<'ser, Option<&'ser i32>, i32>),
        UdxEdxfVolume(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfWeight(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfLength(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfWidth(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfDepth(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfDiameter(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfGtin(IterSerializer<'ser, Option<&'ser String>, String>),
        UdxEdxfGs1128(IterSerializer<'ser, Option<&'ser String>, String>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfPackingUnitElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfPackingUnitElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfQuantityMin (WithSerializer :: serializer (& self . value . udx_edxf_quantity_min , Some ("UDX.EDXF.QUANTITY_MIN") , false) ?) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfQuantityMin (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfQuantityMax (IterSerializer :: new (self . value . udx_edxf_quantity_max . as_ref () , Some ("UDX.EDXF.QUANTITY_MAX") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfQuantityMax (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingUnitCode (WithSerializer :: serializer (& self . value . udx_edxf_packing_unit_code , Some ("UDX.EDXF.PACKING_UNIT_CODE") , false) ?) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingUnitCode (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingUnitName (IterSerializer :: new (& self . value . udx_edxf_packing_unit_name [..] , Some ("UDX.EDXF.PACKING_UNIT_NAME") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingUnitName (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackageBreak (IterSerializer :: new (self . value . udx_edxf_package_break . as_ref () , Some ("UDX.EDXF.PACKAGE_BREAK") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackageBreak (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingParts (IterSerializer :: new (self . value . udx_edxf_packing_parts . as_ref () , Some ("UDX.EDXF.PACKING_PARTS") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfPackingParts (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfVolume (IterSerializer :: new (self . value . udx_edxf_volume . as_ref () , Some ("UDX.EDXF.VOLUME") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfVolume (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfWeight (IterSerializer :: new (self . value . udx_edxf_weight . as_ref () , Some ("UDX.EDXF.WEIGHT") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfWeight (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfLength (IterSerializer :: new (self . value . udx_edxf_length . as_ref () , Some ("UDX.EDXF.LENGTH") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfLength (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfWidth (IterSerializer :: new (self . value . udx_edxf_width . as_ref () , Some ("UDX.EDXF.WIDTH") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfWidth (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfDepth (IterSerializer :: new (self . value . udx_edxf_depth . as_ref () , Some ("UDX.EDXF.DEPTH") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfDepth (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfDiameter (IterSerializer :: new (self . value . udx_edxf_diameter . as_ref () , Some ("UDX.EDXF.DIAMETER") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfDiameter (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfGtin (IterSerializer :: new (self . value . udx_edxf_gtin . as_ref () , Some ("UDX.EDXF.GTIN") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfGtin (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfGs1128 (IterSerializer :: new (self . value . udx_edxf_gs_1128 . as_ref () , Some ("UDX.EDXF.GS1_128") , false)) , } UdxEdxfPackingUnitElementTypeSerializerState :: UdxEdxfGs1128 (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: End__ , } UdxEdxfPackingUnitElementTypeSerializerState :: End__ => { * self . state = UdxEdxfPackingUnitElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfPackingUnitElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfPackingUnitElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfPackingUnitElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfPackingUnitElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfHazardousSubstancesElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfHazardousSubstancesElementType,
        pub(super) state: Box<UdxEdxfHazardousSubstancesElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfHazardousSubstancesElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfUnNumber(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfNetWeightOfHazardousSubstance(IterSerializer<'ser, Option<&'ser f64>, f64>),
        UdxEdxfVolumeOfHazardousSubstances(IterSerializer<'ser, Option<&'ser f64>, f64>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfHazardousSubstancesElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfHazardousSubstancesElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfHazardousSubstancesElementTypeSerializerState :: UdxEdxfUnNumber (WithSerializer :: serializer (& self . value . udx_edxf_un_number , Some ("UDX.EDXF.UN_NUMBER") , false) ?) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfHazardousSubstancesElementTypeSerializerState :: UdxEdxfUnNumber (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfHazardousSubstancesElementTypeSerializerState :: UdxEdxfNetWeightOfHazardousSubstance (IterSerializer :: new (self . value . udx_edxf_net_weight_of_hazardous_substance . as_ref () , Some ("UDX.EDXF.NET_WEIGHT_OF_HAZARDOUS_SUBSTANCE") , false)) , } UdxEdxfHazardousSubstancesElementTypeSerializerState :: UdxEdxfNetWeightOfHazardousSubstance (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfHazardousSubstancesElementTypeSerializerState :: UdxEdxfVolumeOfHazardousSubstances (IterSerializer :: new (self . value . udx_edxf_volume_of_hazardous_substances . as_ref () , Some ("UDX.EDXF.VOLUME_OF_HAZARDOUS_SUBSTANCES") , false)) , } UdxEdxfHazardousSubstancesElementTypeSerializerState :: UdxEdxfVolumeOfHazardousSubstances (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfHazardousSubstancesElementTypeSerializerState :: End__ , } UdxEdxfHazardousSubstancesElementTypeSerializerState :: End__ => { * self . state = UdxEdxfHazardousSubstancesElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfHazardousSubstancesElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfHazardousSubstancesElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfHazardousSubstancesElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfHazardousSubstancesElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfSurchargeElementType,
        pub(super) state: Box<UdxEdxfSurchargeElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfSurchargeElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfSurchargeElementTypeContent],
                super::UdxEdxfSurchargeElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfSurchargeElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfSurchargeElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfSurchargeElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfSurchargeElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxEdxfSurchargeElementTypeSerializerState::End__,
                        }
                    }
                    UdxEdxfSurchargeElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfSurchargeElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfSurchargeElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfSurchargeElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfSurchargeElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfSurchargeElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfSurchargeElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfSurchargeElementTypeContent,
        pub(super) state: Box<UdxEdxfSurchargeElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfSurchargeElementTypeContentSerializerState<'ser> {
        Init__ , UdxEdxfSurchargeType (< String as WithSerializer > :: Serializer < 'ser >) , UdxEdxfSurchargeClass (< String as WithSerializer > :: Serializer < 'ser >) , UdxEdxfSurchargeManner (< super :: UdxEdxfSurchargeMannerElementType as WithSerializer > :: Serializer < 'ser >) , UdxEdxfSurchargePercentage (< f64 as WithSerializer > :: Serializer < 'ser >) , UdxEdxfSurchargePriceAmount (< f64 as WithSerializer > :: Serializer < 'ser >) , UdxEdxfSurchargeCalculation (< super :: UdxEdxfSurchargeUdxEdxfSurchargeCalculationElementType as WithSerializer > :: Serializer < 'ser >) , UdxEdxfMaterialBasis (< f64 as WithSerializer > :: Serializer < 'ser >) , UdxEdxfMaterialBasisWeight (< f64 as WithSerializer > :: Serializer < 'ser >) , UdxEdxfMaterialBasisSurchargeThreshold (< f64 as WithSerializer > :: Serializer < 'ser >) , UdxEdxfMaterialBasisSurchargeShutter (< super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeShutterElementType as WithSerializer > :: Serializer < 'ser >) , UdxEdxfMaterialBasisSurchargeCredit (< super :: UdxEdxfSurchargeUdxEdxfMaterialBasisSurchargeCreditElementType as WithSerializer > :: Serializer < 'ser >) , UdxEdxfMaterialBasisSurchargeTable (< super :: DtMlstring as WithSerializer > :: Serializer < 'ser >) , Done__ , Phantom__ (& 'ser ()) , }
    impl<'ser> UdxEdxfSurchargeElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfSurchargeElementTypeContentSerializerState :: Init__ => { match self . value { super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargeType (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeType (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_TYPE") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargeClass (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeClass (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_CLASS") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargeManner (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeManner (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_MANNER") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargePercentage (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargePercentage (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_PERCENTAGE") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargePriceAmount (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargePriceAmount (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_PRICE_AMOUNT") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfSurchargeCalculation (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeCalculation (WithSerializer :: serializer (x , Some ("UDX.EDXF.SURCHARGE_CALCULATION") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasis (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasis (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisWeight (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisWeight (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_WEIGHT") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeThreshold (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeThreshold (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_THRESHOLD") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeShutter (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeShutter (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_SHUTTER") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeCredit (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeCredit (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_CREDIT") , false) ?) , super :: UdxEdxfSurchargeElementTypeContent :: UdxEdxfMaterialBasisSurchargeTable (x) => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeTable (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATERIAL_BASIS_SURCHARGE_TABLE") , false) ?) , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeType (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeClass (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeManner (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargePercentage (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargePriceAmount (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfSurchargeCalculation (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasis (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisWeight (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeThreshold (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeShutter (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeCredit (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: UdxEdxfMaterialBasisSurchargeTable (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ , } } UdxEdxfSurchargeElementTypeContentSerializerState :: Done__ => return Ok (None) , UdxEdxfSurchargeElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfSurchargeElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfSurchargeElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfFeatureMcElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfFeatureMcElementType,
        pub(super) state: Box<UdxEdxfFeatureMcElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfFeatureMcElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfFeatureMcElementTypeContent],
                super::UdxEdxfFeatureMcElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfFeatureMcElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfFeatureMcElementTypeSerializerState::Init__ => {
                        *self.state = UdxEdxfFeatureMcElementTypeSerializerState::Content__(
                            IterSerializer::new(&self.value.content[..], None, false),
                        );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfFeatureMcElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = UdxEdxfFeatureMcElementTypeSerializerState::End__,
                        }
                    }
                    UdxEdxfFeatureMcElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfFeatureMcElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfFeatureMcElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfFeatureMcElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfFeatureMcElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfFeatureMcElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfFeatureMcElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfFeatureMcElementTypeContent,
        pub(super) state: Box<UdxEdxfFeatureMcElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfFeatureMcElementTypeContentSerializerState<'ser> {
        Init__,
        UdxEdxfPortcode(<i32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfFname(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfFvalue(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfCoordinateX(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfCoordinateY(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfCoordinateZ(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfMatrixValues(
            <super::UdxEdxfMatrixValuesElementType as WithSerializer>::Serializer<'ser>,
        ),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfFeatureMcElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfFeatureMcElementTypeContentSerializerState :: Init__ => { match self . value { super :: UdxEdxfFeatureMcElementTypeContent :: UdxEdxfPortcode (x) => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfPortcode (WithSerializer :: serializer (x , Some ("UDX.EDXF.PORTCODE") , false) ?) , super :: UdxEdxfFeatureMcElementTypeContent :: UdxEdxfFname (x) => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfFname (WithSerializer :: serializer (x , Some ("UDX.EDXF.FNAME") , false) ?) , super :: UdxEdxfFeatureMcElementTypeContent :: UdxEdxfFvalue (x) => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfFvalue (WithSerializer :: serializer (x , Some ("UDX.EDXF.FVALUE") , false) ?) , super :: UdxEdxfFeatureMcElementTypeContent :: UdxEdxfCoordinateX (x) => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfCoordinateX (WithSerializer :: serializer (x , Some ("UDX.EDXF.COORDINATE_X") , false) ?) , super :: UdxEdxfFeatureMcElementTypeContent :: UdxEdxfCoordinateY (x) => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfCoordinateY (WithSerializer :: serializer (x , Some ("UDX.EDXF.COORDINATE_Y") , false) ?) , super :: UdxEdxfFeatureMcElementTypeContent :: UdxEdxfCoordinateZ (x) => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfCoordinateZ (WithSerializer :: serializer (x , Some ("UDX.EDXF.COORDINATE_Z") , false) ?) , super :: UdxEdxfFeatureMcElementTypeContent :: UdxEdxfMatrixValues (x) => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfMatrixValues (WithSerializer :: serializer (x , Some ("UDX.EDXF.MATRIX_VALUES") , false) ?) , } } UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfPortcode (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: Done__ , } } UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfFname (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: Done__ , } } UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfFvalue (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: Done__ , } } UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfCoordinateX (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: Done__ , } } UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfCoordinateY (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: Done__ , } } UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfCoordinateZ (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: Done__ , } } UdxEdxfFeatureMcElementTypeContentSerializerState :: UdxEdxfMatrixValues (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfFeatureMcElementTypeContentSerializerState :: Done__ , } } UdxEdxfFeatureMcElementTypeContentSerializerState :: Done__ => return Ok (None) , UdxEdxfFeatureMcElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfFeatureMcElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfFeatureMcElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductCharacteristicElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfProductCharacteristicElementType,
        pub(super) state: Box<UdxEdxfProductCharacteristicElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfProductCharacteristicElementTypeSerializerState<'ser> {
        Init__,
        Content__(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfProductCharacteristicElementTypeContent],
                super::UdxEdxfProductCharacteristicElementTypeContent,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfProductCharacteristicElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfProductCharacteristicElementTypeSerializerState::Init__ => {
                        *self.state =
                            UdxEdxfProductCharacteristicElementTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfProductCharacteristicElementTypeSerializerState::Content__(x) => {
                        match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    UdxEdxfProductCharacteristicElementTypeSerializerState::End__
                            }
                        }
                    }
                    UdxEdxfProductCharacteristicElementTypeSerializerState::End__ => {
                        *self.state =
                            UdxEdxfProductCharacteristicElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfProductCharacteristicElementTypeSerializerState::Done__ => {
                        return Ok(None)
                    }
                    UdxEdxfProductCharacteristicElementTypeSerializerState::Phantom__(_) => {
                        unreachable!()
                    }
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfProductCharacteristicElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfProductCharacteristicElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfProductCharacteristicElementTypeContentSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfProductCharacteristicElementTypeContent,
        pub(super) state: Box<UdxEdxfProductCharacteristicElementTypeContentSerializerState<'ser>>,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfProductCharacteristicElementTypeContentSerializerState<'ser> {
        Init__,
        UdxEdxfProductCharacteristicCode(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfProductCharacteristicName(<super::DtMlstring as WithSerializer>::Serializer<'ser>),
        UdxEdxfProductCharacteristicValueBoolean(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfProductCharacteristicValueNumeric(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfProductCharacteristicValueRangeFrom(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfProductCharacteristicValueRangeTo(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfProductCharacteristicValueString(
            <super::DtMlstring as WithSerializer>::Serializer<'ser>,
        ),
        UdxEdxfProductCharacteristicValueSet(
            <super::DtMlstring as WithSerializer>::Serializer<'ser>,
        ),
        UdxEdxfProductCharacteristicValueSelect(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfProductCharacteristicValueUnitCode(<String as WithSerializer>::Serializer<'ser>),
        UdxEdxfProductCharacteristicReferenceGtin(<String as WithSerializer>::Serializer<'ser>),
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfProductCharacteristicElementTypeContentSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Init__ => { match self . value { super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicCode (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicCode (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_CODE") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicName (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicName (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_NAME") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueBoolean (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueBoolean (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_BOOLEAN") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueNumeric (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueNumeric (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_NUMERIC") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueRangeFrom (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueRangeFrom (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_RANGE_FROM") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueRangeTo (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueRangeTo (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_RANGE_TO") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueString (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueString (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_STRING") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueSet (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueSet (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_SET") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueSelect (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueSelect (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_SELECT") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicValueUnitCode (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueUnitCode (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_VALUE_UNIT_CODE") , false) ?) , super :: UdxEdxfProductCharacteristicElementTypeContent :: UdxEdxfProductCharacteristicReferenceGtin (x) => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicReferenceGtin (WithSerializer :: serializer (x , Some ("UDX.EDXF.PRODUCT_CHARACTERISTIC_REFERENCE_GTIN") , false) ?) , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicCode (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicName (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueBoolean (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueNumeric (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueRangeFrom (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueRangeTo (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueString (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueSet (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueSelect (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicValueUnitCode (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: UdxEdxfProductCharacteristicReferenceGtin (x) => { match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ , } } UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Done__ => return Ok (None) , UdxEdxfProductCharacteristicElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfProductCharacteristicElementTypeContentSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state =
                        UdxEdxfProductCharacteristicElementTypeContentSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfMatrixValuesElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfMatrixValuesElementType,
        pub(super) state: Box<UdxEdxfMatrixValuesElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfMatrixValuesElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfMatrixValue(
            IterSerializer<
                'ser,
                &'ser [super::UdxEdxfMatrixValueElementType],
                super::UdxEdxfMatrixValueElementType,
            >,
        ),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfMatrixValuesElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match &mut *self.state {
                    UdxEdxfMatrixValuesElementTypeSerializerState::Init__ => {
                        *self.state =
                            UdxEdxfMatrixValuesElementTypeSerializerState::UdxEdxfMatrixValue(
                                IterSerializer::new(
                                    &self.value.udx_edxf_matrix_value[..],
                                    Some("UDX.EDXF.MATRIX_VALUE"),
                                    false,
                                ),
                            );
                        let bytes = BytesStart::new(self.name);
                        return Ok(Some(Event::Start(bytes)));
                    }
                    UdxEdxfMatrixValuesElementTypeSerializerState::UdxEdxfMatrixValue(x) => match x
                        .next()
                        .transpose()?
                    {
                        Some(event) => return Ok(Some(event)),
                        None => *self.state = UdxEdxfMatrixValuesElementTypeSerializerState::End__,
                    },
                    UdxEdxfMatrixValuesElementTypeSerializerState::End__ => {
                        *self.state = UdxEdxfMatrixValuesElementTypeSerializerState::Done__;
                        return Ok(Some(Event::End(BytesEnd::new(self.name))));
                    }
                    UdxEdxfMatrixValuesElementTypeSerializerState::Done__ => return Ok(None),
                    UdxEdxfMatrixValuesElementTypeSerializerState::Phantom__(_) => unreachable!(),
                }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfMatrixValuesElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfMatrixValuesElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
    #[derive(Debug)]
    pub struct UdxEdxfMatrixValueElementTypeSerializer<'ser> {
        pub(super) value: &'ser super::UdxEdxfMatrixValueElementType,
        pub(super) state: Box<UdxEdxfMatrixValueElementTypeSerializerState<'ser>>,
        pub(super) name: &'ser str,
        pub(super) is_root: bool,
    }
    #[derive(Debug)]
    pub(super) enum UdxEdxfMatrixValueElementTypeSerializerState<'ser> {
        Init__,
        UdxEdxfMatrixSourceValue(<f32 as WithSerializer>::Serializer<'ser>),
        UdxEdxfMatrixResultValue(<f32 as WithSerializer>::Serializer<'ser>),
        End__,
        Done__,
        Phantom__(&'ser ()),
    }
    impl<'ser> UdxEdxfMatrixValueElementTypeSerializer<'ser> {
        fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
            loop {
                match & mut * self . state { UdxEdxfMatrixValueElementTypeSerializerState :: Init__ => { * self . state = UdxEdxfMatrixValueElementTypeSerializerState :: UdxEdxfMatrixSourceValue (WithSerializer :: serializer (& self . value . udx_edxf_matrix_source_value , Some ("UDX.EDXF.MATRIX_SOURCE_VALUE") , false) ?) ; let bytes = BytesStart :: new (self . name) ; return Ok (Some (Event :: Start (bytes))) } UdxEdxfMatrixValueElementTypeSerializerState :: UdxEdxfMatrixSourceValue (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfMatrixValueElementTypeSerializerState :: UdxEdxfMatrixResultValue (WithSerializer :: serializer (& self . value . udx_edxf_matrix_result_value , Some ("UDX.EDXF.MATRIX_RESULT_VALUE") , false) ?) , } UdxEdxfMatrixValueElementTypeSerializerState :: UdxEdxfMatrixResultValue (x) => match x . next () . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = UdxEdxfMatrixValueElementTypeSerializerState :: End__ , } UdxEdxfMatrixValueElementTypeSerializerState :: End__ => { * self . state = UdxEdxfMatrixValueElementTypeSerializerState :: Done__ ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } UdxEdxfMatrixValueElementTypeSerializerState :: Done__ => return Ok (None) , UdxEdxfMatrixValueElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
            }
        }
    }
    impl<'ser> Iterator for UdxEdxfMatrixValueElementTypeSerializer<'ser> {
        type Item = Result<Event<'ser>, Error>;
        fn next(&mut self) -> Option<Self::Item> {
            match self.next_event() {
                Ok(Some(event)) => Some(Ok(event)),
                Ok(None) => None,
                Err(error) => {
                    *self.state = UdxEdxfMatrixValueElementTypeSerializerState::Done__;
                    Some(Err(error))
                }
            }
        }
    }
}
